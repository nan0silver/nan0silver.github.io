---
layout: post
collection: project_diary
title: 친구하자 프로젝트 일기 - Agora Cloud Recording 구현 중 Hibernate 에러 해결
description: >
  음성 통화 녹음 기능 구현 중 비동기 처리에서 발생한 LazyInitializationException과 OptimisticLockingFailureException을 해결한 과정을 정리했습니다.
sitemap: false
---

# [친구하자] Agora Cloud Recording 구현 시 Hibernate 에러 트러블슈팅

- [1. 문제 발견](#1-문제-발견)
- [2. LazyInitializationException 이해하기](#2-lazyinitializationexception-이해하기)
- [3. OptimisticLockingFailureException 이해하기](#3-optimisticlockingfailureexception-이해하기)
- [4. 문제 원인 분석](#4-문제-원인-분석)
- [5. 해결 방법](#5-해결-방법)
- [6. 최종 해결 코드](#6-최종-해결-코드)
- [7. 핵심 개념 정리](#7-핵심-개념-정리)

## 음성 통화 녹음, 기능은 동작하는데 에러가?

> Agora Cloud Recording을 이용한 음성 통화 녹음 기능을 구현했다. 녹음 시작과 중지는 정상적으로 동작하는 것처럼 보였지만, 통화 종료 직후 콘솔에 예외 스택이 연속으로 출력되었다. LazyInitializationException과 OptimisticLockingFailureException... 둘 다 뭔가 익숙한데 동시에 발생하다니?

## 1. 문제 발견

### 상황

Agora Cloud Recording을 사용하여 음성 통화 녹음 기능을 구현하던 중, 통화는 정상적으로 시작되고 녹음도 시작되지만, **통화 종료 시점에 예외가 연달아 발생**했다.

```java
// 통화 종료 시 자동으로 녹음을 중지하는 로직
@Async("recordingTaskExecutor")
@Transactional
public CompletableFuture<Void> autoStopRecordingOnCallEnd(Long callId) {
    return CompletableFuture.runAsync(() -> {
        stopRecording(callId);  // ← 여기서 에러 발생!
    });
}
```

### 에러 로그

```
Cloud Recording 중지 실패 - callId: 1
org.hibernate.LazyInitializationException: Could not initialize proxy [com.ldsilver.chingoohaja.domain.call.Call#1] - no session
	at org.hibernate.proxy.AbstractLazyInitializer.initialize(AbstractLazyInitializer.java:174)
	at com.ldsilver.chingoohaja.domain.call.Call$HibernateProxy.getAgoraChannelName(Unknown Source)
	at com.ldsilver.chingoohaja.dto.call.response.RecordingResponse.from(RecordingResponse.java:76)
	at com.ldsilver.chingoohaja.service.AgoraRecordingService.stopRecording(AgoraRecordingService.java:138)
```

이어서 두 번째 에러:

```
Recording 실패 상태 저장 실패 - callId: 1
org.springframework.orm.ObjectOptimisticLockingFailureException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect): [com.ldsilver.chingoohaja.domain.call.CallRecording#1]

Caused by: org.hibernate.StaleObjectStateException: Row was updated or deleted by another transaction
```

### 첫 번째 의문

"분명히 `@Transactional` 어노테이션도 붙였고, 엔티티도 제대로 조회했는데 왜 세션이 없다는 거지? 그리고 왜 낙관적 락 충돌이 발생하는 거야?"

---

## 2. LazyInitializationException 이해하기

### 에러의 의미

`LazyInitializationException`은 Hibernate에서 **지연 로딩(Lazy Loading)으로 설정된 연관 엔티티에 접근하려 할 때, 이미 영속성 컨텍스트(Persistence Context)가 닫혀있어서 발생**하는 에러다.

### 일반적인 발생 상황

**1. 트랜잭션 밖에서 Lazy 프록시 접근**

```java
@Transactional
public User findUser(Long id) {
    return userRepository.findById(id);  // User.orders는 LAZY
}

// 트랜잭션 밖 - 서비스 메서드 밖이나 컨트롤러
user.getOrders().size();  // ❌ LazyInitializationException!
```

**2. 트랜잭션이 종료된 후 비동기 작업에서 접근**

```java
@Transactional
public void processOrder(Long orderId) {
    Order order = findOrder(orderId);
    CompletableFuture.runAsync(() -> {
        // 이 시점에는 트랜잭션이 종료되어 세션이 없음
        order.getUser().getName();  // ❌ LazyInitializationException!
    });
}
```

---

## 3. OptimisticLockingFailureException 이해하기

### 에러의 의미

`OptimisticLockingFailureException`은 **낙관적 락(Optimistic Lock) 검증 실패** 시 발생하는 에러다. JPA의 `@Version`을 사용한 엔티티에서 **다른 트랜잭션이 이미 해당 레코드를 수정하여 버전이 증가했을 때** 발생한다.

### 일반적인 발생 상황

**1. 동시에 같은 엔티티를 수정**

```java
// 트랜잭션 1
User user = userRepository.findById(1L);  // version = 0
user.setName("Alice");
userRepository.save(user);  // version = 1로 증가

// 트랜잭션 2 (동시 실행)
User user = userRepository.findById(1L);  // version = 0 (조회 시점)
user.setEmail("new@email.com");
userRepository.save(user);  // ❌ version이 이미 1이라 실패!
```

**2. 분리된(Detached) 엔티티를 merge**

```java
User user = userRepository.findById(1L);  // version = 0
// 엔티티가 영속성 컨텍스트에서 분리됨
// ... 다른 트랜잭션에서 해당 엔티티를 수정하여 버전이 증가
user.setName("Bob");
userRepository.save(user);  // ❌ version 불일치!
```

---

## 4. 문제 원인 분석
