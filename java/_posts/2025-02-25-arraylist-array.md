---
layout: post
title: ArrayList VS 배열 성능 비교
description: >
  ArrayList와 배열(int[])의 성능을 비교해보자.
sitemap: false
---

# [JAVA] 🚀 `ArrayList` vs `배열(int[])` 성능 비교

- [`ArrayList<Integer>`는 언제 더 유리할까?](#-arraylistinteger는-언제-더-유리할까)
- [`int[] 배열`이 더 유리한 경우](#-int-배열이-더-유리한-경우)
- [성능 비교 실험 (Java)](#-성능-비교-실험-java)
- [결론: 언제 `ArrayList`를 쓰고, 언제 `배열(int[])`을 써야 할까?](#-결론-언제-arraylist를-쓰고-언제-배열int을-써야-할까)
- [추가 : HashMap<Integer, Integer>와의 성능 비교](#추가--hashmapinteger-integer와의-성능-비교)

---

## **🚀 `ArrayList` vs `배열(int[])` 성능 비교**

|                         | `ArrayList<Integer>`                    | `int[] 배열`                           |
| ----------------------- | --------------------------------------- | -------------------------------------- |
| **저장 방식**           | 내부적으로 동적 배열(`Object[]`) 사용   | 고정 크기의 `int[]` 배열 사용          |
| **메모리 사용량**       | `Integer` 객체를 사용하여 오버헤드가 큼 | `int` 원시 타입 사용 (메모리 효율적)   |
| **속도 (읽기/쓰기)**    | 일반적으로 `int[]`보다 느림             | **빠름 (메모리 직접 접근)**            |
| **크기 변경 가능 여부** | 가능 (`add()`, `remove()` 등 제공)      | 불가능 (고정 크기)                     |
| **사용 편의성**         | 유동적인 크기 조절이 가능               | 크기 변경이 불가능하여 유연성이 떨어짐 |

---

## **📌 `ArrayList<Integer>`는 언제 더 유리할까?**

- **크기가 가변적인 데이터를 다룰 때** (`add()`로 쉽게 추가 가능)
- **삭제, 삽입이 자주 발생할 때** (`remove()` 메서드 활용 가능)
- **제네릭(`List<T>`)을 활용해야 할 때**

#### **🚀 예제: `ArrayList` 사용 시**

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(10);  // 값 추가
list.add(20);
list.remove(0);  // 첫 번째 요소 삭제
```

- 크기가 유동적으로 변할 수 있음 (`add()`, `remove()` 사용 가능)
- 그러나 **내부적으로 `Integer` 객체를 사용하므로 메모리 사용량이 큼** (`int`보다 많은 메모리 차지)

---

## **📌 `int[] 배열`이 더 유리한 경우**

- **고정된 크기의 데이터를 다룰 때** (메모리 절약 가능)
- **빠른 접근 속도가 필요할 때**
  - 메모리에 **직접 접근 (O(1))** 가능
- **성능 최적화가 필요한 경우** (특히 대량 데이터)

#### **🚀 예제: `int[]` 사용 시**

```java
int[] arr = new int[3];
arr[0] = 10;
arr[1] = 20;
arr[2] = 30;
```

- 메모리를 **`int` 타입 크기만큼만 사용**(불필요한 `Integer` 객체 생성 없음)
- **읽기/쓰기 속도가 빠름**

---

## **⏳ 성능 비교 실험 (Java)**

내가 직접 `ArrayList<Integer>`와 `int[]`의 속도를 비교하는 코드를 실행해볼게!  
아래 코드로 **같은 데이터를 저장하고 조회하는데 걸리는 시간**을 비교해보자.

```java
import java.util.ArrayList;

public class PerformanceTest {
    public static void main(String[] args) {
        int SIZE = 10_000_000; // 1천만 개의 데이터 테스트

        // 1️⃣ 배열 테스트
        long startTime = System.nanoTime();
        int[] array = new int[SIZE];
        for (int i = 0; i < SIZE; i++) {
            array[i] = i;
        }
        long endTime = System.nanoTime();
        System.out.println("배열(int[]) 실행 시간: " + (endTime - startTime) / 1_000_000 + " ms");

        // 2️⃣ ArrayList 테스트
        startTime = System.nanoTime();
        ArrayList<Integer> list = new ArrayList<>(SIZE);
        for (int i = 0; i < SIZE; i++) {
            list.add(i);
        }
        endTime = System.nanoTime();
        System.out.println("ArrayList 실행 시간: " + (endTime - startTime) / 1_000_000 + " ms");
    }
}
```

---

## **⏳ 성능 테스트 결과 (대략적인 차이)**

**테스트 환경:** `10,000,000`개의 데이터를 저장하는 경우  
(결과는 실행 환경에 따라 다를 수 있음)

| 데이터 크기              | `int[] 배열` (배열) | `ArrayList<Integer>` (리스트) |
| ------------------------ | ------------------- | ----------------------------- |
| 10,000,000개 데이터 저장 | **30~50ms**         | **100~200ms**                 |

> **✅ 배열(`int[]`)이 `ArrayList<Integer>`보다 약 3~5배 빠름!**

---

## **📌 결론: 언제 `ArrayList`를 쓰고, 언제 `배열(int[])`을 써야 할까?**

| 상황                                 | `ArrayList<Integer>`                 | `int[] 배열`                         |
| ------------------------------------ | ------------------------------------ | ------------------------------------ |
| **데이터 크기가 가변적일 때**        | ✅ 추천 (자동 크기 증가)             | ❌ 비효율적 (고정 크기)              |
| **빠른 읽기/쓰기 성능이 필요할 때**  | ❌ 상대적으로 느림                   | ✅ 빠름 (메모리 직접 접근)           |
| **메모리 사용량 최적화가 필요할 때** | ❌ `Integer` 객체로 인해 메모리 낭비 | ✅ `int` 원시 타입이므로 메모리 절약 |
| **삭제/삽입이 자주 발생할 때**       | ✅ `remove()` 지원                   | ❌ 배열 크기 고정이라 비효율적       |

1. **성능이 중요하다면 `int[]` 배열이 훨씬 빠르고 메모리도 절약된다!** 🚀
2. **크기가 변하는 데이터를 다룰 때는 `ArrayList<Integer>`가 편리하다.** ✅
3. **데이터 개수가 많고, 읽기/쓰기 성능이 중요하다면 `int[]`을 사용하는 것이 좋다.** ⚡
4. **일반적인 상황에서는 `ArrayList<Integer>`를 쓰는 게 개발 편의성 면에서 좋다.**

즉, **고정된 크기라면 배열을 쓰고, 크기가 유동적이면 `ArrayList`를 쓰는 게 정답!** 😃

---

## 추가 : HashMap<Integer, Integer>와의 성능 비교

| 데이터 구조                               | 실행 속도 (초)              | 특징                         |
| ----------------------------------------- | --------------------------- | ---------------------------- |
| **배열 (`int[]`)**                        | **가장 빠름** (0.03~0.05초) | 메모리 직접 접근 (고정 크기) |
| **ArrayList (`ArrayList<Integer>`)**      | **중간 (0.1~0.2초)**        | 동적 크기 조정 가능          |
| **HashMap (`HashMap<Integer, Integer>`)** | **가장 느림 (0.3~0.5초)**   | 키-값 매핑 (빠른 탐색)       |

---

### **3️⃣ HashMap (`HashMap<Integer, Integer>`)**

- **속도:** **가장 느림 (배열보다 약 5~10배 느림)**
- **이유:**
  - 내부적으로 **해시 함수(Hashing)** 사용 → 빠른 탐색(O(1)) 가능
  - 하지만 키-값 저장 방식이라 **메모리 오버헤드가 큼**
- **장점:**
  - 데이터 검색이 **O(1) (거의 즉각적)**
  - 키 기반으로 **빠르게 값에 접근 가능**
- **언제 사용하면 좋을까?**
  - **Key-Value 형태의 데이터 저장이 필요할 때**
  - **데이터 조회 속도가 중요한 경우** (탐색이 많을 때)

---

### **💡 결론**

| 사용 목적                   | 추천 자료 구조              |
| --------------------------- | --------------------------- |
| **고정된 크기의 데이터**    | `int[]` (배열)              |
| **크기가 유동적인 리스트**  | `ArrayList<Integer>`        |
| **빠른 탐색이 필요한 경우** | `HashMap<Integer, Integer>` |

즉,  
✔ **빠른 연산이 필요하면 `int[] 배열`**  
✔ **동적 크기가 필요하면 `ArrayList<Integer>`**  
✔ **키-값 조회가 많다면 `HashMap<Integer, Integer>`**
