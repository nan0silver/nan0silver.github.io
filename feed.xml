<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-01-22T03:18:34+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[HTML] CSS Flex</title><link href="https://nan0silver.github.io/miscellaneous/2025-01-21-css-flex/" rel="alternate" type="text/html" title="[HTML] CSS Flex" /><published>2025-01-21T00:00:00+00:00</published><updated>2025-01-22T03:17:43+00:00</updated><id>https://nan0silver.github.io/miscellaneous/css-flex</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-01-21-css-flex/"><![CDATA[<ul>
  <li><a href="#flexflexbox">Flex(Flexbox)</a></li>
  <li><a href="#주요-flexbox-속성">주요 Flexbox 속성 20개</a></li>
  <li><a href="#예제-통합-코드">예제: 통합 코드</a></li>
  <li><a href="#flex를-이용한-게임">flex를 이용한 게임</a></li>
</ul>

<hr />

<h2 id="flexflexbox">Flex(Flexbox)</h2>

<ul>
  <li>Flexbox(Flexible Box Layout Module)</li>
  <li>컨테이너 내의 아이템 간 공간 배분과 정렬 기능을 제공하는 1차원 레이아웃 모델</li>
  <li>
    <p>주로 행이나 열 단위로 작동하며, 복잡한 계산 없이도 요소들의 크기와 순서를 유연하게 배치할 수 있음</p>
  </li>
  <li>장점
    <ul>
      <li>복잡한 레이아웃을 간단하게 구현</li>
      <li>컨테이너 내 요소의 크기가 불명확하거나 동적인 경우에도 효과적으로 대응</li>
      <li>요소의 순서를 CSS로 변경할 수 있어 반응형 디자인에 유용</li>
      <li>float나 Position을 사용할 때보다 코드가 간결해짐</li>
    </ul>
  </li>
</ul>

<h2 id="주요-flexbox-속성">주요 Flexbox 속성</h2>

<p>CSS3 Flexbox에서 가장 많이 사용되는 <strong>20개의 속성(property)</strong>을 아래에 정리했습니다. 각각의 속성에 대한 간략한 설명과 함께 예제 코드를 제공합니다.</p>

<hr />

<h3 id="1-display-flex"><strong>1. <code class="language-plaintext highlighter-rouge">display: flex</code></strong></h3>

<ul>
  <li>Flexbox를 활성화.</li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="2-flex-direction"><strong>2. <code class="language-plaintext highlighter-rouge">flex-direction</code></strong></h3>

<ul>
  <li>주축의 방향 설정.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">row</code> (기본값), <code class="language-plaintext highlighter-rouge">row-reverse</code>, <code class="language-plaintext highlighter-rouge">column</code>, <code class="language-plaintext highlighter-rouge">column-reverse</code>.</li>
    </ul>
  </li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">flex-direction</span><span class="p">:</span> <span class="n">column</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="3-justify-content"><strong>3. <code class="language-plaintext highlighter-rouge">justify-content</code></strong></h3>

<ul>
  <li>주축에서 항목 정렬.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">flex-start</code>, <code class="language-plaintext highlighter-rouge">flex-end</code>, <code class="language-plaintext highlighter-rouge">center</code>, <code class="language-plaintext highlighter-rouge">space-between</code>, <code class="language-plaintext highlighter-rouge">space-around</code>, <code class="language-plaintext highlighter-rouge">space-evenly</code>.</li>
    </ul>
  </li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="n">space-between</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="4-align-items"><strong>4. <code class="language-plaintext highlighter-rouge">align-items</code></strong></h3>

<ul>
  <li>교차축에서 항목 정렬.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">stretch</code> (기본값), <code class="language-plaintext highlighter-rouge">flex-start</code>, <code class="language-plaintext highlighter-rouge">flex-end</code>, <code class="language-plaintext highlighter-rouge">center</code>, <code class="language-plaintext highlighter-rouge">baseline</code>.</li>
    </ul>
  </li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="5-align-content"><strong>5. <code class="language-plaintext highlighter-rouge">align-content</code></strong></h3>

<ul>
  <li>여러 줄에서 교차축 정렬.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">stretch</code>, <code class="language-plaintext highlighter-rouge">flex-start</code>, <code class="language-plaintext highlighter-rouge">flex-end</code>, <code class="language-plaintext highlighter-rouge">center</code>, <code class="language-plaintext highlighter-rouge">space-between</code>, <code class="language-plaintext highlighter-rouge">space-around</code>.</li>
    </ul>
  </li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">align-content</span><span class="p">:</span> <span class="n">space-around</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="6-flex-wrap"><strong>6. <code class="language-plaintext highlighter-rouge">flex-wrap</code></strong></h3>

<ul>
  <li>항목이 컨테이너를 초과하면 줄 바꿈 여부.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">nowrap</code> (기본값), <code class="language-plaintext highlighter-rouge">wrap</code>, <code class="language-plaintext highlighter-rouge">wrap-reverse</code>.</li>
    </ul>
  </li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">flex-wrap</span><span class="p">:</span> <span class="n">wrap</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="7-flex"><strong>7. <code class="language-plaintext highlighter-rouge">flex</code></strong></h3>

<ul>
  <li>개별 항목의 크기 설정 (약어).
    <ul>
      <li><code class="language-plaintext highlighter-rouge">flex: grow shrink basis;</code></li>
    </ul>
  </li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex</span><span class="p">:</span> <span class="m">1</span> <span class="m">1</span> <span class="nb">auto</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="8-flex-grow"><strong>8. <code class="language-plaintext highlighter-rouge">flex-grow</code></strong></h3>

<ul>
  <li>남은 공간을 차지할 비율.
    <ul>
      <li>기본값: <code class="language-plaintext highlighter-rouge">0</code>.</li>
    </ul>
  </li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-grow</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="9-flex-shrink"><strong>9. <code class="language-plaintext highlighter-rouge">flex-shrink</code></strong></h3>

<ul>
  <li>공간 부족 시 줄어드는 비율.
    <ul>
      <li>기본값: <code class="language-plaintext highlighter-rouge">1</code>.</li>
    </ul>
  </li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-shrink</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="10-flex-basis"><strong>10. <code class="language-plaintext highlighter-rouge">flex-basis</code></strong></h3>

<ul>
  <li>항목의 기본 크기 설정.</li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-basis</span><span class="p">:</span> <span class="m">100px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="11-order"><strong>11. <code class="language-plaintext highlighter-rouge">order</code></strong></h3>

<ul>
  <li>항목의 배치 순서.
    <ul>
      <li>기본값: <code class="language-plaintext highlighter-rouge">0</code>.</li>
    </ul>
  </li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">order</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="12-gap"><strong>12. <code class="language-plaintext highlighter-rouge">gap</code></strong></h3>

<ul>
  <li>항목 간 간격 설정.</li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">gap</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="13-row-gap"><strong>13. <code class="language-plaintext highlighter-rouge">row-gap</code></strong></h3>

<ul>
  <li>가로축 항목 간 간격 설정.</li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">row-gap</span><span class="p">:</span> <span class="m">15px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="14-column-gap"><strong>14. <code class="language-plaintext highlighter-rouge">column-gap</code></strong></h3>

<ul>
  <li>세로축 항목 간 간격 설정.</li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">column-gap</span><span class="p">:</span> <span class="m">10px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="15-align-self"><strong>15. <code class="language-plaintext highlighter-rouge">align-self</code></strong></h3>

<ul>
  <li>개별 항목의 교차축 정렬 설정.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">auto</code>, <code class="language-plaintext highlighter-rouge">flex-start</code>, <code class="language-plaintext highlighter-rouge">flex-end</code>, <code class="language-plaintext highlighter-rouge">center</code>, <code class="language-plaintext highlighter-rouge">baseline</code>, <code class="language-plaintext highlighter-rouge">stretch</code>.</li>
    </ul>
  </li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">align-self</span><span class="p">:</span> <span class="n">flex-end</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="16-min-width"><strong>16. <code class="language-plaintext highlighter-rouge">min-width</code></strong></h3>

<ul>
  <li>항목의 최소 너비.</li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">min-width</span><span class="p">:</span> <span class="m">100px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="17-max-width"><strong>17. <code class="language-plaintext highlighter-rouge">max-width</code></strong></h3>

<ul>
  <li>항목의 최대 너비.</li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">max-width</span><span class="p">:</span> <span class="m">200px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="18-min-height"><strong>18. <code class="language-plaintext highlighter-rouge">min-height</code></strong></h3>

<ul>
  <li>항목의 최소 높이.</li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">min-height</span><span class="p">:</span> <span class="m">50px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="19-max-height"><strong>19. <code class="language-plaintext highlighter-rouge">max-height</code></strong></h3>

<ul>
  <li>항목의 최대 높이.</li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">max-height</span><span class="p">:</span> <span class="m">150px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="20-place-content"><strong>20. <code class="language-plaintext highlighter-rouge">place-content</code></strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">justify-content</code>와 <code class="language-plaintext highlighter-rouge">align-content</code>를 한 번에 설정.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">center</code>, <code class="language-plaintext highlighter-rouge">stretch</code>, <code class="language-plaintext highlighter-rouge">space-between</code> 등.</li>
    </ul>
  </li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">place-content</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="예제-통합-코드">예제: 통합 코드</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"container"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"item"</span><span class="nt">&gt;</span>Item 1<span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"item"</span><span class="nt">&gt;</span>Item 2<span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"item"</span><span class="nt">&gt;</span>Item 3<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;style&gt;</span>
  <span class="nc">.container</span> <span class="p">{</span>
    <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
    <span class="nl">flex-direction</span><span class="p">:</span> <span class="n">row</span><span class="p">;</span>
    <span class="nl">justify-content</span><span class="p">:</span> <span class="n">space-between</span><span class="p">;</span>
    <span class="nl">align-items</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
    <span class="nl">flex-wrap</span><span class="p">:</span> <span class="n">wrap</span><span class="p">;</span>
    <span class="py">gap</span><span class="p">:</span> <span class="m">10px</span><span class="p">;</span>
    <span class="nl">height</span><span class="p">:</span> <span class="m">300px</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nc">.item</span> <span class="p">{</span>
    <span class="nl">flex</span><span class="p">:</span> <span class="m">1</span> <span class="m">1</span> <span class="m">100px</span><span class="p">;</span>
    <span class="nl">align-self</span><span class="p">:</span> <span class="n">stretch</span><span class="p">;</span>
    <span class="nl">min-width</span><span class="p">:</span> <span class="m">100px</span><span class="p">;</span>
    <span class="nl">max-width</span><span class="p">:</span> <span class="m">300px</span><span class="p">;</span>
  <span class="p">}</span>
<span class="nt">&lt;/style&gt;</span>
</code></pre></div></div>

<h2 id="flex를-이용한-게임">flex를 이용한 게임</h2>

<ul>
  <li>https://flexboxfroggy.com/#ko</li>
  <li><img src="2025-01-21-css-flex-image.png" alt="flexboxfroggy" />
    <ul>
      <li>다 깼다!</li>
    </ul>
  </li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[웹 페이지의 컨테이너 내 아이템 간 공간 배분에 사용되는 CSS Flex에 대해 알아보자.]]></summary></entry><entry><title type="html">[Etc] Responsive VS Reactive</title><link href="https://nan0silver.github.io/miscellaneous/2025-01-20-responsive/" rel="alternate" type="text/html" title="[Etc] Responsive VS Reactive" /><published>2025-01-20T00:00:00+00:00</published><updated>2025-01-22T03:17:43+00:00</updated><id>https://nan0silver.github.io/miscellaneous/responsive</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-01-20-responsive/"><![CDATA[<ul>
  <li><a href="#responsive-반응형">Responsive</a></li>
  <li><a href="#reactive-반응형">Reactive</a></li>
  <li><a href="#responsive-vs-reactive">Responsive VS Reactive</a></li>
  <li><a href="#결합된-활용">결합된 활용</a></li>
</ul>

<hr />

<h2 id="responsive-반응형">Responsive (반응형)</h2>

<ul>
  <li>Responsive는 주로 UI/UX 디자인이나 프론트엔트 개발에서 사용되는 개념</li>
  <li>애플리케이션 또는 웹 페이지가 화면 크기, 해상도, 디바이스 특성에 따라 적절히 변하도록 설계된 것을 의미</li>
  <li>특징
    <ul>
      <li>주요 초점
        <ul>
          <li>레이아웃 및 디자인이 다양한 화면 환경(데스크톱, 태블릿, 모바일)에 적응</li>
        </ul>
      </li>
      <li>기술
        <ul>
          <li>주로 CSS, Flexbox, Grid, Viewport 등을 사용</li>
        </ul>
      </li>
      <li>목적
        <ul>
          <li>사용자 경험을 개선하고, 어떤 장치에서도 보기 좋은 디자인을 제공</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>예시
    <ul>
      <li>웹사이트 반응형 디자인
        <ul>
          <li>큰 화면에서는 여러 열(column)을 보여주고, 작은 화면에서는 한 열로 정렬</li>
          <li>이미지와 텍스트 사이즈가 디바이스 크기에 따라 자동으로 조정</li>
        </ul>
      </li>
      <li><a href="https://getbootstrap.kr/">부트스트랩 (Bootstrap)</a>
        <ul>
          <li>col-m-6와 같은 클래스 이름을 사용하여 화면 크기에 따라 레이아웃을 조정</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="reactive-반응형">Reactive (반응형)</h2>

<ul>
  <li>Reactive는 주로 프로그래밍 패러다임과 관련이 있음</li>
  <li>시스템이 변화를 감지하고 즉각적으로 동작을 수행하는 것을 의미</li>
  <li>특징
    <ul>
      <li>주요 초점
        <ul>
          <li>데이터와 상태의 변화에 따라 UI가 자동으로 업데이트</li>
        </ul>
      </li>
      <li>기술
        <ul>
          <li>Reactive Programming과 관련된 라이브러리와 프레임워크를 활용</li>
          <li>ex) RxJS, React, Vue, Svelte 등</li>
        </ul>
      </li>
      <li>목적
        <ul>
          <li>상태 관리와 데이터 흐름을 단순화하고, 사용자 입력 또는 데이터 변화에 실시간으로 반응</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>예시</p>

    <ul>
      <li>
        <p>React.js에서의 State변화</p>

        <ul>
          <li>사용자가 버튼을 클릭하면 상태가 변경되고, 해당 상태에 따라 UI가 즉각적으로 업데이트</li>
        </ul>

        <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Counter</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Count</span><span class="p">:</span> <span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span><span class="o">&gt;</span><span class="nx">Increase</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>RxJS 스트림</p>

        <ul>
          <li>데이터를 스트림(stream) 형태로 처리하고, 데이터 변경에 실시간으로 반응</li>
        </ul>

        <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">fromEvent</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">rxjs</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">button</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">myButton</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">clicks</span> <span class="o">=</span> <span class="nx">fromEvent</span><span class="p">(</span><span class="nx">button</span><span class="p">,</span> <span class="dl">"</span><span class="s2">click</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">clicks</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Button clicked!</span><span class="dl">"</span><span class="p">));</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="responsive-vs-reactive">Responsive VS Reactive</h2>

<table>
  <thead>
    <tr>
      <th><strong>측면</strong></th>
      <th><strong>Responsive</strong></th>
      <th><strong>Reactive</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>적용 범위</td>
      <td>주로 UI/UX와 레이아웃 디자인</td>
      <td>상태 관리와 데이터 흐름</td>
    </tr>
    <tr>
      <td>목적</td>
      <td>화면 크기에 따른 레이아웃 및 스타일 변경</td>
      <td>데이터 및 상태 변경에 따른 즉각적인 반응</td>
    </tr>
    <tr>
      <td>사용 기술</td>
      <td>CSS, Flexbox, Grid 등</td>
      <td>React, RxJS, Vue 등 상태 기반 프레임워크</td>
    </tr>
    <tr>
      <td>초점</td>
      <td>디바이스별 최적화된 레이아웃 제공</td>
      <td>데이터의 흐름과 UI 동기화</td>
    </tr>
    <tr>
      <td>예시</td>
      <td>모바일에서 1열 레이아웃, 데스크톱에서 3열 레이아웃</td>
      <td>버튼 클릭 시 상태 업데이트 후 UI 리렌더링</td>
    </tr>
  </tbody>
</table>

<h2 id="결합된-활용">결합된 활용</h2>

<ul>
  <li>Responsive와 Reactive는 함께 사용될 때 더 큰 효과를 발휘한다.</li>
  <li>예를 들어, React.js로 만들어진 SPA(Single Page Application)에서 반응형 디자인(CSS)을 사용해 다양한 디바이스를 지원하면서, React의 상태 관리(State Management)를 통해 UI를 데이터와 동기화할 수 있음.</li>
  <li>
    <p>예시</p>

    <ul>
      <li>Reaponsive는 레이아웃과 UI에 초점을 맞추고, Reactive는 데이터와 상태 관리에 집중
        <ul>
          <li>둘이 상호보완적!</li>
        </ul>
      </li>
    </ul>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="dl">'</span><span class="s1">./App.css</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// Responsive 스타일 포함</span>

<span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">isDarkMode</span><span class="p">,</span> <span class="nx">setIsDarkMode</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="s2">`app </span><span class="p">${</span><span class="nx">isDarkMode</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">dark-mode</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">''</span><span class="p">}</span><span class="s2">`</span><span class="p">}</span><span class="o">&gt;</span>
            <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Welcome</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">responsive</span> <span class="nx">and</span> <span class="nx">reactive</span> <span class="nx">app</span><span class="o">!&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>            <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setIsDarkMode</span><span class="p">(</span><span class="o">!</span><span class="nx">isDarkMode</span><span class="p">)}</span><span class="o">&gt;</span>
                <span class="nx">Toggle</span> <span class="nx">Dark</span> <span class="nx">Mode</span>
            <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* App.css */</span>
<span class="p">.</span><span class="nx">app</span> <span class="p">{</span>
    <span class="nl">padding</span><span class="p">:</span> <span class="mi">20</span><span class="nx">px</span><span class="p">;</span>
    <span class="nl">transition</span><span class="p">:</span> <span class="nx">background</span><span class="o">-</span><span class="nx">color</span> <span class="mf">0.3</span><span class="nx">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">.</span><span class="nx">dark</span><span class="o">-</span><span class="nx">mode</span> <span class="p">{</span>
    <span class="nx">background</span><span class="o">-</span><span class="nx">color</span><span class="p">:</span> <span class="err">#</span><span class="mi">333</span><span class="p">;</span>
    <span class="nl">color</span><span class="p">:</span> <span class="err">#</span><span class="nx">fff</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">@</span><span class="nd">media</span> <span class="p">(</span><span class="nx">max</span><span class="o">-</span><span class="nx">width</span><span class="p">:</span> <span class="mi">768</span><span class="nx">px</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">.</span><span class="nx">app</span> <span class="p">{</span>
        <span class="nx">font</span><span class="o">-</span><span class="nx">size</span><span class="p">:</span> <span class="mi">14</span><span class="nx">px</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[프론트엔드 개발자 관점에서 Responsive와 Reactive의 뜻을 알아보자.]]></summary></entry><entry><title type="html">[HTML] CSS Float</title><link href="https://nan0silver.github.io/miscellaneous/2025-01-19-css-float/" rel="alternate" type="text/html" title="[HTML] CSS Float" /><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-22T03:17:43+00:00</updated><id>https://nan0silver.github.io/miscellaneous/css-float</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-01-19-css-float/"><![CDATA[<ul>
  <li><a href="#css-float이란">CSS Float란</a></li>
  <li><a href="#clearfix">Clearfix</a></li>
  <li><a href="#clear-속성">Clear 속성</a></li>
  <li><a href="#clearfix-vs-clear-속성">Clearfix VS Clear</a></li>
  <li><a href="#float-사용-시-주의사항">Float 사용시 주의사항</a></li>
  <li><a href="#결론">결론</a></li>
</ul>

<hr />

<h2 id="css-float이란">CSS Float이란?</h2>

<ul>
  <li>
    <p><strong>Float의 기본 개념</strong></p>

    <ul>
      <li>요소가 normal flow에서 벗어나 부모 요소의 왼쪽 또는 오른쪽으로 이동한다.</li>
      <li>텍스트와 inline 요소들이 float된 요소 주변을 감싼다.</li>
    </ul>
  </li>
  <li>
    <p><strong>Float의 사용</strong></p>
    <ul>
      <li>전통적으로 다단 레이아웃을 만드는 데 사용된다.</li>
      <li>이미지나 다른 요소를 텍스트 흐름 내에 배치하는 데 유용</li>
    </ul>
  </li>
</ul>

<h2 id="clearfix">Clearfix</h2>

<ul>
  <li>Float의 문제점
    <ul>
      <li><strong>부모 요소 높이 붕괴</strong> float된 요소는 부모 요소의 높이에 영향을 주지 않아 부모 요소가 높이를 잃을 수 있다.</li>
    </ul>
  </li>
  <li>
    <p><strong>Clearfix</strong></p>

    <ul>
      <li>이 문제를 해결하기 위해 clearfix 기법이 사용된다.</li>
      <li><code class="language-plaintext highlighter-rouge">overflow: auto</code> 또는 <code class="language-plaintext highlighter-rouge">overflow: hidden</code>을 부모 요소에 적용한다.</li>
      <li>가상 요소 (<code class="language-plaintext highlighter-rouge">::after</code>)를 사용하여 float를 해제한다.</li>
    </ul>
  </li>
  <li><strong>Clearfix 방법:</strong>
    <ul>
      <li><strong>CSS를 이용한 Clearfix:</strong>
        <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.clearfix</span><span class="nd">::after</span> <span class="p">{</span>
  <span class="nl">content</span><span class="p">:</span> <span class="s1">""</span><span class="p">;</span>
  <span class="nl">display</span><span class="p">:</span> <span class="nb">block</span><span class="p">;</span>
  <span class="nl">clear</span><span class="p">:</span> <span class="nb">both</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>부모 요소에 <code class="language-plaintext highlighter-rouge">clearfix</code> 클래스를 추가하여 float 문제를 해결한다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="clear-속성">Clear 속성</h2>

<ul>
  <li><strong>핵심 문제</strong>: 특정 요소가 바로 앞에 있는 float 요소의 영향을 받아 원하는 위치에 배치되지 않을 수 있다.</li>
  <li><strong>clear 속성의 역할</strong>:
    <ul>
      <li>특정 요소가 이전의 float 요소 아래로 내려가도록 강제하여 float의 영향을 방지한다.</li>
      <li>float 요소 다음에 나오는 요소에 주로 사용된다.</li>
    </ul>
  </li>
</ul>

<p><strong>사용 예시 (clear 속성):</strong></p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.element</span> <span class="p">{</span>
  <span class="nl">clear</span><span class="p">:</span> <span class="nb">both</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">clear: both</code>: 왼쪽과 오른쪽의 float 요소로부터 벗어남.</li>
  <li>특정 요소 자체의 위치를 조정하기 위한 용도로 사용된다.</li>
</ul>

<hr />

<h2 id="clearfix-vs-clear-속성">Clearfix VS Clear 속성</h2>

<table>
  <thead>
    <tr>
      <th><strong>개념</strong></th>
      <th><strong>Clearfix</strong></th>
      <th><strong>Clear 속성</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>적용 대상</strong></td>
      <td>부모 요소가 float된 자식 요소를 감싸도록 해결</td>
      <td>특정 요소가 float 요소의 영향을 받지 않도록 해결</td>
    </tr>
    <tr>
      <td><strong>해결 문제</strong></td>
      <td>부모 요소 높이 붕괴 문제</td>
      <td>특정 요소의 위치 문제</td>
    </tr>
    <tr>
      <td><strong>주요 방식</strong></td>
      <td><code class="language-plaintext highlighter-rouge">overflow</code> 속성, <code class="language-plaintext highlighter-rouge">::after</code> 가상 요소</td>
      <td><code class="language-plaintext highlighter-rouge">clear: left/right/both</code> 속성</td>
    </tr>
    <tr>
      <td><strong>사용 위치</strong></td>
      <td>부모 요소</td>
      <td>float 요소 바로 다음에 나오는 요소</td>
    </tr>
  </tbody>
</table>

<hr />

<ul>
  <li><strong>부모 요소의 높이 붕괴 문제</strong>를 해결하려면 <strong>Clearfix</strong>를 사용한다.</li>
  <li><strong>요소가 float의 영향을 받아 잘못된 위치에 있을 때</strong>는 <strong>clear 속성</strong>을 사용한다.</li>
</ul>

<hr />

<h3 id="float-사용-시-주의사항">Float 사용 시 주의사항</h3>

<ul>
  <li>Float는 레이아웃의 기본적인 도구이지만, Flexbox나 Grid와 같은 현대적인 레이아웃 기술로 대체될 수 있다.</li>
  <li>복잡한 레이아웃에서는 유지보수가 어려워질 수 있다.</li>
  <li><strong>Float의 대안:</strong>
    <ul>
      <li><strong>Flexbox:</strong> 1차원 레이아웃에 적합하며, 요소의 정렬 및 간격 조절에 강력하다.</li>
      <li><strong>CSS Grid:</strong> 2차원 레이아웃에 적합하며, 행과 열을 기반으로 복잡한 레이아웃을 만들 수 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="결론">결론</h3>

<ul>
  <li>CSS Float는 여전히 유용한 기술이지만, 현대적인 레이아웃 기술과 함께 이해하고 사용하는 것이 중요</li>
  <li>프로젝트의 요구 사항에 따라 적절한 레이아웃 기술을 선택해야 함</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[웹 페이지 레이아웃을 만들때 사용되는 CSS Float에 대해 알아보자.]]></summary></entry><entry><title type="html">[HTML] CSS 문법</title><link href="https://nan0silver.github.io/miscellaneous/2025-01-18-css/" rel="alternate" type="text/html" title="[HTML] CSS 문법" /><published>2025-01-18T00:00:00+00:00</published><updated>2025-01-22T03:17:43+00:00</updated><id>https://nan0silver.github.io/miscellaneous/css</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-01-18-css/"><![CDATA[<ul>
  <li><a href="#css란">CSS란?</a></li>
  <li><a href="#css-문법-기초">CSS 문법 기초</a></li>
  <li><a href="#css-적용-방법">CSS 적용 방법</a></li>
  <li><a href="#css-프로퍼티-값의-단위">CSS 프로퍼티 값의 단위</a></li>
</ul>

<hr />

<h2 id="css란">CSS란?</h2>

<ul>
  <li>CSS : Cascading Style Sheets</li>
  <li>웹 페이지의 시각적 표현을 담당하는 스타일 언어
    <ul>
      <li>다양한 디바이스의 화면 크기에 대응하는 반응형 디자인 구현</li>
      <li>내용과 디자인의 분리로 유지보수성 향</li>
    </ul>
  </li>
  <li>HTML VS CSS
    <ul>
      <li>HTML
        <ul>
          <li>웹페이지 구조와 콘텐츠 정의</li>
        </ul>
      </li>
      <li>CSS
        <ul>
          <li>HTML 요소의 스타일과 레이아웃 지정</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="css-문법-기초">CSS 문법 기초</h2>

<ul>
  <li>
    <p>선택자 (Selector)</p>

    <ul>
      <li>스타일을 적용할 HTML 요소 지정</li>
      <li>
        <pre><code class="language-CSS">    /* 요소 선택자 */
    p {
    color: blue;
    }

    /* 클래스 선택자 */
    .highlight {
    background-color: yellow;
    }

    /* ID 선택자 */
    #header {
    font-size: 24px;
    }

    /* 전체 선택자 */
    * {
    margin: 0;
    padding: 0;
    }
    /* 무조건 뒤에 오는게 이긴다. 뒤로 갈수록 덮어씌우는 개념 */
    /* 아이디랑 클래스 중 아이디가 이김 */


</code></pre>
      </li>
    </ul>
  </li>
  <li>속성 (Property)
    <ul>
      <li>변경하고자 하는 스타일의 종류</li>
    </ul>
  </li>
  <li>값 (Value)
    <ul>
      <li>속성에 적용할 구체적인 스타일 값</li>
    </ul>
  </li>
  <li>선언 (Declaration)
    <ul>
      <li>속성과 값의 쌍</li>
    </ul>
  </li>
  <li>규칙 (Rule)
    <ul>
      <li>선택자와 선언 블록의 조합</li>
    </ul>
  </li>
</ul>

<pre><code class="language-CSS">    선택자 {
        속성: 값;
        속성: 값;
    }

    /* 구체적인 예시 */
    h1 {
        color: blue;
        font-size: 18px;
    }
</code></pre>

<h2 id="css-적용-방법">CSS 적용 방법</h2>

<ol>
  <li>인라인 스타일
    <ul>
      <li>HTML 요소 내부에 직접 스타일 적용</li>
    </ul>
  </li>
  <li>내부 스타일시트
    <ul>
      <li>head 섹션 내 style 태그에 CSS 작성</li>
    </ul>
  </li>
  <li>외부 스타일시트
    <ul>
      <li>별도의 .css파일에 스타일 정의</li>
      <li>HTML 문서의 head 섹션에서 링크로 연결</li>
    </ul>
  </li>
</ol>

<h2 id="css-프로퍼티-값의-단위">CSS 프로퍼티 값의 단위</h2>

<ul>
  <li>크기 단위
    <ul>
      <li>px : 픽셀 단위, 절대값</li>
      <li>% : 백분율 단위, 상대값</li>
      <li>em : 요소에 지정된 사이즈에 상대적인 배수 단위</li>
      <li>rem : 최상위 요소(html)의 사이즈 기준 배수 단위</li>
      <li>Viewport 단위 : vh, vw, vmin, vmax</li>
    </ul>
  </li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[웹 개발 생산성을 극대화하는 Emmet의 강력한 기능과 활용법을 알아보자.]]></summary></entry><entry><title type="html">[HTML] Emmet</title><link href="https://nan0silver.github.io/miscellaneous/2025-01-17-emmet/" rel="alternate" type="text/html" title="[HTML] Emmet" /><published>2025-01-17T00:00:00+00:00</published><updated>2025-01-22T03:17:43+00:00</updated><id>https://nan0silver.github.io/miscellaneous/emmet</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-01-17-emmet/"><![CDATA[<ol>
  <li><a href="#emmet이란">Emmet이란?</a></li>
  <li><a href="#emmet의-강력한-단축키---tab">Emmet의 강력한 단축키 !+Tab</a></li>
  <li><a href="#emmet-사용법-굉장히-쉽고-편리함">Emmet 사용법</a></li>
  <li><a href="#emmet-어디에서-사용할-수-있나요">Emmet, 어디에서 사용할 수 있나요?</a></li>
</ol>

<hr />

<h2 id="emmet이란">Emmet이란?</h2>

<p>Emmet은 웹 개발자가 HTML, CSS 코드를 훨씬 빠르고 효율적으로 작성할 수 있도록 도와주는 플러그인입니다. <br />
간단한 축약어를 입력하면 Emmet이 알아서 전체 코드로 확장해줍니다. 예를 들어, <code class="language-plaintext highlighter-rouge">ul&gt;li*5&gt;a</code>라고 입력하면 다음과 같은 HTML 코드가 자동으로 생성됩니다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;ul&gt;</span>
  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">""</span><span class="nt">&gt;&lt;/a&gt;&lt;/li&gt;</span>
  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">""</span><span class="nt">&gt;&lt;/a&gt;&lt;/li&gt;</span>
  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">""</span><span class="nt">&gt;&lt;/a&gt;&lt;/li&gt;</span>
  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">""</span><span class="nt">&gt;&lt;/a&gt;&lt;/li&gt;</span>
  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">""</span><span class="nt">&gt;&lt;/a&gt;&lt;/li&gt;</span>
<span class="nt">&lt;/ul&gt;</span>
</code></pre></div></div>

<p>Emmet을 사용하면 이런 불필요한 작업을 줄이고, 개발자는 오롯이 로직과 디자인에 집중할 수 있습니다.</p>

<h2 id="emmet의-강력한-단축키---tab">Emmet의 강력한 단축키 ! + Tab</h2>

<p>Emmet을 사용하는 가장 대표적인 사례 중 하나는 ! + Tab 단축키입니다. 이 단축키를 입력하면 기본 HTML 문서의 구조가 즉시 생성됩니다. 예를 들어, 빈 파일에서 !를 입력한 후 Tab 키를 누르면 다음과 같은 기본 HTML 문서가 자동으로 작성됩니다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width, initial-scale=1.0"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;title&gt;</span>Document<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>이 기본 구조는 웹 페이지를 시작할 때 반드시 필요한 요소들로 구성되어 있으며, 직접 입력하는 번거로움을 크게 줄여줍니다. 이 기능만 사용해도 초보자부터 숙련된 개발자까지 작업 시간을 크게 단축할 수 있습니다.</p>

<h2 id="emmet-사용법-굉장히-쉽고-편리함">Emmet 사용법 (굉장히 쉽고 편리함)</h2>

<p>Emmet의 문법은 간단하면서도 강력합니다. 몇 가지 기본 규칙만 익히면 금방 능숙하게 사용할 수 있습니다.</p>

<ul>
  <li><strong>자식 요소:</strong> <code class="language-plaintext highlighter-rouge">&gt;</code> 기호를 사용하여 자식 요소를 생성합니다. 예를 들어, <code class="language-plaintext highlighter-rouge">div&gt;p</code>는 <code class="language-plaintext highlighter-rouge">&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;</code>로 확장됩니다.</li>
  <li><strong>형제 요소:</strong> <code class="language-plaintext highlighter-rouge">+</code> 기호를 사용하여 형제 요소를 생성합니다. 예를 들어, <code class="language-plaintext highlighter-rouge">h2+p</code>는 <code class="language-plaintext highlighter-rouge">&lt;h2&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;</code>로 확장됩니다.</li>
  <li><strong>반복 요소:</strong> <code class="language-plaintext highlighter-rouge">*</code> 기호를 사용하여 요소를 반복 생성합니다. 예를 들어, <code class="language-plaintext highlighter-rouge">li*3</code>는 <code class="language-plaintext highlighter-rouge">&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;</code>로 확장됩니다.</li>
  <li><strong>그룹화:</strong> <code class="language-plaintext highlighter-rouge">()</code> 괄호를 사용하여 요소들을 그룹으로 묶을 수 있습니다. 예를 들어, <code class="language-plaintext highlighter-rouge">div&gt;(header&gt;ul&gt;li*2)+footer</code>는 다음과 같이 확장됩니다.</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div&gt;</span>
  <span class="nt">&lt;header&gt;</span>
    <span class="nt">&lt;ul&gt;</span>
      <span class="nt">&lt;li&gt;&lt;/li&gt;</span>
      <span class="nt">&lt;li&gt;&lt;/li&gt;</span>
    <span class="nt">&lt;/ul&gt;</span>
  <span class="nt">&lt;/header&gt;</span>
  <span class="nt">&lt;footer&gt;&lt;/footer&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<ul>
  <li><strong>속성 추가:</strong> <code class="language-plaintext highlighter-rouge">[]</code> 괄호를 사용하여 요소에 속성을 추가할 수 있습니다. 예를 들어, <code class="language-plaintext highlighter-rouge">a[href=#]</code>는 <code class="language-plaintext highlighter-rouge">&lt;a href="#"&gt;&lt;/a&gt;</code>로 확장됩니다. 여러 속성을 추가하려면 <code class="language-plaintext highlighter-rouge">a[href=# title=링크]</code>와 같이 작성합니다.</li>
  <li><strong>클래스 및 ID 추가:</strong> CSS 선택자처럼 <code class="language-plaintext highlighter-rouge">.</code> 기호로 클래스를, <code class="language-plaintext highlighter-rouge">#</code> 기호로 ID를 추가할 수 있습니다. 예를 들어, <code class="language-plaintext highlighter-rouge">div.container</code>는 <code class="language-plaintext highlighter-rouge">&lt;div class="container"&gt;&lt;/div&gt;</code>로, <code class="language-plaintext highlighter-rouge">div#header</code>는 <code class="language-plaintext highlighter-rouge">&lt;div id="header"&gt;&lt;/div&gt;</code>로 확장됩니다. 여러 개의 클래스를 추가하려면 <code class="language-plaintext highlighter-rouge">div.container.main</code>처럼 작성합니다.</li>
  <li><strong>텍스트 내용 추가:</strong> <code class="language-plaintext highlighter-rouge">{}</code> 중괄호 안에 텍스트 내용을 입력할 수 있습니다. 예를 들어, <code class="language-plaintext highlighter-rouge">p{안녕하세요}</code>는 <code class="language-plaintext highlighter-rouge">&lt;p&gt;안녕하세요&lt;/p&gt;</code>로 확장됩니다.</li>
</ul>

<p>이 외에도 다양한 기능들이 있지만, 이 정도만 알아도 Emmet의 강력함을 충분히 경험할 수 있습니다.</p>

<h2 id="emmet-어디에서-사용할-수-있나요">Emmet, 어디에서 사용할 수 있나요?</h2>

<p>Emmet은 대부분의 텍스트 에디터와 IDE에서 플러그인 형태로 제공됩니다. Visual Studio Code, Sublime Text, Atom, IntelliJ IDEA 등 유명한 에디터에서는 기본적으로 Emmet을 지원하거나, 간단한 설치만으로 사용할 수 있습니다.</p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[웹 개발 생산성을 극대화하는 Emmet의 강력한 기능과 활용법을 알아보자.]]></summary></entry><entry><title type="html">[AI] 생성형 AI와 LLM</title><link href="https://nan0silver.github.io/ai/2025-01-16-basic/" rel="alternate" type="text/html" title="[AI] 생성형 AI와 LLM" /><published>2025-01-16T00:00:00+00:00</published><updated>2025-01-22T03:17:43+00:00</updated><id>https://nan0silver.github.io/ai/basic</id><content type="html" xml:base="https://nan0silver.github.io/ai/2025-01-16-basic/"><![CDATA[<ul>
  <li><a href="#llm-large-language-model">LLM</a></li>
  <li><a href="#생성형-ai-generative-ai">생성형 AI</a></li>
  <li><a href="#gpt-genertive-pre-trained-transformer">GPT</a></li>
  <li><a href="#prompt-engineering">Prompt Engineering</a></li>
  <li><a href="#rtf-framework">RTF Framework</a></li>
</ul>

<hr />

<h2 id="llm-large-language-model">LLM (Large Language Model)</h2>

<ul>
  <li>광범위한 양의 텍스트 데이터를 학습한 모델</li>
  <li>인간의 글과 대화 방식을 받아들이며 더욱 정교하고 자연스러운 대화 능력 갖춰감</li>
</ul>

<h2 id="생성형-ai-generative-ai">생성형 AI (Generative AI)</h2>

<ul>
  <li>데이터를 분석하고 학습하여 새로운 콘텐츠를 생성하는 인공지능 기술</li>
</ul>

<h3 id="gpt-genertive-pre-trained-transformer">GPT (Genertive Pre-trained Transformer)</h3>

<ul>
  <li>OpenAI가 개발한 대형 언어 모델로, 사전 학습된 트렌스포머 구조를 기반으로 한 생성형 AI기술
    <ul>
      <li>트렌스포머 구조
        <ul>
          <li>Google의 논문 “Attention is All You Need”에서 소개된 딥러닝 모델 구조</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Pre-training
    <ul>
      <li>방대한 텍스트 데이터를 기반으로 언어의 패턴과 문맥을 학습</li>
    </ul>
  </li>
  <li>Fine-tuning (미세 조정)
    <ul>
      <li>특정 목적이나 응용에 맞춰 추가 학습을 진행하여 성능 최적화</li>
    </ul>
  </li>
  <li>
    <p>생성 능력</p>

    <ul>
      <li>기존 데이터를 이해하고 이를 기반으로 새로운 텍스트 생성</li>
    </ul>
  </li>
  <li>
    <p>ChatGPT</p>

    <ul>
      <li>맥락을 파악하는 능력이 뛰어남</li>
    </ul>
  </li>
  <li>환각(Hallucinate)
    <ul>
      <li>실제 데이터나 사실을 반영하지 않고 비현실적이거나 오류를 포함하 내용을 만들어내는 경우가 있다</li>
      <li>해결 방법
        <ol>
          <li>파인 튜닝</li>
          <li>프롬프트 엔지니어링</li>
          <li>크로스체킹</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h2 id="prompt-engineering">Prompt Engineering</h2>

<ul>
  <li>어떻게 질문을 하느냐에 따라 결과가 달라질 수 있음</li>
  <li>필요성
    <ol>
      <li>내가 원하는 바를 정확히 주면 줄수록 정확한 대답을 얻을 수 있음</li>
      <li>언제나 고급 모델을 쓸수는 없음 (너무 비쌈)</li>
    </ol>
  </li>
</ul>

<ol>
  <li>Zero-shot Prompting
    <ul>
      <li>작업에 대한 지시만 포함하는 프롬프트 방식</li>
    </ul>
  </li>
  <li>One-shot Prompting
    <ul>
      <li>작업 예시를 하나 제공하여 AI가 이를 참고로 결과를 생성하도록 하는 방식</li>
    </ul>
  </li>
  <li>Few-shot Prompting
    <ul>
      <li>작업 예시를 여러 개 제공하는 방식</li>
      <li>복잡한 작업 수행에서 사용</li>
    </ul>
  </li>
  <li>Chain of Thought (CoT)
    <ul>
      <li>모델이 단계적으로 사고 과정을 출력하도록 유도</li>
    </ul>
  </li>
  <li>Zero-shot CoT</li>
  <li>Tree of Thoughts (ToT)
    <ul>
      <li>가능한 대안을 모두 도출하고 그 중 촤선의 답변을 선택하도록 하는 방식</li>
      <li>“모든 옵션을 평가하고 가장 좋은 대안을 제시하세요”</li>
    </ul>
  </li>
  <li>ReAct
    <ul>
      <li>결과물을 생성(Reaction)하고 피드백(Reasoning)을 통해 개선해나가는 방식</li>
      <li>“예제를 짜고 정상적으로 작동하는지 검증하시오”</li>
    </ul>
  </li>
</ol>

<h2 id="rtf-framework">RTF Framework</h2>

<ul>
  <li>Role, Task, Format를 명확히 정의해 프롬프트를 설계하는 방법론</li>
  <li>Role-based Prompting
    <ul>
      <li>AI의 역할을 명확히 지정하여 특정 관점이나 전문성으로 답 얻을 수 있음</li>
    </ul>
  </li>
  <li>Task
    <ul>
      <li>특정 작업을 지시</li>
      <li>프롬프트의 핵심</li>
    </ul>
  </li>
  <li>
    <p>Format</p>

    <ul>
      <li>AI의 응답 형식을 지정 (JSON, 엑셀 등)</li>
    </ul>
  </li>
  <li>면접할때 사용 가능
    <ul>
      <li>당신은 백엔드 면접관입니다. 주니어 개발자 면접을 진행할 때 어떤 질문을 묻겠습니까?</li>
    </ul>
  </li>
  <li>학습자의 수준에 맞춘 접근 가능</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="ai" /><summary type="html"><![CDATA[생성형 AI와 LLM에 대해 알아보자.]]></summary></entry><entry><title type="html">[AI] RAG (Retrieval-Augmented Generation) 이란?</title><link href="https://nan0silver.github.io/ai/2025-01-15-rag/" rel="alternate" type="text/html" title="[AI] RAG (Retrieval-Augmented Generation) 이란?" /><published>2025-01-15T00:00:00+00:00</published><updated>2025-01-22T03:17:43+00:00</updated><id>https://nan0silver.github.io/ai/rag</id><content type="html" xml:base="https://nan0silver.github.io/ai/2025-01-15-rag/"><![CDATA[<ul>
  <li><a href="#rag-retrieval-augmented-generation">RAG</a></li>
  <li><a href="#rag의-작동-방식">RAG의 작동 방식</a></li>
  <li><a href="#rag의-장점">RAG의 장점</a></li>
  <li><a href="#rag의-활용-분야">RAG의 활용 분야</a></li>
  <li><a href="#결론">결론</a></li>
</ul>

<hr />

<h2 id="rag-retrieval-augmented-generation">RAG (Retrieval-Augmented Generation)</h2>

<p>최근 몇 년 동안 인공지능 분야, 특히 자연어 처리(NLP) 분야는 놀라운 발전을 거듭해 왔습니다. 그 중심에는 사용자의 질문에 답변하거나, 글을 창작하거나, 심지어 코드를 생성하는 등 다양한 작업을 수행할 수 있는 거대 언어 모델(LLM)이 있습니다. 하지만 이러한 강력한 모델도 <em>학습 데이터에 없거나 최신 정보</em>에 대해서는 어려움을 겪을 수 있습니다.</p>

<p>이러한 한계를 극복하기 위해 등장한 기술이 바로 <strong>RAG (Retrieval-Augmented Generation)</strong>, 즉 <strong>검색 증강 생성</strong>입니다.
RAG는 <strong>언어 모델이 답변을 생성하기 전에 외부 지식 소스에서 관련 정보를 검색하여 답변의 품질과 정확성을 높이는 방법론</strong>입니다. 마치 20년차 개발자가 새로운 기술에 대해 설명하기 전에 관련 문서를 찾아보고 이해하는 과정과 유사하다고 볼 수 있습니다.</p>

<h2 id="rag의-작동-방식">RAG의 작동 방식</h2>

<ol>
  <li>
    <p><strong>검색 (Retrieval)</strong></p>

    <ul>
      <li>사용자의 질문이나 요청이 들어오면, RAG 시스템은 미리 구축된 외부 지식 베이스에서 관련 정보를 검색합니다. 이 지식 베이스는 문서, 웹 페이지, 데이터베이스 등 다양한 형태를 가질 수 있습니다.</li>
      <li>검색 과정에서는 질문의 의미를 파악하고, 지식 베이스 내의 정보와 유사성을 비교하여 가장 관련성이 높은 정보를 추출합니다.</li>
    </ul>
  </li>
  <li>
    <p><strong>생성 (Generation)</strong></p>
    <ul>
      <li>검색된 관련 정보는 원래의 질문 또는 요청과 함께 언어 모델에 입력됩니다. 언어 모델은 이 정보를 바탕으로 답변을 생성합니다.</li>
      <li>이때, 단순히 검색된 정보를 나열하는 것이 아니라, 검색된 정보를 바탕으로 새로운 문장을 구성하거나, 질문에 대한 답변을 논리적으로 도출하는 등 더욱 풍부하고 맥락에 맞는 답변을 생성할 수 있습니다.</li>
    </ul>
  </li>
</ol>

<h2 id="rag의-장점">RAG의 장점</h2>

<ul>
  <li><strong>정보의 최신성 확보</strong>
    <ul>
      <li>언어 모델은 학습 데이터 시점 이후의 최신 정보에 접근하기 어렵습니다. RAG는 외부 지식 베이스를 통해 실시간 또는 최신 정보를 활용하여 답변의 정확성을 높일 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>답변의 근거 제시</strong>
    <ul>
      <li>RAG는 답변을 생성할 때 사용된 외부 정보의 출처를 제시할 수 있습니다. 이는 답변의 신뢰도를 높이고, 사용자가 정보를 추가적으로 검증할 수 있도록 돕습니다.</li>
    </ul>
  </li>
  <li><strong>모델 업데이트 비용 절감</strong>
    <ul>
      <li>기존 언어 모델은 새로운 정보를 학습시키기 위해 모델 전체를 재학습해야 하는 경우가 많아 비용과 시간이 많이 소요됩니다. RAG는 외부 지식 베이스만 업데이트하면 되므로 모델 업데이트 비용을 크게 절감할 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>특정 도메인에 대한 전문성 강화</strong>
    <ul>
      <li>특정 분야의 지식 베이스를 RAG에 활용하면, 언어 모델은 해당 분야에 대한 전문적인 답변을 제공할 수 있습니다. 예를 들어, 의료 분야의 RAG 시스템은 최신 의학 논문을 검색하여 환자에게 정확한 정보를 제공할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="rag의-활용-분야">RAG의 활용 분야</h2>

<ul>
  <li><strong>챗봇 및 가상 비서</strong>
    <ul>
      <li>사용자의 질문에 대해 최신 정보를 기반으로 정확하고 상세한 답변을 제공하는 챗봇을 구축할 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>지식 검색 시스템</strong>
    <ul>
      <li>방대한 양의 문서나 데이터베이스에서 사용자의 질문에 가장 적합한 정보를 빠르게 찾아 제공하는 시스템을 구축할 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>콘텐츠 생성</strong>
    <ul>
      <li>특정 주제에 대한 최신 정보를 검색하여 블로그 게시물, 기사, 보고서 등 다양한 형태의 콘텐츠를 생성하는 데 활용될 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>교육 및 연구</strong>
    <ul>
      <li>학생이나 연구자가 특정 주제에 대한 정보를 검색하고 이해하는 과정을 돕는 도구로 활용될 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="결론">결론</h2>

<p>RAG (Retrieval-Augmented Generation)은 언어 모델의 잠재력을 한 단계 더 끌어올리는 중요한 기술입니다. 외부 지식 소스를 활용하여 답변의 정확성, 최신성, 신뢰성을 높임으로써, 인공지능이 더욱 유용하고 신뢰할 수 있는 도구로 발전하는 데 기여할 것입니다. 마치 숙련된 개발자가 끊임없이 새로운 정보를 습득하고 활용하여 문제를 해결하는 것처럼, RAG는 인공지능이 더욱 똑똑하게 정보를 처리하고 활용할 수 있도록 돕는 핵심적인 기술입니다.</p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="ai" /><summary type="html"><![CDATA[RAG (Retrieval-Augmented Generation)에 대해 알아보자.]]></summary></entry><entry><title type="html">[Algorithm] Linear Time Sorting Algorithm</title><link href="https://nan0silver.github.io/algorithm/2024-12-13-linear-time-sorting/" rel="alternate" type="text/html" title="[Algorithm] Linear Time Sorting Algorithm" /><published>2024-12-13T00:00:00+00:00</published><updated>2025-01-22T03:17:43+00:00</updated><id>https://nan0silver.github.io/algorithm/linear-time-sorting</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2024-12-13-linear-time-sorting/"><![CDATA[<ol>
  <li><a href="#counting-sort">Counting Sort</a></li>
  <li><a href="#radix-sort">Radix Sort</a></li>
  <li><a href="#order-statistics">Order Statistics</a></li>
  <li><a href="#randomized-selection">Randomized Selection</a></li>
  <li><a href="#worst-case-linear-time-selection">Worst-Case Linear-Time Selection</a></li>
  <li><a href="#그외">그외</a></li>
</ol>

<hr />

<h2 id="counting-sort">Counting Sort</h2>

<ul>
  <li>No comparison sort</li>
  <li>조건
    <ul>
      <li>데이터의 크기 범위가 제한된 경우</li>
      <li>데이터의 갯수가 상수개인 경우</li>
    </ul>
  </li>
  <li>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">CountingSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">k</span>
          <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span>
          <span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">to</span> <span class="n">k</span>
          <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="n">downto</span> <span class="mi">1</span>
      <span class="c1">//stable하게 만들기 위해 1 to n이 아닌 n to 1 수행</span>
          <span class="n">B</span><span class="p">[</span><span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
          <span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>k가 n개 이하일 때 정렬이 가능하다.
    <ul>
      <li>k가 너무 큰 경우 각 자리수마다 counting sort를 수행하는 방법을 사용할 수 있다. - radix sort</li>
    </ul>
  </li>
  <li>시간 복잡도 : \(O(n)\)</li>
  <li>장점
    <ul>
      <li>stable하다</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>in-place 알고리즘은 아니다. (extra place 필요)</li>
    </ul>
  </li>
</ul>

<h2 id="radix-sort">Radix Sort</h2>

<ul>
  <li>counting sort의 일반 버전</li>
  <li>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">RadixSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">d</span><span class="p">){</span>
      <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span> <span class="n">to</span> <span class="n">d</span>
          <span class="n">StableSort</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="n">on</span> <span class="n">digit</span> <span class="n">i</span>
          <span class="c1">//StableSort = counting sort</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>시간 복잡도 : \(d*O(n)\)</li>
  <li>Radix Sort의 핵심은 stable한 것이다.</li>
  <li>counting sort때문에 in-place하진 않다.</li>
  <li>자릿수의 최대 값은 \(logn\)이다. 따라서 radix sort가 merge sort보다 빠를 수 있다.</li>
  <li>한계
    <ul>
      <li>길이가 다른 문자열같은 digit이 정확하지 않으면 사용할 수 없다.</li>
    </ul>
  </li>
</ul>

<h2 id="order-statistics">Order Statistics</h2>

<ul>
  <li>n개의 요소들 중 i번째로 작은 요소를 고르는 것</li>
  <li>minimun은 첫 번째 order statistic</li>
</ul>

<h3 id="randomized-selection">Randomized Selection</h3>

<ul>
  <li>quicksort의 partition()을 사용한다.</li>
  <li>하지만 우리는 오직 하나의 subarray만 평가하면 된다.</li>
  <li>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">RandomizedSelect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="n">then</span> <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
      <span class="n">p</span> <span class="o">=</span> <span class="n">RandomizedPartition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="n">then</span> <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="n">then</span>
          <span class="k">return</span> <span class="nf">RandomizedSelect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
      <span class="k">else</span>
          <span class="k">return</span> <span class="nf">RandomizedSelect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
      <span class="err">```</span>
</code></pre></div>    </div>
  </li>
  <li>시간 복잡도
    <ul>
      <li>worst case : \(O(n^2)\)</li>
      <li>best, average case : \(O(n)\)</li>
    </ul>
  </li>
</ul>

<h3 id="worst-case-linear-time-selection">Worst-Case Linear-Time Selection</h3>

<ul>
  <li>generte a good partitioning element</li>
  <li>Randomized selection에서 pivot value를 고르는데 추가로 $\Theta(n)$시간을 써 업그레이드한 방법</li>
  <li>알고리즘
    <ul>
      <li>n개의 element들을 5개씩 묶어 그룹을 만든다.</li>
      <li>각 그룹의 중간값을 찾는다. -&gt; \(O(const)\)</li>
      <li>Select()를 재귀적으로 사용해 n/5개의 중간값 x를 찾는다.
        <ul>
          <li>
\[n/5 + n/25 + n/125 + ... &lt; n\]
          </li>
        </ul>
      </li>
      <li>x를 중심으로 partition을 진행한다.</li>
    </ul>
  </li>
  <li>시간 복잡도 : \(O(n)\)</li>
  <li>Quick sort에서도 해당 알고리즘을 이용해 worst case의 시간복잡도를 \(O(nlogn)\)으로 만들 수 있다.
    <ul>
      <li>하지만 이 경우 pivot value를 찾는 과정에서 캐쉬가 한번 뒤집혀져 quick sort의 장점 중 하나인 cache friendly 장점이 사라진다.</li>
      <li>차라리 merge sort나 heap sort를 사용한다.</li>
    </ul>
  </li>
</ul>

<h3 id="그외">그외</h3>

<ul>
  <li>Insertion sort
    <ul>
      <li>
\[O(n^2)\]
      </li>
    </ul>
  </li>
  <li>Merge sort, Heap sort, Quick sort
    <ul>
      <li>comparison sort</li>
      <li>all comparison sorts are \(\Omega(nlogn)\)</li>
    </ul>
  </li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[선형 시간이 걸리는 정렬 알고리즘에 대해 알아본다.]]></summary></entry><entry><title type="html">[Algorithm] 분할정복 알고리즘 (Divide and conquer)</title><link href="https://nan0silver.github.io/algorithm/2024-12-12-divide-conquer/" rel="alternate" type="text/html" title="[Algorithm] 분할정복 알고리즘 (Divide and conquer)" /><published>2024-12-12T00:00:00+00:00</published><updated>2025-01-22T03:17:43+00:00</updated><id>https://nan0silver.github.io/algorithm/divide-conquer</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2024-12-12-divide-conquer/"><![CDATA[<ul>
  <li><a href="#분할정복-알고리즘-divide-and-conquer-algorithm">분할정복 알고리즘</a>
    <ul>
      <li><a href="#설계-방법">설계 방법</a></li>
      <li><a href="#특징-및-장단점">특징 및 장단점</a></li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="분할정복-알고리즘-divide-and-conquer-algorithm">분할정복 알고리즘 (Divide and conquer algorithm)</h2>

<ul>
  <li>
    <p>그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법.</p>
  </li>
  <li>
    <p>대표적인 예로는 정렬 알고리즘 중에서 퀵 정렬이나 합병 정렬과 이진 탐색, 선택 문제, 고속 푸리에 변환(FFT) 문제들이 있음.</p>
  </li>
</ul>

<h3 id="설계-방법"><strong>설계 방법</strong></h3>

<p><strong>1) Divide</strong></p>

<p>∙  원래 문제가 분할하여 비슷한 유형의 더 작은 하위 문제로 분할이 가능할 때 까지 나눈다.</p>

<p><strong>2) Conquer</strong></p>

<p>∙  각 하위 문제를 재귀적으로 해결한다. 하위 문제의 규모가 나눌 수 없는 단위가 되면 탈출 조건을 설정하고 해결한다.</p>

<p><strong>3) Combine</strong></p>

<p>∙  Conquer한 문제들을 통합하여 원래 문제의 답을 얻어 해결한다.</p>

<p>🖋 Divide를 제대로 나누면 Conquer과정은 자동으로 쉬워진다. 그래서 Divide를 잘 설계하는 것이 중요!</p>

<p>🖋 분할정복 알고리즘은 재귀 알고리즘이 많이 사용되는데, 이 부분에서 분할정복 알고리즘의 효율성을 깎아내릴 수 있다.</p>

<h3 id="특징-및-장단점"><strong>특징 및 장단점</strong></h3>

<p>∙  분할된 작은 문제는 원래 문제와 성격이 동일하다  -&gt; 입력 크기만 작아짐</p>

<p>∙  분할된 문제는 서로 독립적이다(중복 제거 X) -&gt; 순환적 분할  및 결과 결합 가능</p>

<p>∙  분할정복은 Top-down방식으로 재귀 호출의 장단점과 똑같다고 보면 된다.</p>

<table>
  <thead>
    <tr>
      <th>장점</th>
      <th>단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>∙  Top-down 재귀방식으로 구현하기 때문에 코드가 직관적이다.</td>
      <td>∙  재귀함수 호출로 오버헤드가 발생할 수 있다</td>
    </tr>
    <tr>
      <td>∙  문제를 나누어 해결한다는 특징상 병렬적으로 문제를 해결할 수 있다.</td>
      <td>∙  스택에 다량의 데이터가 보관되는 경우 오버플로우가 발생할 수 있다.</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[분할정복 알고리즘에 대한 설명입니다.]]></summary></entry><entry><title type="html">[JAVA] Set</title><link href="https://nan0silver.github.io/java/2024-12-08-set/" rel="alternate" type="text/html" title="[JAVA] Set" /><published>2024-12-08T00:00:00+00:00</published><updated>2025-01-22T03:17:43+00:00</updated><id>https://nan0silver.github.io/java/set</id><content type="html" xml:base="https://nan0silver.github.io/java/2024-12-08-set/"><![CDATA[<p>목차</p>
<ol>
  <li><a href="#텍스트-블록">텍스트 블록</a></li>
  <li><a href="#formatted-메서드">formatted() 메서드</a></li>
  <li><a href="#레코드">레코드</a></li>
  <li><a href="#패턴-매칭">패턴 매칭</a></li>
  <li><a href="#자료형에-맞는-case-처리">case문 개선</a></li>
</ol>

<hr />

<h2 id="set">Set</h2>
<ul>
  <li>데이터 자료구조(데이터 컬렉션) 중 하나로, 특정한 값들을 저장하는 추상자료형</li>
  <li>List와 다르게 데이터를 중복해서 저장할 수 없음</li>
  <li>저장된 데이터를 인덱스로 관리하지 않기 때문에 저장 순서가 보장되지 않음</li>
  <li>수학의 유한 집합을 컴퓨터로 구현한 것</li>
  <li>특성
    <ul>
      <li>데이터를 비순차적으로 저장할 수 있는 순열 자료구조</li>
      <li>삽입한 데이터가 순서대로 저장되지 않음</li>
      <li>수정 가능(mutable)</li>
      <li>중복해서 삽입 불가능</li>
      <li>Fast Lookup이 필요할 때 주로 쓰임</li>
    </ul>
  </li>
  <li>대표적인 클래스
    <ul>
      <li>HashSet, TreeSet, LinkedHashSet</li>
    </ul>
  </li>
  <li>클래스들의 주요 메소드
    <ul>
      <li>add(E e)
        <ul>
          <li>리턴타입 : boolean</li>
        </ul>
      </li>
      <li>interator()
        <ul>
          <li>리턴타입 : Iterator<E></E></li>
          <li>검색을 위한 반복자 생성</li>
        </ul>
      </li>
      <li>size()
        <ul>
          <li>리턴타입 : int</li>
        </ul>
      </li>
      <li>clear()
        <ul>
          <li>리턴타입 : void</li>
        </ul>
      </li>
      <li>remove(Object o)
        <ul>
          <li>리턴타입 : boolean</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="hashset">HashSet</h3>
<ul>
  <li>Set 컬랙션을 구현하는 대표적인 클래스</li>
  <li>데이터를 중복 저장할 수 없고 순서를 보장하지 않는다.</li>
  <li>예시
    <ul>
      <li>
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
  <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"one"</span><span class="o">);</span>
  <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"two"</span><span class="o">);</span>

  <span class="nc">Interator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        
  <span class="k">while</span><span class="o">(</span><span class="n">iter</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span> <span class="c1">//꺼낼 것이 있다면 true 리턴</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">iter</span><span class="o">.</span><span class="na">next</span><span class="o">());</span> <span class="c1">//다음 데이터 리턴</span>
  <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="treeset">TreeSet</h3>
<ul>
  <li>중복된 데이터를 저장할 수 없고 입력한 순서대로 값을 저장하지 않음</li>
  <li>TreeSet은 기본적으로 오름차순으로 데이터를 정렬</li>
</ul>

<h3 id="linkedhashset">LinkedHashSet</h3>
<ul>
  <li>입력된 순서대로 데이터를 관리한다.</li>
  <li>중복된 데이터를 저장할 수는 없음</li>
  <li>저장된 데이터의 존재를 빠르게 확인할 수 있지만 내부에 삽입 순서로 정렬된 목록이 포함됨</li>
  <li>포켓몬 고와 같은 게임에서 객체가 이미 목록에 있는지 여부를 빠르게 확인하고 목록에 없는 경우 목록에 추가할 수 있음</li>
  <li>LinkedHashSet vs HashSet
    <ul>
      <li>HashSet은 HashMap을 사용해 개체를 저장</li>
      <li>LinkedHashSet은 LinkedHashMap을 사용</li>
      <li>삽입 순서를 유지할 필요가 없지만 고유한 개체를 저장해야하는 경우 HashSet이 적합</li>
      <li>LinkedHashSet의 성능은 HashSet보다 약간 느림</li>
    </ul>
  </li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="java" /><summary type="html"><![CDATA[JAVA의 Set의 사용법을 알아본다.]]></summary></entry></feed>