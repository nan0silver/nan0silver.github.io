<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2026-01-12T05:19:58+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[친구하자] SSL 인증서 자동 갱신 설정하기 (Amazon Linux + Let’s Encrypt)</title><link href="https://nan0silver.github.io/projectdiary/2026-01-12-diary/" rel="alternate" type="text/html" title="[친구하자] SSL 인증서 자동 갱신 설정하기 (Amazon Linux + Let’s Encrypt)" /><published>2026-01-12T00:00:00+00:00</published><updated>2026-01-12T05:19:16+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2026-01-12-diary/"><![CDATA[<ul>
  <li><a href="#문제-상황">문제 상황</a></li>
  <li><a href="#ssl-인증서란">SSL 인증서란?</a></li>
  <li><a href="#lets-encrypt와-90일-갱신-주기">Let’s Encrypt와 90일 갱신 주기</a></li>
  <li><a href="#해결-과정">해결 과정</a></li>
</ul>

<hr />

<h2 id="문제-상황">문제 상황</h2>

<p>프로덕션 환경에서 갑자기 로그인이 안 되는 문제가 발생했다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET https://{backend-domain}/api/v1/auth/oauth/kakao/config?platform=web
net::ERR_CERT_DATE_INVALID
</code></pre></div></div>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2026-01-11-pic1.png?raw=true" alt="에러 이미지1" /></p>

<p>브라우저 콘솔에 찍힌 에러 메시지를 보니 <code class="language-plaintext highlighter-rouge">ERR_CERT_DATE_INVALID</code> - SSL 인증서 날짜가 유효하지 않다는 것이었다.</p>

<h2 id="ssl-인증서란">SSL 인증서란?</h2>

<p>SSL(Secure Sockets Layer) 인증서는 웹사이트와 사용자 브라우저 간의 통신을 암호화하는 디지털 인증서이다.
HTTPS 통신을 위해서는 반드시 필요하며, 다음과 같은 역할을 한다:</p>

<ul>
  <li><strong>데이터 암호화</strong>: 사용자와 서버 간 주고받는 데이터를 암호화</li>
  <li><strong>신원 검증</strong>: 해당 도메인이 인증된 소유자에 의해 운영됨을 증명</li>
  <li><strong>데이터 무결성</strong>: 전송 중 데이터가 변조되지 않았음을 보장</li>
</ul>

<p>특히 OAuth 로그인 같은 민감한 정보를 다루는 경우, 카카오나 구글 같은 OAuth 제공자들은 <strong>HTTPS를 필수</strong>로 요구한다.</p>

<h2 id="lets-encrypt와-90일-갱신-주기">Let’s Encrypt와 90일 갱신 주기</h2>

<p>Let’s Encrypt는 무료로 SSL 인증서를 발급해주는 비영리 인증 기관이다. 하지만 한 가지 특징이 있다:</p>

<p><strong>인증서 유효기간이 90일</strong></p>

<p>왜 90일일까?</p>

<ol>
  <li><strong>보안 강화</strong>: 인증서가 탈취되더라도 피해 기간이 짧음</li>
  <li><strong>자동화 유도</strong>: 수동 갱신이 번거로워 자동화를 강제함</li>
  <li><strong>키 교체 주기</strong>: 정기적인 키 교체로 보안성 향상</li>
</ol>

<p>일반 상용 인증서는 1년 단위인데, Let’s Encrypt는 무료 대신 짧은 주기로 설정했다.
결과적으로 <strong>자동 갱신 설정</strong>이 필요했다.</p>

<h2 id="해결-과정">해결 과정</h2>

<h3 id="1-즉시-인증서-갱신">1. 즉시 인증서 갱신</h3>

<p>먼저 만료된 인증서를 갱신해서 서비스를 복구했다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># EC2 서버에 SSH 접속</span>
ssh <span class="nt">-i</span> ~/.ssh/your-key.pem ec2-user@<span class="o">{</span>backend-domain<span class="o">}</span>

<span class="c"># 인증서 확인</span>
<span class="nb">sudo </span>certbot certificates
</code></pre></div></div>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2026-01-11-pic2.png?raw=true" alt="에러 이미지2" /></p>

<ul>
  <li>인증서를 확인하니 어제자로 만료된 것을 확인했다. (오늘은 1월 12일)</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 인증서 갱신</span>
<span class="nb">sudo </span>certbot renew

<span class="c"># Nginx 재시작</span>
<span class="nb">sudo </span>systemctl reload nginx
</code></pre></div></div>

<h3 id="2-자동-갱신-설정">2. 자동 갱신 설정</h3>

<p>하지만 90일마다 수동으로 갱신할 수는 없다고 생각해, cron을 이용해 자동 갱신을 설정했다.</p>

<h4 id="amazon-linux에서-cron-설치">Amazon Linux에서 cron 설치</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># cronie 패키지 설치</span>
<span class="nb">sudo </span>yum <span class="nb">install </span>cronie

<span class="c"># crond 서비스 시작 및 활성화</span>
<span class="nb">sudo </span>systemctl start crond
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>crond

<span class="c"># 상태 확인</span>
<span class="nb">sudo </span>systemctl status crond
</code></pre></div></div>

<p><strong>주의</strong>: Amazon Linux는 <code class="language-plaintext highlighter-rouge">cron</code>이 아니라 <code class="language-plaintext highlighter-rouge">crond</code>를 사용!</p>

<h4 id="crontab-설정">crontab 설정</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># root 계정의 crontab 편집</span>
<span class="nb">sudo </span>crontab <span class="nt">-e</span>
</code></pre></div></div>

<p>다음 내용을 추가한다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 2 * * * /usr/bin/certbot renew --quiet --post-hook "systemctl reload nginx"
</code></pre></div></div>

<p><strong>설정 의미:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0 2 * * *</code>: 매일 새벽 2시에 실행</li>
  <li><code class="language-plaintext highlighter-rouge">certbot renew</code>: 인증서 갱신 체크 (30일 이내 만료 시 자동 갱신)</li>
  <li><code class="language-plaintext highlighter-rouge">--quiet</code>: 출력 최소화</li>
  <li><code class="language-plaintext highlighter-rouge">--post-hook</code>: 갱신 성공 시 Nginx 재시작</li>
</ul>

<p>저장하고 종료:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i           # 입력 모드
(내용 입력)
ESC         # 명령 모드
:wq         # 저장 후 종료
</code></pre></div></div>

<h3 id="3-설정-확인">3. 설정 확인</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># crontab 목록 확인</span>
<span class="nb">sudo </span>crontab <span class="nt">-l</span>

<span class="c"># 갱신 테스트 (실제 갱신 없이 시뮬레이션)</span>
<span class="nb">sudo </span>certbot renew <span class="nt">--dry-run</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">--dry-run</code>으로 테스트하면 실제 갱신 없이 프로세스가 정상 작동하는지 확인할 수 있다.</p>

<h2 id="작동-원리">작동 원리</h2>

<p>설정 후 시스템은 다음과 같이 동작한다:</p>

<ol>
  <li><strong>매일 새벽 2시</strong>, cron이 <code class="language-plaintext highlighter-rouge">certbot renew</code> 실행</li>
  <li>certbot이 인증서 만료일 체크</li>
  <li><strong>만료 30일 이내</strong>인 경우에만 실제 갱신 진행</li>
  <li>갱신 성공 시 자동으로 Nginx 재시작</li>
  <li>갱신 불필요 시 조용히 종료</li>
</ol>

<p>즉, 설정만 해두면 <strong>완전 자동으로</strong> 인증서가 관리된다.</p>

<h2 id="결론">결론</h2>

<p>SSL 인증서 만료로 인한 서비스 장애는 치명적이다. 특히 OAuth 인증을 사용하는 서비스에서는 로그인 자체가 불가능해잔다.</p>

<p>Let’s Encrypt를 사용한다면:</p>

<ul>
  <li>✅ cron 자동 갱신 설정은 필수</li>
  <li>✅ <code class="language-plaintext highlighter-rouge">--dry-run</code>으로 정기적으로 테스트</li>
  <li>✅ 갱신 실패 시 알림 설정 권장 (이메일 등)</li>
</ul>

<p>90일마다 수동 갱신하는 것보다, 한 번 제대로 자동화 설정해두는 것이 훨씬 안전하고 편리하다.</p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://letsencrypt.org/docs/">Let’s Encrypt 공식 문서</a></li>
  <li><a href="https://certbot.eff.org/">Certbot 사용 가이드</a></li>
  <li><a href="https://docs.aws.amazon.com/linux/">Amazon Linux cron 설정</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[SSH 인증서가 만료되어 이에 대해 공부한 내용과 해결한 내용에 대해 정리했습니다.]]></summary></entry><entry><title type="html">[Algorithm] 코딩테스트 알고리즘 선택방법 요약</title><link href="https://nan0silver.github.io/algorithm/2026-01-09-summary/" rel="alternate" type="text/html" title="[Algorithm] 코딩테스트 알고리즘 선택방법 요약" /><published>2026-01-09T00:00:00+00:00</published><updated>2026-01-12T05:19:16+00:00</updated><id>https://nan0silver.github.io/algorithm/summary</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2026-01-09-summary/"><![CDATA[<p>코딩테스트에서 어떤 알고리즘을 선택해야 할지 고민될 때가 많다.
이 글에서는 <strong>코테 기준으로 딱 필요한 만큼만</strong> 정리한다.</p>

<hr />

<h2 id="1️⃣-문제를-읽자마자-던질-5가지-질문">1️⃣ 문제를 읽자마자 던질 5가지 질문</h2>

<table>
  <thead>
    <tr>
      <th>순서</th>
      <th>스스로에게 묻는 질문</th>
      <th>YES면</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Q1</td>
      <td>최단 거리 / 최소 횟수인가?</td>
      <td>👉 아래 Q2</td>
    </tr>
    <tr>
      <td>Q2</td>
      <td>모든 간선 가중치가 같은가?</td>
      <td>👉 <strong>BFS</strong></td>
    </tr>
    <tr>
      <td>Q3</td>
      <td>가중치가 다르지만 음수는 없는가?</td>
      <td>👉 <strong>다익스트라</strong></td>
    </tr>
    <tr>
      <td>Q4</td>
      <td>모든 쌍 (i, j) 최단거리인가?</td>
      <td>👉 <strong>플로이드-워셜</strong></td>
    </tr>
    <tr>
      <td>Q5</td>
      <td>트리(사이클 없음)인가?</td>
      <td>👉 <strong>DFS / 트리 DP</strong></td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="2️⃣-bfs--dfs--다익스트라--플로이드-비교표">2️⃣ BFS / DFS / 다익스트라 / 플로이드 비교표</h2>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>BFS</th>
      <th>DFS</th>
      <th>다익스트라</th>
      <th>플로이드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>목적</td>
      <td>최단 거리(가중치=1)</td>
      <td>탐색/구조</td>
      <td>최단 거리(가중치≠1)</td>
      <td>모든 쌍 최단</td>
    </tr>
    <tr>
      <td>자료구조</td>
      <td>Queue</td>
      <td>재귀 / Stack</td>
      <td>PriorityQueue</td>
      <td>2차원 배열</td>
    </tr>
    <tr>
      <td>시간복잡도</td>
      <td>O(N+M)</td>
      <td>O(N+M)</td>
      <td>O((N+M)logN)</td>
      <td>O(N³)</td>
    </tr>
    <tr>
      <td>거리 배열</td>
      <td>O</td>
      <td>△</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>visited</td>
      <td>O</td>
      <td>O</td>
      <td>△</td>
      <td>X</td>
    </tr>
    <tr>
      <td>대표 문제</td>
      <td>미로, 숨바꼭질</td>
      <td>트리 지름</td>
      <td>최단 비용</td>
      <td>플로이드</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="3️⃣-가중치로-바로-고르는-공식-암기용">3️⃣ “가중치”로 바로 고르는 공식 (암기용)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>최단 거리 + 가중치 = 1  → BFS
최단 거리 + 가중치 다름 → 다익스트라
모든 쌍 최단 거리      → 플로이드
</code></pre></div></div>

<hr />

<h2 id="4️⃣-트리가-나오면-이렇게-생각하자">4️⃣ “트리”가 나오면 이렇게 생각하자</h2>

<table>
  <thead>
    <tr>
      <th>문제 키워드</th>
      <th>거의 정답</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>트리 / 부모 / 자식</td>
      <td>DFS</td>
    </tr>
    <tr>
      <td>가장 긴 경로</td>
      <td>트리 지름</td>
    </tr>
    <tr>
      <td>서브트리</td>
      <td>트리 DP</td>
    </tr>
    <tr>
      <td>루트가 있음</td>
      <td>DFS</td>
    </tr>
    <tr>
      <td>간선 = 노드 - 1</td>
      <td>트리</td>
    </tr>
  </tbody>
</table>

<p>👉 <strong>트리 = DFS 기본값</strong></p>

<hr />

<h2 id="5️⃣-인접-리스트-vs-인접-행렬-선택표">5️⃣ 인접 리스트 vs 인접 행렬 선택표</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>선택</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>N ≥ 1,000</td>
      <td>인접 리스트</td>
    </tr>
    <tr>
      <td>BFS / DFS / 다익스트라</td>
      <td>인접 리스트</td>
    </tr>
    <tr>
      <td>플로이드-워셜</td>
      <td>인접 행렬</td>
    </tr>
    <tr>
      <td>메모리 제한 빡빡</td>
      <td>인접 리스트</td>
    </tr>
  </tbody>
</table>

<p><strong>코테 기본값</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;[]</span> <span class="n">graph</span><span class="o">;</span>
</code></pre></div></div>

<hr />

<h2 id="6️⃣-문제-문장--알고리즘-자동-변환-예시">6️⃣ 문제 문장 → 알고리즘 자동 변환 예시</h2>

<table>
  <thead>
    <tr>
      <th>문제 문장</th>
      <th>바로 떠올릴 것</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>“최소 몇 번 만에”</td>
      <td>BFS</td>
    </tr>
    <tr>
      <td>“최소 비용”</td>
      <td>다익스트라</td>
    </tr>
    <tr>
      <td>“모든 도시 쌍”</td>
      <td>플로이드</td>
    </tr>
    <tr>
      <td>“가장 긴 경로”</td>
      <td>트리 지름</td>
    </tr>
    <tr>
      <td>“연결되어 있는가”</td>
      <td>DFS/BFS</td>
    </tr>
    <tr>
      <td>“K 거리인 노드”</td>
      <td>BFS</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="7️⃣-실전에서-쓰는-판별-한-줄-공식">7️⃣ 실전에서 쓰는 <strong>판별 한 줄 공식</strong></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>최단 거리인가?
→ 가중치가 전부 1인가?
  → YES: BFS
  → NO : 다익스트라
트리인가?
→ DFS / 트리 DP
</code></pre></div></div>

<hr />

<h2 id="8️⃣-너가-자주-헷갈리던-문제들-정답-알고리즘">8️⃣ 너가 자주 헷갈리던 문제들, 정답 알고리즘</h2>

<table>
  <thead>
    <tr>
      <th>문제</th>
      <th>정답 알고리즘</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>특정 거리의 도시 찾기</td>
      <td>BFS</td>
    </tr>
    <tr>
      <td>숨바꼭질</td>
      <td>BFS</td>
    </tr>
    <tr>
      <td>트리의 지름</td>
      <td>DFS (2번 or DP)</td>
    </tr>
    <tr>
      <td>거짓말</td>
      <td>DSU / BFS</td>
    </tr>
    <tr>
      <td>치킨 배달</td>
      <td>조합 + 거리 계산</td>
    </tr>
    <tr>
      <td>플로이드</td>
      <td>플로이드-워셜</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-최종-요약-이-문장만-외워도-됨">🎯 최종 요약 (이 문장만 외워도 됨)</h2>

<blockquote>
  <p><strong>“알고리즘은 외우는 게 아니라,
문제 조건으로 제거하고 남는 하나를 고르는 것”</strong></p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[코딩테스트 알고리즘 선택 방법에 대해 정리해보았습니다.]]></summary></entry><entry><title type="html">[Algorithm] 플로이드-워셜 알고리즘</title><link href="https://nan0silver.github.io/algorithm/2025-12-29-floyd-warshall/" rel="alternate" type="text/html" title="[Algorithm] 플로이드-워셜 알고리즘" /><published>2025-12-29T00:00:00+00:00</published><updated>2026-01-12T05:19:16+00:00</updated><id>https://nan0silver.github.io/algorithm/floyd-warshall</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2025-12-29-floyd-warshall/"><![CDATA[<ol>
  <li><a href="#-1️⃣-플로이드-워셜이란">플로이드-워셜이란?</a></li>
  <li><a href="#-2️⃣-핵심-개념-이해하기">핵심 개념 이해하기</a></li>
  <li><a href="#-3️⃣-k-i-j의-정확한-의미">k, i, j의 의미</a></li>
  <li><a href="#-4️⃣-동작-과정-시각화">동작 과정 시각화</a></li>
  <li><a href="#-5️⃣-코드-구현">코드 구현</a></li>
  <li><a href="#-6️⃣-시간복잡도와-공간복잡도">시간복잡도와 공간복잡도</a></li>
  <li><a href="#-7️⃣-다익스트라와의-비교">다익스트라와의 비교</a></li>
  <li><a href="#-8️⃣-실전-문제-적용">실전 문제 적용</a></li>
</ol>

<hr />

<h2 id="-1️⃣-플로이드-워셜이란">🎯 1️⃣ 플로이드-워셜이란?</h2>

<h3 id="-한-문장-정의">💡 한 문장 정의</h3>

<p><strong>“모든 정점 쌍 사이의 최단 경로를 한 번에 구하는 알고리즘”</strong></p>

<h3 id="-언제-사용하는가">💡 언제 사용하는가?</h3>

<ul>
  <li>“A 도시에서 B 도시로 가는 최단 거리는?” → 모든 도시 쌍에 대해 물어볼 때</li>
  <li>“경유지를 거쳐가는 것이 더 빠른가?” → 중간 노드를 허용하며 최적 경로를 찾을 때</li>
  <li>그래프의 모든 쌍 최단 거리를 구해야 할 때</li>
</ul>

<h3 id="-특징">💡 특징</h3>

<table>
  <thead>
    <tr>
      <th>특징</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>시간복잡도</strong></td>
      <td>O(V³) - 정점 개수의 세제곱</td>
    </tr>
    <tr>
      <td><strong>공간복잡도</strong></td>
      <td>O(V²) - 2차원 배열</td>
    </tr>
    <tr>
      <td><strong>음수 간선</strong></td>
      <td>처리 가능 (단, 음수 사이클은 불가)</td>
    </tr>
    <tr>
      <td><strong>그래프 종류</strong></td>
      <td>방향/무방향 모두 가능</td>
    </tr>
    <tr>
      <td><strong>구현 난이도</strong></td>
      <td>매우 쉬움 (3중 for문)</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-2️⃣-핵심-개념-이해하기">🧠 2️⃣ 핵심 개념 이해하기</h2>

<h3 id="-알고리즘의-본질">💡 알고리즘의 본질</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"도시 i에서 도시 j로 갈 때,
k번 도시를 중간에 한 번 거쳐도 되는지를
매 단계마다 허용해가며 최소 비용을 갱신하는 알고리즘"
</code></pre></div></div>

<h3 id="-distij의-의미">💡 dist[i][j]의 의미</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">지금까지</span> <span class="n">허용된</span> <span class="n">중간</span> <span class="n">도시들만</span> <span class="n">이용해서</span>
             <span class="n">i</span> <span class="err">→</span> <span class="n">j로</span> <span class="n">가는</span> <span class="n">최소</span> <span class="n">비용</span>
</code></pre></div></div>

<p>여기서 “지금까지 허용된”이 핵심이다. k값에 따라 허용 범위가 달라진다.</p>

<h3 id="-동적-계획법dp으로서의-플로이드-워셜">💡 동적 계획법(DP)으로서의 플로이드-워셜</h3>

<p>플로이드-워셜의 본질적인 점화식:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DP[k][i][j] = 중간 도시를 1~k까지만 써서 i→j로 가는 최소 비용

DP[k][i][j] = min(
    DP[k-1][i][j],           // k를 거치지 않는 경우
    DP[k-1][i][k] + DP[k-1][k][j]  // k를 거치는 경우
)
</code></pre></div></div>

<p>실제 코드는 3차원 배열 대신 2차원 배열을 덮어쓰면서 k 단계를 확장한다.</p>

<hr />

<h2 id="-3️⃣-k-i-j의-정확한-의미">🔑 3️⃣ k, i, j의 정확한 의미</h2>

<h3 id="-기본-구조">💡 기본 구조</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>        <span class="c1">// 중간 노드</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>    <span class="c1">// 출발 노드</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 도착 노드</span>
            <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
                <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span>
                <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">+</span> <span class="n">dist</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>
            <span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="-각-변수의-의미">💡 각 변수의 의미</h3>

<table>
  <thead>
    <tr>
      <th>변수</th>
      <th>의미</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>k</strong></td>
      <td>중간에 거쳐도 되는 도시 번호</td>
      <td>k=1일 때는 1번만, k=2일 때는 1,2번까지 허용</td>
    </tr>
    <tr>
      <td><strong>i</strong></td>
      <td>출발 도시</td>
      <td>모든 출발지를 순회</td>
    </tr>
    <tr>
      <td><strong>j</strong></td>
      <td>도착 도시</td>
      <td>모든 도착지를 순회</td>
    </tr>
  </tbody>
</table>

<h3 id="-핵심-로직의-의미">💡 핵심 로직의 의미</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
    <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span>          <span class="c1">// 원래 알고 있던 i → j 최단 경로</span>
    <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">+</span> <span class="n">dist</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>  <span class="c1">// i → k → j로 가는 새로운 경로</span>
<span class="o">);</span>
</code></pre></div></div>

<p>이 코드가 묻는 질문:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"i에서 j로 바로 가는 게 낫나?"
"아니면 k를 한 번 들렀다 가는 게 낫나?"
</code></pre></div></div>

<p>시각적 표현:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i ─────────▶ j  (직접)
│
│
▼
k
</code></pre></div></div>

<h3 id="-왜-k가-가장-바깥-루프인가">💡 왜 k가 가장 바깥 루프인가?</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ 올바른 순서</span>
<span class="k">for</span> <span class="n">k</span>
  <span class="k">for</span> <span class="n">i</span>
    <span class="k">for</span> <span class="n">j</span>

<span class="c1">// ❌ 잘못된 순서</span>
<span class="k">for</span> <span class="n">i</span>
  <span class="k">for</span> <span class="n">j</span>
    <span class="k">for</span> <span class="n">k</span>
</code></pre></div></div>

<p><strong>이유</strong>: k는 “중간 도시로 k까지 허용한 상태에서 모든 i→j 최단거리를 갱신”한다는 의미다. 만약 i나 j가 바깥에 있으면 아직 허용되지 않은 중간 도시를 사용하게 되어 DP의 단계적 의미가 깨진다.</p>

<hr />

<h2 id="-4️⃣-동작-과정-시각화">📊 4️⃣ 동작 과정 시각화</h2>

<h3 id="-예시-그래프">💡 예시 그래프</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1 ──(4)── 2
    │         │
   (3)       (2)
    │         │
    3 ──(5)── 4
</code></pre></div></div>

<h3 id="-초기-상태-k--0-중간-노드-허용-안-함">💡 초기 상태 (k = 0, 중간 노드 허용 안 함)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dist[i][j] = 직접 연결된 간선만 사용

      1    2    3    4
1  [  0    4   INF  INF ]
2  [  4    0   INF   2  ]
3  [ INF  INF   0    5  ]
4  [ INF   2    5    0  ]
</code></pre></div></div>

<h3 id="-k--1-1번-노드를-중간에-사용-가능">💡 k = 1 (1번 노드를 중간에 사용 가능)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"1번을 거쳐가면 더 빠른 경로가 있나?"

i=2, j=3일 때:
dist[2][3] = min(INF, dist[2][1] + dist[1][3])
           = min(INF, 4 + INF) = INF

i=3, j=2일 때:
dist[3][2] = min(INF, dist[3][1] + dist[1][2])
           = min(INF, INF + 4) = INF
</code></pre></div></div>

<h3 id="-k--2-12번-노드를-중간에-사용-가능">💡 k = 2 (1,2번 노드를 중간에 사용 가능)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"2번을 거쳐가면 더 빠른 경로가 있나?"

i=1, j=4일 때:
dist[1][4] = min(INF, dist[1][2] + dist[2][4])
           = min(INF, 4 + 2) = 6
</code></pre></div></div>

<h3 id="-최종-결과-k--4-모든-노드-허용">💡 최종 결과 (k = 4, 모든 노드 허용)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      1    2    3    4
1  [  0    4    8    6  ]
2  [  4    0    7    2  ]
3  [  8    7    0    5  ]
4  [  6    2    5    0  ]
</code></pre></div></div>

<hr />

<h2 id="-5️⃣-코드-구현">💻 5️⃣ 코드 구현</h2>

<h3 id="-기본-템플릿">💡 기본 템플릿</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">FloydWarshall</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">INF</span> <span class="o">=</span> <span class="mi">987654321</span><span class="o">;</span>  <span class="c1">// 충분히 큰 값</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// 1. 초기화</span>

        <span class="c1">// 2. 간선 정보 입력</span>

        <span class="c1">// 3. 플로이드-워셜 알고리즘</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">!=</span> <span class="no">INF</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="no">INF</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span>
                                              <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">+</span> <span class="n">dist</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 4. 결과 출력</span>
        <span class="n">printDistances</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="-6️⃣-시간복잡도와-공간복잡도">📈 6️⃣ 시간복잡도와 공간복잡도</h2>

<h3 id="-시간복잡도">💡 시간복잡도</h3>

<table>
  <thead>
    <tr>
      <th>연산</th>
      <th>복잡도</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>플로이드-워셜</strong></td>
      <td>O(V³)</td>
      <td>3중 for문</td>
    </tr>
    <tr>
      <td><strong>초기화</strong></td>
      <td>O(V²)</td>
      <td>2차원 배열 초기화</td>
    </tr>
    <tr>
      <td><strong>전체</strong></td>
      <td>O(V³)</td>
      <td>플로이드-워셜이 지배적</td>
    </tr>
  </tbody>
</table>

<h3 id="-공간복잡도">💡 공간복잡도</h3>

<table>
  <thead>
    <tr>
      <th>자료구조</th>
      <th>크기</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>거리 배열</strong></td>
      <td>O(V²)</td>
      <td>dist[n][n]</td>
    </tr>
    <tr>
      <td><strong>경로 배열</strong></td>
      <td>O(V²)</td>
      <td>next[n][n] (선택적)</td>
    </tr>
    <tr>
      <td><strong>전체</strong></td>
      <td>O(V²)</td>
      <td>2차원 배열</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="️-7️⃣-다익스트라와의-비교">⚖️ 7️⃣ 다익스트라와의 비교</h2>

<h3 id="-핵심-차이점">💡 핵심 차이점</h3>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>플로이드-워셜</th>
      <th>다익스트라</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>목적</strong></td>
      <td>모든 쌍 최단 경로</td>
      <td>한 정점에서 모든 정점으로</td>
    </tr>
    <tr>
      <td><strong>시간복잡도</strong></td>
      <td>O(V³)</td>
      <td>O((V+E)logV)</td>
    </tr>
    <tr>
      <td><strong>공간복잡도</strong></td>
      <td>O(V²)</td>
      <td>O(V)</td>
    </tr>
    <tr>
      <td><strong>음수 간선</strong></td>
      <td>가능 (음수 사이클 제외)</td>
      <td>불가능</td>
    </tr>
    <tr>
      <td><strong>구현 난이도</strong></td>
      <td>매우 쉬움</td>
      <td>중간 (우선순위 큐)</td>
    </tr>
    <tr>
      <td><strong>적용 상황</strong></td>
      <td>정점이 적을 때 (V ≤ 500)</td>
      <td>정점이 많을 때, 특정 출발점</td>
    </tr>
  </tbody>
</table>

<h3 id="-언제-무엇을-쓸까">💡 언제 무엇을 쓸까?</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ 플로이드-워셜을 쓸 때</span>
<span class="k">if</span> <span class="o">(</span><span class="n">모든</span> <span class="n">정점</span> <span class="n">쌍의</span> <span class="n">최단</span> <span class="n">거리가</span> <span class="n">필요</span> <span class="o">&amp;&amp;</span> <span class="n">정점</span> <span class="n">수</span> <span class="err">≤</span> <span class="mi">500</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">플로이드워셜</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// ✅ 다익스트라를 쓸 때</span>
<span class="k">if</span> <span class="o">(</span><span class="n">특정</span> <span class="n">출발점에서</span> <span class="n">모든</span> <span class="n">정점까지</span> <span class="o">&amp;&amp;</span> <span class="n">음수</span> <span class="n">간선</span> <span class="n">없음</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">다익스트라</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// ✅ 벨만-포드를 쓸 때</span>
<span class="k">if</span> <span class="o">(</span><span class="n">음수</span> <span class="n">간선</span> <span class="n">있음</span> <span class="o">&amp;&amp;</span> <span class="n">음수</span> <span class="n">사이클</span> <span class="n">감지</span> <span class="n">필요</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">벨만포드</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="-8️⃣-실전-문제-적용">🎯 8️⃣ 실전 문제 적용</h2>

<h3 id="-대표-문제-유형">💡 대표 문제 유형</h3>

<table>
  <thead>
    <tr>
      <th>유형</th>
      <th>설명</th>
      <th>예시 문제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>모든 쌍 최단 경로</strong></td>
      <td>모든 도시 간 최단 거리</td>
      <td>백준 11404 플로이드</td>
    </tr>
    <tr>
      <td><strong>경유지 문제</strong></td>
      <td>특정 경유지를 거쳐야 할 때</td>
      <td>프로그래머스 순위</td>
    </tr>
    <tr>
      <td><strong>연결성 판단</strong></td>
      <td>모든 노드가 연결되어 있는가?</td>
      <td>백준 1389 케빈 베이컨</td>
    </tr>
    <tr>
      <td><strong>최단 경로 개수</strong></td>
      <td>최단 경로가 몇 개인가?</td>
      <td>백준 1613 역사</td>
    </tr>
  </tbody>
</table>

<h3 id="-체크리스트">💡 체크리스트</h3>

<p>플로이드-워셜 문제를 풀 때 확인할 것:</p>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />정점 수가 500 이하인가? (아니면 다익스트라 고려)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />모든 쌍의 최단 거리가 필요한가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />음수 간선이 있는가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />음수 사이클을 감지해야 하는가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />INF 값을 충분히 크게 설정했는가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />중복 간선 처리를 했는가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />k가 가장 바깥 루프인가?</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[플로이드-워셜 알고리즘에 대해 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자 2025 회고] 실시간 매칭 시스템, 생각보다 어려웠던 이야기</title><link href="https://nan0silver.github.io/projectdiary/2025-12-25-diary/" rel="alternate" type="text/html" title="[친구하자 2025 회고] 실시간 매칭 시스템, 생각보다 어려웠던 이야기" /><published>2025-12-25T00:00:00+00:00</published><updated>2026-01-12T05:19:16+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-12-25-diary/"><![CDATA[<ul>
  <li><a href="#들어가며">들어가며</a></li>
  <li><a href="#1-처음-그린-그림">1. 처음 그린 그림</a></li>
  <li><a href="#2-redis-대기열-생각보다-복잡했다">2. Redis 대기열, 생각보다 복잡했다</a></li>
  <li><a href="#3-매칭-알고리즘의-딜레마">3. 매칭 알고리즘의 딜레마</a></li>
  <li><a href="#4-알림이-안-가요">4. “알림이 안 가요”</a></li>
  <li><a href="#5-동시성의-늪">5. 동시성의 늪</a></li>
  <li><a href="#6-db와-redis-사이에서">6. DB와 Redis 사이에서</a></li>
  <li><a href="#7-배운-것들">7. 배운 것들</a></li>
</ul>

<hr />

<h2 id="들어가며">들어가며</h2>

<p>“매칭이요? 그냥 대기열 만들고, 2명 되면 연결하면 되는 거 아니에요?”</p>

<p>처음에 나도 그렇게 생각했다. 버튼 하나 누르면 매칭되고, 바로 통화 시작. 간단하지 않나?</p>

<p>그런데 막상 만들기 시작하니까… 전혀 간단하지 않았다.</p>

<hr />

<h2 id="1-처음-그린-그림">1. 처음 그린 그림</h2>

<p>가장 먼저 그린 건 이런 흐름이었다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 사용자가 "매칭 시작" 버튼 클릭
2. 대기열에 들어감
3. 다른 사람이 들어오면 자동 매칭
4. 통화 시작!
</code></pre></div></div>

<p>어렵지 않아 보였다. 그래서 바로 코딩을 시작했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 첫 번째 시도</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">startMatching</span><span class="o">(</span><span class="nc">Long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">userId</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">User</span> <span class="n">user1</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="nc">User</span> <span class="n">user2</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="n">createCall</span><span class="o">(</span><span class="n">user1</span><span class="o">,</span> <span class="n">user2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>로컬에서 테스트하니까 잘 됐다. “오, 쉽네?” 싶었다.</p>

<p>그런데…</p>

<hr />

<h2 id="2-redis-대기열-생각보다-복잡했다">2. Redis 대기열, 생각보다 복잡했다</h2>

<h3 id="같은-사람이랑-계속-매칭돼요">“같은 사람이랑 계속 매칭돼요”</h3>

<p>첫 번째 문제는 금방 발견됐다. 테스트하던 친구가 말했다.</p>

<p>“어… 나 방금 매칭된 사람이랑 또 매칭됐는데?”</p>

<p>그제야 깨달았다. 그냥 랜덤으로 매칭하면 방금 통화한 사람이랑 또 만날 수 있다는 걸.</p>

<p>“그럼 대기순으로 하면 되겠네!”</p>

<p>List를 써서 먼저 온 사람부터 매칭하도록 바꿨다. 문제 해결!</p>

<h3 id="10분째-기다리고-있는데요">“10분째 기다리고 있는데요”</h3>

<p>그런데 이번엔 다른 문제가 생겼다.</p>

<p>새벽 시간대에 사용자가 적을 때, 한 명이 들어와서 10분을 기다리고 있었다. 상대방이 안 와서.</p>

<p>“아… 타임아웃 처리를 해야 하는구나.”</p>

<p>그런데 List로는 “언제 들어왔는지”를 알 수가 없었다. 그냥 순서만 알 수 있었다.</p>

<p>여기서 Redis의 <strong>Sorted Set(ZSET)</strong> 을 알게 됐다.</p>

<pre><code class="language-redis"># 들어온 시각을 점수로 저장
ZADD queue:music 1734840123456 user_101
ZADD queue:music 1734840125789 user_205
</code></pre>

<p>이제 시간 기준으로 정렬도 되고, 오래된 사람 찾기도 쉬워졌다.</p>

<h3 id="랜덤도-하고-싶은데요">“랜덤도 하고 싶은데요?”</h3>

<p>대기순만 하니까 너무 지루하다는 피드백이 왔다.</p>

<p>“가끔은 랜덤 매칭도 하면 재밌을 것 같아요!”</p>

<p>ZSET의 <code class="language-plaintext highlighter-rouge">ZRANDMEMBER</code> 명령어를 발견했다. 완벽했다.</p>

<p>하지만 여기서 또 고민이 생겼다. 항상 랜덤? 항상 대기순? 어떻게 섞지?</p>

<hr />

<h2 id="3-매칭-알고리즘의-딜레마">3. 매칭 알고리즘의 딜레마</h2>

<h3 id="공정성-vs-다양성">공정성 vs 다양성</h3>

<p>고민을 정리해봤다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>대기순만 하면:
✅ 공정함
❌ 지루함

랜덤만 하면:
✅ 재미있음
❌ 오래 기다린 사람 불공평
</code></pre></div></div>

<p>결국 <strong>하이브리드 방식</strong>을 선택했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 대기순과 랜덤을 적절히 섞기</span>
<span class="kt">boolean</span> <span class="n">useRandom</span> <span class="o">=</span> <span class="n">shouldUseRandom</span><span class="o">();</span>

<span class="k">if</span> <span class="o">(</span><span class="n">useRandom</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 랜덤 매칭</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="c1">// 대기순 매칭</span>
<span class="o">}</span>
</code></pre></div></div>

<p>(비율은 사실 감으로 정했다. 나중에 데이터 보면서 조정할 생각이다.)</p>

<h3 id="스케줄러-vs-실시간">스케줄러 vs 실시간</h3>

<p>또 다른 고민: 누가 들어올 때마다 매칭을 시도할까? 아니면 주기적으로 확인할까?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>실시간 시도:
✅ 빠름
❌ 트래픽 많으면 부하

주기적 확인:
✅ 안정적
❌ 약간 느림
</code></pre></div></div>

<p>일단 <strong>주기적으로 확인하는 스케줄러</strong>로 구현했다. 1분 이내 매칭이 목표였으니까 충분했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedDelay</span> <span class="o">=</span> <span class="mi">30000</span><span class="o">)</span>  <span class="c1">// 30초</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processMatching</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 매칭 로직</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="4-알림이-안-가요">4. “알림이 안 가요”</h2>

<p>매칭은 되는데, 사용자가 모른다는 게 문제였다.</p>

<h3 id="websocket의-등장">WebSocket의 등장</h3>

<p>“알림 어떻게 보내지?”</p>

<p>처음엔 클라이언트가 계속 서버에 물어보는 <strong>폴링</strong> 방식을 생각했다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이렇게?</span>
<span class="nx">setInterval</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">/api/matching/status</span><span class="dl">"</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span> <span class="c1">// 1초마다</span>
</code></pre></div></div>

<p>그런데 이건 너무 비효율적이었다. 서버도 부담스럽고.</p>

<p>그래서 <strong>WebSocket</strong>을 쓰기로 했다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 구독하고 기다리면 알림이 옴</span>
<span class="nx">client</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s2">`/topic/matching/</span><span class="p">${</span><span class="nx">userId</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span> <span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 매칭 완료!</span>
  <span class="nx">navigate</span><span class="p">(</span><span class="dl">"</span><span class="s2">/call</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="타이밍-이슈">타이밍 이슈</h3>

<p>그런데 여기서 또 함정이 있었다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 매칭 완료 → DB 저장
2. WebSocket 알림 발송
3. 클라이언트가 통화 정보 조회
4. ❌ 아직 DB에 커밋 안 됨!
</code></pre></div></div>

<p>알림은 보냈는데 DB에는 아직 데이터가 없는 상황.</p>

<p>클라이언트에서 에러가 났다. “통화를 찾을 수 없습니다.”</p>

<p><strong>해결:</strong> 트랜잭션 커밋 후에 알림 보내기</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// DB 커밋 성공 후에만 알림</span>
<span class="nc">TransactionSynchronizationManager</span><span class="o">.</span><span class="na">registerSynchronization</span><span class="o">(</span>
    <span class="k">new</span> <span class="nf">TransactionSynchronization</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterCommit</span><span class="o">()</span> <span class="o">{</span>
            <span class="c1">// 이제야 알림 발송</span>
            <span class="n">sendNotification</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">);</span>
</code></pre></div></div>

<p>이 부분은 Spring 문서를 뒤져가며 찾았다. “트랜잭션 동기화”라는 개념을 처음 알았다.</p>

<hr />

<h2 id="5-동시성의-늪">5. 동시성의 늪</h2>

<p>로컬에서는 잘 되던 게, 배포하니까 문제가 생겼다.</p>

<h3 id="저-두-명이랑-동시에-매칭됐어요">“저 두 명이랑 동시에 매칭됐어요”</h3>

<p>한 사용자가 두 개의 통화에 동시에 매칭되는 버그였다.</p>

<p>원인을 찾아보니… 여러 스레드가 동시에 매칭 로직을 실행하면서 생긴 문제였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[스레드 A] 사용자 101, 102 매칭 시작
[스레드 B] 사용자 101, 103 매칭 시작
     ↓
사용자 101이 두 번 매칭됨!
</code></pre></div></div>

<p><strong>해결:</strong> 사용자 상태 체크</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// "나 지금 매칭 중이야" 표시</span>
<span class="nc">String</span> <span class="n">lockKey</span> <span class="o">=</span> <span class="s">"user:queued:"</span> <span class="o">+</span> <span class="n">userId</span><span class="o">;</span>

<span class="nc">Boolean</span> <span class="n">acquired</span> <span class="o">=</span> <span class="n">redisTemplate</span><span class="o">.</span><span class="na">opsForValue</span><span class="o">()</span>
    <span class="o">.</span><span class="na">setIfAbsent</span><span class="o">(</span><span class="n">lockKey</span><span class="o">,</span> <span class="s">"1"</span><span class="o">,</span> <span class="nc">Duration</span><span class="o">.</span><span class="na">ofMinutes</span><span class="o">(</span><span class="mi">10</span><span class="o">));</span>

<span class="k">if</span> <span class="o">(!</span><span class="n">acquired</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">AlreadyInQueueException</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Redis의 <code class="language-plaintext highlighter-rouge">SETNX</code> (Set if Not eXists) 명령어를 쓰면 원자적으로 체크하고 설정할 수 있다는 걸 배웠다.</p>

<h3 id="카테고리별-독립-처리">카테고리별 독립 처리</h3>

<p>음악, 영화, 게임… 카테고리가 여러 개인데, 하나의 카테고리에서 에러가 나면 다른 카테고리 매칭도 다 실패했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 문제가 있던 코드</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processMatching</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Category</span> <span class="n">category</span> <span class="o">:</span> <span class="n">categories</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">matchCategory</span><span class="o">(</span><span class="n">category</span><span class="o">);</span>  <span class="c1">// 하나 실패하면 전체 롤백!</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>해결:</strong> 각 카테고리마다 독립적인 트랜잭션</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="nc">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">matchCategory</span><span class="o">(</span><span class="nc">Category</span> <span class="n">category</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 이제 하나 실패해도 다른 카테고리는 계속 진행</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">REQUIRES_NEW</code>라는 옵션이 있다는 걸 이때 알았다. Spring은 정말 배울 게 많다.</p>

<hr />

<h2 id="6-db와-redis-사이에서">6. DB와 Redis 사이에서</h2>

<h3 id="어디에-뭘-저장할까">어디에 뭘 저장할까?</h3>

<p>처음엔 Redis에만 대기열을 관리했다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Redis만 사용:
✅ 빠름
❌ 서버 재시작하면 대기열 사라짐
❌ 누가 언제 들어왔는지 기록 없음
</code></pre></div></div>

<p>그래서 DB에도 저장하기로 했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. DB에 저장</span>
<span class="nc">MatchingQueue</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">matchingQueueRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span>
    <span class="k">new</span> <span class="nf">MatchingQueue</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">categoryId</span><span class="o">)</span>
<span class="o">);</span>

<span class="c1">// 2. Redis에도 추가</span>
<span class="n">redisService</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">categoryId</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="그런데-redis-추가가-실패하면">그런데 Redis 추가가 실패하면?</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. DB 저장 성공 ✅
2. Redis 추가 실패 ❌
   ↓
대기열에는 없는데 DB엔 있는 상태
</code></pre></div></div>

<p>이게 생각보다 골치 아팠다.</p>

<p>처음엔 “둘 다 성공하게 만들어야지!” 라고 생각했다. 그런데 현실은 그렇지 않았다.</p>

<p>DB와 Redis는 완전히 다른 시스템이다. 하나의 트랜잭션으로 묶을 수 없다.</p>

<p><strong>결론:</strong> 완벽한 일치는 불가능하다.</p>

<p>대신 이렇게 접근했다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. DB는 "기록용"
   - 누가 언제 매칭을 시도했는지
   - 통계와 분석용

2. Redis는 "실시간 처리용"
   - 지금 대기 중인 사람들
   - 빠른 매칭용

3. 불일치가 생기면?
   - Redis 실패하면 로그 남기고
   - 서버 시작할 때 DB에서 복구
</code></pre></div></div>

<p>“최선”을 “완벽” 대신 선택했다.</p>

<hr />

<h2 id="7-배운-것들">7. 배운 것들</h2>

<h3 id="간단해-보이는-기능도-간단하지-않다">“간단해 보이는 기능도 간단하지 않다”</h3>

<p>“매칭 버튼 하나면 되는 거 아니야?”</p>

<p>아니었다. 정말 아니었다.</p>

<ul>
  <li>타임아웃 처리</li>
  <li>중복 방지</li>
  <li>알림 발송</li>
  <li>동시성 제어</li>
  <li>데이터 일관성</li>
  <li>서버 재시작 대응</li>
  <li>…</li>
</ul>

<p>하나하나 다 신경 써야 할 게 있었다.</p>

<h3 id="완벽은-없다">“완벽은 없다”</h3>

<p>처음엔 “완벽하게 만들어야지!” 라고 생각했다.</p>

<p>DB와 Redis가 항상 일치해야 하고, 알림이 절대 빠지면 안 되고, 매칭이 1초 만에 되어야 하고…</p>

<p>그런데 현실은:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Redis는 가끔 연결이 끊긴다
- 알림은 가끔 실패한다
- 네트워크는 언제나 불안정하다
</code></pre></div></div>

<p>완벽을 추구하다가 영원히 못 끝낼 뻔했다.</p>

<p><strong>대신 이렇게 접근했다:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ 대부분의 경우 잘 작동하면 OK
✅ 실패해도 복구할 수 있으면 OK
✅ 사용자가 크게 불편하지 않으면 OK
</code></pre></div></div>

<h3 id="문제는-운영하면서-발견된다">“문제는 운영하면서 발견된다”</h3>

<p>로컬에서는 몰랐던 문제들:</p>

<ul>
  <li>동시성 이슈</li>
  <li>타임아웃 처리</li>
  <li>메모리 관리</li>
  <li>네트워크 지연</li>
</ul>

<p>다 운영하면서 만났다.</p>

<p>그리고 하나씩 해결했다.</p>

<h3 id="설계보다-중요한-건-개선">“설계보다 중요한 건 개선”</h3>

<p>처음 설계가 완벽할 순 없다.</p>

<p>중요한 건:</p>

<ul>
  <li>문제를 빨리 발견하고</li>
  <li>빨리 고치고</li>
  <li>다시 배포하는 것</li>
</ul>

<p>이 사이클을 빠르게 돌리는 게 핵심이었다.</p>

<h3 id="검색과-시도의-힘">“검색과 시도의 힘”</h3>

<p>이 과정에서 새로 배운 것들:</p>

<ul>
  <li>Redis ZSET</li>
  <li>WebSocket과 STOMP</li>
  <li>트랜잭션 동기화</li>
  <li>SETNX (원자적 연산)</li>
  <li>REQUIRES_NEW 전파 속성</li>
</ul>

<p>하나도 몰랐다. 다 검색하고, 블로그 읽고, 시도하고, 실패하고, 다시 해보면서 배웠다.</p>

<p>“모르는 게 부끄러운 게 아니라, 배우지 않는 게 부끄러운 것”이라는 걸 다시 한번 느꼈다.</p>

<hr />

<h2 id="마치며">마치며</h2>

<p>6개월 전 “매칭 기능 만들어야지!” 라고 생각했을 때는 몰랐다.</p>

<p>이렇게 많은 고민과 삽질이 필요할 줄.</p>

<p>하지만 돌아보니, 이 과정에서 정말 많이 배웠다.</p>

<ul>
  <li>Redis의 다양한 자료구조</li>
  <li>WebSocket 실시간 통신</li>
  <li>동시성 제어</li>
  <li>분산 시스템의 어려움</li>
  <li>완벽함보다 실용성</li>
</ul>

<p>그리고 가장 중요한 것:</p>

<p><strong>“모르는 건 부끄러운 게 아니다. 배우면 된다.”</strong></p>

<p>하나씩 검색하고, 블로그 읽고, 시도해보고, 실패하고, 다시 해보고.</p>

<p>그렇게 만들어졌다.</p>

<p>완벽하진 않지만, 작동한다.</p>

<p>그리고 계속 개선하고 있다.</p>

<hr />

<p>다음 편에서는 이 시스템을 운영하면서 만난 <strong>진짜 문제들</strong>을 이야기해보려고 한다.</p>

<ul>
  <li>Redis 메모리가 터졌던 날</li>
  <li>WebSocket이 다 끊어졌던 날</li>
  <li>매칭이 안 되는 버그를 3일 동안 찾았던 이야기</li>
</ul>

<p>기대해주시길!</p>

<hr />

<p><strong>시리즈:</strong></p>

<ol>
  <li><a href="https://nan0silver.github.io/projectdiary/2025-12-20-diary/">왜 이 기술들을 선택했나</a></li>
  <li><strong>실시간 매칭 시스템, 생각보다 어려웠던 이야기</strong> ← 현재 글</li>
</ol>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA["버튼 하나면 되는 거 아냐?" 라고 생각했던 나에게 현실이 알려준 것들]]></summary></entry><entry><title type="html">[친구하자 2025 회고] 실시간 음성 매칭 서비스, 왜 이 기술들을 선택했나</title><link href="https://nan0silver.github.io/projectdiary/2025-12-20-diary/" rel="alternate" type="text/html" title="[친구하자 2025 회고] 실시간 음성 매칭 서비스, 왜 이 기술들을 선택했나" /><published>2025-12-20T00:00:00+00:00</published><updated>2026-01-12T05:19:16+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-12-20-diary/"><![CDATA[<ul>
  <li><a href="#들어가며">들어가며</a></li>
  <li><a href="#1-전체-그림-우리-서비스가-필요한-것">1. 전체 그림: 우리 서비스가 필요한 것</a></li>
  <li><a href="#2-backend-spring-boot--webflux를-선택한-이유">2. Backend: Spring Boot + WebFlux를 선택한 이유</a></li>
  <li><a href="#3-database-mysql을-선택한-이유">3. Database: MySQL을 선택한 이유</a></li>
  <li><a href="#4-cache--queue-redis를-선택한-이유">4. Cache &amp; Queue: Redis를 선택한 이유</a></li>
  <li><a href="#5-webrtc-agora를-선택한-이유">5. WebRTC: Agora를 선택한 이유</a></li>
  <li><a href="#6-file-storage-firebase-storage를-선택한-이유">6. File Storage: Firebase Storage를 선택한 이유</a></li>
  <li><a href="#7-frontend-react--capacitor를-선택한-이유">7. Frontend: React + Capacitor를 선택한 이유</a></li>
  <li><a href="#8-배포-환경-aws--vercel">8. 배포 환경: AWS + Vercel</a></li>
  <li><a href="#9-기술-선택의-원칙">9. 기술 선택의 원칙</a></li>
  <li><a href="#10-마치며">10. 마치며</a></li>
</ul>

<hr />

<h2 id="들어가며">들어가며</h2>

<p>“관심사 기반 1:1 랜덤 음성 통화”라는 아이디어를 떠올렸을 때, 가장 먼저 든 생각은 “어떻게 구현하지?”였다. 학부와 석사 과정에서 배운 이론과 토이 프로젝트 경험은 있었지만, 실제 사용자가 쓸 서비스를 만드는 것은 처음이었다.</p>

<p>기술 스택을 선택하는 과정에서 수많은 블로그 글을 읽었고, 여러 서비스를 비교했다. 하지만 결국 깨달은 건 <strong>“정답은 없다”</strong>는 것이었다. 각 기술은 장단점이 있고, 중요한 건 우리 서비스의 맥락에서 어떤 게 적합한가였다.</p>

<p>이 글에서는 내가 왜 이런 선택을 했는지, 어떤 고민을 했는지를 솔직하게 공유해보려 한다.</p>

<hr />

<h2 id="1-전체-그림-우리-서비스가-필요한-것">1. 전체 그림: 우리 서비스가 필요한 것</h2>

<p>기술을 선택하기 전에, 먼저 우리 서비스의 특성을 정리했다.</p>

<h3 id="핵심-요구사항">핵심 요구사항</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 실시간성
   - 매칭 대기 시간을 최소화 (목표: 1분 이내)
   - 매칭 완료 즉시 알림
   - 끊김 없는 음성 통화

2. 확장성
   - 초기엔 소규모지만, 사용자 증가에 대응 가능해야 함
   - 트래픽 급증 시나리오 고려

3. 운영 편의성
   - 문제 발생 시 빠른 파악과 대응
   - 모니터링과 로깅
   - 배포 자동화

4. 비용 효율성
   - MVP 단계에서 과도한 인프라 비용 지양
   - 사용량에 따른 탄력적 비용 구조
</code></pre></div></div>

<p>이 네 가지 축을 기준으로 모든 기술 선택을 평가했다.</p>

<hr />

<h2 id="2-backend-spring-boot--webflux를-선택한-이유">2. Backend: Spring Boot + WebFlux를 선택한 이유</h2>

<h3 id="왜-비동기가-필요했나">왜 비동기가 필요했나?</h3>

<p>처음에는 익숙한 Spring MVC를 쓸까 고민했다. 하지만 우리 서비스의 특성을 생각해보니 WebFlux가 더 적합해 보였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 시나리오: 통화 종료 후 녹음 저장</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">endCall</span><span class="o">(</span><span class="nc">Long</span> <span class="n">callId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 1. 통화 종료 처리</span>
    <span class="n">callService</span><span class="o">.</span><span class="na">endCall</span><span class="o">(</span><span class="n">callId</span><span class="o">);</span>

    <span class="c1">// 2. Agora API 호출 (외부 API, 2-3초 소요)</span>
    <span class="n">agoraService</span><span class="o">.</span><span class="na">stopRecording</span><span class="o">(</span><span class="n">callId</span><span class="o">);</span>  <span class="c1">// ← 여기서 블로킹!</span>

    <span class="c1">// 3. 평가 페이지로 리다이렉트</span>
    <span class="k">return</span> <span class="s">"redirect:/evaluation"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>동기 방식의 문제는 Agora API 응답을 기다리는 2-3초 동안 스레드가 블로킹된다는 거였다. 200개 스레드로 동시 200명만 처리 가능하고, 대기 시간이 증가하면 사용자 경험이 저하된다.</p>

<p>비동기 방식을 쓰면:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">endCall</span><span class="o">(</span><span class="nc">Long</span> <span class="n">callId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">callService</span><span class="o">.</span><span class="na">endCall</span><span class="o">(</span><span class="n">callId</span><span class="o">)</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">agoraService</span><span class="o">.</span><span class="na">stopRecording</span><span class="o">(</span><span class="n">callId</span><span class="o">))</span>  <span class="c1">// 논블로킹</span>
        <span class="o">.</span><span class="na">then</span><span class="o">();</span>
    <span class="c1">// 스레드가 즉시 다른 요청 처리 가능</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="실제-경험-webflux의-학습-곡선">실제 경험: WebFlux의 학습 곡선</h3>

<p>솔직히 말하면, WebFlux는 쉽지 않았다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ 이렇게 하면 안 됨</span>
<span class="kd">public</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="nf">getUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">).</span><span class="na">block</span><span class="o">();</span>  <span class="c1">// 블로킹!</span>
    <span class="k">return</span> <span class="nc">Mono</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ✅ 올바른 방법</span>
<span class="kd">public</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="nf">getUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>  <span class="c1">// 논블로킹 체인</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">block()</code>을 쓰는 순간 비동기의 의미가 사라진다. “Reactive하게 생각하기”까지 시간이 필요했지만, 익숙해지니 외부 API 호출이 많은 우리 서비스에 딱 맞았다.</p>

<h3 id="언제-webflux를-쓰면-좋을까">언제 WebFlux를 쓰면 좋을까?</h3>

<p>내 경험상 이런 경우 WebFlux가 적합하다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ WebFlux 추천:
- 외부 API 호출이 많은 서비스
- WebSocket 등 실시간 통신 필요
- I/O 대기 시간이 긴 작업
- 동시 접속자가 많은 서비스

❌ WebFlux 비추천:
- CPU 집약적 작업 (이미지 처리, 암호화 등)
- 간단한 CRUD 중심 서비스
- 팀이 Spring MVC에 익숙하고, 학습 시간이 부족한 경우
</code></pre></div></div>

<hr />

<h2 id="3-database-mysql을-선택한-이유">3. Database: MySQL을 선택한 이유</h2>

<h3 id="mysql-vs-nosql-고민">MySQL vs NoSQL 고민</h3>

<p>“요즘 트렌드는 NoSQL 아닌가?”라는 생각도 했다. MongoDB를 쓸까 진지하게 고민했다.</p>

<p>우리 데이터의 특성을 분석해봤다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User ←→ Friendships ←→ User
  ↓
Calls ←→ CallRecordings
  ↓
CallEvaluations
</code></pre></div></div>

<p>친구 관계는 양방향이고 상태 관리가 필요하다 (요청중/수락/차단). 통화 이력은 두 사용자 간의 연결이고, 평가는 통화와 1:1 관계다.</p>

<p>이런 구조를 보니 관계형 데이터베이스가 더 자연스러웠다.</p>

<h3 id="데이터-일관성의-중요성">데이터 일관성의 중요성</h3>

<p>특히 친구 관계에서 일관성이 중요했다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 친구 요청은 반드시 양쪽 모두 저장되어야 함</span>
<span class="k">BEGIN</span> <span class="n">TRANSACTION</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">friendships</span> <span class="p">(</span><span class="n">user_a_id</span><span class="p">,</span> <span class="n">user_b_id</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'PENDING'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">friendships</span> <span class="p">(</span><span class="n">user_b_id</span><span class="p">,</span> <span class="n">user_a_id</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'REQUESTED'</span><span class="p">);</span>
<span class="k">COMMIT</span><span class="p">;</span>

<span class="c1">-- 하나라도 실패하면 전체 롤백</span>
</code></pre></div></div>

<p>NoSQL에서는 이런 트랜잭션 보장이 상대적으로 약하다.</p>

<h3 id="쿼리-복잡도">쿼리 복잡도</h3>

<p>통화 이력 조회 같은 경우, JOIN이 필요했다:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 내 통화 이력 + 상대방 정보 + 친구 상태</span>
<span class="k">SELECT</span>
    <span class="k">c</span><span class="p">.</span><span class="o">*</span><span class="p">,</span>
    <span class="n">u</span><span class="p">.</span><span class="n">nickname</span> <span class="k">as</span> <span class="n">partner_name</span><span class="p">,</span>
    <span class="n">f</span><span class="p">.</span><span class="n">status</span> <span class="k">as</span> <span class="n">friend_status</span>
<span class="k">FROM</span> <span class="n">calls</span> <span class="k">c</span>
<span class="k">JOIN</span> <span class="n">users</span> <span class="n">u</span> <span class="k">ON</span> <span class="p">(</span><span class="k">c</span><span class="p">.</span><span class="n">user_a_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span> <span class="k">OR</span> <span class="k">c</span><span class="p">.</span><span class="n">user_b_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">AND</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span> <span class="o">!=</span> <span class="p">:</span><span class="n">myId</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">friendships</span> <span class="n">f</span> <span class="k">ON</span> <span class="n">f</span><span class="p">.</span><span class="n">friend_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">f</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="p">:</span><span class="n">myId</span>
<span class="k">WHERE</span> <span class="k">c</span><span class="p">.</span><span class="n">user_a_id</span> <span class="o">=</span> <span class="p">:</span><span class="n">myId</span> <span class="k">OR</span> <span class="k">c</span><span class="p">.</span><span class="n">user_b_id</span> <span class="o">=</span> <span class="p">:</span><span class="n">myId</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="k">c</span><span class="p">.</span><span class="n">created_at</span> <span class="k">DESC</span><span class="p">;</span>
</code></pre></div></div>

<p>NoSQL에서 이런 쿼리는 애플리케이션 레벨에서 여러 번 조회해야 한다.</p>

<h3 id="그럼-nosql은-언제">그럼 NoSQL은 언제?</h3>

<p>내가 생각하는 NoSQL 적합 케이스:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ NoSQL 추천:
- 스키마가 자주 변하는 경우
- 단순 Key-Value 조회가 대부분
- 대용량 로그/이벤트 데이터
- 수평 확장이 필수적인 경우

❌ NoSQL 비추천:
- 복잡한 관계와 트랜잭션 필요
- JOIN 쿼리가 많은 경우
- 데이터 일관성이 중요한 비즈니스 로직
</code></pre></div></div>

<p>결론은 MySQL로 시작하고, 필요시 캐시(Redis)와 조합하기로 했다.</p>

<hr />

<h2 id="4-cache--queue-redis를-선택한-이유">4. Cache &amp; Queue: Redis를 선택한 이유</h2>

<h3 id="redis의-세-가지-역할">Redis의 세 가지 역할</h3>

<p>우리 서비스에서 Redis는 단순 캐시를 넘어 세 가지 역할을 한다:</p>

<ol>
  <li><strong>매칭 대기열</strong> - 카테고리별로 대기 중인 사용자 관리</li>
  <li><strong>실시간 세션 관리</strong> - WebSocket 연결 정보</li>
  <li><strong>캐시</strong> - 자주 조회되는 카테고리 정보</li>
</ol>

<h3 id="자료구조-선택-zset-vs-set-vs-list">자료구조 선택: ZSET vs SET vs List</h3>

<p>매칭 대기열을 어떤 자료구조로 구현할지 고민이 많았다.</p>

<h4 id="시도-1-list-lpushrpop">시도 1: List (LPUSH/RPOP)</h4>

<pre><code class="language-redis"># 입장
LPUSH wait:music userId_101

# 매칭 (2명 추출)
RPOP wait:music  # userId_101
RPOP wait:music  # userId_205
</code></pre>

<p>문제점은 대기 순서는 보장되지만, 타임아웃 처리가 어렵고 랜덤 매칭이 불가능했다.</p>

<h4 id="시도-2-set-saddspop">시도 2: Set (SADD/SPOP)</h4>

<pre><code class="language-redis"># 입장
SADD wait:music userId_101

# 매칭 (랜덤 2명)
SPOP wait:music 2
</code></pre>

<p>랜덤은 쉽지만 대기 순서를 알 수 없어서 공정성이 없었다.</p>

<h4 id="최종-선택-zset-sorted-set">최종 선택: ZSET (Sorted Set)</h4>

<pre><code class="language-redis"># 입장 (점수 = 대기 시작 시각)
ZADD wait:music 1725430000456 userId_101
ZADD wait:music 1725430001234 userId_205

# 대기순 매칭
ZPOPMIN wait:music 2

# 랜덤 매칭
ZRANDMEMBER wait:music 2
</code></pre>

<p>장점이 명확했다:</p>

<ul>
  <li>대기 시간 기준 정렬 ✅</li>
  <li>대기순/랜덤 모두 가능 ✅</li>
  <li>타임아웃 쉬움 (점수 기준 삭제) ✅</li>
</ul>

<h3 id="왜-별도의-메시지-큐를-안-썼나">왜 별도의 메시지 큐를 안 썼나?</h3>

<p>RabbitMQ, Kafka 같은 전문 메시지 큐도 고려했다.</p>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Redis</th>
      <th>RabbitMQ</th>
      <th>Kafka</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>학습 곡선</td>
      <td>낮음</td>
      <td>중간</td>
      <td>높음</td>
    </tr>
    <tr>
      <td>운영 복잡도</td>
      <td>낮음</td>
      <td>중간</td>
      <td>높음</td>
    </tr>
    <tr>
      <td>성능 (우리 규모)</td>
      <td>충분</td>
      <td>충분</td>
      <td>과함</td>
    </tr>
    <tr>
      <td>비용</td>
      <td>낮음</td>
      <td>중간</td>
      <td>높음</td>
    </tr>
  </tbody>
</table>

<p>초기 단계에서는 Redis로 충분하다고 판단했다. 트래픽이 늘면 그때 전환을 고려하기로 했다. “과도한 엔지니어링”을 경계해야 한다고 생각했다.</p>

<hr />

<h2 id="5-webrtc-agora를-선택한-이유">5. WebRTC: Agora를 선택한 이유</h2>

<h3 id="직접-구현-vs-saas">직접 구현 vs SaaS</h3>

<p>WebRTC를 직접 구현할지, SaaS를 쓸지 고민했다.</p>

<p>직접 구현 시나리오를 생각해보니:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>필요한 것:
- STUN/TURN 서버 구축 및 운영
- Signaling 서버 개발
- NAT Traversal 처리
- 통화 품질 모니터링
- 녹음 기능 구현

예상 개발 시간: 2-3개월
예상 운영 부담: 높음
</code></pre></div></div>

<p>SaaS 사용 시나리오:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>필요한 것:
- SDK 통합 (1-2주)
- 설정 및 테스트

예상 개발 시간: 2주
예상 운영 부담: 낮음
</code></pre></div></div>

<p>MVP는 빠르게 검증하는 게 중요하다고 생각해서 SaaS를 선택했다.</p>

<h3 id="agora-vs-twilio-vs-daily">Agora vs Twilio vs Daily</h3>

<p>WebRTC SaaS를 비교 분석했다.</p>

<p>비교 기준:</p>

<ol>
  <li><strong>통화 품질</strong> - 모두 우수한 수준, 한국 리전 지원 여부가 중요</li>
  <li><strong>Cloud Recording</strong> - 우리 서비스에 필수 기능</li>
  <li><strong>가격</strong> - 초기 단계라 비용 민감</li>
  <li><strong>문서 및 커뮤니티</strong> - 문제 해결이 쉬운가</li>
</ol>

<p>최종적으로 Agora를 선택한 이유:</p>

<ul>
  <li>Cloud Recording 기능이 강력 (Individual Mode 지원)</li>
  <li>Firebase Storage 직접 연동 가능</li>
  <li>가격 경쟁력</li>
  <li>한국어 문서와 한국 리전 지원</li>
</ul>

<p>다만 Twilio보다 커뮤니티가 작고, 일부 고급 기능은 Twilio가 우세하다는 점은 고려사항이었다.</p>

<h3 id="실제-사용-후기">실제 사용 후기</h3>

<p>Agora를 6개월간 사용한 경험을 정리하면:</p>

<p>만족스러운 점:</p>

<ul>
  <li>SDK 통합이 생각보다 쉬움</li>
  <li>녹음 기능이 안정적</li>
  <li>통화 품질 좋음</li>
</ul>

<p>아쉬운 점:</p>

<ul>
  <li>일부 에러 메시지가 불친절</li>
  <li>고급 설정 시 영어 문서 의존도 높음</li>
</ul>

<hr />

<h2 id="6-file-storage-firebase-storage를-선택한-이유">6. File Storage: Firebase Storage를 선택한 이유</h2>

<h3 id="왜-aws-s3가-아닌가">왜 AWS S3가 아닌가?</h3>

<p>통화 녹음 파일을 저장할 곳이 필요했다. 가장 먼저 떠오른 건 AWS S3였다.</p>

<p>고민한 점:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AWS S3:
✅ 업계 표준
✅ 많은 레퍼런스
✅ 강력한 기능

Firebase Storage:
✅ 이미 프로필 이미지에 사용 중
✅ GCS 기반 (Agora와 호환성 좋음)
✅ Firebase 생태계 활용 가능
</code></pre></div></div>

<h3 id="실용적-판단">실용적 판단</h3>

<p>결정적이었던 건 <strong>이미 사용하고 있다</strong>는 점이었다.</p>

<p>새로운 기술을 도입하면:</p>

<ul>
  <li>학습 시간</li>
  <li>설정 및 테스트</li>
  <li>운영 노하우 축적</li>
  <li>문제 해결 경험</li>
</ul>

<p>이 모든 비용이 든다.</p>

<p>기존 기술을 활용하면:</p>

<ul>
  <li>즉시 사용 가능</li>
  <li>이미 익숙함</li>
  <li>통합 관리 편함</li>
</ul>

<p>“최신/유명 != 우리에게 최선”이라는 걸 다시 한번 깨달았다.</p>

<h3 id="agora와의-통합">Agora와의 통합</h3>

<p>특히 Agora Cloud Recording이 GCS(Google Cloud Storage)와 직접 연동된다는 점이 좋았다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Agora → Firebase Storage (GCS 기반)
- HMAC 인증으로 직접 업로드
- 별도의 파일 전송 서버 불필요
- 자동 업로드 (15초마다 segment)
</code></pre></div></div>

<hr />

<h2 id="7-frontend-react--capacitor를-선택한-이유">7. Frontend: React + Capacitor를 선택한 이유</h2>

<h3 id="웹인가-앱인가">웹인가, 앱인가?</h3>

<p>처음부터 모바일 앱을 목표로 했다. 음성 통화 특성상 앱이 더 자연스럽다고 판단했다.</p>

<p>선택지를 정리하면:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 웹 (React)만 개발
   → 빠르지만 접근성 낮음

2. React Native
   → 네이티브 성능, 웹 코드 재사용 불가

3. Flutter
   → 성능 좋음, Dart 새로 학습 필요

4. Capacitor (선택!)
   → 웹 코드 100% 재사용, WebView 기반
</code></pre></div></div>

<h3 id="capacitor의-장점">Capacitor의 장점</h3>

<p>가장 큰 장점은 빠른 개발이었다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기존 React 웹 코드</span>
<span class="kd">const</span> <span class="nx">CallPage</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">setChannel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="dl">''</span><span class="p">);</span>
  <span class="c1">// Agora WebRTC 로직</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// Capacitor 추가 후</span>
<span class="nx">npm</span> <span class="nx">install</span> <span class="p">@</span><span class="nd">capacitor</span><span class="sr">/cor</span><span class="err">e
</span><span class="nx">npx</span> <span class="nx">cap</span> <span class="nx">add</span> <span class="nx">android</span> <span class="nx">ios</span>

<span class="c1">// 앱 빌드 완료!</span>
</code></pre></div></div>

<p>단일 코드베이스로 관리할 수 있다는 것도 큰 장점이었다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/
  components/
    CallPage.tsx      ← 웹, Android, iOS 모두 사용
    MatchingButton.tsx
  lib/
    agora.ts          ← 한 번만 작성
    websocket.ts
</code></pre></div></div>

<h3 id="네이티브-기능-접근">네이티브 기능 접근</h3>

<p>Capacitor 플러그인으로 네이티브 기능도 사용 가능했다:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 카카오 네이티브 로그인</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">KakaoLoginPlugin</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">capacitor-kakao-login-plugin</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">KakaoLoginPlugin</span><span class="p">.</span><span class="nx">goLogin</span><span class="p">();</span>

<span class="c1">// 구글 네이티브 로그인</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">GoogleAuth</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@codetrix-studio/capacitor-google-auth</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">GoogleAuth</span><span class="p">.</span><span class="nx">signIn</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="한계와-트레이드오프">한계와 트레이드오프</h3>

<p>WebView 제약이 있다:</p>

<ul>
  <li>네이티브 앱보다 성능 떨어짐</li>
  <li>일부 브라우저 제약 (CORS, Cookie 등)</li>
  <li>플랫폼별 차이 (iOS vs Android)</li>
</ul>

<p>그럼에도 선택한 이유는:</p>

<ul>
  <li><strong>속도:</strong> 2-3개월 단축</li>
  <li><strong>유지보수:</strong> 하나의 코드베이스</li>
  <li><strong>검증:</strong> MVP 빠르게 출시</li>
</ul>

<p>초기에는 Capacitor로 시작하고, 성장하면 부분적으로 네이티브 전환을 고려하기로 했다.</p>

<hr />

<h2 id="8-배포-환경-aws--vercel">8. 배포 환경: AWS + Vercel</h2>

<h3 id="backend-aws-ec2">Backend: AWS EC2</h3>

<p>“왜 컨테이너(ECS, EKS)가 아닌가?”라는 질문을 받을 수 있는데:</p>

<p>우리 상황:</p>

<ul>
  <li>단일 서버로 충분</li>
  <li>오토 스케일링 아직 불필요</li>
  <li>운영 복잡도 최소화</li>
</ul>

<p>선택:</p>

<ul>
  <li>EC2 단일 인스턴스</li>
  <li>Nginx 리버스 프록시</li>
  <li>Let’s Encrypt SSL</li>
</ul>

<p>비용도 고려했다. ECS/EKS는 추가 비용이 들고, Elastic Load Balancer도 고정 비용이 든다. EC2 단독이 가장 경제적이었다.</p>

<h3 id="frontend-vercel">Frontend: Vercel</h3>

<p>왜 Vercel인가?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ 장점:
- Git push → 자동 배포
- HTTPS 기본 제공
- CDN 자동 설정
- 무료 플랜으로 충분

vs

AWS S3 + CloudFront:
- 직접 설정 필요
- 비용 발생
- CI/CD 직접 구축
</code></pre></div></div>

<p>프론트엔드는 정적 파일이므로 Vercel이 훨씬 편했다.</p>

<hr />

<h2 id="9-기술-선택의-원칙">9. 기술 선택의 원칙</h2>

<p>6개월간의 경험을 돌아보니, 내게는 몇 가지 원칙이 생겼다.</p>

<h3 id="원칙-1-맥락이-가장-중요하다">원칙 1: “맥락”이 가장 중요하다</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❌ "요즘 A가 대세니까 A를 써야지"
✅ "우리 상황에서는 B가 더 적합해"
</code></pre></div></div>

<p>예시:</p>

<ul>
  <li>Kafka는 강력하지만 우리 규모에는 과함 → Redis 선택</li>
  <li>React Native는 좋지만 웹 코드 재사용 중요 → Capacitor 선택</li>
</ul>

<h3 id="원칙-2-mvp는-빠르게-확장은-점진적으로">원칙 2: MVP는 빠르게, 확장은 점진적으로</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>처음부터 완벽한 설계 (X)
빠른 검증 → 점진적 개선 (O)
</code></pre></div></div>

<p>실제 적용:</p>

<ul>
  <li>단일 EC2로 시작 → 트래픽 증가 시 확장 고려</li>
  <li>Redis 대기열 → 필요시 Kafka 전환</li>
  <li>Capacitor → 성장하면 부분 네이티브</li>
</ul>

<h3 id="원칙-3-익숙함도-중요한-가치">원칙 3: “익숙함”도 중요한 가치</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>새로운 기술 학습 비용 vs 익숙한 기술 활용

학부/석사에서 Spring 사용 경험
→ Spring Boot 선택이 자연스러움
</code></pre></div></div>

<h3 id="원칙-4-비용은-현실적-제약">원칙 4: 비용은 현실적 제약</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기 단계의 인프라 비용:
- EC2, RDS, Redis, Agora, Firebase
→ 월 수십 달러 수준으로 통제

vs

이상적 아키텍처:
- ECS, ELB, CloudFront, Kafka...
→ 월 수백 달러
</code></pre></div></div>

<p>서비스 검증이 우선이고, 인프라는 필요 시 확장하기로 했다.</p>

<hr />

<h2 id="10-마치며">10. 마치며</h2>

<p>기술 선택은 트레이드오프의 연속이었다.</p>

<ul>
  <li>성능 vs 개발 속도</li>
  <li>이상 vs 현실</li>
  <li>최신 기술 vs 익숙한 기술</li>
  <li>비용 vs 확장성</li>
</ul>

<p>중요한 건 “정답”을 찾는 게 아니라, “우리에게 맞는 답”을 찾는 것이었다.</p>

<p>6개월간 이 기술들로 서비스를 만들고 운영하며 정말 많이 배웠다.
선택이 완벽하진 않았지만, 후회는 없다.
각 선택의 이유를 명확히 알고 있고, 필요하면 언제든 바꿀 수 있다는 확신이 있기 때문이다!</p>

<p><strong>“왜?”라는 질문을 끊임없이 던지자. 그 답이 쌓이면, 그게 바로 우리의 기술 철학이 된다.</strong></p>

<hr />

<p><strong>시리즈:</strong></p>

<ol>
  <li><strong>왜 이 기술들을 선택했나</strong> ← 현재 글</li>
  <li><a href="https://nan0silver.github.io/projectdiary/2025-12-25-diary/">실시간 매칭 시스템 설계</a></li>
</ol>

<hr />

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://docs.spring.io/spring-framework/reference/web/webflux.html">Spring WebFlux 공식 문서</a></li>
  <li><a href="https://redis.io/docs/data-types/">Redis 자료구조 가이드</a></li>
  <li><a href="https://docs.agora.io/en/cloud-recording">Agora Cloud Recording</a></li>
  <li><a href="https://capacitorjs.com/docs">Capacitor 공식 문서</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[컴퓨터공학 석사 출신 개발자가 첫 실전 프로젝트에서 마주한 기술 선택의 기록]]></summary></entry><entry><title type="html">[친구하자] Agora Cloud Recording과 Firebase Storage로 음성 통화 녹음 구현하기</title><link href="https://nan0silver.github.io/projectdiary/2025-11-24-diary/" rel="alternate" type="text/html" title="[친구하자] Agora Cloud Recording과 Firebase Storage로 음성 통화 녹음 구현하기" /><published>2025-11-24T00:00:00+00:00</published><updated>2026-01-12T05:19:16+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-24-diary/"><![CDATA[<p>‘친구하자’를 개발하며 통화 녹음 기능을 구현해야 했다. AI 개발과 통화 분석 등 추후 기능들을 위해 통화를 녹음하는 것을 전제로 구현을 시작했다.</p>

<p>처음에는 단순할 줄 알았는데, 생각보다 에러도 많이 나고 시행착오가 많아서 MVP에서 제외하고 개발했다. 이 글에서는 어떤 문제들을 겪었고, 어떻게 해결했는지를 정리하려고 한다.</p>

<h2 id="목차">목차</h2>

<ul>
  <li><a href="#1-기술-스택-선택">1. 기술 스택 선택</a></li>
  <li><a href="#2-구현-과정에서-만난-문제들">2. 구현 과정에서 만난 문제들</a></li>
  <li><a href="#3-최종-구조">3. 최종 구조</a></li>
  <li><a href="#4-배운-점">4. 배운 점</a></li>
  <li><a href="#5-운영-지표">5. 운영 지표</a></li>
  <li><a href="#6-마치며">6. 마치며</a></li>
  <li><a href="#참고-자료">참고 자료</a></li>
</ul>

<hr />

<h2 id="1-기술-스택-선택">1. 기술 스택 선택</h2>

<h3 id="11-왜-agora-cloud-recording을-선택했나">1.1. 왜 Agora Cloud Recording을 선택했나?</h3>

<p>처음에 WebRTC 서비스를 선택하기에 앞서 Recording 구현을 고려했다. WebRTC 중에는 recording을 지원하는 서비스가 있고, 아닌 서비스가 있었다. 그중 Agora는 Recording 지원이 가장 다양했고, 가격도 저렴했다.</p>

<p>Recording을 저장하는 것에도 많은 선택지가 있었다:</p>

<ol>
  <li><strong>Agora 백업 저장소</strong>
    <ul>
      <li>제3자 스토리지 설정이 실패하면 백업 서버에 <strong>24시간 동안만</strong> 임시 저장</li>
      <li>운영용이 아니므로 반드시 외부 저장소 연동 필요</li>
    </ul>
  </li>
  <li><strong>AWS S3 직접 연동</strong>
    <ul>
      <li>가장 일반적이고 안정적인 방법</li>
    </ul>
  </li>
  <li><strong>Firebase Storage (GCS 기반)</strong>
    <ul>
      <li>이미 프로젝트에서 사용 중 (프로필 이미지 등)</li>
    </ul>
  </li>
</ol>

<p>고민 끝에 <strong>Firebase Storage</strong>를 선택했다:</p>

<ul>
  <li>이미 프로젝트에서 사용 중이어서 익숙함</li>
  <li>GCS(Google Cloud Storage) 기반이라 Agora와 호환성이 좋음</li>
  <li>Firebase의 다른 기능들과도 잘 통합됨</li>
  <li>AWS S3와 비용이 비슷한 수준 (월 1,000분 통화 기준 약 80원 차이)</li>
</ul>

<h3 id="12-individual-recording-mode-선택">1.2. Individual Recording Mode 선택</h3>

<p>Agora Cloud Recording에는 여러 모드가 있다:</p>

<ul>
  <li><strong>Composite Mode</strong>: 모든 사람의 음성을 하나로 합침</li>
  <li><strong>Individual Mode</strong>: 각 사용자별로 별도 녹음</li>
</ul>

<p>나는 <strong>Individual Mode</strong>를 선택했다. 추후 각 사용자의 음성을 따로 분석할 수도 있고, 더 유연하기 때문이다.</p>

<h2 id="2-구현-과정에서-만난-문제들">2. 구현 과정에서 만난 문제들</h2>

<h3 id="21-비동기-처리-설정-문제">2.1. 비동기 처리 설정 문제</h3>

<p>녹음 시작/중지는 시간이 걸리는 작업이기 때문에 비동기로 처리해야 했다. 그런데 Spring에서 이런 경고가 떴다:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>More than one TaskExecutor bean found within the context,
and none is named <span class="s1">'taskExecutor'</span>
</code></pre></div></div>

<p><strong>문제:</strong></p>

<p><code class="language-plaintext highlighter-rouge">@Async</code>만 쓰면 Spring이 <code class="language-plaintext highlighter-rouge">SimpleAsyncTaskExecutor</code>를 사용한다. 이는 매번 새 스레드를 생성하기 때문에 매우 비효율적이다.</p>

<p>내 경우, 애플리케이션 컨텍스트에 이미 여러 개의 <code class="language-plaintext highlighter-rouge">TaskExecutor</code> 빈이 존재했는데 (<code class="language-plaintext highlighter-rouge">recordingTaskExecutor</code>, <code class="language-plaintext highlighter-rouge">matchingTaskExecutor</code> 등), 어느 것도 <code class="language-plaintext highlighter-rouge">taskExecutor</code>라는 이름을 가지고 있지 않았다. Executor를 지정하지 않고 <code class="language-plaintext highlighter-rouge">@Async</code>만 작성하니 Spring에서 경고를 보냈다.</p>

<p><strong>해결:</strong></p>

<p>용도별로 Executor를 분리하고, 기본 <code class="language-plaintext highlighter-rouge">taskExecutor</code>를 명시적으로 지정했다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableAsync</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsyncConfig</span> <span class="kd">implements</span> <span class="nc">AsyncConfigurer</span> <span class="o">{</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"taskExecutor"</span><span class="o">)</span>
    <span class="nd">@Primary</span>
    <span class="kd">public</span> <span class="nc">Executor</span> <span class="nf">taskExecutor</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ThreadPoolTaskExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolTaskExecutor</span><span class="o">();</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setCorePoolSize</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setMaxPoolSize</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setQueueCapacity</span><span class="o">(</span><span class="mi">25</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setThreadNamePrefix</span><span class="o">(</span><span class="s">"Async-"</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">executor</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"recordingTaskExecutor"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Executor</span> <span class="nf">recordingTaskExecutor</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ThreadPoolTaskExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolTaskExecutor</span><span class="o">();</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setCorePoolSize</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setMaxPoolSize</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setQueueCapacity</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setThreadNamePrefix</span><span class="o">(</span><span class="s">"Recording-"</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">executor</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 하면 스레드 풀을 재사용해서 성능이 훨씬 좋아진다:</p>

<ul>
  <li>스레드 생성 비용: ~1-2ms → ~0.01ms</li>
  <li>리소스 제한: 무제한 → 최대 5개로 제어</li>
</ul>

<h3 id="22-firebase-storage-저장-실패">2.2. Firebase Storage 저장 실패</h3>

<p>드디어 녹음이 시작되었다! 로그에도 성공 메시지가 떴다. 그런데 Firebase Storage를 확인해보니… 파일이 없었다. 😱</p>

<p><strong>문제의 핵심: <code class="language-plaintext highlighter-rouge">uploadingStatus=backuped</code></strong></p>

<p><code class="language-plaintext highlighter-rouge">uploadingStatus</code>에는 두 가지 값이 있다:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">uploaded</code></strong>: 제3자 스토리지(Firebase)에 업로드 성공</li>
  <li><strong><code class="language-plaintext highlighter-rouge">backuped</code></strong>: Agora 자체 백업 서버에 저장 (24시간 후 삭제)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">backuped</code>가 나왔다는 건 Firebase에 업로드가 실패했다는 의미였다.</p>

<p><strong>원인: HMAC 키가 없었다!</strong></p>

<p>Agora가 GCS(Google Cloud Storage)에 파일을 올리려면 <strong>HMAC 인증 키</strong>가 필요하다. Firebase Console → Storage → Settings → Interoperability를 확인해보니 아무것도 없었다.</p>

<p><strong>해결 과정:</strong></p>

<ol>
  <li>
    <p><strong>Google Cloud Console 접속</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cloud Console → Storage → Settings → Interoperability
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>HMAC 키 생성</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Service account HMAC 섹션
→ Create a key for a service account
→ firebase-adminsdk-xxxxx@프로젝트명.iam.gserviceaccount.com 선택
→ CREATE KEY
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Access Key와 Secret 복사</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Access Key: GOOG1E...로 시작하는 긴 문자열
Secret: 한 번만 보여주니 즉시 복사!
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>application.yml 설정</strong></p>
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">app</span><span class="pi">:</span>
  <span class="na">agora</span><span class="pi">:</span>
    <span class="na">recording-region</span><span class="pi">:</span> <span class="m">0</span> <span class="c1"># GCS Multi-region US</span>
    <span class="na">recording-storage-vendor</span><span class="pi">:</span> <span class="s2">"</span><span class="s">6"</span> <span class="c1"># 6 = GCS</span>
    <span class="na">recording-storage-bucket</span><span class="pi">:</span> <span class="s">프로젝트명.appspot.com</span>
    <span class="na">recording-storage-access-key</span><span class="pi">:</span> <span class="s">${AGORA_STORAGE_ACCESS_KEY}</span>
    <span class="na">recording-storage-secret-key</span><span class="pi">:</span> <span class="s">${AGORA_STORAGE_SECRET_KEY}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>이렇게 설정하고 다시 녹음을 시작했더니… 드디어 성공! 🎉</p>

<h2 id="3-최종-구조">3. 최종 구조</h2>

<p>모든 삽질을 마치고 완성된 구조는 다음과 같다:</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-24-pic1.png?raw=true" alt="이미지1" /></p>

<h3 id="31-주요-특징">3.1. 주요 특징</h3>

<ol>
  <li><strong>Individual Recording Mode</strong>: 각 사용자별로 별도 녹음</li>
  <li><strong>Audio Only</strong>: 비용 절감 (비디오 없음)</li>
  <li><strong>자동 업로드</strong>: Agora → Firebase Storage 직접 저장</li>
  <li><strong>파일 구조화</strong>: 날짜/Call ID별 폴더 정리</li>
  <li><strong>비동기 처리</strong>: 녹음 시작/중지가 메인 스레드를 블로킹하지 않음</li>
</ol>

<h2 id="4-배운-점">4. 배운 점</h2>

<h3 id="41-공식-문서를-꼼꼼히-읽자">4.1. 공식 문서를 꼼꼼히 읽자</h3>

<p>Agora 공식 문서에 Individual Mode와 Composite Mode의 차이가 명확하게 나와 있었다. 처음부터 제대로 읽었으면 불필요한 시행착오를 줄일 수 있었을 것이다.</p>

<h3 id="42-클라우드-서비스는-인증이-핵심">4.2. 클라우드 서비스는 인증이 핵심</h3>

<p>Firebase Storage에 파일이 안 올라가는 이유가 HMAC 키 때문이었다. 클라우드 간 연동에서는 항상 <strong>인증 설정을 먼저 확인</strong>해야 한다.</p>

<h3 id="43-비동기-처리는-제대로-설정하자">4.3. 비동기 처리는 제대로 설정하자</h3>

<p><code class="language-plaintext highlighter-rouge">@Async</code>만 쓰고 넘어가면 안 된다. 제대로 된 <code class="language-plaintext highlighter-rouge">ThreadPoolTaskExecutor</code>를 설정해야 운영에서 안정적이다.</p>

<h2 id="5-운영-지표">5. 운영 지표</h2>

<p>현재 운영 중인 시스템의 주요 지표:</p>

<ul>
  <li><strong>녹음 시작 시간</strong>: 평균 2-3초</li>
  <li><strong>파일 업로드</strong>: Agora가 자동 처리 (15초마다)</li>
  <li><strong>DB 저장</strong>: 비동기 처리로 메인 로직에 영향 없음</li>
  <li><strong>스레드 풀</strong>: 최대 5개 스레드로 제한되어 안정적</li>
</ul>

<p><strong>비용 최적화:</strong></p>

<ul>
  <li>Audio Only로 비디오 대비 비용 1/5 수준</li>
  <li>maxIdleTime 설정으로 30초 무음 시 자동 종료</li>
  <li>streamMode: standard (Agora 권장)</li>
</ul>

<h2 id="6-마치며">6. 마치며</h2>

<p>처음엔 “그냥 녹음만 하면 되는 거 아니야?”라고 쉽게 생각했는데, 실제로는 정말 많은 함정이 있었다:</p>

<ul>
  <li>Individual vs Composite Mode 이해</li>
  <li>HMAC 키 설정</li>
  <li>비동기 처리 구성</li>
  <li>에러 핸들링</li>
</ul>

<p>하나하나 해결하면서 많이 배웠다. 특히 클라우드 서비스 간 연동에서 <strong>인증과 권한 설정</strong>이 얼마나 중요한지 깨달았다.</p>

<p>이 글이 Agora Cloud Recording과 Firebase Storage를 연동하려는 누군가에게 도움이 되었으면 좋겠다. 😅</p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://docs.agora.io/en/cloud-recording/develop/individual-mode">Agora Individual Recording 공식 문서</a></li>
  <li><a href="https://docs.agora.io/en/cloud-recording/reference/region-vendor">Agora Cloud Storage 설정</a></li>
  <li><a href="https://cloud.google.com/storage/docs/authentication/hmackeys">Google Cloud HMAC 키 생성</a></li>
  <li><a href="https://spring.io/guides/gs/async-method">Spring Async 설정</a></li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Agora Cloud Recording을 통한 통화 녹음과 이를 Firebase Storage에 저장하는 기능을 구현하면서 경험한 것과 느낀 점을 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor 앱 Custom Splash Screen 구현하기</title><link href="https://nan0silver.github.io/projectdiary/2025-11-20-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor 앱 Custom Splash Screen 구현하기" /><published>2025-11-20T00:00:00+00:00</published><updated>2026-01-12T05:19:16+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-20-diary/"><![CDATA[<ul>
  <li>이번 포스팅에선 Capacitor로 빌드한 앱에서 여러 아이콘이 순차적으로 표시되는 커스텀 스플래시 스크린을 구현하는 방법을 정리했다.</li>
  <li>왜 Custom splash screen이 필요했나?
    <ul>
      <li>Capacitor의 기본 splash screen은 단일 정적 이미지만 지원한다.<a href="https://capacitorjs.com/docs/apis/splash-screen">🔗링크</a></li>
      <li>나는 여러 아이콘을 순차적으로 보여주는 애니메이션을 구현하고 싶어 React 컴포넌트로 직접 구현하였다!</li>
    </ul>
  </li>
</ul>

<h2 id="목차">목차</h2>

<ul>
  <li><a href="#1-필요한-패키지-설치">1. 필요한 패키지 설치</a></li>
  <li><a href="#2-capacitor-설정">2. Capacitor 설정</a></li>
  <li><a href="#3-커스텀-스플래시-스크린-컴포넌트-생성">3. 커스텀 스플래시 스크린 컴포넌트 생성</a></li>
  <li><a href="#4-apptsx에-통합">4. App.tsx에 통합</a></li>
  <li><a href="#핵심-구현-포인트">핵심 구현 포인트</a></li>
  <li><a href="#주의사항">주의사항</a></li>
  <li><a href="#참고-문헌">참고 문헌</a></li>
</ul>

<hr />

<h2 id="1-필요한-패키지-설치">1. 필요한 패키지 설치</h2>

<p>먼저 스플래시 스크린 관련 패키지를 설치하자.</p>

<blockquote>
  <p>나는 pnpm을 사용하고 있었으므로 pnpm으로 설치했다.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pnpm add @capacitor/splash-screen
pnpm add <span class="nt">-D</span> @capacitor/assets
</code></pre></div></div>

<h2 id="2-capacitor-설정">2. Capacitor 설정</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">capacitor.config.ts</code> 파일에 스플래시 스크린 설정을 추가하자.</li>
  <li>‼️ 커스텀 스플래시를 사용하므로 네이티브 스플래시는 최소화!</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// &lt;reference types="@capacitor/splash-screen" /&gt;</span>

<span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">CapacitorConfig</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@capacitor/cli</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">config</span><span class="p">:</span> <span class="nx">CapacitorConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ... 기타 설정</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">SplashScreen</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">launchShowDuration</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// 커스텀 스플래시를 사용하므로 0으로 설정</span>
      <span class="na">launchAutoHide</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 자동으로 숨길지 여부</span>
      <span class="na">launchFadeOutDuration</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// 페이드 아웃 애니메이션 시간 (커스텀 스플래시에서 처리)</span>
      <span class="na">backgroundColor</span><span class="p">:</span> <span class="dl">"</span><span class="s2">#ffffff</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 배경색 (hex 형식) - 커스텀 스플래시와 동일하게 설정</span>
      <span class="c1">// ... 기타 설정</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">config</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="3-커스텀-스플래시-스크린-컴포넌트-생성">3. 커스텀 스플래시 스크린 컴포넌트 생성</h2>

<p><code class="language-plaintext highlighter-rouge">client/components/CustomSplashScreen.tsx</code> 파일을 생성한다.</p>

<h3 id="props-정의">Props 정의</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">CustomSplashScreenProps</span> <span class="p">{</span>
  <span class="nl">onComplete</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span> <span class="c1">// 스플래시 완료 시 콜백</span>
  <span class="nl">icons</span><span class="p">?:</span> <span class="kr">string</span><span class="p">[];</span> <span class="c1">// 표시할 아이콘 배열</span>
  <span class="nl">iconDuration</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// 각 아이콘 표시 시간(ms)</span>
  <span class="nl">minDisplayDuration</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// 최소 표시 시간(ms)</span>
  <span class="nl">animationType</span><span class="p">?:</span> <span class="dl">"</span><span class="s2">slide-up</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">fade</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">none</span><span class="dl">"</span><span class="p">;</span>
  <span class="nl">backgroundColor</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="핵심-로직">핵심 로직</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">CustomSplashScreen</span> <span class="o">=</span> <span class="p">({</span>
  <span class="nx">onComplete</span><span class="p">,</span>
  <span class="nx">icons</span> <span class="o">=</span> <span class="p">[],</span>
  <span class="nx">iconDuration</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
  <span class="nx">minDisplayDuration</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
  <span class="nx">animationType</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">slide-up</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">backgroundColor</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">#ffffff</span><span class="dl">"</span><span class="p">,</span>
<span class="p">}:</span> <span class="nx">CustomSplashScreenProps</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">currentIconIndex</span><span class="p">,</span> <span class="nx">setCurrentIconIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">isVisible</span><span class="p">,</span> <span class="nx">setIsVisible</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

  <span class="c1">// 1. 네이티브 스플래시 스크린 즉시 숨기기</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">hideNativeSplash</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="k">await</span> <span class="nx">SplashScreen</span><span class="p">.</span><span class="nx">hide</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 웹 환경에서는 에러가 발생할 수 있으므로 무시</span>
      <span class="p">}</span>
    <span class="p">};</span>
    <span class="nx">hideNativeSplash</span><span class="p">();</span>
  <span class="p">},</span> <span class="p">[]);</span>

  <span class="c1">// 2. 아이콘 순차 표시 로직</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">icons</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">setIsVisible</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">onComplete</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
      <span class="p">},</span> <span class="nx">minDisplayDuration</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 아이콘 전환 인터벌</span>
    <span class="kd">const</span> <span class="nx">iconInterval</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setCurrentIconIndex</span><span class="p">((</span><span class="nx">prev</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">prev</span> <span class="o">&lt;</span> <span class="nx">icons</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">prev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">prev</span><span class="p">;</span>
      <span class="p">});</span>
    <span class="p">},</span> <span class="nx">iconDuration</span><span class="p">);</span>

    <span class="c1">// 총 표시 시간 계산</span>
    <span class="kd">const</span> <span class="nx">totalAnimationDuration</span> <span class="o">=</span> <span class="nx">icons</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="nx">iconDuration</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">actualDuration</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">totalAnimationDuration</span><span class="p">,</span> <span class="nx">minDisplayDuration</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">completeTimer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setIsVisible</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
      <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">onComplete</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
    <span class="p">},</span> <span class="nx">actualDuration</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">iconInterval</span><span class="p">);</span>
      <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">completeTimer</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">},</span> <span class="p">[</span><span class="nx">icons</span><span class="p">,</span> <span class="nx">iconDuration</span><span class="p">,</span> <span class="nx">minDisplayDuration</span><span class="p">,</span> <span class="nx">onComplete</span><span class="p">]);</span>

  <span class="c1">// ... 렌더링 로직</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li>아이콘 슬라이드 애니메이션과 텍스트 추가 등 개인의 디자인에 맞게 React 코드를 수정해서 꾸며주면 된다!!</li>
</ul>

<h2 id="4-apptsx에-통합">4. App.tsx에 통합</h2>

<p>메인 앱 컴포넌트에 커스텀 스플래시 스크린을 통합합니다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">CustomSplashScreen</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./components/CustomSplashScreen</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">AppRoutes</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">showSplash</span><span class="p">,</span> <span class="nx">setShowSplash</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

  <span class="c1">// 스플래시 스크린에 표시할 아이콘들</span>
  <span class="kd">const</span> <span class="nx">splashIcons</span> <span class="o">=</span> <span class="p">[</span>
    <span class="dl">"</span><span class="s2">/splash-icons/icon1.png</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">/splash-icons/icon2.png</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">/splash-icons/icon3.png</span><span class="dl">"</span><span class="p">,</span>
    <span class="c1">// ... 더 많은 아이콘</span>
  <span class="p">];</span>

  <span class="kd">const</span> <span class="nx">handleSplashComplete</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setShowSplash</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">showSplash</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">CustomSplashScreen</span>
        <span class="nx">onComplete</span><span class="o">=</span><span class="p">{</span><span class="nx">handleSplashComplete</span><span class="p">}</span>
        <span class="nx">icons</span><span class="o">=</span><span class="p">{</span><span class="nx">splashIcons</span><span class="p">}</span>
        <span class="nx">iconDuration</span><span class="o">=</span><span class="p">{</span><span class="mi">400</span><span class="p">}</span>
        <span class="nx">minDisplayDuration</span><span class="o">=</span><span class="p">{</span><span class="mi">2000</span><span class="p">}</span>
        <span class="nx">animationType</span><span class="o">=</span><span class="dl">"</span><span class="s2">slide-up</span><span class="dl">"</span>
      <span class="o">/&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ... 나머지 앱 로직</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="-핵심-구현-포인트-">🍎 핵심 구현 포인트 🍎</h2>

<h3 id="1-네이티브-스플래시와-커스텀-스플래시-분리">1. 네이티브 스플래시와 커스텀 스플래시 분리</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">launchShowDuration: 0</code>으로 설정하여 네이티브 스플래시를 즉시 숨김</li>
  <li><code class="language-plaintext highlighter-rouge">SplashScreen.hide()</code>를 컴포넌트 마운트 시 호출</li>
</ul>

<h3 id="2-텍스트-깜빡임-방지">2. 텍스트 깜빡임 방지</h3>

<p>아이콘과 텍스트를 별도의 <code class="language-plaintext highlighter-rouge">div</code>로 렌더링하여 아이콘이 변경될 때 텍스트가 깜빡이지 않도록 구현</p>

<h3 id="3-부드러운-애니메이션">3. 부드러운 애니메이션</h3>

<p>CSS <code class="language-plaintext highlighter-rouge">transition</code>과 <code class="language-plaintext highlighter-rouge">cubic-bezier</code> 타이밍 함수를 사용하여 자연스러운 전환 효과 구현</p>

<h3 id="4-최소-표시-시간-보장">4. 최소 표시 시간 보장</h3>

<p><code class="language-plaintext highlighter-rouge">minDisplayDuration</code>을 설정하여 애니메이션이 너무 빨리 끝나도 최소 시간은 보장</p>

<h3 id="5-이미지-준비">5. 이미지 준비</h3>

<p>아이콘 이미지는 <code class="language-plaintext highlighter-rouge">public/splash-icons/</code> 디렉토리에 저장합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public/
  splash-icons/
    icon1.png
    icon2.png
    icon3.png
</code></pre></div></div>

<h2 id="️-주의사항">‼️ 주의사항</h2>

<ul>
  <li>이미지는 반드시 <code class="language-plaintext highlighter-rouge">public</code> 폴더에 저장 (빌드 시 자동 포함)</li>
  <li>웹 환경에서는 <code class="language-plaintext highlighter-rouge">SplashScreen.hide()</code>가 에러를 발생시킬 수 있으므로 try-catch 처리 필요</li>
  <li>Android 12 이상에서는 네이티브 스플래시 API가 강제 적용되므로 초기 0.5초는 네이티브 스플래시가 보일 수 있음</li>
</ul>

<h2 id="-참고-문헌">🍀 참고 문헌</h2>

<ul>
  <li><a href="https://github.com/ionic-team/capacitor-assets">Capacitor assets github page</a></li>
  <li><a href="https://capacitorjs.com/docs/apis/splash-screen">@capacitor/splash-screen DOCS</a></li>
  <li><a href="https://capacitorjs.com/docs/guides/splash-screens-and-icons">Splash Screens and Icons DOCS</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 앱에서 Splash Screen을 React로 직접 구현한 내용에 대해 다룹니다.]]></summary></entry><entry><title type="html">[친구하자] SockJS Transport와 JSONP: 2025년에 만난 레거시 기술</title><link href="https://nan0silver.github.io/projectdiary/2025-11-18-diary/" rel="alternate" type="text/html" title="[친구하자] SockJS Transport와 JSONP: 2025년에 만난 레거시 기술" /><published>2025-11-18T00:00:00+00:00</published><updated>2026-01-12T05:19:16+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-18-diary/"><![CDATA[<ul>
  <li>이번 포스팅에서는 Capacitor로 빌드한 Android 앱에서 WebSocket 통신 중 발생한 JSONP 에러에 대해 다루었다.</li>
  <li>해결하는 과정에서 공부한 내용에 대해 정리해보았다.</li>
</ul>

<h2 id="목차">목차</h2>

<ul>
  <li><a href="#들어가며">들어가며</a></li>
  <li><a href="#문제-상황">문제 상황</a></li>
  <li><a href="#jsonp란-무엇인가">JSONP란 무엇인가?</a></li>
  <li><a href="#sockjs에서-jsonp가-필요했던-이유">SockJS에서 JSONP가 필요했던 이유</a></li>
  <li><a href="#왜-현대-웹에서는-사용하지-않는가">왜 현대 웹에서는 사용하지 않는가?</a></li>
  <li><a href="#내-프로젝트에서의-문제">내 프로젝트에서의 문제</a></li>
  <li><a href="#해결-방법">해결 방법</a></li>
  <li><a href="#교훈">결론</a></li>
  <li><a href="#참고-자료">참고 자료</a></li>
</ul>

<h2 id="들어가며">들어가며</h2>

<p>Capacitor 기반 Android 앱에서 WebSocket 연결을 구현하던 중, 예상치 못한 에러를 만났다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❌ Refused to execute script from 'https://silverld.site/ws/270/s4swngca/jsonp?c=_jp.a050t2f'
   because its MIME type ('') is not executable
</code></pre></div></div>

<p>JSONP? 분명 WebSocket을 사용하고 있는데 왜 갑자기 JSONP가 등장했을까?</p>

<hr />

<h2 id="문제-상황">문제 상황</h2>

<p>로그를 분석해보니 SockJS가 다음과 같은 순서로 연결을 시도하고 있었다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. WebSocket → 실패
2. xhr-streaming → 응답 없음
3. xhr-polling → 부분 성공
4. jsonp → MIME type 에러 발생!
5. Connection closed → 5초 후 재연결 시도
</code></pre></div></div>

<p>WebSocket 연결이 실패하자 SockJS가 <strong>fallback 메커니즘</strong>을 통해 JSONP까지 시도한 것이었다.</p>

<hr />

<h2 id="jsonp란-무엇인가">JSONP란 무엇인가?</h2>

<h3 id="탄생-배경">탄생 배경</h3>

<p>JSONP(JSON with Padding)는 <strong>2000년대 중반</strong>, CORS가 표준화되기 전에 등장한 크로스 도메인 통신 기법이다.</p>

<p>당시 웹 개발자들은 <strong>같은 출처 정책(Same-Origin Policy)</strong> 때문에 다른 도메인의 데이터를 가져올 수 없었다:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ 다른 도메인 AJAX 요청 → 차단됨</span>
<span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://api.example.com/data</span><span class="dl">"</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">());</span>
<span class="c1">// Error: CORS policy 위반!</span>
</code></pre></div></div>

<h3 id="작동-원리">작동 원리</h3>

<p>JSONP는 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 태그가 <strong>CORS 제약을 받지 않는다</strong>는 점을 활용한다:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- ✅ script 태그는 다른 도메인 로드 가능 --&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://api.example.com/data?callback=handleData"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div>

<p><strong>서버 응답:</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">handleData</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
<span class="p">});</span>
</code></pre></div></div>

<p><strong>클라이언트에서 미리 정의:</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">handleData</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="c1">// { name: "John", age: 30 }</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 서버가 <strong>콜백 함수로 데이터를 감싸서</strong> 반환하면, 브라우저가 이를 실행하면서 데이터를 전달받는 방식이다.</p>

<hr />

<h2 id="sockjs에서-jsonp가-필요했던-이유">SockJS에서 JSONP가 필요했던 이유</h2>

<p><strong>SockJS</strong>는 WebSocket을 지원하지 않는 구형 브라우저(IE8/9 등)를 위한 라이브러리이다.</p>

<p>실시간 양방향 통신을 보장하기 위해 다양한 fallback 전략을 사용한다:</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-18-pic1.png?raw=true" alt="이미지1" /></p>

<p>JSONP는 <strong>가장 오래된 브라우저도 지원</strong>하기 위한 최후의 수단!</p>

<hr />

<h2 id="왜-현대-웹에서는-사용하지-않는가">왜 현대 웹에서는 사용하지 않는가?</h2>

<h3 id="1-cors의-등장">1. CORS의 등장</h3>

<p>2014년 CORS(Cross-Origin Resource Sharing)가 표준화되면서 안전하게 크로스 도메인 통신이 가능해졌다:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 현대적인 방법</span>
<span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://api.example.com/data</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// ✅ POST, PUT, DELETE 모두 가능</span>
  <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">),</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="2-보안-취약점">2. 보안 취약점</h3>

<p>JSONP는 심각한 보안 문제를 갖고 있다:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ XSS 공격에 취약</span>
<span class="o">&lt;</span><span class="nx">script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://malicious.com/data?callback=alert('hacked!')</span><span class="dl">"</span><span class="o">&gt;&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span>
<span class="c1">// ❌ CSRF 공격 가능 (GET 요청만 가능하므로)</span>
<span class="c1">// ❌ 인증 토큰 노출 위험</span>
</code></pre></div></div>

<h3 id="3-기능-제한">3. 기능 제한</h3>

<ul>
  <li><strong>GET 요청만 가능</strong> (POST, PUT, DELETE 불가)</li>
  <li><strong>에러 핸들링 어려움</strong> (HTTP 상태 코드 확인 불가)</li>
  <li><strong>타임아웃 제어 어려움</strong></li>
</ul>

<hr />

<h2 id="내-프로젝트에서의-문제">내 프로젝트에서의 문제</h2>

<p>Capacitor 앱에서 WebSocket 연결이 실패하자, SockJS가 JSONP까지 fallback을 시도했다.</p>

<p>하지만 백엔드(Spring Boot)가 <strong>JSONP 응답에 올바른 MIME type 헤더를 보내지 않아</strong> 브라우저가 스크립트 실행을 거부한 것이다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❌ MIME type ('') is not executable
</code></pre></div></div>

<p><strong>근본 원인:</strong></p>

<ul>
  <li>Capacitor 앱에서는 JSONP가 <strong>전혀 필요 없음</strong> (최신 WebView 사용)</li>
  <li>하지만 SockJS가 기본 설정으로 JSONP를 포함하고 있었음</li>
</ul>

<hr />

<h2 id="해결-방법">해결 방법</h2>

<p>SockJS 초기화 시 <strong>사용할 transport를 명시적으로 제한</strong>했다:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">sockJSOptions</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">transports</span><span class="p">:</span> <span class="p">[</span>
    <span class="dl">"</span><span class="s2">websocket</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 최우선</span>
    <span class="dl">"</span><span class="s2">xhr-streaming</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 2순위</span>
    <span class="dl">"</span><span class="s2">xhr-polling</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 3순위</span>
    <span class="c1">// 'jsonp' 제거! (레거시 transport)</span>
  <span class="p">],</span>
  <span class="na">timeout</span><span class="p">:</span> <span class="mi">20000</span><span class="p">,</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SockJS</span><span class="p">(</span><span class="nx">wsUrl</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">sockJSOptions</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>결과:</strong></p>

<ul>
  <li>✅ JSONP 에러 해결</li>
  <li>✅ 불필요한 fallback 시도 제거</li>
  <li>✅ 연결 속도 향상</li>
</ul>

<hr />

<h2 id="교훈">교훈</h2>

<ol>
  <li>
    <p><strong>레거시 코드는 예상치 못한 곳에 숨어있다</strong></p>

    <ul>
      <li>현대적인 라이브러리도 하위 호환성을 위해 오래된 기술을 포함</li>
    </ul>
  </li>
  <li>
    <p><strong>기본 설정을 맹신하지 말자</strong></p>

    <ul>
      <li>SockJS의 기본 transport 설정은 IE8 시대의 유산</li>
      <li>현대 환경에 맞게 커스터마이징 필요</li>
    </ul>
  </li>
  <li>
    <p><strong>프레임워크의 동작 방식을 이해하자</strong></p>
    <ul>
      <li>“왜 WebSocket을 쓰는데 JSONP가?”라는 의문</li>
      <li>Fallback 메커니즘을 이해하니 해결 방법도 명확해짐</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="마치며">마치며</h2>

<p>JSONP 에러를 처음 마주했다. 하지만 웹의 역사를 이해하고, 현대 기술이 어떻게 발전해왔는지 공부하는 좋은 기회가 되었다.</p>

<p>여러분의 프로젝트에서도 SockJS를 사용한다면, transport 설정을 확인해보시길 추천합니다!
불필요한 레거시 코드를 제거하면 성능과 안정성 모두 향상될 수 있습니다.😊</p>

<hr />

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">SockJS Protocol</a></li>
  <li><a href="https://en.wikipedia.org/wiki/JSONP">JSONP의 작동 원리와 보안 이슈</a></li>
  <li><a href="https://stackoverflow.com/questions/2067472/what-is-jsonp-and-why-was-it-created">CORS vs JSONP</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 Android 앱에서의 웹소켓 오류 중 X-Frame-Options 에러 트러블슈팅을 다룹니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor Android 앱 X-Frame-Options 에러 해결</title><link href="https://nan0silver.github.io/projectdiary/2025-11-17-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor Android 앱 X-Frame-Options 에러 해결" /><published>2025-11-17T00:00:00+00:00</published><updated>2026-01-12T05:19:16+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-17-diary/"><![CDATA[<ul>
  <li>이번 포스팅에서는 Capacitor로 빌드한 Android 앱에서 WebSocket 통신 중 발생한 X-Frame-Options 에러에 대해 다루었다.</li>
  <li>해결하는 과정에서 공부한 내용에 대해 정리해보았다.</li>
</ul>

<h2 id="문제-상황">문제 상황</h2>

<ul>
  <li>웹에서는 정상적으로 작동하던 <strong>매칭 완료 -&gt; WebSocket 메시지 수신 -&gt; 통화 시작 페이지 이동</strong> 로직이 Android 앱에서 다음과 같은 에러로 실패했다.</li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-17-pic1.png?raw=true" alt="에러 이미지1" /></p>

<ul>
  <li>🔥 이 문제는 <strong>Capacitor의 WebView 환경과 Spring Security의 기본 보안 설정이 충돌</strong>하면서 발생! 🔥</li>
  <li>WebSocket 라이브러리인 SockJS가 fallback 메커니즘으로 iframe을 사용하려 했지만, 서버가 보안상의 이유로 이를 차단했기 때문이다.</li>
  <li>이 글에서는 X-Frame-Options가 무엇인지, iframe이 무엇인지, 그리고 왜 이런 에러가 발생햇는지를 자세히 알아보겠습니다.</li>
</ul>

<h2 id="1-iframe-이란">1. iframe 이란?</h2>

<ul>
  <li><strong>iframe (inline frame)</strong>은 HTML 문서 안에서 다른 HTML 문서를 삽입하는 태그이다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- 예시: 유튜브 영상 삽입 --&gt;
&lt;iframe
    src="https://www.youtube.com/embed/VIDEO_ID"
    width="560"
    height="315"&gt;
&lt;/iframe&gt;
</code></pre></div></div>

<p><strong>시각적 구조:</strong>
<img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-17-pic2.png?raw=true" alt="설명 이미지1" /></p>

<ul>
  <li>실생활 예시 : 유튜브 영상 삽입, 구글 지도 삽입, 페이스북 “좋아요” 버튼 등</li>
</ul>

<h2 id="2-x-frame-options-이란">2. X-Frame-Options 이란?</h2>

<ul>
  <li>
    <p><strong>X-Frame-Options</strong>는 HTTP 응답 헤더로, 내 웹사이트가 다른 사이트의 iframe안에 표시되는 것을 제어하는 보안 메커니즘</p>
  </li>
  <li>
    <p>헤더 값 3가지:</p>
    <ul>
      <li>X-Frame-Options: DENY
        <ul>
          <li>어떤 사이트든 iframe으로 내 페이지를 로드할 수 없음</li>
        </ul>
      </li>
      <li>X-Frame-Options: SAMEORIGIN
        <ul>
          <li>같은 도메인에서만 iframe으로 로드 가능</li>
        </ul>
      </li>
      <li>X-Frame-Options: ALLOW-FROM https://example.com
        <ul>
          <li>특정 도메인에서만 iframe으로 로드 가능 (deprecated)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="왜-x-frame-options가-필요한가">왜 X-Frame-Options가 필요한가?</h3>

<ul>
  <li><strong>Clickjacking 공격 방지</strong>
    <ul>
      <li>악의적인 사이트가 투명한 iframe을 통해 사용자를 속여 원하지 않는 행동을 하게 만드는 공격</li>
    </ul>
  </li>
</ul>

<p><strong>공격 시나리오:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 공격자가 악의적인 사이트 만들기 (evil.com)

2. 투명한 iframe으로 은행 사이트를 숨김
   ┌─────────────────────────────────┐
   │ evil.com                        │
   │                                 │
   │ [무료 iPhone 받기!] 버튼           │
   │        ↑                        │
   │        실제로는 투명한 iframe       │
   │        은행 송금 버튼이 위치         │
   └─────────────────────────────────┘

3. 사용자가 "무료 iPhone 받기!" 클릭
   → 실제로는 은행의 "송금 승인" 버튼 클릭
   → 돈이 공격자에게 전송됨 🥲
</code></pre></div></div>

<p><strong>X-Frame-Options: DENY가 막는 방법:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────────────────────┐
│ evil.com                        │
│                                 │
│ &lt;iframe src="bank.com"&gt;         │
│   ❌ 브라우저가 로드 거부!           │
│   "X-Frame-Options: DENY"       │
│ &lt;/iframe&gt;                       │
└─────────────────────────────────┘
</code></pre></div></div>

<h2 id="️-capacitor로-빌드한-앱에서-이-문제가-발생한-이유">‼️ Capacitor로 빌드한 앱에서 이 문제가 발생한 이유</h2>

<ul>
  <li>Capacitor는 <strong>하이브리드 앱</strong>을 만드는 프레임워크이다.</li>
</ul>

<p><strong>하이브리드 앱 구조</strong>
<img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-17-pic3.png?raw=true" alt="설명 이미지2" /></p>

<ul>
  <li>WebView는 본질적으로 iframe과 유사하다!</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>네이티브 앱 (Android/iOS)
    └── WebView ≈ iframe
         └── React 앱 (https://localhost)
              └── WebSocket 연결 시도 → 백엔드 (https://backend.domain)
</code></pre></div></div>

<h3 id="sockjs의-iframe-transport"><strong>SockJS의 iframe Transport</strong></h3>

<p><strong>SockJS</strong>는 WebSocket이 안 될 때를 대비한 여러 fallback 방법을 제공한다.</p>

<p><strong>SockJS Transport 순서:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. WebSocket (가장 빠르고 효율적)
   ↓ 실패
2. xhr-streaming (HTTP 스트리밍)
   ↓ 실패
3. xhr-polling (HTTP 폴링)
   ↓ 실패
4. iframe-based transports (레거시 브라우저용)
   ↓ 실패
5. jsonp-polling (최후의 수단)
</code></pre></div></div>

<ul>
  <li>iframe-based transport가 하는 일:</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- SockJS가 내부적으로 생성하는 숨겨진 iframe --&gt;</span>
<span class="nt">&lt;iframe</span> <span class="na">src=</span><span class="s">"https://backend.domain/ws/iframe.html"</span> <span class="na">style=</span><span class="s">"display: none;"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/iframe&gt;</span>
</code></pre></div></div>

<h3 id="문제-발생-시나리오"><strong>문제 발생 시나리오:</strong></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Capacitor 앱 (WebView) 시작
   Origin: capacitor://localhost

2. WebSocket 연결 시도 (친구하자 프로젝트의 경우, 통화 매칭시 사용 중)
   → https://backend.domain/ws

3. SockJS가 iframe transport 시도
   ┌─────────────────────────────────┐
   │ Capacitor WebView               │
   │ (capacitor://localhost)         │
   │                                 │
   │ &lt;iframe src="backend.domain/ws"&gt; │
   │   ❌ 차단됨!                     │
   │   "X-Frame-Options: DENY"       │
   │ &lt;/iframe&gt;                       │
   └─────────────────────────────────┘

4. 에러 메시지:
   "Refused to display 'https://backend.domain/'
    in a frame because it set 'X-Frame-Options' to 'deny'"
</code></pre></div></div>

<h3 id="왜-spring-security가-기본적으로-deny를-설정할까">왜 Spring Security가 기본적으로 Deny를 설정할까?</h3>

<ul>
  <li>Spring Security의 보안 우선 철학 :
<img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-17-pic4.png?raw=true" alt="설명 이미지3" /></li>
</ul>

<p><strong>이유</strong></p>

<ol>
  <li><strong>보안 우선주의</strong>: 안전하지 않은 것보다 안전한 것이 낫다</li>
  <li><strong>Clickjacking 방지</strong>: 대부분의 웹 애플리케이션은 iframe에 로드될 필요 없음</li>
  <li><strong>명시적 허용</strong>: 개발자가 필요하면 명시적으로 변경하도록 유도</li>
</ol>

<p><strong>일반적인 웹사이트는 DENY가 맞다:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>은행, 쇼핑몰, 관리자 페이지 등
→ iframe에 로드될 이유가 없음
→ DENY로 보안 강화
</code></pre></div></div>

<p><strong>하지만 우리의 경우:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Capacitor 하이브리드 앱
→ WebView는 iframe과 유사한 환경
→ DENY면 앱 자체가 작동 안 함
→ SAMEORIGIN 또는 특정 origin 허용 필요
</code></pre></div></div>

<h2 id="해결-방법">해결 방법</h2>

<h3 id="방법-1-frameoptionssameorigin-운영-환경-권장">방법 1: frameOptions().sameOrigin() (운영 환경 권장)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">headers</span><span class="o">(</span><span class="n">headers</span> <span class="o">-&gt;</span> <span class="n">headers</span>
    <span class="o">.</span><span class="na">frameOptions</span><span class="o">(</span><span class="n">frameOptions</span> <span class="o">-&gt;</span> <span class="n">frameOptions</span><span class="o">.</span><span class="na">sameOrigin</span><span class="o">())</span>
<span class="o">)</span>
</code></pre></div></div>

<p><strong>의미:</strong></p>

<ul>
  <li>같은 도메인에서만 iframe 허용</li>
  <li><code class="language-plaintext highlighter-rouge">https://backend.domain</code>에서 <code class="language-plaintext highlighter-rouge">https://backend.domain</code>를 iframe으로 로드 가능</li>
  <li>Capacitor WebView는 <code class="language-plaintext highlighter-rouge">capacitor://localhost</code>이지만, WebView 자체가 특수 처리됨</li>
</ul>

<p><strong>왜 이게 Capacitor에서 작동하나?</strong>
WebView는 브라우저 엔진의 특수 모드
→ origin 검사가 일반 웹과 다르게 처리됨
→ SAMEORIGIN이어도 WebView 내부 컨텍스트에서는 허용</p>

<h3 id="방법-2-content-security-policy-추가-최고-보안">방법 2: Content-Security-Policy 추가 (최고 보안)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">headers</span><span class="o">(</span><span class="n">headers</span> <span class="o">-&gt;</span> <span class="n">headers</span>
    <span class="o">.</span><span class="na">frameOptions</span><span class="o">(</span><span class="n">frameOptions</span> <span class="o">-&gt;</span> <span class="n">frameOptions</span><span class="o">.</span><span class="na">sameOrigin</span><span class="o">())</span>
    <span class="o">.</span><span class="na">contentSecurityPolicy</span><span class="o">(</span><span class="n">csp</span> <span class="o">-&gt;</span> <span class="n">csp</span>
        <span class="o">.</span><span class="na">policyDirectives</span><span class="o">(</span><span class="s">"frame-ancestors 'self' capacitor://localhost http://localhost https://localhost"</span><span class="o">)</span>
    <span class="o">)</span>
<span class="o">)</span>
</code></pre></div></div>

<p><strong>의미:</strong></p>

<ul>
  <li>현대적인 보안 헤더 (X-Frame-Options의 후속)</li>
  <li>더 세밀한 제어 가능</li>
  <li>특정 origin만 명시적으로 허용</li>
</ul>

<h2 id="결론">결론</h2>

<ul>
  <li>Capacitor로 앱을 빌드한 다음에 웹에서는 발생하지 않는 에러들이 생겨서 찾아보고, 공부하고, 해결하는 재미가 있다.</li>
  <li>이제 통화연결까지 앱으로 수행할 수 있게 되었다!!</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 Android 앱에서의 웹소켓 오류 중 X-Frame-Options 에러 트러블슈팅을 다룹니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor 앱에서 Kakao/Google 네이티브 로그인 구현 정리</title><link href="https://nan0silver.github.io/projectdiary/2025-11-13-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor 앱에서 Kakao/Google 네이티브 로그인 구현 정리" /><published>2025-11-13T00:00:00+00:00</published><updated>2026-01-12T05:19:16+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-13-diary/"><![CDATA[<ul>
  <li>Capacitor로 빌드한 React 앱에서 카카오와 구글 네이티브 로그인을 구현하는 방법을 정리해 보았다.</li>
  <li>관련되서 정리되어있는게 없는것 같아서.. 내가 나중에 찾아볼 수 있게 일단 문서를 만들어보았다.</li>
  <li>웹에서는 일반 OAuth 리다이렉트를 사용하지만, 모바일 앱에서는 <strong>네이티브 SDK를 직접 사용</strong>하는 방식으로 구현했다. (kakao, google)
    <ul>
      <li>kakao developer에는 flutter문서에서 크로스 플랫폼에서는 커스텀 URL 스킴을 사용하라고 권장한다. 하지만 나는 플러그인을 사용하는 방식으로 구현해보았다.</li>
    </ul>
  </li>
</ul>

<h3 id="네이티브-sdk-직접-사용-구헌-방식-카카오-구글">네이티브 SDK 직접 사용 구헌 방식 (카카오, 구글)</h3>

<p><strong>네이티브 SDK 로그인 방식이란?</strong></p>

<ul>
  <li>카카오/구글이 제공하는 Android/iOS 전용 SDK를 사용한 로그인 방식</li>
  <li>앱 간 통신 방식을 사용한다.
    <ul>
      <li>즉, 기기에 설치된 카카오톡/구글 앱과 직접 통신하여 인증한다.</li>
    </ul>
  </li>
  <li>WebView를 우회하여 브라우저 리다이렉트 없이 앱 레벨에서 토큰을 교환한다.</li>
</ul>

<p><strong>이 방식이 하이브리드 앱에서 가능한 이유</strong></p>

<ul>
  <li>⭐️<strong>Capacitor의 플러그인 시스템</strong>⭐️이 핵심!</li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-13-pic1.png?raw=true" alt="설명 이미지1" /></p>

<ul>
  <li>WebView의 JavaScript 코드가 네이티브 코드를 호출할 수 있게 해줌</li>
  <li><code class="language-plaintext highlighter-rouge">KakaoLoginPlugin.goLogin()</code>을 통해 실제로 Android의 카카오 SDK 실행</li>
  <li>결과를 다시 JavaScript로 전달</li>
</ul>

<p>*<em>앱 구조 비교</em></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 안드로이드에서 실행 시</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">Capacitor</span><span class="p">.</span><span class="nx">isNativePlatform</span><span class="p">())</span> <span class="p">{</span>
  <span class="c1">// ✅ 네이티브 SDK 사용 (앱간 통신)</span>
  <span class="c1">// 카카오톡 앱 → 내 앱 (빠르고 안정적)</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">KakaoLoginPlugin</span><span class="p">.</span><span class="nx">goLogin</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 웹 브라우저에서 실행 시</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="c1">// ✅ OAuth 리다이렉트 사용 (브라우저 기반)</span>
  <span class="c1">// 브라우저 → 카카오 웹 → 콜백 URL</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">https://kauth.kakao.com/oauth/...</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>이렇게 하는 이유</strong></p>

<ul>
  <li>네이티브 로그인의 장점:
    <ul>
      <li>사용자가 카카오톡이 설치되어 있으면 앱 전환만으로 즉시 로그인</li>
      <li>브라우저 리다이렉트보다 UX가 훨씬 부드러움</li>
      <li>DeepLink, Custom URL Scheme 문제 없음</li>
    </ul>
  </li>
  <li>웹 로그인:
    <ul>
      <li>브라우저에서는 네이티브 SDK를 쓸 수 없으니 전통적인 OAuth 방식 사용</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="1-카카오-네이티브-로그인-구현">1. 카카오 네이티브 로그인 구현</h2>

<h3 id="11-플러그인-설치">1.1 플러그인 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pnpm add capacitor-kakao-login-plugin
npx cap <span class="nb">sync</span>
</code></pre></div></div>

<h3 id="12-android-설정">1.2 Android 설정</h3>

<h4 id="121-kakao-sdk-의존성-추가">1.2.1 Kakao SDK 의존성 추가</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/build.gradle</code>:</p>

<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">dependencies</span> <span class="o">{</span>
    <span class="c1">// ... 기존 의존성 ...</span>
    <span class="n">implementation</span> <span class="s2">"com.kakao.sdk:v2-common:2.20.1"</span>
    <span class="n">implementation</span> <span class="s2">"com.kakao.sdk:v2-auth:2.20.1"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">android/build.gradle</code>:</p>

<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">allprojects</span> <span class="o">{</span>
    <span class="k">repositories</span> <span class="o">{</span>
        <span class="n">google</span><span class="o">()</span>
        <span class="n">mavenCentral</span><span class="o">()</span>
        <span class="n">maven</span> <span class="o">{</span> <span class="n">url</span> <span class="s1">'https://devrepo.kakao.com/nexus/content/groups/public/'</span> <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="122-androidmanifestxml-설정">1.2.2 AndroidManifest.xml 설정</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/src/main/AndroidManifest.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;application&gt;</span>
    <span class="c">&lt;!-- 카카오 SDK 메타데이터 --&gt;</span>
    <span class="nt">&lt;meta-data</span>
        <span class="na">android:name=</span><span class="s">"com.kakao.sdk.AppKey"</span>
        <span class="na">android:value=</span><span class="s">"@string/kakao_app_key"</span> <span class="nt">/&gt;</span>

    <span class="nt">&lt;activity</span>
        <span class="na">android:name=</span><span class="s">".MainActivity"</span>
        <span class="na">android:exported=</span><span class="s">"true"</span><span class="nt">&gt;</span>
        <span class="c">&lt;!-- 카카오 로그인 리다이렉트 --&gt;</span>
        <span class="nt">&lt;intent-filter&gt;</span>
            <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">"android.intent.action.VIEW"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.DEFAULT"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.BROWSABLE"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;data</span> <span class="na">android:host=</span><span class="s">"kakaolink"</span> <span class="na">android:scheme=</span><span class="s">"@string/kakao_scheme"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/intent-filter&gt;</span>
    <span class="nt">&lt;/activity&gt;</span>

    <span class="c">&lt;!-- 카카오 인증 코드 핸들러 --&gt;</span>
    <span class="nt">&lt;activity</span>
        <span class="na">android:name=</span><span class="s">"com.kakao.sdk.auth.AuthCodeHandlerActivity"</span>
        <span class="na">android:exported=</span><span class="s">"true"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;intent-filter&gt;</span>
            <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">"android.intent.action.VIEW"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.DEFAULT"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.BROWSABLE"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;data</span> <span class="na">android:host=</span><span class="s">"oauth"</span> <span class="na">android:scheme=</span><span class="s">"@string/kakao_scheme"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/intent-filter&gt;</span>
    <span class="nt">&lt;/activity&gt;</span>
<span class="nt">&lt;/application&gt;</span>
</code></pre></div></div>

<h4 id="123-stringsxml-설정">1.2.3 strings.xml 설정</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/src/main/res/values/strings.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;resources&gt;</span>
    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">"kakao_app_key"</span><span class="nt">&gt;</span>YOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">"kakao_scheme"</span><span class="nt">&gt;</span>kakaoYOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>
<span class="nt">&lt;/resources&gt;</span>
</code></pre></div></div>

<h4 id="124-mainactivityjava-초기화">1.2.4 MainActivity.java 초기화</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/src/main/java/com/yourpackage/app/MainActivity.java</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">com.kakao.sdk.common.KakaoSdk</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="nc">BridgeActivity</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="nc">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>

        <span class="c1">// 카카오 SDK 초기화</span>
        <span class="nc">KakaoSdk</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">getResources</span><span class="o">().</span><span class="na">getString</span><span class="o">(</span><span class="no">R</span><span class="o">.</span><span class="na">string</span><span class="o">.</span><span class="na">kakao_app_key</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="13-ios-설정">1.3 iOS 설정</h3>

<h4 id="131-infoplist-설정">1.3.1 Info.plist 설정</h4>

<p><code class="language-plaintext highlighter-rouge">ios/App/App/Info.plist</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;key&gt;</span>KAKAO_APP_KEY<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;string&gt;</span>YOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>

<span class="nt">&lt;key&gt;</span>CFBundleURLTypes<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;array&gt;</span>
    <span class="nt">&lt;dict&gt;</span>
        <span class="nt">&lt;key&gt;</span>CFBundleURLSchemes<span class="nt">&lt;/key&gt;</span>
        <span class="nt">&lt;array&gt;</span>
            <span class="nt">&lt;string&gt;</span>kakaoYOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>
            <span class="nt">&lt;string&gt;</span>com.yourapp.bundleid<span class="nt">&lt;/string&gt;</span>
        <span class="nt">&lt;/array&gt;</span>
    <span class="nt">&lt;/dict&gt;</span>
<span class="nt">&lt;/array&gt;</span>

<span class="nt">&lt;key&gt;</span>LSApplicationQueriesSchemes<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;array&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaoYOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaokompassauth<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>storykompassauth<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaolink<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>storylink<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaotalk<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaotalk-5.9.7<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaostory-2.9.0<span class="nt">&lt;/string&gt;</span>
<span class="nt">&lt;/array&gt;</span>
</code></pre></div></div>

<h4 id="132-appdelegateswift-초기화">1.3.2 AppDelegate.swift 초기화</h4>

<p><code class="language-plaintext highlighter-rouge">ios/App/App/AppDelegate.swift</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">KakaoSDKAuth</span>
<span class="kd">import</span> <span class="kt">KakaoSDKCommon</span>

<span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="n">_</span> <span class="nv">application</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="p">,</span> <span class="n">didFinishLaunchingWithOptions</span> <span class="nv">launchOptions</span><span class="p">:</span> <span class="p">[</span><span class="kt">UIApplication</span><span class="o">.</span><span class="kt">LaunchOptionsKey</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]?)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">key</span> <span class="o">=</span> <span class="kt">Bundle</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">infoDictionary</span><span class="p">?[</span><span class="s">"KAKAO_APP_KEY"</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">String</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">kakaoKey</span> <span class="o">=</span> <span class="n">key</span> <span class="p">{</span>
        <span class="kt">KakaoSDK</span><span class="o">.</span><span class="nf">initSDK</span><span class="p">(</span><span class="nv">appKey</span><span class="p">:</span> <span class="n">kakaoKey</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="n">_</span> <span class="nv">app</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="p">,</span> <span class="kd">open</span> <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="kt">UIApplication</span><span class="o">.</span><span class="kt">OpenURLOptionsKey</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:])</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="kt">AuthApi</span><span class="o">.</span><span class="nf">isKakaoTalkLoginUrl</span><span class="p">(</span><span class="n">url</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">AuthController</span><span class="o">.</span><span class="nf">handleOpenUrl</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kt">ApplicationDelegateProxy</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">application</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="nv">open</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="n">options</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="14-프론트엔드-코드">1.4 프론트엔드 코드</h3>

<p><code class="language-plaintext highlighter-rouge">client/lib/auth.ts</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">KakaoLoginPlugin</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">capacitor-kakao-login-plugin</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">startSocialLogin</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">provider</span><span class="p">:</span> <span class="nx">OAuthProvider</span>
<span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isMobile</span> <span class="o">=</span> <span class="nx">Capacitor</span><span class="p">.</span><span class="nx">isNativePlatform</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">isMobile</span> <span class="o">&amp;&amp;</span> <span class="nx">provider</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">kakao</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 카카오 네이티브 로그인 실행</span>
      <span class="kd">const</span> <span class="nx">kakaoResult</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">KakaoLoginPlugin</span><span class="p">.</span><span class="nx">goLogin</span><span class="p">();</span>

      <span class="c1">// 카카오 액세스 토큰을 백엔드로 전달</span>
      <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">processKakaoNativeLogin</span><span class="p">(</span><span class="nx">kakaoResult</span><span class="p">.</span><span class="nx">accessToken</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span>
          <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">"</span><span class="s2">oauth-login-success</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
            <span class="na">detail</span><span class="p">:</span> <span class="p">{</span> <span class="na">userInfo</span><span class="p">:</span> <span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">user_info</span> <span class="p">},</span>
          <span class="p">})</span>
        <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span>
        <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">"</span><span class="s2">oauth-login-error</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
          <span class="na">detail</span><span class="p">:</span> <span class="p">{</span> <span class="na">error</span><span class="p">:</span> <span class="nx">error</span><span class="p">.</span><span class="nx">message</span> <span class="p">},</span>
        <span class="p">})</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 웹: 일반 OAuth 리다이렉트</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="nx">config</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">authorization_url</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 백엔드로 카카오 토큰 전달</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">processKakaoNativeLogin</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">kakaoAccessToken</span><span class="p">:</span> <span class="kr">string</span>
<span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">OAuthLoginResponse</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">getApiUrl</span><span class="p">()}</span><span class="s2">/v1/auth/oauth/kakao/native`</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span> <span class="p">},</span>
    <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
      <span class="na">kakao_access_token</span><span class="p">:</span> <span class="nx">kakaoAccessToken</span><span class="p">,</span>
      <span class="na">device_info</span><span class="p">:</span> <span class="s2">`</span><span class="p">${</span><span class="nb">navigator</span><span class="p">.</span><span class="nx">platform</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nb">navigator</span><span class="p">.</span><span class="nx">userAgent</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
    <span class="p">}),</span>
    <span class="na">credentials</span><span class="p">:</span> <span class="dl">"</span><span class="s2">include</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="15-카카오-개발자-콘솔-설정">1.5 카카오 개발자 콘솔 설정</h3>

<ol>
  <li>
    <p><strong>키 해시 등록</strong> (Android)</p>

    <ul>
      <li>Android Studio Logcat에서 SHA-1, SHA-256 키 해시 확인</li>
      <li>카카오 개발자 콘솔 → 내 애플리케이션 → 플랫폼 → Android → 키 해시 등록</li>
    </ul>
  </li>
  <li>
    <p><strong>리다이렉트 URI 설정</strong></p>
    <ul>
      <li>Android: <code class="language-plaintext highlighter-rouge">kakao{NATIVE_APP_KEY}://oauth</code></li>
      <li>iOS: <code class="language-plaintext highlighter-rouge">kakao{NATIVE_APP_KEY}://oauth</code></li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="2-구글-네이티브-로그인-구현">2. 구글 네이티브 로그인 구현</h2>

<h3 id="21-플러그인-설치">2.1 플러그인 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pnpm add @codetrix-studio/capacitor-google-auth
npx cap <span class="nb">sync</span>
</code></pre></div></div>

<h3 id="22-google-console-설정">2.2 Google Console 설정</h3>

<h4 id="221-웹-클라이언트-id-생성">2.2.1 웹 클라이언트 ID 생성</h4>

<ol>
  <li>Google Console → API 및 서비스 → 사용자 인증 정보</li>
  <li>
    <ul>
      <li>사용자 인증 정보 만들기 → OAuth 2.0 클라이언트 ID</li>
    </ul>
  </li>
  <li>애플리케이션 유형: <strong>웹 애플리케이션</strong></li>
  <li>생성된 클라이언트 ID를 복사</li>
</ol>

<h4 id="222-android-클라이언트-id-생성">2.2.2 Android 클라이언트 ID 생성</h4>

<ol>
  <li>
    <ul>
      <li>사용자 인증 정보 만들기 → OAuth 2.0 클라이언트 ID</li>
    </ul>
  </li>
  <li>애플리케이션 유형: <strong>Android</strong></li>
  <li>패키지 이름: <code class="language-plaintext highlighter-rouge">com.yourapp.bundleid</code></li>
  <li><strong>SHA-1 인증서 지문 등록</strong> (중요!)</li>
</ol>

<p><strong>SHA-1 지문 확인 방법:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 디버그 키스토어</span>
keytool <span class="nt">-list</span> <span class="nt">-v</span> <span class="nt">-keystore</span> ~/.android/debug.keystore <span class="nt">-alias</span> androiddebugkey <span class="nt">-storepass</span> android <span class="nt">-keypass</span> android

<span class="c"># 또는 MainActivity에서 로그로 확인</span>
</code></pre></div></div>

<p>SHA-1 지문을 <strong>콜론 없이</strong> 등록</p>

<h4 id="223-ios-클라이언트-id-생성-선택">2.2.3 iOS 클라이언트 ID 생성 (선택)</h4>

<ol>
  <li>
    <ul>
      <li>사용자 인증 정보 만들기 → OAuth 2.0 클라이언트 ID</li>
    </ul>
  </li>
  <li>애플리케이션 유형: <strong>iOS</strong></li>
  <li>번들 ID: <code class="language-plaintext highlighter-rouge">com.yourapp.bundleid</code></li>
  <li><code class="language-plaintext highlighter-rouge">GoogleService.plist</code> 파일 다운로드</li>
</ol>

<h3 id="23-android-설정">2.3 Android 설정</h3>

<h4 id="231-stringsxml-설정">2.3.1 strings.xml 설정</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/src/main/res/values/strings.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;resources&gt;</span>
    <span class="c">&lt;!-- 웹 클라이언트 ID (server_client_id) --&gt;</span>
    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">"server_client_id"</span><span class="nt">&gt;</span>YOUR_WEB_CLIENT_ID.apps.googleusercontent.com<span class="nt">&lt;/string&gt;</span>
<span class="nt">&lt;/resources&gt;</span>
</code></pre></div></div>

<p><strong>참고</strong>: Android 클라이언트 ID는 코드에 넣을 필요 없습니다. 플러그인이 자동으로 사용합니다.</p>

<h4 id="232-androidmanifestxml-권한-추가">2.3.2 AndroidManifest.xml 권한 추가</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;uses-permission</span> <span class="na">android:name=</span><span class="s">"android.permission.GET_ACCOUNTS"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<h4 id="233-capacitorconfigts-설정">2.3.3 capacitor.config.ts 설정</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">GoogleAuth</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">scopes</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">profile</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">email</span><span class="dl">"</span><span class="p">],</span>
      <span class="na">serverClientId</span><span class="p">:</span> <span class="dl">"</span><span class="s2">YOUR_WEB_CLIENT_ID.apps.googleusercontent.com</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">forceCodeForRefreshToken</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="24-ios-설정">2.4 iOS 설정</h3>

<h4 id="241-googleserviceplist-추가">2.4.1 GoogleService.plist 추가</h4>

<ol>
  <li>Google Console에서 다운로드한 <code class="language-plaintext highlighter-rouge">GoogleService.plist</code> 파일을</li>
  <li><code class="language-plaintext highlighter-rouge">ios/App/App/</code> 폴더에 복사</li>
</ol>

<h4 id="242-infoplist-설정">2.4.2 Info.plist 설정</h4>

<p><code class="language-plaintext highlighter-rouge">ios/App/App/Info.plist</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;key&gt;</span>CFBundleURLTypes<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;array&gt;</span>
    <span class="nt">&lt;dict&gt;</span>
        <span class="nt">&lt;key&gt;</span>CFBundleURLSchemes<span class="nt">&lt;/key&gt;</span>
        <span class="nt">&lt;array&gt;</span>
            <span class="nt">&lt;string&gt;</span>com.yourapp.bundleid<span class="nt">&lt;/string&gt;</span>
            <span class="c">&lt;!-- GoogleService.plist의 REVERSED_CLIENT_ID 값 --&gt;</span>
            <span class="nt">&lt;string&gt;</span>YOUR_REVERSED_CLIENT_ID<span class="nt">&lt;/string&gt;</span>
        <span class="nt">&lt;/array&gt;</span>
    <span class="nt">&lt;/dict&gt;</span>
<span class="nt">&lt;/array&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">REVERSED_CLIENT_ID</code>는 <code class="language-plaintext highlighter-rouge">GoogleService.plist</code> 파일에서 확인할 수 있습니다.</p>

<h3 id="25-프론트엔드-코드">2.5 프론트엔드 코드</h3>

<p><code class="language-plaintext highlighter-rouge">client/lib/auth.ts</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">GoogleAuth</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@codetrix-studio/capacitor-google-auth</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">startSocialLogin</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">provider</span><span class="p">:</span> <span class="nx">OAuthProvider</span>
<span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isMobile</span> <span class="o">=</span> <span class="nx">Capacitor</span><span class="p">.</span><span class="nx">isNativePlatform</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">isMobile</span> <span class="o">&amp;&amp;</span> <span class="nx">provider</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">google</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 구글 플러그인 초기화 (scopes 포함)</span>
      <span class="k">await</span> <span class="nx">GoogleAuth</span><span class="p">.</span><span class="nx">initialize</span><span class="p">({</span>
        <span class="na">scopes</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">profile</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">email</span><span class="dl">"</span><span class="p">],</span>
      <span class="p">});</span>

      <span class="c1">// 구글 네이티브 로그인 실행</span>
      <span class="kd">const</span> <span class="nx">googleResult</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">GoogleAuth</span><span class="p">.</span><span class="nx">signIn</span><span class="p">();</span>

      <span class="c1">// 구글 ID 토큰을 백엔드로 전달</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">googleResult</span><span class="p">.</span><span class="nx">authentication</span><span class="p">?.</span><span class="nx">idToken</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">구글 ID 토큰을 받지 못했습니다.</span><span class="dl">"</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">processGoogleNativeLogin</span><span class="p">(</span>
        <span class="nx">googleResult</span><span class="p">.</span><span class="nx">authentication</span><span class="p">.</span><span class="nx">idToken</span>
      <span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span>
          <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">"</span><span class="s2">oauth-login-success</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
            <span class="na">detail</span><span class="p">:</span> <span class="p">{</span> <span class="na">userInfo</span><span class="p">:</span> <span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">user_info</span> <span class="p">},</span>
          <span class="p">})</span>
        <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span>
        <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">"</span><span class="s2">oauth-login-error</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
          <span class="na">detail</span><span class="p">:</span> <span class="p">{</span> <span class="na">error</span><span class="p">:</span> <span class="nx">error</span><span class="p">.</span><span class="nx">message</span> <span class="p">},</span>
        <span class="p">})</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 웹: 일반 OAuth 리다이렉트</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="nx">config</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">authorization_url</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 백엔드로 구글 ID 토큰 전달</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">processGoogleNativeLogin</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">googleIdToken</span><span class="p">:</span> <span class="kr">string</span>
<span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">OAuthLoginResponse</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">getApiUrl</span><span class="p">()}</span><span class="s2">/v1/auth/oauth/google/native`</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span> <span class="p">},</span>
    <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
      <span class="na">google_id_token</span><span class="p">:</span> <span class="nx">googleIdToken</span><span class="p">,</span>
      <span class="na">device_info</span><span class="p">:</span> <span class="s2">`</span><span class="p">${</span><span class="nb">navigator</span><span class="p">.</span><span class="nx">platform</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nb">navigator</span><span class="p">.</span><span class="nx">userAgent</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
    <span class="p">}),</span>
    <span class="na">credentials</span><span class="p">:</span> <span class="dl">"</span><span class="s2">include</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="26-웹-설정-선택">2.6 웹 설정 (선택)</h3>

<p><code class="language-plaintext highlighter-rouge">index.html</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;meta</span>
  <span class="na">name=</span><span class="s">"google-signin-client_id"</span>
  <span class="na">content=</span><span class="s">"YOUR_WEB_CLIENT_ID.apps.googleusercontent.com"</span>
<span class="nt">/&gt;</span>
</code></pre></div></div>

<hr />

<h2 id="3-백엔드-api-엔드포인트">3. 백엔드 API 엔드포인트</h2>

<h3 id="31-카카오-네이티브-로그인">3.1 카카오 네이티브 로그인</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /v1/auth/oauth/kakao/native
Content-Type: application/json

{
  "kakao_access_token": "카카오_액세스_토큰",
  "device_info": "플랫폼 정보"
}
</code></pre></div></div>

<h3 id="32-구글-네이티브-로그인">3.2 구글 네이티브 로그인</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /v1/auth/oauth/google/native
Content-Type: application/json

{
  "google_id_token": "구글_ID_토큰",
  "device_info": "플랫폼 정보"
}
</code></pre></div></div>

<hr />

<h2 id="4-체크리스트">4. 체크리스트</h2>

<h3 id="카카오-로그인">카카오 로그인</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><code class="language-plaintext highlighter-rouge">capacitor-kakao-login-plugin</code> 설치</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: Kakao SDK 의존성 추가</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code> 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">strings.xml</code>에 앱 키 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">MainActivity.java</code>에서 SDK 초기화</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />iOS: <code class="language-plaintext highlighter-rouge">Info.plist</code> 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />iOS: <code class="language-plaintext highlighter-rouge">AppDelegate.swift</code>에서 SDK 초기화</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />카카오 개발자 콘솔에 키 해시 등록</li>
</ul>

<h3 id="구글-로그인">구글 로그인</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><code class="language-plaintext highlighter-rouge">@codetrix-studio/capacitor-google-auth</code> 설치</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Google Console에 웹 클라이언트 ID 생성</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Google Console에 Android 클라이언트 ID 생성 (SHA-1 지문 등록)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Google Console에 iOS 클라이언트 ID 생성 (선택)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">strings.xml</code>에 웹 클라이언트 ID 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">capacitor.config.ts</code> 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />iOS: <code class="language-plaintext highlighter-rouge">GoogleService.plist</code> 추가</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />iOS: <code class="language-plaintext highlighter-rouge">Info.plist</code>에 <code class="language-plaintext highlighter-rouge">REVERSED_CLIENT_ID</code> 추가</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />웹: <code class="language-plaintext highlighter-rouge">index.html</code>에 meta tag 추가</li>
</ul>

<hr />

<h2 id="5-참고-자료">5. 참고 자료</h2>

<ul>
  <li><a href="https://capacitorjs.com/docs">Capacitor 공식 문서</a></li>
  <li><a href="https://developers.kakao.com/docs/latest/ko/flutter/getting-started#project-scheme">Kakao developer</a></li>
  <li><a href="https://github.com/nerdFrenzs/capacitor-kakao-login-plugin">capacitor-kakao-login-plugin</a></li>
  <li><a href="https://github.com/CodetrixStudio/CapacitorGoogleAuth">@codetrix-studio/capacitor-google-auth</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 Android 앱에서 카카오/구글 네이티브 로그인을 구현한 방법에 대해 정리해보았습니다.]]></summary></entry></feed>