<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-07-23T07:15:27+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[Etc] FastAPI vs Flask: Python 백엔드 프레임워크 비교</title><link href="https://nan0silver.github.io/miscellaneous/til/2025-07-20-flask-fastAPI/" rel="alternate" type="text/html" title="[Etc] FastAPI vs Flask: Python 백엔드 프레임워크 비교" /><published>2025-07-20T00:00:00+00:00</published><updated>2025-07-23T16:30:00+00:00</updated><id>https://nan0silver.github.io/miscellaneous/til/flask-fastAPI</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/til/2025-07-20-flask-fastAPI/"><![CDATA[<ul>
  <li><a href="#-새롭게-배운-것">새롭게 배운 것</a></li>
  <li><a href="#-오늘의-문제-상황--해결-과정">오늘의 문제 상황 &amp; 해결 과정</a></li>
  <li><a href="#-pydantic이란">Pydantic이란?</a></li>
  <li><a href="#-spring-boot-dto와-pydantic의-비교">Spring Boot DTO와 Pydantic의 비교</a></li>
  <li><a href="#-느낀-점">느낀 점</a></li>
</ul>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<ul>
  <li>Python 백엔드 프레임워크인 <strong>FastAPI</strong>와 <strong>Flask</strong>를 비교해보았다.</li>
  <li>두 프레임워크 모두 경량 웹 서버를 빠르게 개발할 수 있도록 도와주지만, 철학과 기능 면에서 차이가 존재한다.</li>
  <li>주요 비교 항목: 비동기 처리, 타입 힌트 지원, 성능, 문서 자동화, 커뮤니티 및 생태계 등</li>
</ul>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th><strong>FastAPI</strong></th>
      <th><strong>Flask</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>출시 연도</strong></td>
      <td>2018</td>
      <td>2010</td>
    </tr>
    <tr>
      <td><strong>비동기 지원</strong></td>
      <td><code class="language-plaintext highlighter-rouge">async/await</code> 기반 비동기 처리 완전 지원</td>
      <td>기본은 동기, 비동기 처리는 별도 패키지 필요</td>
    </tr>
    <tr>
      <td><strong>타입 힌트</strong></td>
      <td>필수적으로 사용하며, 자동 문서화 및 검증에 활용</td>
      <td>선택적 사용, 검증은 외부 라이브러리 의존</td>
    </tr>
    <tr>
      <td><strong>문서 자동화</strong></td>
      <td>Swagger UI 및 Redoc 자동 생성</td>
      <td>기본 제공 없음 (Flasgger 등으로 보완)</td>
    </tr>
    <tr>
      <td><strong>성능</strong></td>
      <td>매우 빠름 (Starlette 기반, Uvicorn 활용)</td>
      <td>상대적으로 느림</td>
    </tr>
    <tr>
      <td><strong>러닝 커브</strong></td>
      <td>초기 진입 장벽이 다소 높음 (타입, Pydantic 등)</td>
      <td>매우 쉬운 진입, 학습 곡선 완만</td>
    </tr>
    <tr>
      <td><strong>커뮤니티</strong></td>
      <td>빠르게 성장 중</td>
      <td>매우 크고 안정적인 생태계</td>
    </tr>
    <tr>
      <td><strong>데이터 검증</strong></td>
      <td>Pydantic 기반의 자동 검증</td>
      <td>별도 유효성 검사 코드 필요</td>
    </tr>
    <tr>
      <td><strong>REST API 개발</strong></td>
      <td>RESTful 설계에 최적화</td>
      <td>자유도가 높음, 규칙이 느슨함</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-오늘의-문제-상황--해결-과정">🍎 오늘의 문제 상황 &amp; 해결 과정</h2>

<ul>
  <li>지금까지는 Flask의 간결함과 진입 장벽이 낮은 점이 마음에 들어 주로 Flask를 사용해왔다.</li>
  <li>하지만 이번에는 FastAPI를 직접 적용해보고 싶어 새 프로젝트에 도입해보았다.</li>
  <li>특히 <code class="language-plaintext highlighter-rouge">Pydantic</code> 모델이 처음엔 어렵게 느껴질까 걱정했지만, 막상 사용해보니 <strong>Spring Boot의 DTO와 매우 유사한 느낌</strong>이 들어 빠르게 익숙해졌다.</li>
  <li>타입 기반 구조와 자동 검증, 문서화 덕분에 프로젝트가 자연스럽게 구조화되고 개발 속도도 빨랐다.</li>
</ul>

<hr />

<h2 id="-pydantic이란">📌 Pydantic이란?</h2>

<ul>
  <li><strong>Pydantic</strong>은 FastAPI에서 입력/출력 데이터의 구조를 정의하고, 유효성을 검사하며, JSON 직렬화를 자동으로 처리하는 핵심 컴포넌트다.</li>
  <li>Python의 <strong>타입 힌트(type hint)</strong>를 기반으로 동작하며, <code class="language-plaintext highlighter-rouge">BaseModel</code>을 상속하여 필드와 제약 조건을 선언할 수 있다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(...,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">age</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">email</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div></div>

<ul>
  <li>위와 같이 작성하면, FastAPI는 요청 데이터가 이 조건을 만족하는지 자동으로 검증하고, Swagger 문서까지 자동 생성해준다.</li>
</ul>

<hr />

<h2 id="-spring-boot-dto와-pydantic의-비교">🔍 Spring Boot DTO와 Pydantic의 비교</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Spring Boot DTO</th>
      <th>FastAPI Pydantic Model</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>역할</strong></td>
      <td>요청/응답 객체 정의 + 유효성 검사</td>
      <td>요청/응답 객체 정의 + 유효성 검사</td>
    </tr>
    <tr>
      <td><strong>유효성 검사 도구</strong></td>
      <td>JSR 380 (e.g., <code class="language-plaintext highlighter-rouge">@NotNull</code>, <code class="language-plaintext highlighter-rouge">@Size</code>)</td>
      <td>Pydantic (<code class="language-plaintext highlighter-rouge">Field</code>, <code class="language-plaintext highlighter-rouge">validator</code>)</td>
    </tr>
    <tr>
      <td><strong>직렬화/역직렬화</strong></td>
      <td>Jackson 사용</td>
      <td>내장 기능으로 자동 처리</td>
    </tr>
    <tr>
      <td><strong>중첩 구조 지원</strong></td>
      <td>중첩 DTO 클래스</td>
      <td>중첩 <code class="language-plaintext highlighter-rouge">BaseModel</code>을 통한 자연스러운 처리</td>
    </tr>
    <tr>
      <td><strong>문서화 연동</strong></td>
      <td>Swagger/OpenAPI 설정 필요</td>
      <td>FastAPI에 자동 내장</td>
    </tr>
    <tr>
      <td><strong>확장성</strong></td>
      <td>Bean Validation 위주</td>
      <td>타입 변환, 커스텀 직렬화 등 더 다양한 기능 내장</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>결론적으로 <strong>Pydantic은 Spring의 DTO와 유사한 사용 경험을 제공하면서도</strong>, 그 이상의 기능(데이터 직렬화, 문서화, 타입 변환 등)을 하나의 모델에서 처리할 수 있다는 점에서 <strong>DTO + Validator + Mapper + Serializer의 통합체</strong>로 볼 수 있다.</p>
</blockquote>

<hr />

<h2 id="-느낀-점">🦄 느낀 점</h2>

<ul>
  <li>Flask는 여전히 빠른 개발과 간단한 구조를 원할 때 유용한 선택지다.</li>
  <li>반면 FastAPI는 프로젝트 구조를 더 명확히 하고, 자동화된 유효성 검사 및 문서화 기능까지 갖추고 있어 <strong>중·대형 규모 프로젝트나 협업 시에 훨씬 효율적</strong>이라는 점을 느꼈다.</li>
  <li>개인적으로는 Pydantic이 예상보다 익숙했고, Spring Boot의 DTO를 써본 경험이 FastAPI 적응에 큰 도움이 되었다.</li>
  <li>앞으로는 프로젝트의 성격에 따라 Flask와 FastAPI를 유연하게 선택하며, 각 도구의 장점을 상황에 맞게 활용할 계획이다.</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><category term="til" /><category term="TIL" /><category term="FastAPI" /><category term="Flask" /><category term="Backend" /><summary type="html"><![CDATA[2025-07-20 FastAPI vs Flask]]></summary></entry><entry><title type="html">[TIL] Jenkins vs GitHub Actions, IaaS vs PaaS vs SaaS</title><link href="https://nan0silver.github.io/til/2025-05-27-til/" rel="alternate" type="text/html" title="[TIL] Jenkins vs GitHub Actions, IaaS vs PaaS vs SaaS" /><published>2025-05-27T00:00:00+00:00</published><updated>2025-05-28T00:36:49+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-27-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/62">#62</a><br />
📅 <strong>작성일</strong>: 2025-05-27<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 28일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<ul>
  <li>AI Tech 2025 : AI 융합 비즈니스 개발 컨퍼런스 후기 작성 완료!
    <ul>
      <li><a href="https://silvernh.tistory.com/3">Tistory</a></li>
    </ul>
  </li>
</ul>

<h3 id="1️⃣-jenkins-vs-github-actions">1️⃣ <strong>Jenkins vs GitHub Actions</strong></h3>

<p>둘 다 **CI/CD(지속적 통합/지속적 배포)**를 자동화하는 도구다.
개발자가 코드를 push하면 <strong>자동으로 빌드하고, 테스트하고, 배포</strong>까지 해주는 파이프라인 역할.</p>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Jenkins</th>
      <th>GitHub Actions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>배포 방식</td>
      <td>직접 서버에 설치 (온프레미스, 클라우드)</td>
      <td>GitHub 내장 서비스 (클라우드 기반)</td>
    </tr>
    <tr>
      <td>파이프라인 구성</td>
      <td>Groovy 기반 DSL (Jenkinsfile)</td>
      <td>YAML 기반 설정 (.github/workflows/)</td>
    </tr>
    <tr>
      <td>UI/플러그인</td>
      <td>수많은 플러그인과 커스터마이징 가능</td>
      <td>GitHub 생태계에 최적화된 워크플로우</td>
    </tr>
    <tr>
      <td>설정 난이도</td>
      <td>다소 복잡 (서버 관리 필요)</td>
      <td>상대적으로 간단하고 빠른 적용 가능</td>
    </tr>
    <tr>
      <td>장점</td>
      <td>유연한 환경 설정, 다양한 툴 연동 가능</td>
      <td>GitHub와 완벽하게 통합, 설정이 간단</td>
    </tr>
    <tr>
      <td>단점</td>
      <td>서버 유지보수 필요, 러닝커브 있음</td>
      <td>GitHub 내에서만 동작 (GitLab, Bitbucket X)</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>✅ GitHub Actions는 빠르게 CI/CD를 도입하고 싶은 팀에 좋고,
✅ Jenkins는 복잡한 환경이나 내부망에서의 CI/CD가 필요할 때 적합하다.</p>
</blockquote>

<p>—å</p>

<h3 id="-간단-예시--github-actions">🧪 간단 예시 – GitHub Actions</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># .github/workflows/deploy.yml</span>
<span class="na">name</span><span class="pi">:</span> <span class="s">Build and Deploy</span>

<span class="na">on</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">push</span><span class="pi">]</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>
      <span class="pi">-</span> <span class="na">run</span><span class="pi">:</span> <span class="s">./gradlew build</span>
</code></pre></div></div>

<hr />

<h3 id="2️⃣-iaas-vs-paas-vs-saas">2️⃣ <strong>IaaS vs PaaS vs SaaS</strong></h3>

<p>클라우드 서비스 모델을 구분할 때 자주 등장하는 세 가지 개념.
“내가 어디까지 책임지고, 어디서부터는 제공자가 해주는가?”가 핵심.</p>

<h4 id="-개념-요약">✅ 개념 요약</h4>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>설명</th>
      <th>예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>IaaS (Infrastructure as a Service)</td>
      <td>인프라만 제공받고, OS부터 직접 설치</td>
      <td>AWS EC2, Google Compute Engine</td>
    </tr>
    <tr>
      <td>PaaS (Platform as a Service)</td>
      <td>실행 환경까지 제공, 앱 코드만 올리면 됨</td>
      <td>Heroku, Google App Engine, Render</td>
    </tr>
    <tr>
      <td>SaaS (Software as a Service)</td>
      <td>소프트웨어 완제품 사용</td>
      <td>Gmail, Notion, Slack</td>
    </tr>
  </tbody>
</table>

<h4 id="-비교-예시">✅ 비교 예시</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>IaaS</th>
      <th>PaaS</th>
      <th>SaaS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>서버 관리</td>
      <td>내가 함</td>
      <td>클라우드가 함</td>
      <td>필요 없음</td>
    </tr>
    <tr>
      <td>개발 유연성</td>
      <td>높음</td>
      <td>중간</td>
      <td>거의 없음</td>
    </tr>
    <tr>
      <td>배포 편의성</td>
      <td>낮음 (직접 설정)</td>
      <td>높음 (코드만 배포)</td>
      <td>매우 높음 (사용만 하면 됨)</td>
    </tr>
    <tr>
      <td>대상 사용자</td>
      <td>인프라 엔지니어, DevOps</td>
      <td>백엔드 개발자</td>
      <td>일반 사용자, 마케터 등</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-요약-정리">🧠 요약 정리</h3>

<table>
  <thead>
    <tr>
      <th>질문</th>
      <th>답변</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Jenkins랑 GitHub Actions 중 뭐가 더 쉽지?</td>
      <td>GitHub Actions! 설정이 YAML이고 GitHub랑 연동이 편함</td>
    </tr>
    <tr>
      <td>IaaS는 언제 써야 해?</td>
      <td>서버에 대해 완전히 커스터마이징이 필요할 때</td>
    </tr>
    <tr>
      <td>SaaS는 어떤 거야?</td>
      <td>구글 드라이브, 노션, 슬랙처럼 바로 쓰는 서비스</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>오늘의 핵심:
✅ CI/CD 도구는 “내가 코드를 어떻게 자동화할지”에 따라 고르고,
✅ 클라우드 서비스 모델은 “어디까지 직접 관리할지”에 따라 고른다.</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><category term="Git" /><category term="DevOps" /><category term="Cloud" /><summary type="html"><![CDATA[2025-05-27 TIL]]></summary></entry><entry><title type="html">[TIL] Nginx, 리버스 프록시, 로드 밸런서</title><link href="https://nan0silver.github.io/til/2025-05-24-til/" rel="alternate" type="text/html" title="[TIL] Nginx, 리버스 프록시, 로드 밸런서" /><published>2025-05-24T00:00:00+00:00</published><updated>2025-05-27T05:35:43+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-24-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/61">#61</a><br />
📅 <strong>작성일</strong>: 2025-05-24<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-nginx란">1️⃣ <strong>Nginx란?</strong></h3>

<ul>
  <li>**Nginx(엔진엑스)**는 고성능 웹 서버 소프트웨어다.</li>
  <li>원래는 정적 콘텐츠 제공을 위한 웹 서버였지만, 현재는 <strong>리버스 프록시</strong>, <strong>로드 밸런서</strong>, <strong>API Gateway</strong>, <strong>캐시 서버</strong> 등 다용도로 활용된다.</li>
</ul>

<hr />

<h3 id="-nginx의-주요-기능">✅ Nginx의 주요 기능</h3>

<table>
  <thead>
    <tr>
      <th>기능</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>웹 서버</td>
      <td>HTML, CSS, JS 같은 <strong>정적 파일 제공</strong></td>
    </tr>
    <tr>
      <td>리버스 프록시</td>
      <td>클라이언트 요청을 <strong>내부 서버에 전달</strong></td>
    </tr>
    <tr>
      <td>로드 밸런서</td>
      <td>여러 서버에 트래픽을 <strong>분산</strong>하여 처리</td>
    </tr>
    <tr>
      <td>캐시 서버</td>
      <td>응답을 <strong>캐싱</strong>해 성능 향상</td>
    </tr>
    <tr>
      <td>SSL 종단 처리</td>
      <td>HTTPS 인증서 처리 (Let’s Encrypt 등과 연동)</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-리버스-프록시란">🔄 리버스 프록시란?</h3>

<ul>
  <li>클라이언트는 Nginx에 요청을 보내고, Nginx는 **백엔드 서버(Apache, Spring, Node 등)**에 요청을 전달한 후 응답을 다시 클라이언트에 전송한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Client] → [Nginx] → [Spring Server]
</code></pre></div></div>

<ul>
  <li>보안, 로드 밸런싱, 서버 분리 등 다양한 이유로 활용됨</li>
</ul>

<hr />

<h3 id="️-로드-밸런서">⚖️ 로드 밸런서</h3>

<ul>
  <li>요청을 <strong>여러 서버에 고르게 분산</strong>시켜 트래픽 집중을 막고 <strong>가용성</strong>을 높임</li>
</ul>

<h4 id="nginx에서-로드-밸런싱-구성-예시">Nginx에서 로드 밸런싱 구성 예시:</h4>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">upstream</span> <span class="s">backend</span> <span class="p">{</span>
    <span class="kn">server</span> <span class="s">backend1.example.com</span><span class="p">;</span>
    <span class="kn">server</span> <span class="s">backend2.example.com</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://backend</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">upstream</code> 블록을 통해 백엔드 서버를 그룹핑하고, Nginx가 자동으로 라운드로빈 방식으로 분산 처리</p>
</blockquote>

<hr />

<h3 id="-정적-파일-서버로의-활용">📦 정적 파일 서버로의 활용</h3>

<ul>
  <li>HTML/CSS/JS 파일을 빠르게 서빙할 수 있음</li>
  <li>WAS(Spring, Node 등)에서 정적 리소스를 분리하면 서버 부하를 줄일 수 있음</li>
</ul>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">root</span> <span class="n">/usr/share/nginx/html</span><span class="p">;</span>
        <span class="kn">index</span> <span class="s">index.html</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="-https-설정">🔒 HTTPS 설정</h3>

<ul>
  <li>Let’s Encrypt와 Certbot을 이용해 무료 SSL 인증서 발급 가능</li>
  <li>HTTPS로 종단 보안(SSL Termination)을 적용하여 <strong>보안 강화</strong></li>
</ul>

<hr />

<h2 id="-함께-알아두면-좋은-심화-키워드">🧠 함께 알아두면 좋은 심화 키워드</h2>

<table>
  <thead>
    <tr>
      <th>키워드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>리버스 프록시</td>
      <td>Nginx가 중간에 서서 내부 서버 대신 요청 응답 처리</td>
    </tr>
    <tr>
      <td>포워드 프록시</td>
      <td>사용자의 요청을 <strong>외부로 보낼 때</strong> 중개하는 프록시</td>
    </tr>
    <tr>
      <td>CDN (Content Delivery Network)</td>
      <td>정적 리소스를 전 세계에 분산 저장하여 빠르게 전송</td>
    </tr>
    <tr>
      <td>캐싱 정책</td>
      <td><code class="language-plaintext highlighter-rouge">Cache-Control</code>, <code class="language-plaintext highlighter-rouge">ETag</code>를 이용한 정적 자원 캐싱</td>
    </tr>
    <tr>
      <td>Blue-Green Deployment</td>
      <td>Nginx로 배포 서버를 스위칭하여 무중단 배포 실현</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="️-오늘의-요약">✍️ 오늘의 요약</h2>

<ul>
  <li>Nginx는 단순 웹 서버 그 이상으로, <strong>프론트와 백엔드 사이의 허브 역할</strong>을 한다.</li>
  <li>리버스 프록시, 로드 밸런서, 정적 파일 서버, SSL 처리까지 담당할 수 있는 멀티플레이어</li>
  <li>실제 운영 환경에서는 <strong>Spring Boot와 Nginx 연동</strong>, <strong>HTTPS 적용</strong>, <strong>EC2 배포 시 로드밸런싱 구성</strong> 등을 할 수 있도록 익숙해져야 한다</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-24 TIL]]></summary></entry><entry><title type="html">[TIL] Grafana &amp;amp; Prometheus, Rolling Policy, 시계열 메트릭</title><link href="https://nan0silver.github.io/til/2025-05-23-til/" rel="alternate" type="text/html" title="[TIL] Grafana &amp;amp; Prometheus, Rolling Policy, 시계열 메트릭" /><published>2025-05-23T00:00:00+00:00</published><updated>2025-05-27T05:34:31+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-23-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/60">#60</a><br />
📅 <strong>작성일</strong>: 2025-05-23<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-grafana--prometheus--시계열-메트릭-시각화-도구">1️⃣ <strong>Grafana &amp; Prometheus – 시계열 메트릭 시각화 도구</strong></h3>

<h4 id="-prometheus">📊 Prometheus</h4>

<ul>
  <li>CNCF(Cloud Native Computing Foundation)에서 관리하는 <strong>시계열 메트릭 수집 도구</strong></li>
  <li>주로 <strong>인프라/애플리케이션 성능 모니터링</strong>에 사용됨</li>
  <li><strong>Pull 방식</strong>으로 타겟 서버의 메트릭을 주기적으로 수집함</li>
  <li>메트릭 쿼리 언어: <strong>PromQL</strong></li>
  <li>내장된 시계열 DB에 메트릭 저장</li>
</ul>

<blockquote>
  <p>예시 메트릭:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http_requests_total{method="GET", status="200"} 1523
cpu_usage_seconds_total{core="1"} 82.3
</code></pre></div></div>

<h4 id="-grafana">📈 Grafana</h4>

<ul>
  <li><strong>Prometheus 등의 시계열 데이터 소스를 시각화하는 대시보드 도구</strong></li>
  <li>사용자가 커스터마이징 가능한 <strong>대시보드/그래프/알람</strong>을 만들 수 있음</li>
  <li>Prometheus 외에도 <strong>Loki(로그), InfluxDB, MySQL, Elasticsearch 등 다양한 소스</strong>와 연동 가능</li>
  <li>
    <p>주요 사용 예:</p>

    <ul>
      <li>CPU/메모리/디스크 사용률 실시간 모니터링</li>
      <li>서비스 요청 응답 시간 추적</li>
      <li>메트릭 기반 알림 설정 (ex. 5분간 에러율이 5% 넘으면 슬랙 알림)</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="-grafana--prometheus--devops-핵심-콤보">🧩 Grafana + Prometheus = DevOps 핵심 콤보</h3>

<table>
  <thead>
    <tr>
      <th>도구</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Prometheus</td>
      <td>메트릭 수집 및 저장</td>
    </tr>
    <tr>
      <td>Grafana</td>
      <td>메트릭 시각화 및 알람</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>두 도구는 함께 사용할 때 진가를 발휘한다.
Prometheus가 메트릭 데이터를 모으고, Grafana가 이를 시각적으로 표현해준다.</p>
</blockquote>

<hr />

<h3 id="2️⃣-rolling-policy-로그-롤링-정책">2️⃣ <strong>Rolling Policy (로그 롤링 정책)</strong></h3>

<h4 id="-개념">🧾 개념</h4>

<ul>
  <li>로그 파일이 커지거나 오래되었을 때, <strong>자동으로 새로운 파일로 교체하거나 백업</strong>하는 정책</li>
  <li>로그 관리를 자동화해서 디스크 과부하를 방지하고, 오래된 로그를 보관하거나 삭제할 수 있게 해줌</li>
</ul>

<h4 id="-적용-예--logback-springxml-예시">📁 적용 예 – <code class="language-plaintext highlighter-rouge">logback-spring.xml</code> 예시:</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;rollingPolicy</span> <span class="na">class=</span><span class="s">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;fileNamePattern&gt;</span>logs/app-%d{yyyy-MM-dd}.log<span class="nt">&lt;/fileNamePattern&gt;</span>
    <span class="nt">&lt;maxHistory&gt;</span>30<span class="nt">&lt;/maxHistory&gt;</span> <span class="c">&lt;!-- 30일간 보관 --&gt;</span>
<span class="nt">&lt;/rollingPolicy&gt;</span>
</code></pre></div></div>

<h4 id="️-주요-타입">🎛️ 주요 타입</h4>

<table>
  <thead>
    <tr>
      <th>정책 유형</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TimeBasedRollingPolicy</td>
      <td>날짜별로 로그 파일 분리 (<code class="language-plaintext highlighter-rouge">app-2025-05-14.log</code>)</td>
    </tr>
    <tr>
      <td>SizeBasedTriggeringPolicy</td>
      <td>특정 크기 초과 시 새로운 파일 생성 (<code class="language-plaintext highlighter-rouge">app.log.1</code>, <code class="language-plaintext highlighter-rouge">.2</code>…)</td>
    </tr>
    <tr>
      <td>FixedWindowRollingPolicy</td>
      <td>번호 기반 순환 롤링 (<code class="language-plaintext highlighter-rouge">app.1.log</code>, <code class="language-plaintext highlighter-rouge">app.2.log</code>)</td>
    </tr>
  </tbody>
</table>

<h4 id="-왜-중요한가">🚧 왜 중요한가?</h4>

<ul>
  <li>로그 파일이 무한히 커지지 않도록 제어</li>
  <li>백업 및 운영에 필요한 로그만 유지 가능</li>
  <li>ELK/EFK 스택과 연동할 때도 파일 기반 로그를 안정적으로 관리</li>
</ul>

<blockquote>
  <p>정리하자면, **“로그를 무한정 쌓지 말고, 잘라서 보관하고, 오래된 건 지우자!”**는 개념이다.</p>
</blockquote>

<hr />

<h3 id="-오늘의-요약">📌 오늘의 요약</h3>

<table>
  <thead>
    <tr>
      <th>개념</th>
      <th>핵심 기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Prometheus</td>
      <td>메트릭 수집 및 저장 (시계열 DB)</td>
    </tr>
    <tr>
      <td>Grafana</td>
      <td>메트릭 시각화 및 알림</td>
    </tr>
    <tr>
      <td>Rolling Policy</td>
      <td>로그 용량/시간 기준 자동 분할 및 관리</td>
    </tr>
  </tbody>
</table>

<h3 id="3️⃣--시계열-메트릭time-series-metrics이란">3️⃣ 🕐 시계열 메트릭(Time Series Metrics)이란?</h3>

<ul>
  <li><strong>시간(Time)</strong> + <strong>값(Value)</strong> 이 쌍으로 구성된 데이터</li>
  <li>특정 지표가 <strong>시간에 따라 어떻게 변하는지</strong>를 보여줌</li>
</ul>

<h4 id="-예시">📊 예시:</h4>

<table>
  <thead>
    <tr>
      <th>시간</th>
      <th>CPU 사용률 (%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2025-05-14 10:00:00</td>
      <td>30</td>
    </tr>
    <tr>
      <td>2025-05-14 10:01:00</td>
      <td>35</td>
    </tr>
    <tr>
      <td>2025-05-14 10:02:00</td>
      <td>70</td>
    </tr>
  </tbody>
</table>

<p>이처럼 “시간에 따른 수치 변화”를 기록한 데이터가 바로 <strong>시계열 메트릭</strong></p>

<hr />

<h4 id="-시계열-메트릭-수집-도구란">📦 시계열 메트릭 수집 도구란?</h4>

<blockquote>
  <p>이런 <strong>시간 기반 데이터</strong>를 <strong>자동으로 수집, 저장, 관리</strong>해주는 도구를 말합니다.</p>
</blockquote>

<ul>
  <li>대표적인 도구:
    <ul>
      <li><strong>Prometheus</strong></li>
      <li>InfluxDB</li>
      <li>Graphite</li>
      <li>OpenTSDB</li>
    </ul>
  </li>
</ul>

<p>이들은 서버나 애플리케이션에서 CPU, 메모리, 요청 수, 에러율 같은 수치를 <strong>주기적으로 수집</strong>해서 시계열 DB에 저장한다.</p>

<h4 id="️-예를-들어-prometheus는">🛠️ 예를 들어 Prometheus는?</h4>

<ul>
  <li>15초마다 모든 서버의 CPU 사용률, HTTP 요청 수 등을 수집</li>
  <li>내부에 <strong>시계열 전용 데이터베이스</strong>를 가지고 있어 시간 순서대로 저장</li>
  <li>나중에 Grafana 같은 도구로 꺾은선 그래프를 그릴 수 있음</li>
</ul>

<h4 id="-정리">📌 정리</h4>

<table>
  <thead>
    <tr>
      <th>용어</th>
      <th>의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>시계열 데이터</td>
      <td>시간에 따라 변화하는 수치 데이터 (예: CPU 70% → 50%)</td>
    </tr>
    <tr>
      <td>시계열 메트릭 도구</td>
      <td>시간 기반 데이터를 주기적으로 수집/저장하는 시스템</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>시계열 메트릭 도구는 결국 **“시간의 흐름에 따라 시스템이 어떻게 작동하고 있는지 보여주는 도구”**</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-23 TIL]]></summary></entry><entry><title type="html">[TIL] 메테리얼 디자인 vs 쿠퍼티노 디자인, Log vs Metrics, Structure…</title><link href="https://nan0silver.github.io/til/2025-05-22-til/" rel="alternate" type="text/html" title="[TIL] 메테리얼 디자인 vs 쿠퍼티노 디자인, Log vs Metrics, Structure…" /><published>2025-05-22T00:00:00+00:00</published><updated>2025-05-27T03:54:57+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-22-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/59">#59</a><br />
📅 <strong>작성일</strong>: 2025-05-22<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-메테리얼-디자인material-design-vs-쿠퍼티노-디자인cupertino-design">1️⃣ <strong>메테리얼 디자인(Material Design) vs 쿠퍼티노 디자인(Cupertino Design)</strong></h3>

<h4 id="-메테리얼-디자인-material-design">🎨 메테리얼 디자인 (Material Design)</h4>

<ul>
  <li>Google에서 만든 디자인 시스템</li>
  <li>Android 앱에서 기본적으로 사용되는 UI 가이드라인</li>
  <li>
    <p>특징:</p>

    <ul>
      <li>실제 종이처럼 동작하는 “표면” 개념 → <strong>레이어, 그림자, 깊이감</strong></li>
      <li><strong>굵은 색상, 명확한 애니메이션, 카드 UI</strong></li>
      <li>일관된 컴포넌트 구조 (Button, Dialog 등)</li>
      <li>다양한 화면 크기 및 접근성 고려가 잘 되어 있음</li>
    </ul>
  </li>
</ul>

<h4 id="-쿠퍼티노-디자인-cupertino-design">🍏 쿠퍼티노 디자인 (Cupertino Design)</h4>

<ul>
  <li>Apple이 만든 iOS용 디자인 철학</li>
  <li>Flutter에서는 <code class="language-plaintext highlighter-rouge">CupertinoWidget</code>으로 구현</li>
  <li>
    <p>특징:</p>

    <ul>
      <li><strong>심플하고 정갈한 UI</strong>, 얇은 폰트, 미니멀한 구성</li>
      <li>iOS의 네이티브한 느낌을 충실히 재현</li>
      <li>스크롤, 네비게이션, 토글 스위치 등에서 iOS 특유의 인터랙션 존재</li>
    </ul>
  </li>
</ul>

<h4 id="비교-요약">비교 요약:</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Material Design</th>
      <th>Cupertino Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>주요 플랫폼</td>
      <td>Android, Web, Desktop</td>
      <td>iOS</td>
    </tr>
    <tr>
      <td>디자인 철학</td>
      <td>종이+레이어+애니메이션</td>
      <td>단순함+미려함+일관성</td>
    </tr>
    <tr>
      <td>주요 사용 예</td>
      <td>Google 앱, Android 앱</td>
      <td>Apple 앱, iOS 앱</td>
    </tr>
    <tr>
      <td>Flutter 적용</td>
      <td><code class="language-plaintext highlighter-rouge">MaterialApp</code></td>
      <td><code class="language-plaintext highlighter-rouge">CupertinoApp</code></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>요약: Android 앱은 Material 위주, iOS는 Cupertino 스타일을 따르며, <strong>Flutter는 둘 다 지원</strong>해 플랫폼에 맞는 UI를 쉽게 만들 수 있다!</p>
</blockquote>

<hr />

<h3 id="2️⃣-log-vs-metrics">2️⃣ <strong>Log vs Metrics</strong></h3>

<p>백엔드/운영 환경에서 시스템 상태를 추적할 때 자주 쓰이는 두 가지 개념을 비교해 보았다.</p>

<h4 id="-로그-log">📄 로그 (Log)</h4>

<ul>
  <li>
    <p><strong>시간 순으로 발생한 이벤트 기록</strong></p>
  </li>
  <li>
    <p>보통 텍스트 기반이며, 문제가 발생했을 때 <strong>무슨 일이 있었는지</strong> 파악하는 데 유용</p>
  </li>
  <li>
    <p>예:</p>

    <ul>
      <li>사용자가 로그인에 실패했습니다.</li>
      <li>서버에서 500 에러가 발생했습니다.</li>
    </ul>
  </li>
  <li>
    <p>특징:</p>

    <ul>
      <li>구조화가 느슨함 (JSON 또는 단순 텍스트)</li>
      <li>디버깅, 감사 추적에 용이</li>
      <li><strong>사후 분석</strong>에 효과적</li>
      <li>저장 공간 많이 차지할 수 있음</li>
    </ul>
  </li>
  <li>
    <p>예시:</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2025-05-13T12:45:00"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"level"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ERROR"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Login failed for user ID 123"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<h4 id="-메트릭-metrics">📊 메트릭 (Metrics)</h4>

<ul>
  <li>
    <p><strong>수치로 측정 가능한 시스템의 상태</strong></p>
  </li>
  <li>
    <p>시간에 따라 변화하는 수치 → CPU 사용량, 요청 수, 응답 시간 등</p>
  </li>
  <li>
    <p>예:</p>

    <ul>
      <li>서버 응답 시간 평균 120ms</li>
      <li>현재 접속 사용자 수 300명</li>
    </ul>
  </li>
  <li>
    <p>특징:</p>

    <ul>
      <li>구조화된 데이터</li>
      <li>시각화 및 대시보드 구성에 유리</li>
      <li>알림(경고) 설정에 적합</li>
      <li>보통 <strong>Prometheus</strong>, <strong>Grafana</strong>와 같이 사용됨</li>
    </ul>
  </li>
  <li>
    <p>예시:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http_requests_total{method="GET", status="200"} 3456
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="비교-요약-1">비교 요약:</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>로그(Log)</th>
      <th>메트릭(Metrics)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>목적</td>
      <td>이벤트 디버깅, 추적</td>
      <td>상태 모니터링, 성능 추적</td>
    </tr>
    <tr>
      <td>형식</td>
      <td>텍스트 기반, 구조 유동적</td>
      <td>수치 기반, 구조화됨</td>
    </tr>
    <tr>
      <td>저장</td>
      <td>로그 파일, ELK Stack</td>
      <td>시계열 DB (Prometheus 등)</td>
    </tr>
    <tr>
      <td>시각화</td>
      <td>Kibana, Logtail 등</td>
      <td>Grafana 등</td>
    </tr>
    <tr>
      <td>실시간성</td>
      <td>낮음 (분석 중심)</td>
      <td>높음 (모니터링, 알림에 적합)</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>로그는 “<strong>무슨 일이 일어났는가</strong>”를 알려주고,
메트릭은 “<strong>현재 시스템이 어떤 상태인가</strong>”를 알려준다.
둘은 보완 관계로 함께 사용하는 것이 가장 효과적이다!</p>
</blockquote>

<h2 id="3️⃣-structured-logging-구조화된-로그">3️⃣ <strong>Structured Logging (구조화된 로그)</strong></h2>

<h3 id="-개념">✅ 개념</h3>

<ul>
  <li>일반 로그는 텍스트 형식으로 사람이 읽기 쉽게 쓰는 반면,
<strong>Structured Logging</strong>은 로그를 <strong>JSON 같은 구조화된 형태로 기록</strong>하는 방식입니다.</li>
</ul>

<h3 id="-예시-비교">🔍 예시 비교</h3>

<p><strong>❌ 일반 로그 (Unstructured)</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User 1234 failed to login due to wrong password
</code></pre></div></div>

<p><strong>✅ 구조화 로그 (Structured)</strong>:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2025-05-13T10:42:00Z"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"level"</span><span class="p">:</span><span class="w"> </span><span class="s2">"WARN"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"event"</span><span class="p">:</span><span class="w"> </span><span class="s2">"login_failed"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"user_id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1234</span><span class="p">,</span><span class="w">
  </span><span class="nl">"reason"</span><span class="p">:</span><span class="w"> </span><span class="s2">"wrong_password"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="-장점">✨ 장점</h3>

<ul>
  <li>기계가 파싱하기 쉽고, <strong>검색/필터링/집계</strong>에 유리</li>
  <li>로그 수집 도구(예: Elasticsearch, Datadog)와 연동할 때 편함</li>
  <li>실시간 모니터링이나 <strong>경고 시스템</strong>과 연계 가능</li>
</ul>

<blockquote>
  <p>구조화 로그는 결국 “<strong>로그도 데이터다</strong>”라는 관점에서 관리하는 것!</p>
</blockquote>

<hr />

<h2 id="4️⃣-elk-vs-efk-스택">4️⃣ <strong>ELK vs EFK 스택</strong></h2>

<h3 id="-공통-목적">✅ 공통 목적</h3>

<ul>
  <li><strong>분산 로그 수집, 저장, 분석, 시각화</strong>를 위한 스택입니다.</li>
  <li>대규모 시스템에서 수많은 서버 로그를 한 곳으로 모아서 검색·분석하기 위해 사용합니다.</li>
</ul>

<hr />

<h3 id="-elk-stack">🧩 <strong>ELK Stack</strong></h3>

<ul>
  <li><strong>E</strong>lasticsearch: 로그를 저장하고 검색 가능한 DB</li>
  <li><strong>L</strong>ogstash: 로그 수집기. 다양한 소스에서 로그를 받아 필터링/변환</li>
  <li><strong>K</strong>ibana: 시각화 도구 (대시보드, 검색 UI 등)</li>
</ul>

<h4 id="장점">장점</h4>

<ul>
  <li>오래된 구성으로 안정적이고 성숙함</li>
  <li>다양한 입력 소스를 지원 (DB, 파일, MQ 등)</li>
</ul>

<h4 id="단점">단점</h4>

<ul>
  <li>Logstash가 무거움 → <strong>리소스 많이 사용</strong></li>
  <li>설정 복잡함</li>
</ul>

<hr />

<h3 id="-efk-stack">🧩 <strong>EFK Stack</strong></h3>

<ul>
  <li><strong>E</strong>lasticsearch</li>
  <li><strong>F</strong>luentd: 경량 로그 수집기 (Logstash 대체)</li>
  <li><strong>K</strong>ibana</li>
</ul>

<h4 id="장점-1">장점</h4>

<ul>
  <li><strong>Kubernetes 환경에 더 적합</strong></li>
  <li>Fluentd는 가볍고 플러그인으로 유연하게 확장 가능</li>
  <li>최근 클라우드 환경에서 더 많이 사용됨</li>
</ul>

<h4 id="단점-1">단점</h4>

<ul>
  <li>복잡한 변환/파이프라인 처리 시엔 Logstash보다 기능 제한 있음</li>
</ul>

<hr />

<h3 id="비교-요약표">비교 요약표:</h3>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>ELK</th>
      <th>EFK</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>로그 수집기</td>
      <td>Logstash (무거움)</td>
      <td>Fluentd (가볍고 유연함)</td>
    </tr>
    <tr>
      <td>시각화</td>
      <td>Kibana</td>
      <td>Kibana</td>
    </tr>
    <tr>
      <td>주 사용 환경</td>
      <td>온프레미스, 레거시 시스템</td>
      <td>클라우드, Kubernetes</td>
    </tr>
    <tr>
      <td>구성 난이도</td>
      <td>다소 복잡</td>
      <td>상대적으로 단순</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-결론">📌 결론</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>추천</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Kubernetes 기반 마이크로서비스</td>
      <td>✅ <strong>EFK Stack</strong></td>
    </tr>
    <tr>
      <td>다양한 로그 소스와 복잡한 처리 필요</td>
      <td>✅ <strong>ELK Stack</strong></td>
    </tr>
    <tr>
      <td>단순한 파일 로그 수집 및 시각화</td>
      <td>✅ 둘 다 가능, 구조화 로그 필수</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>실제로는 <strong>EFK + Structured Logging</strong> 조합이 요즘 가장 트렌디한 방식입니다.
로그를 JSON 형태로 남기고, Fluentd를 통해 Elasticsearch에 넣은 뒤 Kibana로 시각화하면 아주 강력한 로그 분석 시스템이 됩니다.</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-22 TIL]]></summary></entry><entry><title type="html">[TIL] RPM, 앙상블, 비용, WSL, Windows Subsystem for Linux …</title><link href="https://nan0silver.github.io/til/2025-05-21-til/" rel="alternate" type="text/html" title="[TIL] RPM, 앙상블, 비용, WSL, Windows Subsystem for Linux …" /><published>2025-05-21T00:00:00+00:00</published><updated>2025-05-27T03:53:22+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-21-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/58">#58</a><br />
📅 <strong>작성일</strong>: 2025-05-21<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-rpm-앙상블-비용">1️⃣ <strong>RPM, 앙상블, 비용</strong></h3>

<ul>
  <li>
    <p><strong>RPM (Revolutions Per Minute)</strong></p>

    <ul>
      <li>원래는 하드디스크나 모터 회전 속도를 나타내는 단위지만, **웹/앱 분석에서는 보통 “Revenue Per Mille(천 회당 수익)”**로 사용된다.</li>
      <li>
        <p>광고 업계에서는 광고가 <strong>1,000번 노출될 때 수익이 얼마인지</strong>를 뜻함.</p>

        <ul>
          <li>예: RPM = 5라면, 1,000번 광고 노출 시 수익이 $5</li>
        </ul>
      </li>
      <li>수익성을 평가하는 지표로 자주 사용됨.</li>
    </ul>
  </li>
  <li>
    <p><strong>앙상블 (Ensemble)</strong></p>

    <ul>
      <li>머신러닝에서 여러 모델을 조합해 <strong>예측 정확도를 향상시키는 기법</strong></li>
      <li>
        <p>주요 기법:</p>

        <ul>
          <li><strong>Bagging</strong> (ex. Random Forest)</li>
          <li><strong>Boosting</strong> (ex. XGBoost, LightGBM)</li>
          <li><strong>Stacking</strong> (모델들의 출력값을 다시 모델에 입력)</li>
        </ul>
      </li>
      <li>하나의 모델보다 성능이 좋을 가능성이 높고, 특히 Kaggle 등 실전 대회에서 필수 전략임.</li>
    </ul>
  </li>
  <li>
    <p><strong>비용 (Cost)</strong></p>

    <ul>
      <li>머신러닝에서의 비용은 보통 <strong>오차(error)를 수치화한 값</strong></li>
      <li>
        <p>목표는 이 비용(Cost)을 <strong>최소화하는 모델 파라미터를 찾는 것</strong></p>

        <ul>
          <li>예: 회귀에서는 <strong>MSE (Mean Squared Error)</strong></li>
          <li>분류에서는 <strong>Cross Entropy</strong> 같은 손실 함수 사용</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="2️⃣-wsl-windows-subsystem-for-linux-2">2️⃣ <strong>WSL, Windows Subsystem for Linux 2</strong></h3>

<ul>
  <li>
    <p><strong>WSL (Windows Subsystem for Linux)</strong></p>

    <ul>
      <li>Windows에서 Linux 환경을 사용할 수 있게 해주는 Microsoft의 호환 계층</li>
      <li>
        <p>WSL2는 WSL1과 달리 <strong>실제 Linux 커널을 가상 머신 위에 구동</strong>시킴</p>

        <ul>
          <li>더 빠르고 호환성이 뛰어남 (ex. Docker 사용 가능)</li>
        </ul>
      </li>
      <li>개발자가 <strong>Mac 없이도 Unix/Linux 개발 환경</strong>을 Windows에서 구성할 수 있어 유용함</li>
    </ul>
  </li>
  <li>
    <p><strong>UNIX vs MacOS vs WSL2 vs Tux</strong></p>

    <ul>
      <li><strong>UNIX</strong>: OS 설계 철학/표준, 안정성과 보안성으로 서버 환경에서 많이 사용됨</li>
      <li><strong>MacOS</strong>: BSD 계열의 UNIX 기반 OS → 터미널 환경이 UNIX 명령어와 유사</li>
      <li><strong>WSL2</strong>: 윈도우 안에서 리눅스 환경을 제공해, 리눅스 개발 도구 사용 가능</li>
      <li><strong>Tux</strong>: 리눅스의 공식 마스코트 펭귄 이름 🐧</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>요약: Mac이나 Linux 서버가 없더라도 WSL2를 쓰면 로컬에서 UNIX 개발 환경을 손쉽게 세팅할 수 있다.</p>
</blockquote>

<hr />

<h3 id="3️⃣-phoenix-vs-snowflake">3️⃣ <strong>Phoenix vs Snowflake</strong></h3>

<ul>
  <li>이 두 용어는 <strong>데이터 웨어하우스 시스템</strong> 및 <strong>클라우드 아키텍처</strong> 문맥에서 자주 사용됨.</li>
</ul>

<h4 id="-phoenix-server-불사조-서버">🔥 Phoenix Server (불사조 서버)</h4>

<ul>
  <li>시스템을 중단하지 않고 <strong>점진적으로 설정, 코드, 인프라를 바꾸는 방식</strong></li>
  <li>“죽지 않는 서버”</li>
  <li>실시간으로 코드를 수정하거나, 배포 중에도 유저에게 영향을 주지 않음</li>
  <li>하지만 시간이 지날수록 <strong>기술 부채</strong>가 쌓일 수 있음</li>
</ul>

<h4 id="️-snowflake-server-눈송이-서버">❄️ Snowflake Server (눈송이 서버)</h4>

<ul>
  <li>수작업 설정이 많고, <strong>특정 환경에서만 작동하는 불안정한 서버</strong></li>
  <li>배포마다 설정이 조금씩 달라서, 한번 망가지면 <strong>복원하기 어려움</strong></li>
  <li>
    <p>반의어로 <strong>Immutable Infrastructure</strong> (변경 불가능한 인프라)가 선호됨</p>

    <ul>
      <li>예: 컨테이너 기반 인프라 (Docker + CI/CD)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>요약:</p>

  <ul>
    <li><strong>Phoenix 서버</strong>는 장기적으로 위험이 쌓이고,</li>
    <li><strong>Snowflake 서버</strong>는 설정 의존도가 높아 불안정하며,</li>
    <li>**이 둘을 피하기 위해 IaC(Infrastructure as Code)**와 컨테이너, 배포 자동화를 쓰는 것이 최신 DevOps 흐름이다.</li>
  </ul>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-21 TIL]]></summary></entry><entry><title type="html">[TIL] Ollama</title><link href="https://nan0silver.github.io/til/2025-05-20-til/" rel="alternate" type="text/html" title="[TIL] Ollama" /><published>2025-05-20T00:00:00+00:00</published><updated>2025-05-22T05:33:07+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-20-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/57">#57</a><br />
📅 <strong>작성일</strong>: 2025-05-20<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 22일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<ul>
  <li>
    <p>Ollama</p>

    <ul>
      <li>로컬 머신에서 대규모 언어 모델(LLM)을 실행할 수 있게 해주는 오픈소스 도구</li>
      <li>주요 특징
        <ul>
          <li>로컬 실행: 모든 처리가 로컬에서 이루어져 개인정보 보호가 가능</li>
          <li>다양한 모델 지원: Llama, Mistral, Gemma 등 다양한 오픈소스 모델 지원</li>
          <li>간단한 API: REST API를 통해 쉽게 통합 가능</li>
          <li>CPU/GPU 지원: 다양한 하드웨어에서 실행 가능</li>
          <li>크로스 플랫폼: Windows, macOS, Linux 지원</li>
        </ul>
      </li>
      <li>Ollama 시작하기
        <ol>
          <li>ollama.com에서 OS에 맞는 버전 다운로드 및 설치</li>
          <li>터미널에서 모델 다운로드 (예: ollama pull llama3.2)</li>
          <li>모델 실행 (예: ollama run llama3.2)</li>
        </ol>
      </li>
      <li>
        <p>API 사용 방법</p>

        <ul>
          <li>Ollama는 http://localhost:11434에서 REST API를 제공합니다:</li>
          <li>
            <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># Python 예제
</span>  <span class="kn">import</span> <span class="nn">requests</span>

  <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="s">'http://localhost:11434/api/generate'</span><span class="p">,</span>
      <span class="n">json</span><span class="o">=</span><span class="p">{</span>
          <span class="s">'model'</span><span class="p">:</span> <span class="s">'llama3.2'</span><span class="p">,</span>
          <span class="s">'prompt'</span><span class="p">:</span> <span class="s">'백엔드 개발에 필요한 기술은?'</span><span class="p">,</span>
          <span class="s">'stream'</span><span class="p">:</span> <span class="bp">False</span>
      <span class="p">})</span>

  <span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">json</span><span class="p">()[</span><span class="s">'response'</span><span class="p">])</span>
</code></pre></div>            </div>
          </li>
          <li>
            <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JavaScript 예제</span>
<span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">http://localhost:11434/api/generate</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span> <span class="p">},</span>
  <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
    <span class="na">model</span><span class="p">:</span> <span class="dl">"</span><span class="s2">llama3.2</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">prompt</span><span class="p">:</span> <span class="dl">"</span><span class="s2">백엔드 개발에 필요한 기술은?</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">stream</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="p">}),</span>
<span class="p">})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">response</span><span class="p">));</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-20 TIL]]></summary></entry><entry><title type="html">[컨퍼런스] AI Tech 2025 참석 후기</title><link href="https://nan0silver.github.io/projectdiary/2025-05-15-diary/" rel="alternate" type="text/html" title="[컨퍼런스] AI Tech 2025 참석 후기" /><published>2025-05-15T00:00:00+00:00</published><updated>2025-07-23T07:14:46+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-05-15-diary/"><![CDATA[<ul>
  <li><a href="#1-행사-개요">1. 행사 개요</a></li>
  <li><a href="#2-키노트-요약-embodied-ai와-기술-진화-방향">2. 키노트 요약: Embodied AI와 기술 진화 방향</a></li>
  <li><a href="#3-a2a-시대의-도래-agent-협업-구조">3. A2A 시대의 도래: Agent 협업 구조</a></li>
  <li><a href="#4-ai는-이제-운영의-시대">4. AI는 이제 운영의 시대</a></li>
  <li><a href="#5-실무-적용-사례-및-전략">5. 실무 적용 사례 및 전략</a></li>
  <li><a href="#6-기술-인사이트">6. 기술 인사이트</a></li>
  <li><a href="#7-결론">7. 결론</a></li>
</ul>

<blockquote>
  <p>실무자 중심의 AI 도입 이후 전략, 오케스트레이션 구조, 에이전트 협업 사례 중심</p>
</blockquote>

<hr />

<h2 id="1-행사-개요">1. 행사 개요</h2>

<p><strong>AI Tech 2025</strong>는 단순한 모델 개발이나 비전 소개를 넘어서,<br />
<strong>“AI를 어떻게 현업에 도입하고 운영할 것인가”</strong>를 주제로 구성된 실무 중심의 컨퍼런스였다.<br />
다양한 기업과 기술 리더들이 실제 적용 사례, 인프라 설계, 오케스트레이션 전략을 공유했으며,<br />
AI 도입 이후 단계에서 실질적인 생산성을 확보하기 위한 전략들이 인상 깊었다.</p>

<hr />

<h2 id="2-키노트-요약-embodied-ai와-기술-진화-방향">2. 키노트 요약: Embodied AI와 기술 진화 방향</h2>

<p>서울대 장병탁 교수의 기조연설에서는 <strong>AI의 진화 방향</strong>이 강조되었다.</p>

<ul>
  <li>기존: 디지털 정보 공간 내 추론 중심의 AI</li>
  <li>변화: <strong>실세계와 상호작용하며 학습·판단·행동하는 Embodied AI</strong></li>
</ul>

<blockquote>
  <p>Embodied AI는 물리적 환경을 인식하고 그에 반응할 수 있는 에이전트로, 강화학습 및 체화 학습을 통해 자율성을 확보한다.</p>
</blockquote>

<p><img src="https://github-production-user-asset-6210df.s3.amazonaws.com/82145661/448164887-76d2879b-b852-4e1e-95b9-715a1a9c824a.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250528%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20250528T010443Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=3e1da1f9900847a113d2f60899f7bde3f20244757464ad5a77b3ec544728e0ed&amp;X-Amz-SignedHeaders=host" /><br />
<em>Figure: Embodied AI – 환경 인지, 판단, 행동이 통합된 AI 시스템</em></p>

<hr />

<h2 id="3-a2a-시대의-도래-agent-협업-구조">3. A2A 시대의 도래: Agent 협업 구조</h2>

<h3 id="-a2aagent-to-agent-protocol">🔍 A2A(Agent-to-Agent Protocol)</h3>

<p>이번 행사에서 가장 빈번하게 언급된 개념 중 하나는 <strong>A2A</strong>였다.</p>

<ul>
  <li><strong>의미</strong>: 에이전트 간 데이터 공유 및 협업을 위한 통신 프로토콜</li>
  <li><strong>기능</strong>: 목적 지향형 대화, 작업 분담, 협업형 워크플로우 구성</li>
  <li><strong>사례</strong>: 문서 요약 에이전트 → 일정 정리 에이전트로 결과 전달</li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>요약 에이전트 → 분석 결과 전달 → 일정 에이전트가 회의 제안 자동화
</code></pre></div></div>

<h3 id="-관련-개념">🧩 관련 개념</h3>

<ul>
  <li>
    <p><strong>Agent Hub</strong>: 에이전트 설계/운영 통합 플랫폼</p>

    <ul>
      <li>ADK: Agent Design Kit</li>
      <li>Agent Engine: 배포 및 실행 환경</li>
      <li>Agent Garden: 에이전트 레지스트리/관리</li>
    </ul>
  </li>
</ul>

<p>이와 같은 구조는 기존 **MSA(마이크로서비스 아키텍처)**와 유사하게,
AI 시스템에서도 <strong>다수의 특화 에이전트가 상호작용하는 구조적 전환</strong>을 의미한다.</p>

<hr />

<h2 id="4-ai는-이제-운영의-시대">4. AI는 이제 운영의 시대</h2>

<p>기술보다 중요한 건 <strong>운영과 조율</strong>이다. 특히 다음과 같은 통찰이 강조되었다.</p>

<ul>
  <li>AGI는 단일 모델이 아닌, <strong>여러 특화 에이전트의 조합</strong></li>
  <li>이 조합을 조율하는 <strong>AI 오케스트레이션 계층</strong>이 핵심</li>
  <li>개발자는 모델 사용자에서 <strong>AI 아키텍처 설계자</strong>로 역할 확장 필요</li>
</ul>

<p>A2A는 단순한 API 호출이 아니라, <strong>에이전트 간 협업 흐름을 구성하는 전략적 도구</strong>로 자리잡고 있다.</p>

<hr />

<h2 id="5-실무-적용-사례-및-전략">5. 실무 적용 사례 및 전략</h2>

<h3 id="-주요-사례">📌 주요 사례</h3>

<ul>
  <li><strong>한화생명</strong>: 보험 상담 자동화 (LLM + RAG 기반 챗봇 운영)</li>
  <li><strong>KT</strong>: 기관 문서 기반 검색 시스템 구축</li>
  <li><strong>MARA</strong>: 자산 시장 분석 자동화</li>
  <li><strong>Nota AI</strong>: 엣지 디바이스용 AI 모델 경량화 및 배포</li>
</ul>

<p>이 외에도 다양한 기업들이 AI를 ‘기능’으로서가 아닌,
<strong>문제 해결 도구</strong>로서 어떻게 전략적으로 운영하고 있는지를 소개했다.</p>

<hr />

<h2 id="6-기술-인사이트">6. 기술 인사이트</h2>

<h3 id="️-실용-기술">🛠️ 실용 기술</h3>

<ul>
  <li><strong>Structured Pruning</strong>: 불필요한 파라미터 제거로 경량화</li>
  <li><strong>Filter Decomposition</strong>: 병렬 연산을 직렬화하여 성능 최적화</li>
  <li><strong>RAG 기반 검색</strong>: 문서 기반 답변 정확도 향상</li>
  <li><strong>Agent Workflow</strong>: 도메인 특화 다중 에이전트 협업 구성</li>
</ul>

<hr />

<h2 id="7-결론">7. 결론</h2>

<p>AI 시스템은 이제 단일 모델의 정확도보다,
<strong>어떻게 운영되고 협업 구조를 갖추는가</strong>가 더 중요해지고 있다.</p>

<p>이번 컨퍼런스를 통해 확인한 핵심은 다음과 같다:</p>

<ul>
  <li><strong>AI는 플랫폼이다</strong>: 단일 모델보다 다중 에이전트의 구조화된 조율이 핵심</li>
  <li><strong>A2A는 미래의 기본 요소</strong>: 마이크로서비스처럼 에이전트 협업이 표준화될 것</li>
  <li><strong>운영 전략이 곧 성패를 가른다</strong>: 기술보다 프로덕션 환경 최적화가 우선시됨</li>
</ul>

<blockquote>
  <p>기술을 넘어 전략으로서의 AI를 고민하게 된 의미 있는 자리였다.</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[AI Tech 2025 컨퍼런스에서 확인한 LLMOps, A2A, Embodied AI 등 최신 AI 시스템 운영 전략]]></summary></entry><entry><title type="html">[TIL] spring-boot-starter-validation, 테스트 코드 모니터링 툴</title><link href="https://nan0silver.github.io/til/2025-05-12-til/" rel="alternate" type="text/html" title="[TIL] spring-boot-starter-validation, 테스트 코드 모니터링 툴" /><published>2025-05-12T00:00:00+00:00</published><updated>2025-05-22T05:27:40+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-12-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/56">#56</a><br />
📅 <strong>작성일</strong>: 2025-05-12<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 22일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<ul>
  <li>spring-boot-starter-validation</li>
  <li>테스트 코드 모니터링 툴</li>
</ul>

<h3 id="1️⃣-spring-boot-starter-validation">1️⃣ <code class="language-plaintext highlighter-rouge">spring-boot-starter-validation</code></h3>

<blockquote>
  <p><strong>Spring Boot에서 사용자 입력 값(요청 바디 등)을 검증</strong>할 수 있게 해주는 의존성 패키지
내부적으로는 <code class="language-plaintext highlighter-rouge">javax.validation</code> (JSR-380)이나 <code class="language-plaintext highlighter-rouge">jakarta.validation</code> API를 기반으로 동작</p>
</blockquote>

<ul>
  <li>주로 아래와 같은 상황에 동작
    <ul>
      <li>사용자가 회원가입을 할 때</li>
      <li>게시글을 작성할 때</li>
      <li>비밀번호 변경할 때 등</li>
    </ul>
  </li>
</ul>

<p><strong>프론트엔드에서 필터링한다고 해도, 백엔드에서는 무조건 검증이 필요</strong></p>

<ul>
  <li>신뢰할 수 없는 요청이나 보안 위험을 방지하기 위해서 (프론트는 우회가 가능하므로) 백엔드 검증은 필수!</li>
  <li>검증 애너테이션
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@NotNull</code>, <code class="language-plaintext highlighter-rouge">@NotBlank</code>, <code class="language-plaintext highlighter-rouge">@Size</code>, <code class="language-plaintext highlighter-rouge">@Email</code>, <code class="language-plaintext highlighter-rouge">@Min</code>, <code class="language-plaintext highlighter-rouge">@Max</code> 등</li>
    </ul>
  </li>
  <li>검증 실패 시
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@ControllerAdvice</code>와 <code class="language-plaintext highlighter-rouge">@ExceptionHandler</code>를 이용해 에러 메시지 사용</li>
    </ul>
  </li>
</ul>

<h4 id="1-의존성-추가-buildgradle">1. 의존성 추가 (<code class="language-plaintext highlighter-rouge">build.gradle</code>)</h4>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">implementation</span> <span class="s1">'org.springframework.boot:spring-boot-starter-validation'</span>
</code></pre></div></div>

<h4 id="2-dto-클래스에-검증-어노테이션-달기">2. DTO 클래스에 검증 어노테이션 달기</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">jakarta.validation.constraints.NotBlank</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.validation.constraints.Size</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SignupRequestDto</span> <span class="o">{</span>

    <span class="nd">@NotBlank</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"이메일은 필수입니다."</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span><span class="n">min</span> <span class="o">=</span> <span class="mi">8</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"비밀번호는 최소 8자 이상이어야 합니다."</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>

    <span class="c1">// getter, setter</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="3-controller에서-검증-처리">3. Controller에서 검증 처리</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@PostMapping</span><span class="o">(</span><span class="s">"/signup"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;?&gt;</span> <span class="n">signup</span><span class="o">(</span><span class="nd">@Valid</span> <span class="nd">@RequestBody</span> <span class="nc">SignupRequestDto</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 통과 시 로직 실행</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@Valid</code>가 붙은 객체에서 문제가 발생하면 자동으로 400 에러 발생.</li>
  <li>에러 메시지는 <code class="language-plaintext highlighter-rouge">@ControllerAdvice</code>를 통해 커스터마이징도 가능.</li>
</ul>

<h3 id="2️⃣-테스트-코드-모니터링-툴">2️⃣ 테스트 코드 모니터링 툴</h3>

<blockquote>
  <p><strong>“테스트 코드의 품질과 실행 현황을 시각적으로 분석/모니터링하는 도구”</strong>
즉, 테스트가 얼마나 잘 되어 있는지 **“숫자와 그래프”**로 보여주는 도구</p>
</blockquote>

<ul>
  <li>테스트 코드가 있다고 해도, **정말 전체 코드를 잘 테스트하고 있는지는 모름</li>
  <li>그래서 “<strong>코드 커버리지</strong>”, “<strong>테스트 성공률</strong>”, “<strong>실행 시간</strong>” 같은 걸 측정해서 모니터링할 수 있어야 한다.
    <ul>
      <li>커버리지
        <ul>
          <li>코드의 품질과 신뢰성을 수치로 확인할 수 있는 지표</li>
          <li>단순히 테스트를 작성하는 것보다, 커버리지를 보면서 blind spot 없이 테스트하는 게 중요!</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>🔧 대표적인 도구들
| 도구 | 설명 |
| ———————- | ———————————– |
| <strong>JaCoCo</strong> | Java 프로젝트에서 가장 널리 쓰이는 코드 커버리지 측정 도구 |
| <strong>SonarQube</strong> | 코드 품질, 보안 취약점, 커버리지까지 통합 분석 |
| <strong>IntelliJ 자체 기능</strong> | 실행 후 커버리지를 하이라이팅으로 보여줌 |
| <strong>Codecov, Coveralls</strong> | GitHub Actions와 연동해 커버리지 리포트 자동화 |</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><category term="Spring" /><summary type="html"><![CDATA[2025-05-12 TIL]]></summary></entry><entry><title type="html">[TIL] UUID와 Auto Increment PK는 언제 사용할까?</title><link href="https://nan0silver.github.io/til/2025-05-11-til/" rel="alternate" type="text/html" title="[TIL] UUID와 Auto Increment PK는 언제 사용할까?" /><published>2025-05-11T00:00:00+00:00</published><updated>2025-05-22T05:26:48+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-11-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/55">#55</a><br />
📅 <strong>작성일</strong>: 2025-05-11<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 22일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<ul>
  <li><strong>UUID와 Auto Increment PK는 언제 사용할까?</strong></li>
</ul>

<p>오늘은 엔티티의 기본 키(primary key)를 정의할 때 <strong>UUID</strong>와 <strong>Auto Increment(Long 타입)</strong> 중 어떤 것을 선택할지에 대해 정리해보았다.</p>

<h3 id="-auto-increment-일반적인-정수형-pk">✅ Auto Increment (일반적인 정수형 PK)</h3>

<ul>
  <li>
    <p>특징</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">@GeneratedValue(strategy = GenerationType.IDENTITY)</code> 형태로 많이 사용</li>
      <li>DB가 자동으로 증가시키며 관리</li>
      <li>숫자 기반이라 인덱싱 속도가 빠르고, 저장 공간도 적게 차지함</li>
    </ul>
  </li>
  <li>
    <p>사용에 적합한 경우</p>

    <ul>
      <li>내부 시스템용 데이터</li>
      <li>데이터 유출 시에도 ID 자체로는 식별 불가 → 보안 문제가 크지 않은 경우</li>
      <li>검색/조회 성능이 중요한 경우</li>
    </ul>
  </li>
  <li>
    <p>단점</p>

    <ul>
      <li>순차적으로 증가하는 ID는 보안상 예측 가능성이 있음 (특히 API 경로에 노출될 경우 위험)</li>
      <li>시스템 간 병합 시 충돌 가능성 있음 (ex. 여러 서버에서 동시에 데이터를 생성하는 분산 환경)</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="-uuid-범용-고유-식별자">✅ UUID (범용 고유 식별자)</h3>

<ul>
  <li>
    <p>특징</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">@GeneratedValue(strategy = GenerationType.AUTO)</code> 또는 <code class="language-plaintext highlighter-rouge">UUID.randomUUID()</code> 사용</li>
      <li>128비트의 랜덤 고유값 (예: <code class="language-plaintext highlighter-rouge">d290f1ee-6c54-4b01-90e6-d701748f0851</code>)</li>
      <li>전역적으로 충돌 가능성이 거의 없음 → <strong>분산 시스템에 적합</strong></li>
    </ul>
  </li>
  <li>
    <p>사용에 적합한 경우</p>

    <ul>
      <li>외부에 노출되는 식별자(API, 클라이언트 전송 등)</li>
      <li>데이터 생성 주체가 분산되어 있어 충돌을 방지해야 할 때</li>
      <li>보안상 ID 노출을 피하고 싶을 때</li>
    </ul>
  </li>
  <li>
    <p>단점</p>

    <ul>
      <li>길이가 길고 가독성이 떨어짐</li>
      <li>저장 시 공간 낭비 (VARCHAR or BINARY 타입)</li>
      <li>인덱싱 성능이 낮음 → 대량 데이터일수록 성능 저하 가능</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="-결론-어떤-상황에-어떤-걸-쓸까">💡 결론: 어떤 상황에 어떤 걸 쓸까?</h3>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>추천 방식</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>단일 서버, 내부 관리 중심 서비스</td>
      <td>Auto Increment</td>
    </tr>
    <tr>
      <td>외부 노출 ID가 필요하거나, 분산 환경에서 생성되는 데이터</td>
      <td>UUID</td>
    </tr>
    <tr>
      <td>민감한 정보 식별자 (예: 사용자 ID, 주문 번호 등)</td>
      <td>UUID</td>
    </tr>
    <tr>
      <td>빠른 정렬/검색이 중요한 대량 데이터</td>
      <td>Auto Increment (with caution)</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>오늘의 교훈: “보안성과 확장성”이 중요한 시스템이라면 UUID,
“성능과 단순함”이 중요하다면 Auto Increment를 고려하자.
다만 외부에 노출될 수 있는 ID는 무조건 UUID나 별도의 난수 토큰을 사용하는 것이 안전하다!</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-11 TIL]]></summary></entry></feed>