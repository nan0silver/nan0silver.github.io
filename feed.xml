<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-11-28T05:52:17+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[친구하자] Agora Cloud Recording과 Firebase Storage로 음성 통화 녹음 구현하기</title><link href="https://nan0silver.github.io/projectdiary/2025-11-24-diary/" rel="alternate" type="text/html" title="[친구하자] Agora Cloud Recording과 Firebase Storage로 음성 통화 녹음 구현하기" /><published>2025-11-24T00:00:00+00:00</published><updated>2025-11-28T05:51:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-24-diary/"><![CDATA[<p>‘친구하자’를 개발하며 통화 녹음 기능을 구현해야 했다. AI 개발과 통화 분석 등 추후 기능들을 위해 통화를 녹음하는 것을 전제로 구현을 시작했다.</p>

<p>처음에는 단순할 줄 알았는데, 생각보다 에러도 많이 나고 시행착오가 많아서 MVP에서 제외하고 개발했다. 이 글에서는 어떤 문제들을 겪었고, 어떻게 해결했는지를 정리하려고 한다.</p>

<h2 id="1-기술-스택-선택">1. 기술 스택 선택</h2>

<h3 id="11-왜-agora-cloud-recording을-선택했나">1.1. 왜 Agora Cloud Recording을 선택했나?</h3>

<p>처음에 WebRTC 서비스를 선택하기에 앞서 Recording 구현을 고려했다. WebRTC 중에는 recording을 지원하는 서비스가 있고, 아닌 서비스가 있었다. 그중 Agora는 Recording 지원이 가장 다양했고, 가격도 저렴했다.</p>

<p>Recording을 저장하는 것에도 많은 선택지가 있었다:</p>

<ol>
  <li><strong>Agora 백업 저장소</strong>
    <ul>
      <li>제3자 스토리지 설정이 실패하면 백업 서버에 <strong>24시간 동안만</strong> 임시 저장</li>
      <li>운영용이 아니므로 반드시 외부 저장소 연동 필요</li>
    </ul>
  </li>
  <li><strong>AWS S3 직접 연동</strong>
    <ul>
      <li>가장 일반적이고 안정적인 방법</li>
    </ul>
  </li>
  <li><strong>Firebase Storage (GCS 기반)</strong>
    <ul>
      <li>이미 프로젝트에서 사용 중 (프로필 이미지 등)</li>
    </ul>
  </li>
</ol>

<p>고민 끝에 <strong>Firebase Storage</strong>를 선택했다:</p>

<ul>
  <li>이미 프로젝트에서 사용 중이어서 익숙함</li>
  <li>GCS(Google Cloud Storage) 기반이라 Agora와 호환성이 좋음</li>
  <li>Firebase의 다른 기능들과도 잘 통합됨</li>
  <li>AWS S3와 비용이 비슷한 수준 (월 1,000분 통화 기준 약 80원 차이)</li>
</ul>

<h3 id="12-individual-recording-mode-선택">1.2. Individual Recording Mode 선택</h3>

<p>Agora Cloud Recording에는 여러 모드가 있다:</p>

<ul>
  <li><strong>Composite Mode</strong>: 모든 사람의 음성을 하나로 합침</li>
  <li><strong>Individual Mode</strong>: 각 사용자별로 별도 녹음</li>
</ul>

<p>나는 <strong>Individual Mode</strong>를 선택했다. 추후 각 사용자의 음성을 따로 분석할 수도 있고, 더 유연하기 때문이다.</p>

<h2 id="2-구현-과정에서-만난-문제들">2. 구현 과정에서 만난 문제들</h2>

<h3 id="21-비동기-처리-설정-문제">2.1. 비동기 처리 설정 문제</h3>

<p>녹음 시작/중지는 시간이 걸리는 작업이기 때문에 비동기로 처리해야 했다. 그런데 Spring에서 이런 경고가 떴다:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>More than one TaskExecutor bean found within the context,
and none is named <span class="s1">'taskExecutor'</span>
</code></pre></div></div>

<p><strong>문제:</strong></p>

<p><code class="language-plaintext highlighter-rouge">@Async</code>만 쓰면 Spring이 <code class="language-plaintext highlighter-rouge">SimpleAsyncTaskExecutor</code>를 사용한다. 이는 매번 새 스레드를 생성하기 때문에 매우 비효율적이다.</p>

<p>내 경우, 애플리케이션 컨텍스트에 이미 여러 개의 <code class="language-plaintext highlighter-rouge">TaskExecutor</code> 빈이 존재했는데 (<code class="language-plaintext highlighter-rouge">recordingTaskExecutor</code>, <code class="language-plaintext highlighter-rouge">matchingTaskExecutor</code> 등), 어느 것도 <code class="language-plaintext highlighter-rouge">taskExecutor</code>라는 이름을 가지고 있지 않았다. Executor를 지정하지 않고 <code class="language-plaintext highlighter-rouge">@Async</code>만 작성하니 Spring에서 경고를 보냈다.</p>

<p><strong>해결:</strong></p>

<p>용도별로 Executor를 분리하고, 기본 <code class="language-plaintext highlighter-rouge">taskExecutor</code>를 명시적으로 지정했다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableAsync</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsyncConfig</span> <span class="kd">implements</span> <span class="nc">AsyncConfigurer</span> <span class="o">{</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"taskExecutor"</span><span class="o">)</span>
    <span class="nd">@Primary</span>
    <span class="kd">public</span> <span class="nc">Executor</span> <span class="nf">taskExecutor</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ThreadPoolTaskExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolTaskExecutor</span><span class="o">();</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setCorePoolSize</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setMaxPoolSize</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setQueueCapacity</span><span class="o">(</span><span class="mi">25</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setThreadNamePrefix</span><span class="o">(</span><span class="s">"Async-"</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">executor</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"recordingTaskExecutor"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Executor</span> <span class="nf">recordingTaskExecutor</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ThreadPoolTaskExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolTaskExecutor</span><span class="o">();</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setCorePoolSize</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setMaxPoolSize</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setQueueCapacity</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setThreadNamePrefix</span><span class="o">(</span><span class="s">"Recording-"</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">executor</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 하면 스레드 풀을 재사용해서 성능이 훨씬 좋아진다:</p>

<ul>
  <li>스레드 생성 비용: ~1-2ms → ~0.01ms</li>
  <li>리소스 제한: 무제한 → 최대 5개로 제어</li>
</ul>

<h3 id="22-firebase-storage-저장-실패">2.2. Firebase Storage 저장 실패</h3>

<p>드디어 녹음이 시작되었다! 로그에도 성공 메시지가 떴다. 그런데 Firebase Storage를 확인해보니… 파일이 없었다. 😱</p>

<p><strong>문제의 핵심: <code class="language-plaintext highlighter-rouge">uploadingStatus=backuped</code></strong></p>

<p><code class="language-plaintext highlighter-rouge">uploadingStatus</code>에는 두 가지 값이 있다:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">uploaded</code></strong>: 제3자 스토리지(Firebase)에 업로드 성공</li>
  <li><strong><code class="language-plaintext highlighter-rouge">backuped</code></strong>: Agora 자체 백업 서버에 저장 (24시간 후 삭제)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">backuped</code>가 나왔다는 건 Firebase에 업로드가 실패했다는 의미였다.</p>

<p><strong>원인: HMAC 키가 없었다!</strong></p>

<p>Agora가 GCS(Google Cloud Storage)에 파일을 올리려면 <strong>HMAC 인증 키</strong>가 필요하다. Firebase Console → Storage → Settings → Interoperability를 확인해보니 아무것도 없었다.</p>

<p><strong>해결 과정:</strong></p>

<ol>
  <li>
    <p><strong>Google Cloud Console 접속</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cloud Console → Storage → Settings → Interoperability
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>HMAC 키 생성</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Service account HMAC 섹션
→ Create a key for a service account
→ firebase-adminsdk-xxxxx@프로젝트명.iam.gserviceaccount.com 선택
→ CREATE KEY
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Access Key와 Secret 복사</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Access Key: GOOG1E...로 시작하는 긴 문자열
Secret: 한 번만 보여주니 즉시 복사!
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>application.yml 설정</strong></p>
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">app</span><span class="pi">:</span>
  <span class="na">agora</span><span class="pi">:</span>
    <span class="na">recording-region</span><span class="pi">:</span> <span class="m">0</span> <span class="c1"># GCS Multi-region US</span>
    <span class="na">recording-storage-vendor</span><span class="pi">:</span> <span class="s2">"</span><span class="s">6"</span> <span class="c1"># 6 = GCS</span>
    <span class="na">recording-storage-bucket</span><span class="pi">:</span> <span class="s">프로젝트명.appspot.com</span>
    <span class="na">recording-storage-access-key</span><span class="pi">:</span> <span class="s">${AGORA_STORAGE_ACCESS_KEY}</span>
    <span class="na">recording-storage-secret-key</span><span class="pi">:</span> <span class="s">${AGORA_STORAGE_SECRET_KEY}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>이렇게 설정하고 다시 녹음을 시작했더니… 드디어 성공! 🎉</p>

<h2 id="3-최종-구조">3. 최종 구조</h2>

<p>모든 삽질을 마치고 완성된 구조는 다음과 같다:</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-24-pic1.png?raw=true" alt="이미지1" /></p>

<h3 id="31-주요-특징">3.1. 주요 특징</h3>

<ol>
  <li><strong>Individual Recording Mode</strong>: 각 사용자별로 별도 녹음</li>
  <li><strong>Audio Only</strong>: 비용 절감 (비디오 없음)</li>
  <li><strong>자동 업로드</strong>: Agora → Firebase Storage 직접 저장</li>
  <li><strong>파일 구조화</strong>: 날짜/Call ID별 폴더 정리</li>
  <li><strong>비동기 처리</strong>: 녹음 시작/중지가 메인 스레드를 블로킹하지 않음</li>
</ol>

<h2 id="4-배운-점">4. 배운 점</h2>

<h3 id="41-공식-문서를-꼼꼼히-읽자">4.1. 공식 문서를 꼼꼼히 읽자</h3>

<p>Agora 공식 문서에 Individual Mode와 Composite Mode의 차이가 명확하게 나와 있었다. 처음부터 제대로 읽었으면 불필요한 시행착오를 줄일 수 있었을 것이다.</p>

<h3 id="42-클라우드-서비스는-인증이-핵심">4.2. 클라우드 서비스는 인증이 핵심</h3>

<p>Firebase Storage에 파일이 안 올라가는 이유가 HMAC 키 때문이었다. 클라우드 간 연동에서는 항상 <strong>인증 설정을 먼저 확인</strong>해야 한다.</p>

<h3 id="43-비동기-처리는-제대로-설정하자">4.3. 비동기 처리는 제대로 설정하자</h3>

<p><code class="language-plaintext highlighter-rouge">@Async</code>만 쓰고 넘어가면 안 된다. 제대로 된 <code class="language-plaintext highlighter-rouge">ThreadPoolTaskExecutor</code>를 설정해야 운영에서 안정적이다.</p>

<h2 id="5-운영-지표">5. 운영 지표</h2>

<p>현재 운영 중인 시스템의 주요 지표:</p>

<ul>
  <li><strong>녹음 시작 시간</strong>: 평균 2-3초</li>
  <li><strong>파일 업로드</strong>: Agora가 자동 처리 (15초마다)</li>
  <li><strong>DB 저장</strong>: 비동기 처리로 메인 로직에 영향 없음</li>
  <li><strong>스레드 풀</strong>: 최대 5개 스레드로 제한되어 안정적</li>
</ul>

<p><strong>비용 최적화:</strong></p>

<ul>
  <li>Audio Only로 비디오 대비 비용 1/5 수준</li>
  <li>maxIdleTime 설정으로 30초 무음 시 자동 종료</li>
  <li>streamMode: standard (Agora 권장)</li>
</ul>

<h2 id="6-마치며">6. 마치며</h2>

<p>처음엔 “그냥 녹음만 하면 되는 거 아니야?”라고 생각했는데, 실제로는 정말 많은 함정이 있었다:</p>

<ul>
  <li>Individual vs Composite Mode 이해</li>
  <li>HMAC 키 설정</li>
  <li>비동기 처리 구성</li>
  <li>에러 핸들링</li>
</ul>

<p>하나하나 해결하면서 많이 배웠다. 특히 클라우드 서비스 간 연동에서 <strong>인증과 권한 설정</strong>이 얼마나 중요한지 깨달았다.</p>

<p>이 글이 Agora Cloud Recording과 Firebase Storage를 연동하려는 누군가에게 도움이 되었으면 좋겠다. 😅</p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://docs.agora.io/en/cloud-recording/develop/individual-mode">Agora Individual Recording 공식 문서</a></li>
  <li><a href="https://docs.agora.io/en/cloud-recording/reference/region-vendor">Agora Cloud Storage 설정</a></li>
  <li><a href="https://cloud.google.com/storage/docs/authentication/hmackeys">Google Cloud HMAC 키 생성</a></li>
  <li><a href="https://spring.io/guides/gs/async-method">Spring Async 설정</a></li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Agora Cloud Recording을 통한 통화 녹음과 이를 Firebase Storage에 저장하는 기능을 구현하면서 경험한 것과 느낀 점을 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor 앱 Custom Splash Screen 구현하기</title><link href="https://nan0silver.github.io/projectdiary/2025-11-20-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor 앱 Custom Splash Screen 구현하기" /><published>2025-11-20T00:00:00+00:00</published><updated>2025-11-28T05:51:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-20-diary/"><![CDATA[<ul>
  <li>이번 포스팅에선 Capacitor로 빌드한 앱에서 여러 아이콘이 순차적으로 표시되는 커스텀 스플래시 스크린을 구현하는 방법을 정리했다.</li>
  <li>왜 Custom splash screen이 필요했나?
    <ul>
      <li>Capacitor의 기본 splash screen은 단일 정적 이미지만 지원한다.<a href="https://capacitorjs.com/docs/apis/splash-screen">🔗링크</a></li>
      <li>나는 여러 아이콘을 순차적으로 보여주는 애니메이션을 구현하고 싶어 React 컴포넌트로 직접 구현하였다!</li>
    </ul>
  </li>
</ul>

<h2 id="목차">목차</h2>

<ul>
  <li><a href="#1-필요한-패키지-설치">1. 필요한 패키지 설치</a></li>
  <li><a href="#2-capacitor-설정">2. Capacitor 설정</a></li>
  <li><a href="#3-커스텀-스플래시-스크린-컴포넌트-생성">3. 커스텀 스플래시 스크린 컴포넌트 생성</a></li>
  <li><a href="#4-apptsx에-통합">4. App.tsx에 통합</a></li>
  <li><a href="#핵심-구현-포인트">핵심 구현 포인트</a></li>
  <li><a href="#주의사항">주의사항</a></li>
  <li><a href="#참고-문헌">참고 문헌</a></li>
</ul>

<hr />

<h2 id="1-필요한-패키지-설치">1. 필요한 패키지 설치</h2>

<p>먼저 스플래시 스크린 관련 패키지를 설치하자.</p>

<blockquote>
  <p>나는 pnpm을 사용하고 있었으므로 pnpm으로 설치했다.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pnpm add @capacitor/splash-screen
pnpm add <span class="nt">-D</span> @capacitor/assets
</code></pre></div></div>

<h2 id="2-capacitor-설정">2. Capacitor 설정</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">capacitor.config.ts</code> 파일에 스플래시 스크린 설정을 추가하자.</li>
  <li>‼️ 커스텀 스플래시를 사용하므로 네이티브 스플래시는 최소화!</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// &lt;reference types="@capacitor/splash-screen" /&gt;</span>

<span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">CapacitorConfig</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@capacitor/cli</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">config</span><span class="p">:</span> <span class="nx">CapacitorConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ... 기타 설정</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">SplashScreen</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">launchShowDuration</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// 커스텀 스플래시를 사용하므로 0으로 설정</span>
      <span class="na">launchAutoHide</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 자동으로 숨길지 여부</span>
      <span class="na">launchFadeOutDuration</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// 페이드 아웃 애니메이션 시간 (커스텀 스플래시에서 처리)</span>
      <span class="na">backgroundColor</span><span class="p">:</span> <span class="dl">"</span><span class="s2">#ffffff</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 배경색 (hex 형식) - 커스텀 스플래시와 동일하게 설정</span>
      <span class="c1">// ... 기타 설정</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">config</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="3-커스텀-스플래시-스크린-컴포넌트-생성">3. 커스텀 스플래시 스크린 컴포넌트 생성</h2>

<p><code class="language-plaintext highlighter-rouge">client/components/CustomSplashScreen.tsx</code> 파일을 생성한다.</p>

<h3 id="props-정의">Props 정의</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">CustomSplashScreenProps</span> <span class="p">{</span>
  <span class="nl">onComplete</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span> <span class="c1">// 스플래시 완료 시 콜백</span>
  <span class="nl">icons</span><span class="p">?:</span> <span class="kr">string</span><span class="p">[];</span> <span class="c1">// 표시할 아이콘 배열</span>
  <span class="nl">iconDuration</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// 각 아이콘 표시 시간(ms)</span>
  <span class="nl">minDisplayDuration</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// 최소 표시 시간(ms)</span>
  <span class="nl">animationType</span><span class="p">?:</span> <span class="dl">"</span><span class="s2">slide-up</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">fade</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">none</span><span class="dl">"</span><span class="p">;</span>
  <span class="nl">backgroundColor</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="핵심-로직">핵심 로직</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">CustomSplashScreen</span> <span class="o">=</span> <span class="p">({</span>
  <span class="nx">onComplete</span><span class="p">,</span>
  <span class="nx">icons</span> <span class="o">=</span> <span class="p">[],</span>
  <span class="nx">iconDuration</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
  <span class="nx">minDisplayDuration</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
  <span class="nx">animationType</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">slide-up</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">backgroundColor</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">#ffffff</span><span class="dl">"</span><span class="p">,</span>
<span class="p">}:</span> <span class="nx">CustomSplashScreenProps</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">currentIconIndex</span><span class="p">,</span> <span class="nx">setCurrentIconIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">isVisible</span><span class="p">,</span> <span class="nx">setIsVisible</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

  <span class="c1">// 1. 네이티브 스플래시 스크린 즉시 숨기기</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">hideNativeSplash</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="k">await</span> <span class="nx">SplashScreen</span><span class="p">.</span><span class="nx">hide</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 웹 환경에서는 에러가 발생할 수 있으므로 무시</span>
      <span class="p">}</span>
    <span class="p">};</span>
    <span class="nx">hideNativeSplash</span><span class="p">();</span>
  <span class="p">},</span> <span class="p">[]);</span>

  <span class="c1">// 2. 아이콘 순차 표시 로직</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">icons</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">setIsVisible</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">onComplete</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
      <span class="p">},</span> <span class="nx">minDisplayDuration</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 아이콘 전환 인터벌</span>
    <span class="kd">const</span> <span class="nx">iconInterval</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setCurrentIconIndex</span><span class="p">((</span><span class="nx">prev</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">prev</span> <span class="o">&lt;</span> <span class="nx">icons</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">prev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">prev</span><span class="p">;</span>
      <span class="p">});</span>
    <span class="p">},</span> <span class="nx">iconDuration</span><span class="p">);</span>

    <span class="c1">// 총 표시 시간 계산</span>
    <span class="kd">const</span> <span class="nx">totalAnimationDuration</span> <span class="o">=</span> <span class="nx">icons</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="nx">iconDuration</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">actualDuration</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">totalAnimationDuration</span><span class="p">,</span> <span class="nx">minDisplayDuration</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">completeTimer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setIsVisible</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
      <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">onComplete</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
    <span class="p">},</span> <span class="nx">actualDuration</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">iconInterval</span><span class="p">);</span>
      <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">completeTimer</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">},</span> <span class="p">[</span><span class="nx">icons</span><span class="p">,</span> <span class="nx">iconDuration</span><span class="p">,</span> <span class="nx">minDisplayDuration</span><span class="p">,</span> <span class="nx">onComplete</span><span class="p">]);</span>

  <span class="c1">// ... 렌더링 로직</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li>아이콘 슬라이드 애니메이션과 텍스트 추가 등 개인의 디자인에 맞게 React 코드를 수정해서 꾸며주면 된다!!</li>
</ul>

<h2 id="4-apptsx에-통합">4. App.tsx에 통합</h2>

<p>메인 앱 컴포넌트에 커스텀 스플래시 스크린을 통합합니다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">CustomSplashScreen</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./components/CustomSplashScreen</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">AppRoutes</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">showSplash</span><span class="p">,</span> <span class="nx">setShowSplash</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

  <span class="c1">// 스플래시 스크린에 표시할 아이콘들</span>
  <span class="kd">const</span> <span class="nx">splashIcons</span> <span class="o">=</span> <span class="p">[</span>
    <span class="dl">"</span><span class="s2">/splash-icons/icon1.png</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">/splash-icons/icon2.png</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">/splash-icons/icon3.png</span><span class="dl">"</span><span class="p">,</span>
    <span class="c1">// ... 더 많은 아이콘</span>
  <span class="p">];</span>

  <span class="kd">const</span> <span class="nx">handleSplashComplete</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setShowSplash</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">showSplash</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">CustomSplashScreen</span>
        <span class="nx">onComplete</span><span class="o">=</span><span class="p">{</span><span class="nx">handleSplashComplete</span><span class="p">}</span>
        <span class="nx">icons</span><span class="o">=</span><span class="p">{</span><span class="nx">splashIcons</span><span class="p">}</span>
        <span class="nx">iconDuration</span><span class="o">=</span><span class="p">{</span><span class="mi">400</span><span class="p">}</span>
        <span class="nx">minDisplayDuration</span><span class="o">=</span><span class="p">{</span><span class="mi">2000</span><span class="p">}</span>
        <span class="nx">animationType</span><span class="o">=</span><span class="dl">"</span><span class="s2">slide-up</span><span class="dl">"</span>
      <span class="o">/&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ... 나머지 앱 로직</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="-핵심-구현-포인트-">🍎 핵심 구현 포인트 🍎</h2>

<h3 id="1-네이티브-스플래시와-커스텀-스플래시-분리">1. 네이티브 스플래시와 커스텀 스플래시 분리</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">launchShowDuration: 0</code>으로 설정하여 네이티브 스플래시를 즉시 숨김</li>
  <li><code class="language-plaintext highlighter-rouge">SplashScreen.hide()</code>를 컴포넌트 마운트 시 호출</li>
</ul>

<h3 id="2-텍스트-깜빡임-방지">2. 텍스트 깜빡임 방지</h3>

<p>아이콘과 텍스트를 별도의 <code class="language-plaintext highlighter-rouge">div</code>로 렌더링하여 아이콘이 변경될 때 텍스트가 깜빡이지 않도록 구현</p>

<h3 id="3-부드러운-애니메이션">3. 부드러운 애니메이션</h3>

<p>CSS <code class="language-plaintext highlighter-rouge">transition</code>과 <code class="language-plaintext highlighter-rouge">cubic-bezier</code> 타이밍 함수를 사용하여 자연스러운 전환 효과 구현</p>

<h3 id="4-최소-표시-시간-보장">4. 최소 표시 시간 보장</h3>

<p><code class="language-plaintext highlighter-rouge">minDisplayDuration</code>을 설정하여 애니메이션이 너무 빨리 끝나도 최소 시간은 보장</p>

<h3 id="5-이미지-준비">5. 이미지 준비</h3>

<p>아이콘 이미지는 <code class="language-plaintext highlighter-rouge">public/splash-icons/</code> 디렉토리에 저장합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public/
  splash-icons/
    icon1.png
    icon2.png
    icon3.png
</code></pre></div></div>

<h2 id="️-주의사항">‼️ 주의사항</h2>

<ul>
  <li>이미지는 반드시 <code class="language-plaintext highlighter-rouge">public</code> 폴더에 저장 (빌드 시 자동 포함)</li>
  <li>웹 환경에서는 <code class="language-plaintext highlighter-rouge">SplashScreen.hide()</code>가 에러를 발생시킬 수 있으므로 try-catch 처리 필요</li>
  <li>Android 12 이상에서는 네이티브 스플래시 API가 강제 적용되므로 초기 0.5초는 네이티브 스플래시가 보일 수 있음</li>
</ul>

<h2 id="-참고-문헌">🍀 참고 문헌</h2>

<ul>
  <li><a href="https://github.com/ionic-team/capacitor-assets">Capacitor assets github page</a></li>
  <li><a href="https://capacitorjs.com/docs/apis/splash-screen">@capacitor/splash-screen DOCS</a></li>
  <li><a href="https://capacitorjs.com/docs/guides/splash-screens-and-icons">Splash Screens and Icons DOCS</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 앱에서 Splash Screen을 React로 직접 구현한 내용에 대해 다룹니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor Android 앱 X-Frame-Options 에러 해결</title><link href="https://nan0silver.github.io/projectdiary/2025-11-17-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor Android 앱 X-Frame-Options 에러 해결" /><published>2025-11-17T00:00:00+00:00</published><updated>2025-11-28T05:51:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-17-diary/"><![CDATA[<ul>
  <li>이번 포스팅에서는 Capacitor로 빌드한 Android 앱에서 WebSocket 통신 중 발생한 X-Frame-Options 에러에 대해 다루었다.</li>
  <li>해결하는 과정에서 공부한 내용에 대해 정리해보았다.</li>
</ul>

<h2 id="문제-상황">문제 상황</h2>

<ul>
  <li>웹에서는 정상적으로 작동하던 <strong>매칭 완료 -&gt; WebSocket 메시지 수신 -&gt; 통화 시작 페이지 이동</strong> 로직이 Android 앱에서 다음과 같은 에러로 실패했다.</li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-17-pic1.png?raw=true" alt="에러 이미지1" /></p>

<ul>
  <li>🔥 이 문제는 <strong>Capacitor의 WebView 환경과 Spring Security의 기본 보안 설정이 충돌</strong>하면서 발생! 🔥</li>
  <li>WebSocket 라이브러리인 SockJS가 fallback 메커니즘으로 iframe을 사용하려 했지만, 서버가 보안상의 이유로 이를 차단했기 때문이다.</li>
  <li>이 글에서는 X-Frame-Options가 무엇인지, iframe이 무엇인지, 그리고 왜 이런 에러가 발생햇는지를 자세히 알아보겠습니다.</li>
</ul>

<h2 id="1-iframe-이란">1. iframe 이란?</h2>

<ul>
  <li><strong>iframe (inline frame)</strong>은 HTML 문서 안에서 다른 HTML 문서를 삽입하는 태그이다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- 예시: 유튜브 영상 삽입 --&gt;
&lt;iframe
    src="https://www.youtube.com/embed/VIDEO_ID"
    width="560"
    height="315"&gt;
&lt;/iframe&gt;
</code></pre></div></div>

<p><strong>시각적 구조:</strong>
<img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-17-pic2.png?raw=true" alt="설명 이미지1" /></p>

<ul>
  <li>실생활 예시 : 유튜브 영상 삽입, 구글 지도 삽입, 페이스북 “좋아요” 버튼 등</li>
</ul>

<h2 id="2-x-frame-options-이란">2. X-Frame-Options 이란?</h2>

<ul>
  <li>
    <p><strong>X-Frame-Options</strong>는 HTTP 응답 헤더로, 내 웹사이트가 다른 사이트의 iframe안에 표시되는 것을 제어하는 보안 메커니즘</p>
  </li>
  <li>
    <p>헤더 값 3가지:</p>
    <ul>
      <li>X-Frame-Options: DENY
        <ul>
          <li>어떤 사이트든 iframe으로 내 페이지를 로드할 수 없음</li>
        </ul>
      </li>
      <li>X-Frame-Options: SAMEORIGIN
        <ul>
          <li>같은 도메인에서만 iframe으로 로드 가능</li>
        </ul>
      </li>
      <li>X-Frame-Options: ALLOW-FROM https://example.com
        <ul>
          <li>특정 도메인에서만 iframe으로 로드 가능 (deprecated)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="왜-x-frame-options가-필요한가">왜 X-Frame-Options가 필요한가?</h3>

<ul>
  <li><strong>Clickjacking 공격 방지</strong>
    <ul>
      <li>악의적인 사이트가 투명한 iframe을 통해 사용자를 속여 원하지 않는 행동을 하게 만드는 공격</li>
    </ul>
  </li>
</ul>

<p><strong>공격 시나리오:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 공격자가 악의적인 사이트 만들기 (evil.com)

2. 투명한 iframe으로 은행 사이트를 숨김
   ┌─────────────────────────────────┐
   │ evil.com                        │
   │                                 │
   │ [무료 iPhone 받기!] 버튼           │
   │        ↑                        │
   │        실제로는 투명한 iframe       │
   │        은행 송금 버튼이 위치         │
   └─────────────────────────────────┘

3. 사용자가 "무료 iPhone 받기!" 클릭
   → 실제로는 은행의 "송금 승인" 버튼 클릭
   → 돈이 공격자에게 전송됨 🥲
</code></pre></div></div>

<p><strong>X-Frame-Options: DENY가 막는 방법:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────────────────────┐
│ evil.com                        │
│                                 │
│ &lt;iframe src="bank.com"&gt;         │
│   ❌ 브라우저가 로드 거부!           │
│   "X-Frame-Options: DENY"       │
│ &lt;/iframe&gt;                       │
└─────────────────────────────────┘
</code></pre></div></div>

<h2 id="️-capacitor로-빌드한-앱에서-이-문제가-발생한-이유">‼️ Capacitor로 빌드한 앱에서 이 문제가 발생한 이유</h2>

<ul>
  <li>Capacitor는 <strong>하이브리드 앱</strong>을 만드는 프레임워크이다.</li>
</ul>

<p><strong>하이브리드 앱 구조</strong>
<img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-17-pic3.png?raw=true" alt="설명 이미지2" /></p>

<ul>
  <li>WebView는 본질적으로 iframe과 유사하다!</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>네이티브 앱 (Android/iOS)
    └── WebView ≈ iframe
         └── React 앱 (https://localhost)
              └── WebSocket 연결 시도 → 백엔드 (https://backend.domain)
</code></pre></div></div>

<h3 id="sockjs의-iframe-transport"><strong>SockJS의 iframe Transport</strong></h3>

<p><strong>SockJS</strong>는 WebSocket이 안 될 때를 대비한 여러 fallback 방법을 제공한다.</p>

<p><strong>SockJS Transport 순서:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. WebSocket (가장 빠르고 효율적)
   ↓ 실패
2. xhr-streaming (HTTP 스트리밍)
   ↓ 실패
3. xhr-polling (HTTP 폴링)
   ↓ 실패
4. iframe-based transports (레거시 브라우저용)
   ↓ 실패
5. jsonp-polling (최후의 수단)
</code></pre></div></div>

<ul>
  <li>iframe-based transport가 하는 일:</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- SockJS가 내부적으로 생성하는 숨겨진 iframe --&gt;</span>
<span class="nt">&lt;iframe</span> <span class="na">src=</span><span class="s">"https://backend.domain/ws/iframe.html"</span> <span class="na">style=</span><span class="s">"display: none;"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/iframe&gt;</span>
</code></pre></div></div>

<h3 id="문제-발생-시나리오"><strong>문제 발생 시나리오:</strong></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Capacitor 앱 (WebView) 시작
   Origin: capacitor://localhost

2. WebSocket 연결 시도 (친구하자 프로젝트의 경우, 통화 매칭시 사용 중)
   → https://backend.domain/ws

3. SockJS가 iframe transport 시도
   ┌─────────────────────────────────┐
   │ Capacitor WebView               │
   │ (capacitor://localhost)         │
   │                                 │
   │ &lt;iframe src="backend.domain/ws"&gt; │
   │   ❌ 차단됨!                     │
   │   "X-Frame-Options: DENY"       │
   │ &lt;/iframe&gt;                       │
   └─────────────────────────────────┘

4. 에러 메시지:
   "Refused to display 'https://backend.domain/'
    in a frame because it set 'X-Frame-Options' to 'deny'"
</code></pre></div></div>

<h3 id="왜-spring-security가-기본적으로-deny를-설정할까">왜 Spring Security가 기본적으로 Deny를 설정할까?</h3>

<ul>
  <li>Spring Security의 보안 우선 철학 :
<img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-17-pic4.png?raw=true" alt="설명 이미지3" /></li>
</ul>

<p><strong>이유</strong></p>

<ol>
  <li><strong>보안 우선주의</strong>: 안전하지 않은 것보다 안전한 것이 낫다</li>
  <li><strong>Clickjacking 방지</strong>: 대부분의 웹 애플리케이션은 iframe에 로드될 필요 없음</li>
  <li><strong>명시적 허용</strong>: 개발자가 필요하면 명시적으로 변경하도록 유도</li>
</ol>

<p><strong>일반적인 웹사이트는 DENY가 맞다:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>은행, 쇼핑몰, 관리자 페이지 등
→ iframe에 로드될 이유가 없음
→ DENY로 보안 강화
</code></pre></div></div>

<p><strong>하지만 우리의 경우:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Capacitor 하이브리드 앱
→ WebView는 iframe과 유사한 환경
→ DENY면 앱 자체가 작동 안 함
→ SAMEORIGIN 또는 특정 origin 허용 필요
</code></pre></div></div>

<h2 id="해결-방법">해결 방법</h2>

<h3 id="방법-1-frameoptionssameorigin-운영-환경-권장">방법 1: frameOptions().sameOrigin() (운영 환경 권장)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">headers</span><span class="o">(</span><span class="n">headers</span> <span class="o">-&gt;</span> <span class="n">headers</span>
    <span class="o">.</span><span class="na">frameOptions</span><span class="o">(</span><span class="n">frameOptions</span> <span class="o">-&gt;</span> <span class="n">frameOptions</span><span class="o">.</span><span class="na">sameOrigin</span><span class="o">())</span>
<span class="o">)</span>
</code></pre></div></div>

<p><strong>의미:</strong></p>

<ul>
  <li>같은 도메인에서만 iframe 허용</li>
  <li><code class="language-plaintext highlighter-rouge">https://backend.domain</code>에서 <code class="language-plaintext highlighter-rouge">https://backend.domain</code>를 iframe으로 로드 가능</li>
  <li>Capacitor WebView는 <code class="language-plaintext highlighter-rouge">capacitor://localhost</code>이지만, WebView 자체가 특수 처리됨</li>
</ul>

<p><strong>왜 이게 Capacitor에서 작동하나?</strong>
WebView는 브라우저 엔진의 특수 모드
→ origin 검사가 일반 웹과 다르게 처리됨
→ SAMEORIGIN이어도 WebView 내부 컨텍스트에서는 허용</p>

<h3 id="방법-2-content-security-policy-추가-최고-보안">방법 2: Content-Security-Policy 추가 (최고 보안)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">headers</span><span class="o">(</span><span class="n">headers</span> <span class="o">-&gt;</span> <span class="n">headers</span>
    <span class="o">.</span><span class="na">frameOptions</span><span class="o">(</span><span class="n">frameOptions</span> <span class="o">-&gt;</span> <span class="n">frameOptions</span><span class="o">.</span><span class="na">sameOrigin</span><span class="o">())</span>
    <span class="o">.</span><span class="na">contentSecurityPolicy</span><span class="o">(</span><span class="n">csp</span> <span class="o">-&gt;</span> <span class="n">csp</span>
        <span class="o">.</span><span class="na">policyDirectives</span><span class="o">(</span><span class="s">"frame-ancestors 'self' capacitor://localhost http://localhost https://localhost"</span><span class="o">)</span>
    <span class="o">)</span>
<span class="o">)</span>
</code></pre></div></div>

<p><strong>의미:</strong></p>

<ul>
  <li>현대적인 보안 헤더 (X-Frame-Options의 후속)</li>
  <li>더 세밀한 제어 가능</li>
  <li>특정 origin만 명시적으로 허용</li>
</ul>

<h2 id="결론">결론</h2>

<ul>
  <li>Capacitor로 앱을 빌드한 다음에 웹에서는 발생하지 않는 에러들이 생겨서 찾아보고, 공부하고, 해결하는 재미가 있다.</li>
  <li>이제 통화연결까지 앱으로 수행할 수 있게 되었다!!</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 Android 앱에서의 웹소켓 오류 중 X-Frame-Options 에러 트러블슈팅을 다룹니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor 앱에서 Kakao/Google 네이티브 로그인 구현 정리</title><link href="https://nan0silver.github.io/projectdiary/2025-11-13-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor 앱에서 Kakao/Google 네이티브 로그인 구현 정리" /><published>2025-11-13T00:00:00+00:00</published><updated>2025-11-28T05:51:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-13-diary/"><![CDATA[<ul>
  <li>Capacitor로 빌드한 React 앱에서 카카오와 구글 네이티브 로그인을 구현하는 방법을 정리해 보았다.</li>
  <li>관련되서 정리되어있는게 없는것 같아서.. 내가 나중에 찾아볼 수 있게 일단 문서를 만들어보았다.</li>
  <li>웹에서는 일반 OAuth 리다이렉트를 사용하지만, 모바일 앱에서는 <strong>네이티브 SDK를 직접 사용</strong>하는 방식으로 구현했다. (kakao, google)
    <ul>
      <li>kakao developer에는 flutter문서에서 크로스 플랫폼에서는 커스텀 URL 스킴을 사용하라고 권장한다. 하지만 나는 플러그인을 사용하는 방식으로 구현해보았다.</li>
    </ul>
  </li>
</ul>

<h3 id="네이티브-sdk-직접-사용-구헌-방식-카카오-구글">네이티브 SDK 직접 사용 구헌 방식 (카카오, 구글)</h3>

<p><strong>네이티브 SDK 로그인 방식이란?</strong></p>

<ul>
  <li>카카오/구글이 제공하는 Android/iOS 전용 SDK를 사용한 로그인 방식</li>
  <li>앱 간 통신 방식을 사용한다.
    <ul>
      <li>즉, 기기에 설치된 카카오톡/구글 앱과 직접 통신하여 인증한다.</li>
    </ul>
  </li>
  <li>WebView를 우회하여 브라우저 리다이렉트 없이 앱 레벨에서 토큰을 교환한다.</li>
</ul>

<p><strong>이 방식이 하이브리드 앱에서 가능한 이유</strong></p>

<ul>
  <li>⭐️<strong>Capacitor의 플러그인 시스템</strong>⭐️이 핵심!</li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-13-pic1.png?raw=true" alt="설명 이미지1" /></p>

<ul>
  <li>WebView의 JavaScript 코드가 네이티브 코드를 호출할 수 있게 해줌</li>
  <li><code class="language-plaintext highlighter-rouge">KakaoLoginPlugin.goLogin()</code>을 통해 실제로 Android의 카카오 SDK 실행</li>
  <li>결과를 다시 JavaScript로 전달</li>
</ul>

<p>*<em>앱 구조 비교</em></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 안드로이드에서 실행 시</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">Capacitor</span><span class="p">.</span><span class="nx">isNativePlatform</span><span class="p">())</span> <span class="p">{</span>
  <span class="c1">// ✅ 네이티브 SDK 사용 (앱간 통신)</span>
  <span class="c1">// 카카오톡 앱 → 내 앱 (빠르고 안정적)</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">KakaoLoginPlugin</span><span class="p">.</span><span class="nx">goLogin</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 웹 브라우저에서 실행 시</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="c1">// ✅ OAuth 리다이렉트 사용 (브라우저 기반)</span>
  <span class="c1">// 브라우저 → 카카오 웹 → 콜백 URL</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">https://kauth.kakao.com/oauth/...</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>이렇게 하는 이유</strong></p>

<ul>
  <li>네이티브 로그인의 장점:
    <ul>
      <li>사용자가 카카오톡이 설치되어 있으면 앱 전환만으로 즉시 로그인</li>
      <li>브라우저 리다이렉트보다 UX가 훨씬 부드러움</li>
      <li>DeepLink, Custom URL Scheme 문제 없음</li>
    </ul>
  </li>
  <li>웹 로그인:
    <ul>
      <li>브라우저에서는 네이티브 SDK를 쓸 수 없으니 전통적인 OAuth 방식 사용</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="1-카카오-네이티브-로그인-구현">1. 카카오 네이티브 로그인 구현</h2>

<h3 id="11-플러그인-설치">1.1 플러그인 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pnpm add capacitor-kakao-login-plugin
npx cap <span class="nb">sync</span>
</code></pre></div></div>

<h3 id="12-android-설정">1.2 Android 설정</h3>

<h4 id="121-kakao-sdk-의존성-추가">1.2.1 Kakao SDK 의존성 추가</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/build.gradle</code>:</p>

<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">dependencies</span> <span class="o">{</span>
    <span class="c1">// ... 기존 의존성 ...</span>
    <span class="n">implementation</span> <span class="s2">"com.kakao.sdk:v2-common:2.20.1"</span>
    <span class="n">implementation</span> <span class="s2">"com.kakao.sdk:v2-auth:2.20.1"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">android/build.gradle</code>:</p>

<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">allprojects</span> <span class="o">{</span>
    <span class="k">repositories</span> <span class="o">{</span>
        <span class="n">google</span><span class="o">()</span>
        <span class="n">mavenCentral</span><span class="o">()</span>
        <span class="n">maven</span> <span class="o">{</span> <span class="n">url</span> <span class="s1">'https://devrepo.kakao.com/nexus/content/groups/public/'</span> <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="122-androidmanifestxml-설정">1.2.2 AndroidManifest.xml 설정</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/src/main/AndroidManifest.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;application&gt;</span>
    <span class="c">&lt;!-- 카카오 SDK 메타데이터 --&gt;</span>
    <span class="nt">&lt;meta-data</span>
        <span class="na">android:name=</span><span class="s">"com.kakao.sdk.AppKey"</span>
        <span class="na">android:value=</span><span class="s">"@string/kakao_app_key"</span> <span class="nt">/&gt;</span>

    <span class="nt">&lt;activity</span>
        <span class="na">android:name=</span><span class="s">".MainActivity"</span>
        <span class="na">android:exported=</span><span class="s">"true"</span><span class="nt">&gt;</span>
        <span class="c">&lt;!-- 카카오 로그인 리다이렉트 --&gt;</span>
        <span class="nt">&lt;intent-filter&gt;</span>
            <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">"android.intent.action.VIEW"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.DEFAULT"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.BROWSABLE"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;data</span> <span class="na">android:host=</span><span class="s">"kakaolink"</span> <span class="na">android:scheme=</span><span class="s">"@string/kakao_scheme"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/intent-filter&gt;</span>
    <span class="nt">&lt;/activity&gt;</span>

    <span class="c">&lt;!-- 카카오 인증 코드 핸들러 --&gt;</span>
    <span class="nt">&lt;activity</span>
        <span class="na">android:name=</span><span class="s">"com.kakao.sdk.auth.AuthCodeHandlerActivity"</span>
        <span class="na">android:exported=</span><span class="s">"true"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;intent-filter&gt;</span>
            <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">"android.intent.action.VIEW"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.DEFAULT"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.BROWSABLE"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;data</span> <span class="na">android:host=</span><span class="s">"oauth"</span> <span class="na">android:scheme=</span><span class="s">"@string/kakao_scheme"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/intent-filter&gt;</span>
    <span class="nt">&lt;/activity&gt;</span>
<span class="nt">&lt;/application&gt;</span>
</code></pre></div></div>

<h4 id="123-stringsxml-설정">1.2.3 strings.xml 설정</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/src/main/res/values/strings.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;resources&gt;</span>
    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">"kakao_app_key"</span><span class="nt">&gt;</span>YOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">"kakao_scheme"</span><span class="nt">&gt;</span>kakaoYOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>
<span class="nt">&lt;/resources&gt;</span>
</code></pre></div></div>

<h4 id="124-mainactivityjava-초기화">1.2.4 MainActivity.java 초기화</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/src/main/java/com/yourpackage/app/MainActivity.java</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">com.kakao.sdk.common.KakaoSdk</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="nc">BridgeActivity</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="nc">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>

        <span class="c1">// 카카오 SDK 초기화</span>
        <span class="nc">KakaoSdk</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">getResources</span><span class="o">().</span><span class="na">getString</span><span class="o">(</span><span class="no">R</span><span class="o">.</span><span class="na">string</span><span class="o">.</span><span class="na">kakao_app_key</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="13-ios-설정">1.3 iOS 설정</h3>

<h4 id="131-infoplist-설정">1.3.1 Info.plist 설정</h4>

<p><code class="language-plaintext highlighter-rouge">ios/App/App/Info.plist</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;key&gt;</span>KAKAO_APP_KEY<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;string&gt;</span>YOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>

<span class="nt">&lt;key&gt;</span>CFBundleURLTypes<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;array&gt;</span>
    <span class="nt">&lt;dict&gt;</span>
        <span class="nt">&lt;key&gt;</span>CFBundleURLSchemes<span class="nt">&lt;/key&gt;</span>
        <span class="nt">&lt;array&gt;</span>
            <span class="nt">&lt;string&gt;</span>kakaoYOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>
            <span class="nt">&lt;string&gt;</span>com.yourapp.bundleid<span class="nt">&lt;/string&gt;</span>
        <span class="nt">&lt;/array&gt;</span>
    <span class="nt">&lt;/dict&gt;</span>
<span class="nt">&lt;/array&gt;</span>

<span class="nt">&lt;key&gt;</span>LSApplicationQueriesSchemes<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;array&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaoYOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaokompassauth<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>storykompassauth<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaolink<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>storylink<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaotalk<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaotalk-5.9.7<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaostory-2.9.0<span class="nt">&lt;/string&gt;</span>
<span class="nt">&lt;/array&gt;</span>
</code></pre></div></div>

<h4 id="132-appdelegateswift-초기화">1.3.2 AppDelegate.swift 초기화</h4>

<p><code class="language-plaintext highlighter-rouge">ios/App/App/AppDelegate.swift</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">KakaoSDKAuth</span>
<span class="kd">import</span> <span class="kt">KakaoSDKCommon</span>

<span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="n">_</span> <span class="nv">application</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="p">,</span> <span class="n">didFinishLaunchingWithOptions</span> <span class="nv">launchOptions</span><span class="p">:</span> <span class="p">[</span><span class="kt">UIApplication</span><span class="o">.</span><span class="kt">LaunchOptionsKey</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]?)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">key</span> <span class="o">=</span> <span class="kt">Bundle</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">infoDictionary</span><span class="p">?[</span><span class="s">"KAKAO_APP_KEY"</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">String</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">kakaoKey</span> <span class="o">=</span> <span class="n">key</span> <span class="p">{</span>
        <span class="kt">KakaoSDK</span><span class="o">.</span><span class="nf">initSDK</span><span class="p">(</span><span class="nv">appKey</span><span class="p">:</span> <span class="n">kakaoKey</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="n">_</span> <span class="nv">app</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="p">,</span> <span class="kd">open</span> <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="kt">UIApplication</span><span class="o">.</span><span class="kt">OpenURLOptionsKey</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:])</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="kt">AuthApi</span><span class="o">.</span><span class="nf">isKakaoTalkLoginUrl</span><span class="p">(</span><span class="n">url</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">AuthController</span><span class="o">.</span><span class="nf">handleOpenUrl</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kt">ApplicationDelegateProxy</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">application</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="nv">open</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="n">options</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="14-프론트엔드-코드">1.4 프론트엔드 코드</h3>

<p><code class="language-plaintext highlighter-rouge">client/lib/auth.ts</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">KakaoLoginPlugin</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">capacitor-kakao-login-plugin</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">startSocialLogin</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">provider</span><span class="p">:</span> <span class="nx">OAuthProvider</span>
<span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isMobile</span> <span class="o">=</span> <span class="nx">Capacitor</span><span class="p">.</span><span class="nx">isNativePlatform</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">isMobile</span> <span class="o">&amp;&amp;</span> <span class="nx">provider</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">kakao</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 카카오 네이티브 로그인 실행</span>
      <span class="kd">const</span> <span class="nx">kakaoResult</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">KakaoLoginPlugin</span><span class="p">.</span><span class="nx">goLogin</span><span class="p">();</span>

      <span class="c1">// 카카오 액세스 토큰을 백엔드로 전달</span>
      <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">processKakaoNativeLogin</span><span class="p">(</span><span class="nx">kakaoResult</span><span class="p">.</span><span class="nx">accessToken</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span>
          <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">"</span><span class="s2">oauth-login-success</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
            <span class="na">detail</span><span class="p">:</span> <span class="p">{</span> <span class="na">userInfo</span><span class="p">:</span> <span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">user_info</span> <span class="p">},</span>
          <span class="p">})</span>
        <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span>
        <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">"</span><span class="s2">oauth-login-error</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
          <span class="na">detail</span><span class="p">:</span> <span class="p">{</span> <span class="na">error</span><span class="p">:</span> <span class="nx">error</span><span class="p">.</span><span class="nx">message</span> <span class="p">},</span>
        <span class="p">})</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 웹: 일반 OAuth 리다이렉트</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="nx">config</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">authorization_url</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 백엔드로 카카오 토큰 전달</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">processKakaoNativeLogin</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">kakaoAccessToken</span><span class="p">:</span> <span class="kr">string</span>
<span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">OAuthLoginResponse</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">getApiUrl</span><span class="p">()}</span><span class="s2">/v1/auth/oauth/kakao/native`</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span> <span class="p">},</span>
    <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
      <span class="na">kakao_access_token</span><span class="p">:</span> <span class="nx">kakaoAccessToken</span><span class="p">,</span>
      <span class="na">device_info</span><span class="p">:</span> <span class="s2">`</span><span class="p">${</span><span class="nb">navigator</span><span class="p">.</span><span class="nx">platform</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nb">navigator</span><span class="p">.</span><span class="nx">userAgent</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
    <span class="p">}),</span>
    <span class="na">credentials</span><span class="p">:</span> <span class="dl">"</span><span class="s2">include</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="15-카카오-개발자-콘솔-설정">1.5 카카오 개발자 콘솔 설정</h3>

<ol>
  <li>
    <p><strong>키 해시 등록</strong> (Android)</p>

    <ul>
      <li>Android Studio Logcat에서 SHA-1, SHA-256 키 해시 확인</li>
      <li>카카오 개발자 콘솔 → 내 애플리케이션 → 플랫폼 → Android → 키 해시 등록</li>
    </ul>
  </li>
  <li>
    <p><strong>리다이렉트 URI 설정</strong></p>
    <ul>
      <li>Android: <code class="language-plaintext highlighter-rouge">kakao{NATIVE_APP_KEY}://oauth</code></li>
      <li>iOS: <code class="language-plaintext highlighter-rouge">kakao{NATIVE_APP_KEY}://oauth</code></li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="2-구글-네이티브-로그인-구현">2. 구글 네이티브 로그인 구현</h2>

<h3 id="21-플러그인-설치">2.1 플러그인 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pnpm add @codetrix-studio/capacitor-google-auth
npx cap <span class="nb">sync</span>
</code></pre></div></div>

<h3 id="22-google-console-설정">2.2 Google Console 설정</h3>

<h4 id="221-웹-클라이언트-id-생성">2.2.1 웹 클라이언트 ID 생성</h4>

<ol>
  <li>Google Console → API 및 서비스 → 사용자 인증 정보</li>
  <li>
    <ul>
      <li>사용자 인증 정보 만들기 → OAuth 2.0 클라이언트 ID</li>
    </ul>
  </li>
  <li>애플리케이션 유형: <strong>웹 애플리케이션</strong></li>
  <li>생성된 클라이언트 ID를 복사</li>
</ol>

<h4 id="222-android-클라이언트-id-생성">2.2.2 Android 클라이언트 ID 생성</h4>

<ol>
  <li>
    <ul>
      <li>사용자 인증 정보 만들기 → OAuth 2.0 클라이언트 ID</li>
    </ul>
  </li>
  <li>애플리케이션 유형: <strong>Android</strong></li>
  <li>패키지 이름: <code class="language-plaintext highlighter-rouge">com.yourapp.bundleid</code></li>
  <li><strong>SHA-1 인증서 지문 등록</strong> (중요!)</li>
</ol>

<p><strong>SHA-1 지문 확인 방법:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 디버그 키스토어</span>
keytool <span class="nt">-list</span> <span class="nt">-v</span> <span class="nt">-keystore</span> ~/.android/debug.keystore <span class="nt">-alias</span> androiddebugkey <span class="nt">-storepass</span> android <span class="nt">-keypass</span> android

<span class="c"># 또는 MainActivity에서 로그로 확인</span>
</code></pre></div></div>

<p>SHA-1 지문을 <strong>콜론 없이</strong> 등록</p>

<h4 id="223-ios-클라이언트-id-생성-선택">2.2.3 iOS 클라이언트 ID 생성 (선택)</h4>

<ol>
  <li>
    <ul>
      <li>사용자 인증 정보 만들기 → OAuth 2.0 클라이언트 ID</li>
    </ul>
  </li>
  <li>애플리케이션 유형: <strong>iOS</strong></li>
  <li>번들 ID: <code class="language-plaintext highlighter-rouge">com.yourapp.bundleid</code></li>
  <li><code class="language-plaintext highlighter-rouge">GoogleService.plist</code> 파일 다운로드</li>
</ol>

<h3 id="23-android-설정">2.3 Android 설정</h3>

<h4 id="231-stringsxml-설정">2.3.1 strings.xml 설정</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/src/main/res/values/strings.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;resources&gt;</span>
    <span class="c">&lt;!-- 웹 클라이언트 ID (server_client_id) --&gt;</span>
    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">"server_client_id"</span><span class="nt">&gt;</span>YOUR_WEB_CLIENT_ID.apps.googleusercontent.com<span class="nt">&lt;/string&gt;</span>
<span class="nt">&lt;/resources&gt;</span>
</code></pre></div></div>

<p><strong>참고</strong>: Android 클라이언트 ID는 코드에 넣을 필요 없습니다. 플러그인이 자동으로 사용합니다.</p>

<h4 id="232-androidmanifestxml-권한-추가">2.3.2 AndroidManifest.xml 권한 추가</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;uses-permission</span> <span class="na">android:name=</span><span class="s">"android.permission.GET_ACCOUNTS"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<h4 id="233-capacitorconfigts-설정">2.3.3 capacitor.config.ts 설정</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">GoogleAuth</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">scopes</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">profile</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">email</span><span class="dl">"</span><span class="p">],</span>
      <span class="na">serverClientId</span><span class="p">:</span> <span class="dl">"</span><span class="s2">YOUR_WEB_CLIENT_ID.apps.googleusercontent.com</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">forceCodeForRefreshToken</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="24-ios-설정">2.4 iOS 설정</h3>

<h4 id="241-googleserviceplist-추가">2.4.1 GoogleService.plist 추가</h4>

<ol>
  <li>Google Console에서 다운로드한 <code class="language-plaintext highlighter-rouge">GoogleService.plist</code> 파일을</li>
  <li><code class="language-plaintext highlighter-rouge">ios/App/App/</code> 폴더에 복사</li>
</ol>

<h4 id="242-infoplist-설정">2.4.2 Info.plist 설정</h4>

<p><code class="language-plaintext highlighter-rouge">ios/App/App/Info.plist</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;key&gt;</span>CFBundleURLTypes<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;array&gt;</span>
    <span class="nt">&lt;dict&gt;</span>
        <span class="nt">&lt;key&gt;</span>CFBundleURLSchemes<span class="nt">&lt;/key&gt;</span>
        <span class="nt">&lt;array&gt;</span>
            <span class="nt">&lt;string&gt;</span>com.yourapp.bundleid<span class="nt">&lt;/string&gt;</span>
            <span class="c">&lt;!-- GoogleService.plist의 REVERSED_CLIENT_ID 값 --&gt;</span>
            <span class="nt">&lt;string&gt;</span>YOUR_REVERSED_CLIENT_ID<span class="nt">&lt;/string&gt;</span>
        <span class="nt">&lt;/array&gt;</span>
    <span class="nt">&lt;/dict&gt;</span>
<span class="nt">&lt;/array&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">REVERSED_CLIENT_ID</code>는 <code class="language-plaintext highlighter-rouge">GoogleService.plist</code> 파일에서 확인할 수 있습니다.</p>

<h3 id="25-프론트엔드-코드">2.5 프론트엔드 코드</h3>

<p><code class="language-plaintext highlighter-rouge">client/lib/auth.ts</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">GoogleAuth</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@codetrix-studio/capacitor-google-auth</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">startSocialLogin</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">provider</span><span class="p">:</span> <span class="nx">OAuthProvider</span>
<span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isMobile</span> <span class="o">=</span> <span class="nx">Capacitor</span><span class="p">.</span><span class="nx">isNativePlatform</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">isMobile</span> <span class="o">&amp;&amp;</span> <span class="nx">provider</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">google</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 구글 플러그인 초기화 (scopes 포함)</span>
      <span class="k">await</span> <span class="nx">GoogleAuth</span><span class="p">.</span><span class="nx">initialize</span><span class="p">({</span>
        <span class="na">scopes</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">profile</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">email</span><span class="dl">"</span><span class="p">],</span>
      <span class="p">});</span>

      <span class="c1">// 구글 네이티브 로그인 실행</span>
      <span class="kd">const</span> <span class="nx">googleResult</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">GoogleAuth</span><span class="p">.</span><span class="nx">signIn</span><span class="p">();</span>

      <span class="c1">// 구글 ID 토큰을 백엔드로 전달</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">googleResult</span><span class="p">.</span><span class="nx">authentication</span><span class="p">?.</span><span class="nx">idToken</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">구글 ID 토큰을 받지 못했습니다.</span><span class="dl">"</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">processGoogleNativeLogin</span><span class="p">(</span>
        <span class="nx">googleResult</span><span class="p">.</span><span class="nx">authentication</span><span class="p">.</span><span class="nx">idToken</span>
      <span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span>
          <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">"</span><span class="s2">oauth-login-success</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
            <span class="na">detail</span><span class="p">:</span> <span class="p">{</span> <span class="na">userInfo</span><span class="p">:</span> <span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">user_info</span> <span class="p">},</span>
          <span class="p">})</span>
        <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span>
        <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">"</span><span class="s2">oauth-login-error</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
          <span class="na">detail</span><span class="p">:</span> <span class="p">{</span> <span class="na">error</span><span class="p">:</span> <span class="nx">error</span><span class="p">.</span><span class="nx">message</span> <span class="p">},</span>
        <span class="p">})</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 웹: 일반 OAuth 리다이렉트</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="nx">config</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">authorization_url</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 백엔드로 구글 ID 토큰 전달</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">processGoogleNativeLogin</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">googleIdToken</span><span class="p">:</span> <span class="kr">string</span>
<span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">OAuthLoginResponse</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">getApiUrl</span><span class="p">()}</span><span class="s2">/v1/auth/oauth/google/native`</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span> <span class="p">},</span>
    <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
      <span class="na">google_id_token</span><span class="p">:</span> <span class="nx">googleIdToken</span><span class="p">,</span>
      <span class="na">device_info</span><span class="p">:</span> <span class="s2">`</span><span class="p">${</span><span class="nb">navigator</span><span class="p">.</span><span class="nx">platform</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nb">navigator</span><span class="p">.</span><span class="nx">userAgent</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
    <span class="p">}),</span>
    <span class="na">credentials</span><span class="p">:</span> <span class="dl">"</span><span class="s2">include</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="26-웹-설정-선택">2.6 웹 설정 (선택)</h3>

<p><code class="language-plaintext highlighter-rouge">index.html</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;meta</span>
  <span class="na">name=</span><span class="s">"google-signin-client_id"</span>
  <span class="na">content=</span><span class="s">"YOUR_WEB_CLIENT_ID.apps.googleusercontent.com"</span>
<span class="nt">/&gt;</span>
</code></pre></div></div>

<hr />

<h2 id="3-백엔드-api-엔드포인트">3. 백엔드 API 엔드포인트</h2>

<h3 id="31-카카오-네이티브-로그인">3.1 카카오 네이티브 로그인</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /v1/auth/oauth/kakao/native
Content-Type: application/json

{
  "kakao_access_token": "카카오_액세스_토큰",
  "device_info": "플랫폼 정보"
}
</code></pre></div></div>

<h3 id="32-구글-네이티브-로그인">3.2 구글 네이티브 로그인</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /v1/auth/oauth/google/native
Content-Type: application/json

{
  "google_id_token": "구글_ID_토큰",
  "device_info": "플랫폼 정보"
}
</code></pre></div></div>

<hr />

<h2 id="4-체크리스트">4. 체크리스트</h2>

<h3 id="카카오-로그인">카카오 로그인</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><code class="language-plaintext highlighter-rouge">capacitor-kakao-login-plugin</code> 설치</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: Kakao SDK 의존성 추가</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code> 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">strings.xml</code>에 앱 키 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">MainActivity.java</code>에서 SDK 초기화</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />iOS: <code class="language-plaintext highlighter-rouge">Info.plist</code> 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />iOS: <code class="language-plaintext highlighter-rouge">AppDelegate.swift</code>에서 SDK 초기화</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />카카오 개발자 콘솔에 키 해시 등록</li>
</ul>

<h3 id="구글-로그인">구글 로그인</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><code class="language-plaintext highlighter-rouge">@codetrix-studio/capacitor-google-auth</code> 설치</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Google Console에 웹 클라이언트 ID 생성</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Google Console에 Android 클라이언트 ID 생성 (SHA-1 지문 등록)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Google Console에 iOS 클라이언트 ID 생성 (선택)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">strings.xml</code>에 웹 클라이언트 ID 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">capacitor.config.ts</code> 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />iOS: <code class="language-plaintext highlighter-rouge">GoogleService.plist</code> 추가</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />iOS: <code class="language-plaintext highlighter-rouge">Info.plist</code>에 <code class="language-plaintext highlighter-rouge">REVERSED_CLIENT_ID</code> 추가</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />웹: <code class="language-plaintext highlighter-rouge">index.html</code>에 meta tag 추가</li>
</ul>

<hr />

<h2 id="5-참고-자료">5. 참고 자료</h2>

<ul>
  <li><a href="https://capacitorjs.com/docs">Capacitor 공식 문서</a></li>
  <li><a href="https://developers.kakao.com/docs/latest/ko/flutter/getting-started#project-scheme">Kakao developer</a></li>
  <li><a href="https://github.com/nerdFrenzs/capacitor-kakao-login-plugin">capacitor-kakao-login-plugin</a></li>
  <li><a href="https://github.com/CodetrixStudio/CapacitorGoogleAuth">@codetrix-studio/capacitor-google-auth</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 Android 앱에서 카카오/구글 네이티브 로그인을 구현한 방법에 대해 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor Android 앱 로그인 연동 CORS 트러블 슈팅</title><link href="https://nan0silver.github.io/projectdiary/2025-11-10-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor Android 앱 로그인 연동 CORS 트러블 슈팅" /><published>2025-11-10T00:00:00+00:00</published><updated>2025-11-28T05:51:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-10-diary/"><![CDATA[<ul>
  <li>지난 글에서는 Capacitor로 Android, iOS 앱 빌드하는 방법에 대해 다뤘다.</li>
  <li>이번 글에서는 Capacitor로 빌드한 Android 앱에서 로그인 연동을 하는 방법에 대해 다뤄보겠다.</li>
  <li>특히 CORS 에러 해결에 대해 다뤄보겠다..
    <blockquote>
      <p>저번에 한번 여기까진 해결을 했었는데,, 다 밀고 다시하는 과정에서 까먹어서.. 이번에도 삽질을 했다..🥲 <del>진짜 울뻔함</del></p>
    </blockquote>
  </li>
</ul>

<h2 id="문제-상황">문제 상황</h2>

<ul>
  <li>일단 내 프로젝트의 상황을 말하자면</li>
</ul>

<ol>
  <li>React로 웹 빌드시 nginx 사용하고 있음</li>
  <li>Android 앱 빌드 (Capacitor로 감싸고 있음)</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>앱/웹] → HTTPS <span class="o">(</span>443<span class="o">)</span> → <span class="o">[</span>Nginx] → HTTP <span class="o">(</span>8080<span class="o">)</span> → <span class="o">[</span>Spring Boot]
</code></pre></div></div>

<ul>
  <li>
    <p>Nginx의 역할은</p>

    <ol>
      <li>SSL 종료
        <ul>
          <li>HTTPS를 HTTP로 변환</li>
        </ul>
      </li>
      <li>리버스 프록시
        <ul>
          <li>요청을 8080포트로 전달</li>
        </ul>
      </li>
      <li>‼️ 문제 : OPTIONS preflight 요청이 여기서 자꾸 막혔다.🤮</li>
    </ol>

    <p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-10-pic1.png?raw=true" alt="에러 이미지" />
<img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-10-pic2.png?raw=true" alt="에러 이미지2" /></p>
  </li>
</ul>

<h3 id="증상">증상</h3>

<p><strong>웹 (https://chingoohaja.app)</strong>: ✅ 로그인 정상 작동<br />
<strong>앱 (https://localhost)</strong>: ❌ CORS 에러 발생</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Access to fetch at 'https://silverld.site/api/v1/auth/refresh'
from origin 'https://localhost' has been blocked by CORS policy
</code></pre></div></div>

<h3 id="왜-웹은-되고-앱은-안될까">왜 웹은 되고 앱은 안될까?</h3>

<ul>
  <li>웹 브라우저와 Capacitor WebView는 preflight OPTIONS 요청을 다르게 보낸다.</li>
</ul>

<ol>
  <li>웹
    <ul>
      <li>Origin이 <code class="language-plaintext highlighter-rouge">https://chingoohaja.app</code> -&gt; Nginx가 통과시킴</li>
    </ul>
  </li>
  <li>앱
    <ul>
      <li>Origin이 <code class="language-plaintext highlighter-rouge">https:/localhost</code> -&gt; Nginx가 의심
        <blockquote>
          <p>Capacitor의 URL/orign은 아래와 같다</p>

          <blockquote>
            <p>iOS: capacitor://localhost
Android: http://localhost</p>
          </blockquote>
        </blockquote>
      </li>
    </ul>
  </li>
</ol>

<ul>
  <li>서버에서 Cors설정과 Security설정은 다 해놨다.</li>
  <li>그런데도 CORS 에러가 해결되지않아서 Nginx 설정 파일을 손을 댔다
    <ul>
      <li>도메인들을 Nginx에서 동적으로 orign 반환하는 형식으로도 수정을 해봤고..</li>
      <li>모든 도메인을 다 허용도 해봤고..</li>
    </ul>
  </li>
  <li>그런데 CORS 문제는 해결이 되지않았다..!</li>
  <li>하지만 해결방법은 생각보다 간단했다..</li>
</ul>

<h2 id="해결-방법">해결 방법</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">capacitor.config.ts</code>파일에 capacitor의 HTTP 플러그인을 추가해준다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plugins: {
    CapacitorHttp: {
      enabled: true,
    },
  },
</code></pre></div></div>

<h3 id="왜-이게-작동하는가">왜 이게 작동하는가?</h3>

<p><strong>일반 fetch API</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>App WebView → Browser CORS Check → ❌ Blocked
</code></pre></div></div>

<p><strong>Capacitor HTTP 플러그인</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>App → Native HTTP Client → 🚀 Direct Connection (CORS 우회)
</code></pre></div></div>

<p>네이티브 HTTP 클라이언트는 브라우저의 CORS 정책을 따르지 않고 <strong>직접 서버와 통신</strong>한다.</p>

<ul>
  <li>
    <p>물론 서버에서 설정을 다 해준 다음 이 코드도 추가해줘야한다.</p>
  </li>
  <li>이틀간의 삽질이 끝났다..</li>
  <li>이제 리다이렉트 지옥이 시작임</li>
</ul>

<h2 id="핵심-교훈">핵심 교훈</h2>

<h3 id="문제-해결-과정에서-배운-것">문제 해결 과정에서 배운 것</h3>

<ol>
  <li>
    <p><strong>레이어별 디버깅의 중요성</strong></p>

    <ul>
      <li>Frontend (Capacitor) → Nginx → Spring Boot 순서로 단계별 확인</li>
      <li>백엔드 로그에 아무것도 안 찍힌다 = 앞단에서 막힌 것</li>
    </ul>
  </li>
  <li>
    <p><strong>브라우저 vs 네이티브의 차이</strong></p>

    <ul>
      <li>WebView의 <code class="language-plaintext highlighter-rouge">fetch</code>는 브라우저 CORS 정책 따름</li>
      <li>네이티브 HTTP는 CORS 우회 가능</li>
    </ul>
  </li>
  <li>
    <p><strong>Mixed Content 정책</strong></p>
    <ul>
      <li>HTTPS 페이지는 HTTP 리소스 차단</li>
      <li>Nginx를 통한 HTTPS 통신 필수</li>
    </ul>
  </li>
</ol>

<h3 id="주의사항">주의사항</h3>

<p>⚠️ <strong>Capacitor HTTP 플러그인 활성화 시</strong>:</p>

<ul>
  <li>기존 <code class="language-plaintext highlighter-rouge">fetch</code> API 동작 변경 가능</li>
  <li>웹과 앱의 네트워크 동작이 달라질 수 있음</li>
  <li>충분한 테스트 필요</li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-10-pic3.png?raw=true" alt="코드래빗의 평" /></p>

<h3 id="참고-문헌">참고 문헌</h3>

<ul>
  <li><a href="https://stackoverflow.com/questions/75192411/cors-in-capacitor-for-android">StackOverFlow가 짱이야</a></li>
  <li><a href="https://capacitorjs.com/docs/apis/http">Capacitor HTTP Plugin 공식 문서</a></li>
  <li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/CORS">MDN - CORS</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 Android 앱 로그인 연동 해보자! - CORS 에러 해결에 대해 다룹니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor로 웹을 앱으로 빌드해보자!</title><link href="https://nan0silver.github.io/projectdiary/2025-11-06-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor로 웹을 앱으로 빌드해보자!" /><published>2025-11-06T00:00:00+00:00</published><updated>2025-11-28T05:51:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-06-diary/"><![CDATA[<ul>
  <li>“친구하자”를 웹으로 MVP 완성을 하니, 이걸 앱으로 빌드해서 사용자들이 더 쉽게 사용할 수 있으면 좋겠다고 생각했다.</li>
  <li>원래는.. 개발자의 입장으로 링크로 이동하는 방식이 쉬울꺼라고 생각했는데, 막상 사용자에게 링크를 보내주니까 어려움을 토로하거나 방식에 의문을 가지는 사람들이 많았다..
    <ul>
      <li>링크는 일단 어디 저장해놓고 찾아서 연결해야하고..</li>
      <li>핸드폰에서 링크를 통해 이동하는 방식이 익숙하지 않은 사람들이 더 많았다.. (일회용 링크정도만 다들 사용하는 것 같았다.)</li>
    </ul>
  </li>
  <li>네이티브 앱으로 개발하는건 일단 시간이 많이 드니까 최대한 빠른 방법을 찾아보다가 Capacitor 플러그인을 찾게 되었다.</li>
</ul>

<h2 id="capacitor">Capacitor</h2>

<ul>
  <li><a href="https://capacitorjs.com/">Capacitor</a>는 기존 React웹을 네이티브 앱 컨테이너에 담아주는 플러그인이다.</li>
  <li>기존의 React 코드베이스를 거의 건들이지 않고 모바일 앱을 만들 수 있게 해준다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>기존 React 웹 앱
         ↓
    Capacitor 추가
         ↓
네이티브 WebView에서 실행
(iOS/Android 앱으로 패키징)
</code></pre></div></div>

<ul>
  <li>설치만 해서 간단하게 앱으로 빌드할 수 있다!</li>
  <li>일단 나는 ios로 빌드하는 것을 아래에 보여주겠다.</li>
</ul>

<h2 id="capacitor로-ios-앱-빌드하기">Capacitor로 iOS 앱 빌드하기</h2>

<ul>
  <li>
    <p>일단 내 기존 프론트 프로젝트 스펙을 정리하자면</p>

    <ul>
      <li>많은 의존성을 가짐(특히 @radix-ui/* 패키지들)</li>
      <li>React 18 + TypeScript + Vite 스택</li>
      <li>Express 서버 통합</li>
    </ul>
  </li>
  <li>따라서 npm이 아닌 pnpm을 사용하고 있다.</li>
  <li>capacitor 공식문서에는 npm으로 설명이 나와있는데, 그냥 pnpm 명령어로만 바꿔서 똑같이 진행해줬다.</li>
</ul>

<h3 id="1-capacitor의-메인-의존성-설치">1. Capacitor의 메인 의존성 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pnpm add @capacitor/core @capacitor/cli
</code></pre></div></div>

<p>프로젝트 루트 디렉토리에 위의 명령어를 입력!</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic1.png?raw=true" alt="성공 이미지" /></p>

<h3 id="2-capacitor-config-초기화">2. Capacitor Config 초기화</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npx cap init
</code></pre></div></div>

<ul>
  <li>여기서는 이름과, Project ID를 입력하라고 한다.</li>
  <li>Project ID는 도메인 네임 형태로 적어주면 된다. (예: com.example.app)</li>
  <li>나는 프론트 도메인을 사놓은게 있어서 그대로 넣었다.</li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic2.png?raw=true" alt="성공 이미지2" /></p>

<h3 id="3-플랫폼-추가-android-ios">3. 플랫폼 추가 (android, iOS)</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Android</span>
pnpm add @capacitor/android

<span class="c"># iOS (macOS에서만)</span>
pnpm add @capacitor/android
</code></pre></div></div>

<ul>
  <li>
    <p>나는 맥북에서 작업하고 있기 때문에 둘다 추가해줬다.</p>

    <blockquote>
      <p>ios 만들고 싶어서 3년전에 맥북 샀던 기억..</p>
    </blockquote>
  </li>
  <li>
    <p>성공하면 아래와 같은 메시지가 나온다.</p>
  </li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic3.png?raw=true" alt="성공 이미지3" /></p>

<h3 id="이제-실행해보자">이제 실행해보자!!</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Android</span>
npx cap run android

<span class="c"># iOS</span>
npx cap run ios
</code></pre></div></div>

<p>일단 ios로 아래와 같이 실행 성공!</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic4.png?raw=true" alt="성공 이미지4" height="500" /></p>

<p><br />
다음에 android studio 업데이트를 좀 하고.. (안한지 넘 오래됌..) 아래와 같이 빌드 성공!</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic5.png?raw=true" alt="성공 이미지5" height="500" /></p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[웹을 앱으로 빠르게 빌드하기 위해 Capacitor를 사용해보기]]></summary></entry><entry><title type="html">[Algorithm] 코테에서 자주 쓰이는 Collection 모음</title><link href="https://nan0silver.github.io/algorithm/2025-10-23-collections/" rel="alternate" type="text/html" title="[Algorithm] 코테에서 자주 쓰이는 Collection 모음" /><published>2025-10-23T00:00:00+00:00</published><updated>2025-11-28T05:51:20+00:00</updated><id>https://nan0silver.github.io/algorithm/collections</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2025-10-23-collections/"><![CDATA[<ol>
  <li><a href="#️-1️⃣-hashmapk-v--key-value-형태로-빠르게-찾고-세는-용도">HashMap</a></li>
  <li><a href="#-2️⃣-hashset--중복-없는-데이터-저장">HashSet</a></li>
  <li><a href="#-3️⃣-arraylist--순서-있는-리스트-인덱스-접근-가능">ArrayList</a></li>
  <li><a href="#-4️⃣-priorityqueue--우선순위-큐-힙">PriorityQueue</a></li>
  <li><a href="#-5️⃣-stack--queue-deque--선형-구조">Stack / Queue</a></li>
  <li><a href="#-6️⃣-collections--arrays-유틸리티-메서드">Collections / Arrays</a></li>
  <li><a href="#-추천-연습문제-유형별-활용-예시">추천 연습문제 유형별 활용 예시</a></li>
</ol>

<hr />

<h2 id="️-1️⃣-hashmapk-v--key-value-형태로-빠르게-찾고-세는-용도">🗂️ 1️⃣ HashMap&lt;K, V&gt; — key-value 형태로 빠르게 찾고 세는 용도</h2>

<h3 id="-핵심-활용-상황">💡 핵심 활용 상황</h3>

<ul>
  <li>“이 값이 몇 번 나왔는가?”</li>
  <li>“이 key가 이미 존재하나?”</li>
  <li>“카테고리별 개수 세기 (위장 문제 등)”</li>
</ul>

<h3 id="-자주-쓰는-메서드">🚀 자주 쓰는 메서드</h3>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
      <th>예시 코드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">put(K key, V value)</code></td>
      <td>값 삽입 (덮어씀)</td>
      <td><code class="language-plaintext highlighter-rouge">map.put("apple", 3);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">get(K key)</code></td>
      <td>key로 value 조회</td>
      <td><code class="language-plaintext highlighter-rouge">int v = map.get("apple");</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">getOrDefault(K key, V defaultVal)</code></td>
      <td>key 없으면 기본값 반환</td>
      <td><code class="language-plaintext highlighter-rouge">map.getOrDefault("pear", 0);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">containsKey(K key)</code></td>
      <td>key 존재 여부</td>
      <td><code class="language-plaintext highlighter-rouge">if (map.containsKey("apple"))</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(K key)</code></td>
      <td>key/value 쌍 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">map.remove("apple");</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">keySet()</code></td>
      <td>모든 key 조회</td>
      <td><code class="language-plaintext highlighter-rouge">for (String k : map.keySet())</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">values()</code></td>
      <td>모든 value 조회</td>
      <td><code class="language-plaintext highlighter-rouge">for (int v : map.values())</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">entrySet()</code></td>
      <td>key+value 동시 접근</td>
      <td>`for (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) {</td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> System.out.println(e.getKey() + " → " + e.getValue());
</code></pre></div></div>

<p>}<code class="language-plaintext highlighter-rouge">|
|</code>size()<code class="language-plaintext highlighter-rouge">| 원소 수 |</code>map.size();<code class="language-plaintext highlighter-rouge">|
|</code>clear()<code class="language-plaintext highlighter-rouge">| 모두 삭제 |</code>map.clear();` |</p>

<hr />

<h2 id="-2️⃣-hashset--중복-없는-데이터-저장">🧩 2️⃣ HashSet — 중복 없는 데이터 저장</h2>

<h3 id="-핵심-활용-상황-1">💡 핵심 활용 상황</h3>

<ul>
  <li>“이미 나온 적 있는 값인가?”</li>
  <li>“교집합, 중복 제거”</li>
  <li>“전화번호부 접두사, 참가자 중 완주 못한 사람 찾기 등”</li>
</ul>

<h3 id="-자주-쓰는-메서드-1">🚀 자주 쓰는 메서드</h3>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
      <th>예시 코드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(E e)</code></td>
      <td>원소 추가</td>
      <td><code class="language-plaintext highlighter-rouge">set.add("apple");</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">contains(E e)</code></td>
      <td>포함 여부 확인</td>
      <td><code class="language-plaintext highlighter-rouge">if (set.contains("apple"))</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(E e)</code></td>
      <td>원소 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">set.remove("apple");</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td>원소 개수</td>
      <td><code class="language-plaintext highlighter-rouge">set.size();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">clear()</code></td>
      <td>모두 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">set.clear();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td>비었는지 확인</td>
      <td><code class="language-plaintext highlighter-rouge">if (set.isEmpty())</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">iterator()</code></td>
      <td>순회용 Iterator 생성</td>
      <td><code class="language-plaintext highlighter-rouge">for (String s : set) System.out.println(s);</code></td>
    </tr>
  </tbody>
</table>

<p>or
<code class="language-plaintext highlighter-rouge">Iterator&lt;String&gt; it = set.iterator();
while (it.hasNext()) {
      System.out.println(it.next());
}</code> |</p>

<blockquote>
  <p>💡 참고: HashSet은 내부적으로 HashMap을 사용하므로 add, contains 모두 O(1)입니다.</p>
</blockquote>

<hr />

<h2 id="-3️⃣-arraylist--순서-있는-리스트-인덱스-접근-가능">📋 3️⃣ ArrayList — 순서 있는 리스트 (인덱스 접근 가능)</h2>

<h3 id="-핵심-활용-상황-2">💡 핵심 활용 상황</h3>

<ul>
  <li>“순차적 접근”, “정렬”, “조합/순열 저장”</li>
  <li>BFS/DFS에서 방문 순서 저장 등</li>
</ul>

<h3 id="-자주-쓰는-메서드-2">🚀 자주 쓰는 메서드</h3>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
      <th>예시 코드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(E e)</code></td>
      <td>끝에 추가</td>
      <td><code class="language-plaintext highlighter-rouge">list.add(5);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(int idx, E e)</code></td>
      <td>인덱스에 삽입</td>
      <td><code class="language-plaintext highlighter-rouge">list.add(1, 10);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">get(int idx)</code></td>
      <td>특정 인덱스 조회</td>
      <td><code class="language-plaintext highlighter-rouge">list.get(0);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">set(int idx, E e)</code></td>
      <td>특정 위치 값 수정</td>
      <td><code class="language-plaintext highlighter-rouge">list.set(2, 99);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(int idx)</code></td>
      <td>인덱스로 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">list.remove(1);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">contains(E e)</code></td>
      <td>포함 여부</td>
      <td><code class="language-plaintext highlighter-rouge">if (list.contains(5))</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td>크기 확인</td>
      <td><code class="language-plaintext highlighter-rouge">list.size();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">clear()</code></td>
      <td>모두 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">list.clear();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sort(Comparator&lt;? super E&gt; c)</code></td>
      <td>정렬</td>
      <td>`Arrays.sort(arr, new Comparator<String>() {</String></td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        @Override
        public int compare(String o1, String o2) {
            if (o1.length()==o2.length()) {
                return o1.compareTo(o2);
            } else {
                return o1.length()-o2.length();
            }}});` |
</code></pre></div></div>

<hr />

<h2 id="-4️⃣-priorityqueue--우선순위-큐-힙">🧮 4️⃣ PriorityQueue — 우선순위 큐 (힙)</h2>

<h3 id="-핵심-활용-상황-3">💡 핵심 활용 상황</h3>

<ul>
  <li>“가장 작은/큰 값”을 반복적으로 꺼낼 때 (Dijkstra, HeapSort, 스케줄링 문제 등)</li>
</ul>

<h3 id="-자주-쓰는-메서드-3">🚀 자주 쓰는 메서드</h3>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
      <th>예시 코드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(E e)</code></td>
      <td>원소 추가</td>
      <td><code class="language-plaintext highlighter-rouge">pq.add(10);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">peek()</code></td>
      <td>최상단 원소 확인(삭제 안 함)</td>
      <td><code class="language-plaintext highlighter-rouge">int top = pq.peek();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">poll()</code></td>
      <td>최상단 원소 꺼내기</td>
      <td><code class="language-plaintext highlighter-rouge">int top = pq.poll();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td>비었는지 확인</td>
      <td><code class="language-plaintext highlighter-rouge">if (pq.isEmpty())</code></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>💡 디폴트는 오름차순(최소 힙) → 작은 숫자가 먼저 나옴</p>

  <p>내림차순은 <code class="language-plaintext highlighter-rouge">new PriorityQueue&lt;&gt;(Collections.reverseOrder());</code></p>
</blockquote>

<hr />

<h2 id="-5️⃣-stack--queue-deque--선형-구조">🧰 5️⃣ Stack / Queue (Deque) — 선형 구조</h2>

<h3 id="-queue">💡 Queue</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>

<h3 id="-stack-deque로-대체-권장">💡 Stack (Deque로 대체 권장)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>

<hr />

<h2 id="-6️⃣-collections--arrays-유틸리티-메서드">💎 6️⃣ Collections / Arrays 유틸리티 메서드</h2>

<table>
  <thead>
    <tr>
      <th>클래스</th>
      <th>메서드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Collections.sort(list)</code></td>
      <td>리스트 정렬</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Collections.reverse(list)</code></td>
      <td>역순 정렬</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Collections.max(list)</code></td>
      <td>최댓값</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Collections.min(list)</code></td>
      <td>최솟값</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Arrays.sort(arr)</code></td>
      <td>배열 정렬</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Arrays.equals(arr1, arr2)</code></td>
      <td>배열 비교</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Arrays.toString(arr)</code></td>
      <td>배열 출력용</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-추천-연습문제-유형별-활용-예시">📘 추천 연습문제 유형별 활용 예시</h2>

<table>
  <thead>
    <tr>
      <th>유형</th>
      <th>핵심 자료구조/메서드</th>
      <th>예시 문제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Hash (중복, 완주하지 못한 선수 등)</td>
      <td><code class="language-plaintext highlighter-rouge">HashMap</code>, <code class="language-plaintext highlighter-rouge">HashSet</code></td>
      <td><code class="language-plaintext highlighter-rouge">map.getOrDefault</code>, <code class="language-plaintext highlighter-rouge">set.contains</code></td>
    </tr>
    <tr>
      <td>Stack/Queue</td>
      <td><code class="language-plaintext highlighter-rouge">Deque</code>, <code class="language-plaintext highlighter-rouge">LinkedList</code></td>
      <td>괄호 검사, 기능개발</td>
    </tr>
    <tr>
      <td>정렬</td>
      <td><code class="language-plaintext highlighter-rouge">Arrays.sort</code>, <code class="language-plaintext highlighter-rouge">Collections.sort</code></td>
      <td>H-index, K번째 수</td>
    </tr>
    <tr>
      <td>이중 루프 회피</td>
      <td><code class="language-plaintext highlighter-rouge">HashMap</code> lookup</td>
      <td>전화번호 목록</td>
    </tr>
    <tr>
      <td>우선순위 문제</td>
      <td><code class="language-plaintext highlighter-rouge">PriorityQueue</code></td>
      <td>더 맵게, 디스크 컨트롤러</td>
    </tr>
    <tr>
      <td>그래프/BFS/DFS</td>
      <td><code class="language-plaintext highlighter-rouge">Queue</code>, <code class="language-plaintext highlighter-rouge">ArrayList</code></td>
      <td>미로 탐색, 네트워크</td>
    </tr>
  </tbody>
</table>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[코딩테스트 대비 JAVA Collections의 사용처 및 메서드를 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자] Agora Cloud Recording 구현 시 Hibernate 에러 트러블슈팅</title><link href="https://nan0silver.github.io/projectdiary/2025-10-20-diary/" rel="alternate" type="text/html" title="[친구하자] Agora Cloud Recording 구현 시 Hibernate 에러 트러블슈팅" /><published>2025-10-20T00:00:00+00:00</published><updated>2025-11-28T05:51:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-10-20-diary/"><![CDATA[<ul>
  <li><a href="#1-문제-발견">1. 문제 발견</a></li>
  <li><a href="#2-lazyinitializationexception-이해하기">2. LazyInitializationException 이해하기</a></li>
  <li><a href="#3-optimisticlockingfailureexception-이해하기">3. OptimisticLockingFailureException 이해하기</a></li>
  <li><a href="#4-문제-원인-분석">4. 문제 원인 분석</a></li>
  <li><a href="#5-해결-방법">5. 해결 방법</a></li>
  <li><a href="#6-핵심-개념-정리">6. 핵심 개념 정리</a></li>
</ul>

<h2 id="음성-통화-녹음-기능은-동작하는데-에러가">음성 통화 녹음, 기능은 동작하는데 에러가?</h2>

<blockquote>
  <p>Agora Cloud Recording을 이용한 음성 통화 녹음 기능을 구현했다. 녹음 시작과 중지는 정상적으로 동작하는 것처럼 보였지만, 통화 종료 직후 콘솔에 예외 스택이 연속으로 출력되었다. LazyInitializationException과 OptimisticLockingFailureException… 둘 다 뭔가 익숙한데 동시에 발생하다니..🥲</p>
</blockquote>

<h2 id="1-문제-발견">1. 문제 발견</h2>

<h3 id="상황">상황</h3>

<p>Agora Cloud Recording을 사용하여 음성 통화 녹음 기능을 구현하던 중, 통화는 정상적으로 시작되고 녹음도 시작되지만, <strong>통화 종료 시점에 예외가 연달아 발생</strong>했다.</p>

<p>구조는 다음과 같았다:</p>

<ul>
  <li>통화 종료 → 비동기로 녹음 중지 API 호출</li>
  <li>녹음 정보를 DB에 저장하는 과정에서 에러 발생</li>
</ul>

<h3 id="에러-로그">에러 로그</h3>

<p><strong>첫 번째 에러:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>org.hibernate.LazyInitializationException: Could not initialize proxy
[com.example.domain.Call#1] - no session
	at org.hibernate.proxy.AbstractLazyInitializer.initialize(...)
	at RecordingResponse.from(RecordingResponse.java:76)
</code></pre></div></div>

<p><strong>두 번째 에러:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>org.springframework.orm.ObjectOptimisticLockingFailureException:
Row was updated or deleted by another transaction

Caused by: org.hibernate.StaleObjectStateException:
Row was updated or deleted by another transaction
</code></pre></div></div>

<blockquote>
  <p>“분명히 <code class="language-plaintext highlighter-rouge">@Transactional</code>도 붙였고, 엔티티도 제대로 조회했는데 왜 세션이 없다는 거지? 그리고 왜 낙관적 락 충돌이 발생하는 거야?”</p>
</blockquote>

<hr />

<h2 id="2-lazyinitializationexception-이해하기">2. LazyInitializationException 이해하기</h2>

<h3 id="에러의-의미">에러의 의미</h3>

<p><code class="language-plaintext highlighter-rouge">LazyInitializationException</code>은 Hibernate에서 <strong>지연 로딩(Lazy Loading)으로 설정된 연관 엔티티에 접근하려 할 때, 이미 영속성 컨텍스트(Persistence Context)가 닫혀있어서 발생</strong>하는 에러다.</p>

<h3 id="일반적인-발생-상황">일반적인 발생 상황</h3>

<p><strong>1. 트랜잭션 밖에서 Lazy 프록시 접근</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="nc">User</span> <span class="nf">findUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>  <span class="c1">// User.orders는 LAZY</span>
<span class="o">}</span>

<span class="c1">// 트랜잭션 밖</span>
<span class="n">user</span><span class="o">.</span><span class="na">getOrders</span><span class="o">().</span><span class="na">size</span><span class="o">();</span>  <span class="c1">// ❌ LazyInitializationException!</span>
</code></pre></div></div>

<p><strong>2. 비동기 작업에서 접근</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processOrder</span><span class="o">(</span><span class="nc">Long</span> <span class="n">orderId</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">findOrder</span><span class="o">(</span><span class="n">orderId</span><span class="o">);</span>
    <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">runAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">order</span><span class="o">.</span><span class="na">getUser</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>  <span class="c1">// ❌ 세션 종료 후 접근</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="내-경우의-원인">내 경우의 원인</h3>

<p>엔티티 구조:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">class</span> <span class="nc">CallRecording</span> <span class="o">{</span>
    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>  <span class="c1">// ← LAZY 로딩</span>
    <span class="kd">private</span> <span class="nc">Call</span> <span class="n">call</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>문제 흐름:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">@Async</code>로 비동기 스레드에서 녹음 중지 로직 실행</li>
  <li><code class="language-plaintext highlighter-rouge">CallRecording</code> 조회 (이때 <code class="language-plaintext highlighter-rouge">Call</code>은 프록시 상태)</li>
  <li>DTO 변환 시 <code class="language-plaintext highlighter-rouge">call.getChannelName()</code> 호출</li>
  <li><strong>프록시 초기화 시도하지만 이미 세션 종료 → 에러!</strong></li>
</ol>

<p>핵심은 <strong>비동기 스레드는 별도의 영속성 컨텍스트를 가지며</strong>, 연관 엔티티가 LAZY로 설정되어 있으면 세션 밖에서 접근 시 문제가 발생한다는 점이다.</p>

<hr />

<h2 id="3-optimisticlockingfailureexception-이해하기">3. OptimisticLockingFailureException 이해하기</h2>

<h3 id="에러의-의미-1">에러의 의미</h3>

<p><code class="language-plaintext highlighter-rouge">OptimisticLockingFailureException</code>은 <strong>낙관적 락(Optimistic Lock) 검증 실패</strong> 시 발생한다. JPA의 <code class="language-plaintext highlighter-rouge">@Version</code>을 사용한 엔티티에서 <strong>다른 트랜잭션이 이미 해당 레코드를 수정하여 버전이 증가했을 때</strong> 발생한다.</p>

<h3 id="낙관적-락이란">낙관적 락이란?</h3>

<p>동시성 제어 방법 중 하나로, 실제 충돌이 자주 발생하지 않을 것이라고 “낙관적으로” 가정한다.</p>

<p><strong>동작 방식:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">class</span> <span class="nc">CallRecording</span> <span class="o">{</span>
    <span class="nd">@Version</span>
    <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">version</span><span class="o">;</span>  <span class="c1">// 수정될 때마다 자동 증가</span>
<span class="o">}</span>
</code></pre></div></div>

<ol>
  <li>엔티티 조회 시 version 값 함께 조회</li>
  <li>업데이트 시 WHERE 절에 version 조건 추가</li>
</ol>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">UPDATE</span> <span class="n">call_recordings</span>
   <span class="k">SET</span> <span class="n">status</span> <span class="o">=</span> <span class="s1">'COMPLETED'</span><span class="p">,</span> <span class="k">version</span> <span class="o">=</span> <span class="k">version</span> <span class="o">+</span> <span class="mi">1</span>
   <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="k">version</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<ol>
  <li>영향받은 행이 0개면 → <strong>OptimisticLockingFailureException!</strong></li>
</ol>

<h3 id="일반적인-발생-상황-1">일반적인 발생 상황</h3>

<p><strong>동시에 같은 엔티티 수정:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 트랜잭션 1</span>
<span class="nc">Recording</span> <span class="n">rec</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>  <span class="c1">// version = 0</span>
<span class="n">rec</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="no">COMPLETED</span><span class="o">);</span>
<span class="n">repo</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">rec</span><span class="o">);</span>  <span class="c1">// version = 1</span>

<span class="c1">// 트랜잭션 2 (동시 실행)</span>
<span class="nc">Recording</span> <span class="n">rec</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>  <span class="c1">// version = 0 (조회 시점)</span>
<span class="n">rec</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="no">FAILED</span><span class="o">);</span>
<span class="n">repo</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">rec</span><span class="o">);</span>  <span class="c1">// ❌ version이 이미 1이라 실패!</span>
</code></pre></div></div>

<h3 id="내-경우의-원인-1">내 경우의 원인</h3>

<p>문제 흐름:</p>

<ol>
  <li>메인 로직에서 <code class="language-plaintext highlighter-rouge">recording.complete()</code> 호출 → version 증가</li>
  <li>비동기 스레드에서도 같은 recording 접근</li>
  <li>에러 발생 → <code class="language-plaintext highlighter-rouge">recording.fail()</code> 호출</li>
  <li>저장 시도 → <strong>이미 version이 변경되어 충돌!</strong></li>
</ol>

<hr />

<h2 id="4-문제-원인-분석">4. 문제 원인 분석</h2>

<h3 id="근본-원인">근본 원인</h3>

<p>두 에러가 동시에 발생한 이유는 <strong>비동기 처리와 동시성 제어의 조합</strong> 때문이었다.</p>

<p><strong>시나리오:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 통화 종료 이벤트 발생
2. @Async 메서드로 녹음 중지 로직 실행 (별도 스레드)
3. CallRecording 조회 (Call은 LAZY 프록시 상태)
4. DTO 변환 시 Call 접근 → LazyInitializationException
5. 예외 처리 로직에서 recording.fail() 호출
6. 다른 트랜잭션이 이미 recording을 수정 → OptimisticLockingFailureException
</code></pre></div></div>

<p><strong>핵심 문제점:</strong></p>

<ul>
  <li>LAZY 로딩된 연관 엔티티를 비동기 컨텍스트에서 접근</li>
  <li>동일 엔티티에 대한 동시 업데이트 시도</li>
</ul>

<hr />

<h2 id="5-해결-방법">5. 해결 방법</h2>

<h3 id="해결-전략">해결 전략</h3>

<ol>
  <li><strong>LazyInitializationException</strong>: 연관 엔티티를 미리 로드</li>
  <li><strong>OptimisticLockingFailureException</strong>: 예외 처리 전략 수립</li>
</ol>

<h3 id="1-join-fetch로-연관-엔티티-즉시-로딩">1) JOIN FETCH로 연관 엔티티 즉시 로딩</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Query</span><span class="o">(</span><span class="s">"SELECT cr FROM CallRecording cr "</span> <span class="o">+</span>
       <span class="s">"JOIN FETCH cr.call "</span> <span class="o">+</span>
       <span class="s">"WHERE cr.call.id = :callId"</span><span class="o">)</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">CallRecording</span><span class="o">&gt;</span> <span class="nf">findByCallIdWithCall</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">"callId"</span><span class="o">)</span> <span class="nc">Long</span> <span class="n">callId</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>효과:</strong></p>

<ul>
  <li>한 번의 쿼리로 <code class="language-plaintext highlighter-rouge">CallRecording</code>과 <code class="language-plaintext highlighter-rouge">Call</code>을 함께 조회</li>
  <li>LAZY 프록시 문제 해결</li>
</ul>

<h3 id="2-dto-생성-시-필요한-데이터만-전달">2) DTO 생성 시 필요한 데이터만 전달</h3>

<p>기존의 프록시 객체에서 데이터를 꺼내는 대신, <strong>이미 로드된 엔티티를 명시적으로 전달</strong>하는 방식으로 변경:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Before: recording에서 call을 꺼내려 시도 (프록시 초기화)</span>
<span class="nc">RecordingResponse</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">recording</span><span class="o">);</span>

<span class="c1">// After: 이미 로드된 call을 직접 전달</span>
<span class="nc">RecordingResponse</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">recording</span><span class="o">,</span> <span class="n">call</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="3-비동기-메서드에-transactional-추가">3) 비동기 메서드에 @Transactional 추가</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Async</span>
<span class="nd">@Transactional</span>  <span class="c1">// ← 비동기 스레드에도 트랜잭션 컨텍스트</span>
<span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">autoStopRecording</span><span class="o">(</span><span class="nc">Long</span> <span class="n">callId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 새로운 영속성 컨텍스트에서 실행</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="4-낙관적-락-예외-처리">4) 낙관적 락 예외 처리</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="n">recording</span><span class="o">.</span><span class="na">fail</span><span class="o">();</span>
    <span class="n">repository</span><span class="o">.</span><span class="na">saveAndFlush</span><span class="o">(</span><span class="n">recording</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">OptimisticLockException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 이미 다른 트랜잭션에서 처리됨 - 무시</span>
    <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"낙관적 락 충돌 (무시): callId={}"</span><span class="o">,</span> <span class="n">callId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>전략:</strong></p>

<ul>
  <li>이미 처리된 경우 무시 (재시도 불필요)</li>
  <li><code class="language-plaintext highlighter-rouge">saveAndFlush()</code>로 즉시 DB 반영</li>
</ul>

<h3 id="5-적용-후-개선된-흐름">5) 적용 후 개선된 흐름</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 통화 종료
2. JOIN FETCH로 Call과 함께 CallRecording 조회
3. 필요한 데이터를 DTO에 전달 (프록시 접근 없음)
4. 업데이트 시 낙관적 락 충돌 발생 시 적절히 처리
</code></pre></div></div>

<hr />

<h2 id="6-핵심-개념-정리">6. 핵심 개념 정리</h2>

<h3 id="lazy-loading">Lazy Loading</h3>

<p><strong>개념:</strong><br />
연관된 엔티티를 실제로 사용할 때까지 조회를 미루는 전략</p>

<p><strong>장점:</strong></p>

<ul>
  <li>불필요한 쿼리 감소</li>
  <li>성능 최적화</li>
</ul>

<p><strong>단점:</strong></p>

<ul>
  <li>영속성 컨텍스트 밖에서 접근 시 LazyInitializationException</li>
</ul>

<p><strong>해결 방법:</strong></p>

<ul>
  <li>JOIN FETCH로 즉시 로딩</li>
  <li>DTO 변환 시점 조정</li>
  <li>EAGER 로딩 (신중하게)</li>
</ul>

<h3 id="낙관적-락-vs-비관적-락">낙관적 락 vs 비관적 락</h3>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>낙관적 락</th>
      <th>비관적 락</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>가정</td>
      <td>충돌이 적을 것</td>
      <td>충돌이 많을 것</td>
    </tr>
    <tr>
      <td>락 시점</td>
      <td>업데이트 시</td>
      <td>조회 시</td>
    </tr>
    <tr>
      <td>구현</td>
      <td>@Version</td>
      <td>@Lock(PESSIMISTIC_WRITE)</td>
    </tr>
    <tr>
      <td>적합한 경우</td>
      <td>읽기가 많은 경우</td>
      <td>쓰기가 많은 경우</td>
    </tr>
  </tbody>
</table>

<p><strong>낙관적 락 동작:</strong></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 조회</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">recordings</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">-- version = 0</span>

<span class="c1">-- 업데이트</span>
<span class="k">UPDATE</span> <span class="n">recordings</span>
<span class="k">SET</span> <span class="n">status</span> <span class="o">=</span> <span class="s1">'COMPLETED'</span><span class="p">,</span> <span class="k">version</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="k">version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">-- 버전 체크</span>

<span class="c1">-- 영향받은 행이 0개면 실패 → 예외 발생</span>
</code></pre></div></div>

<h3 id="비동기-처리와-영속성-컨텍스트">비동기 처리와 영속성 컨텍스트</h3>

<p><strong>주의사항:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@Async</code> 메서드는 별도 스레드에서 실행</li>
  <li>각 스레드는 독립적인 영속성 컨텍스트</li>
  <li>LAZY 엔티티는 미리 로드하거나 별도 트랜잭션 필요</li>
</ul>

<hr />

<h2 id="7-학습-포인트">7. 학습 포인트</h2>

<h3 id="이번-트러블슈팅을-통해-배운-것">이번 트러블슈팅을 통해 배운 것</h3>

<ol>
  <li>
    <p><strong>비동기 처리 시 영속성 컨텍스트 관리의 중요성</strong></p>

    <ul>
      <li>JOIN FETCH로 필요한 데이터 미리 로드</li>
      <li>비동기 컨텍스트에는 별도의 트랜잭션 필요</li>
    </ul>
  </li>
  <li>
    <p><strong>동시성 제어 전략 선택</strong></p>

    <ul>
      <li>낙관적 락: 충돌이 적을 때 효율적</li>
      <li>예외 처리로 재시도 또는 무시 전략 구현</li>
    </ul>
  </li>
  <li>
    <p><strong>트랜잭션 범위와 데이터 일관성</strong></p>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">saveAndFlush()</code>로 즉시 반영</li>
      <li>에러 처리 시 최신 데이터 재조회 고려</li>
    </ul>
  </li>
</ol>

<h3 id="더-나은-설계를-위한-고민">더 나은 설계를 위한 고민</h3>

<ul>
  <li>비동기 작업에서는 ID만 전달하고 내부에서 재조회</li>
  <li>DTO 변환은 서비스 레이어에서 완료</li>
  <li>동시성이 중요한 엔티티는 비관적 락 고려</li>
</ul>

<hr />

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html">Hibernate User Guide - LazyInitializationException</a></li>
  <li><a href="https://www.baeldung.com/jpa-optimistic-locking">Baeldung - JPA Optimistic Locking</a></li>
  <li><a href="https://docs.spring.io/spring-framework/reference/integration/scheduling.html">Spring Framework - Async Execution</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[음성 통화 녹음 기능 구현 중 비동기 처리에서 발생한 LazyInitializationException과 OptimisticLockingFailureException을 해결한 과정을 정리했습니다.]]></summary></entry><entry><title type="html">[친구하자] 크로스 도메인 환경에서 Refresh Token 쿠키 소실 문제 #2</title><link href="https://nan0silver.github.io/projectdiary/2025-10-16-diary/" rel="alternate" type="text/html" title="[친구하자] 크로스 도메인 환경에서 Refresh Token 쿠키 소실 문제 #2" /><published>2025-10-16T00:00:00+00:00</published><updated>2025-11-28T05:51:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-10-16-diary/"><![CDATA[<ul>
  <li><a href="#1-csrf-토큰-패턴">1. CSRF 토큰 패턴</a></li>
  <li><a href="#2-originreferer-검증">2. Origin/Referer 검증</a></li>
  <li><a href="#3-jwt의-이중-검증">3. JWT의 이중 검증</a></li>
  <li><a href="#4-samsite--csrf-토큰-조합">4. SamSite + CSRF 토큰 조합</a></li>
</ul>

<h2 id="크로스-도메인-환경에서-refresh-token-쿠키-소실-트러블슈팅-2">크로스 도메인 환경에서 Refresh Token 쿠키 소실 트러블슈팅 2</h2>

<blockquote>
  <p>저번 편에서 해결까지는 다뤘지만, 그로 인해 발생하는 CSRF 공격에 대한 약한 방어를 방지하는 로직에 대해서는 이번 편에서 다루기로 한다. (너무 길어져서..)</p>
</blockquote>

<h2 id="csrf-공격-방어">CSRF 공격 방어</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SamSite=None</code>으로 하면 CSRF 공격을 방어할 수 없다. 따라서 추가 설정을 해줘야 한다.</li>
  <li>방어 방법들은 아래와 같다.</li>
</ul>

<h3 id="1-csrf-토큰-패턴">1. CSRF 토큰 패턴</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SecurityConfig.java</span>
<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">SecurityFilterChain</span> <span class="nf">filterChain</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">http</span>
            <span class="o">.</span><span class="na">csrf</span><span class="o">(</span><span class="n">csrf</span> <span class="o">-&gt;</span> <span class="n">csrf</span>
                <span class="o">.</span><span class="na">csrfTokenRepository</span><span class="o">(</span><span class="nc">CookieCsrfTokenRepository</span><span class="o">.</span><span class="na">withHttpOnlyFalse</span><span class="o">())</span>
                <span class="o">.</span><span class="na">csrfTokenRequestHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">SpaCsrfTokenRequestHandler</span><span class="o">())</span>
            <span class="o">)</span>
            <span class="c1">// ... 나머지 설정</span>
            <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 프론트엔드</span>
<span class="kd">const</span> <span class="nx">csrfToken</span> <span class="o">=</span> <span class="nx">getCookie</span><span class="p">(</span><span class="dl">"</span><span class="s2">XSRF-TOKEN</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">axios</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="dl">"</span><span class="s2">/api/v1/users/delete</span><span class="dl">"</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">X-XSRF-TOKEN</span><span class="dl">"</span><span class="p">:</span> <span class="nx">csrfToken</span><span class="p">,</span> <span class="c1">// CSRF 토큰 포함</span>
  <span class="p">},</span>
<span class="p">});</span>
</code></pre></div></div>

<ul>
  <li>이렇게 하면 악의적인 사이트는
    <ul>
      <li>JavaScript로 쿠키를 읽을 수 없음</li>
      <li>따라서 헤더에 토큰을 포함할 수 없음</li>
    </ul>
  </li>
</ul>

<h3 id="2-originreferer-검증">2. Origin/Referer 검증</h3>

<ul>
  <li>서버에서 요청의 <code class="language-plaintext highlighter-rouge">Origin</code> 또는 <code class="language-plaintext highlighter-rouge">Referer</code> 헤더를 확인하여 신뢰할 수 있는 도메인에서 온 요청인지 검증</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// CorsConfig.java</span>
<span class="nd">@Bean</span>
<span class="nd">@Profile</span><span class="o">(</span><span class="s">"prod"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">CorsConfigurationSource</span> <span class="nf">prodCorsConfigurationSource</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">CorsConfiguration</span> <span class="n">configuration</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CorsConfiguration</span><span class="o">();</span>

    <span class="c1">// ✅ 허용된 출처만 명시</span>
    <span class="n">configuration</span><span class="o">.</span><span class="na">setAllowedOriginPatterns</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
        <span class="s">"https://chingoo-frontend.vercel.app"</span><span class="o">,</span>
        <span class="s">"https://www.chingoo-frontend.vercel.app"</span>
    <span class="o">));</span>

    <span class="n">configuration</span><span class="o">.</span><span class="na">setAllowCredentials</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 하면</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DELETE https://your-backend.com/api/v1/users/delete
Origin: https://evil.com  ← 이 값으로 검증!
Cookie: refreshToken=...
</code></pre></div></div>

<ul>
  <li>백엔드가 <code class="language-plaintext highlighter-rouge">Origin</code> 헤더 확인:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">evail.com</code>은 허용 목록에 없음</li>
      <li>CORS 오류 발생으로 요청 차단</li>
    </ul>
  </li>
  <li>이 방법의 단점이 있다.
    <ul>
      <li>Origin 헤더를 조작할 수 있는 환경에서는 우회 가능</li>
      <li>브라우저가 아닌 요청(Postman, curl)에서는 검증 안됨</li>
    </ul>
  </li>
</ul>

<h3 id="3-jwt의-이중-검증">3. JWT의 이중 검증</h3>

<ul>
  <li>가장 현대적인 방법이다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JwtAuthenticationFilter.java</span>
<span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span>
                                <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span>
                                <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// 1️⃣ 쿠키에서 RefreshToken 추출</span>
    <span class="nc">String</span> <span class="n">refreshTokenFromCookie</span> <span class="o">=</span> <span class="n">extractTokenFromCookie</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>

    <span class="c1">// 2️⃣ 헤더에서 AccessToken 추출</span>
    <span class="nc">String</span> <span class="n">accessTokenFromHeader</span> <span class="o">=</span> <span class="n">extractTokenFromHeader</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>

    <span class="c1">// 3️⃣ 둘 다 검증</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isValidToken</span><span class="o">(</span><span class="n">refreshTokenFromCookie</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">isValidToken</span><span class="o">(</span><span class="n">accessTokenFromHeader</span><span class="o">))</span> <span class="o">{</span>

        <span class="c1">// 4️⃣ 토큰의 userId가 일치하는지 확인</span>
        <span class="nc">Long</span> <span class="n">userIdFromRefresh</span> <span class="o">=</span> <span class="n">getUserIdFromToken</span><span class="o">(</span><span class="n">refreshTokenFromCookie</span><span class="o">);</span>
        <span class="nc">Long</span> <span class="n">userIdFromAccess</span> <span class="o">=</span> <span class="n">getUserIdFromToken</span><span class="o">(</span><span class="n">accessTokenFromHeader</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">userIdFromRefresh</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">userIdFromAccess</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// ✅ 인증 성공</span>
            <span class="nc">SecurityContextHolder</span><span class="o">.</span><span class="na">getContext</span><span class="o">()</span>
                <span class="o">.</span><span class="na">setAuthentication</span><span class="o">(</span><span class="n">createAuthentication</span><span class="o">(</span><span class="n">userIdFromAccess</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>쿠키(Refresh Token)이 자동으로 포함됨</li>
  <li>하지만 해더(Access Token)는 JavaScript로 명시적으로 설정해야함</li>
  <li>악의적인 사이트는 정상 사이트의 localStorage에 접근 불가 (Cross-Origin)</li>
  <li>따라서 Access Token을 얻을 수 없음</li>
</ul>

<h3 id="4-samsite--csrf-토큰-조합">4. SamSite + CSRF 토큰 조합</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="nd">@Profile</span><span class="o">(</span><span class="s">"prod"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">SecurityFilterChain</span> <span class="nf">prodFilterChain</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">http</span>
            <span class="c1">// CSRF 토큰 활성화</span>
            <span class="o">.</span><span class="na">csrf</span><span class="o">(</span><span class="n">csrf</span> <span class="o">-&gt;</span> <span class="n">csrf</span>
                <span class="o">.</span><span class="na">csrfTokenRepository</span><span class="o">(</span><span class="nc">CookieCsrfTokenRepository</span><span class="o">.</span><span class="na">withHttpOnlyFalse</span><span class="o">())</span>
            <span class="o">)</span>
            <span class="c1">// CORS 설정 (Origin 검증)</span>
            <span class="o">.</span><span class="na">cors</span><span class="o">(</span><span class="n">cors</span> <span class="o">-&gt;</span> <span class="n">cors</span><span class="o">.</span><span class="na">configurationSource</span><span class="o">(</span><span class="n">corsConfigurationSource</span><span class="o">))</span>
            <span class="c1">// ...</span>
            <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># application-prod.yml</span>
<span class="na">app</span><span class="pi">:</span>
  <span class="na">cookie</span><span class="pi">:</span>
    <span class="na">secure</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">same-site</span><span class="pi">:</span> <span class="s">None</span> <span class="c1"># 크로스 도메인 지원</span>
    <span class="na">max-age</span><span class="pi">:</span> <span class="m">2592000</span>
</code></pre></div></div>

<ul>
  <li>이렇게 하면 다중 방어선이 만들어진다.
    <ul>
      <li>Origin 검증 (CORS)</li>
      <li>CSRF 토큰 검증</li>
      <li>JWT 검증</li>
    </ul>
  </li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[백엔드, 프론트 도메인이 다른 크로스 도메인의 Production 환경에서 Refresh Token이 사라지는 문제에 대해 정리해보았습니다!]]></summary></entry><entry><title type="html">[친구하자] 크로스 도메인 환경에서 Refresh Token 쿠키 소실 문제</title><link href="https://nan0silver.github.io/projectdiary/2025-10-15-diary/" rel="alternate" type="text/html" title="[친구하자] 크로스 도메인 환경에서 Refresh Token 쿠키 소실 문제" /><published>2025-10-15T00:00:00+00:00</published><updated>2025-11-28T05:51:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-10-15-diary/"><![CDATA[<ul>
  <li><a href="#문제-상황">문제 상황</a></li>
  <li><a href="#원인-분석">원인 분석</a></li>
  <li><a href="#해결-방법">해결방법</a></li>
  <li><a href="#참고-사항">참고사항</a></li>
</ul>

<h2 id="크로스-도메인-환경에서-refresh-token-쿠키-소실-트러블슈팅">크로스 도메인 환경에서 Refresh Token 쿠키 소실 트러블슈팅</h2>

<ul>
  <li>개발 환경에서는 token관련 문제가 전혀 없었다. 그런데 배포한 후 로그인이 새로운 탭에서 유지되지 않는 문제를 해결하려고 하다가 Refresh Token이 새로고침하면 사라지는걸 발견하였다.
    <blockquote>
      <p>어디갔어.. 내 refresh token 🥲</p>
    </blockquote>
  </li>
  <li>로그인이 유지되지 않는 문제는 왜인지 알았기 때문에 금방 해결하였지만, refresh token이 사라지는 문제가 더 나를 힘들게 만들었다..</li>
  <li>따라서 왜 그런 문제가 발생하는지 좀 더 알아보고자 했다.</li>
</ul>

<h2 id="문제-상황">문제 상황</h2>

<ul>
  <li>Local 환경: Refresh Token 쿠키가 정상적으로 유지됨 ✅</li>
  <li>Production 환경 : 로그인은 성공하지만, 새로고침하면 Refresh Token 쿠키가 사라짐 👻 (Refresh Token은 HttpOnly Cookie에 저장함)</li>
  <li>
    <p>브라우저 개발자 도구에서 확인한 쿠키 만료 시간: 30일 ✅</p>

    <blockquote>
      <p>처음엔 만료 시간이 잘못 설정되어있는줄 알았다.</p>
    </blockquote>
  </li>
  <li>
    <p>환경 정보</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Local 환경:
- Frontend: http://localhost:3000
- Backend:  http://localhost:8080
- 동일 호스트(localhost), 다른 포트 → Same-Site

Production 환경:
- Frontend: https://chingoo-frontend.vercel.app
- Backend:  https://your-backend-domain.com
- 다른 도메인 → Cross-Site
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="원인-분석">원인 분석</h2>

<h3 id="1-잘못된-쿠키-설정">1. 잘못된 쿠키 설정</h3>

<p>application-prod.yml의 문제:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">app:
  cookie:
    secure: false     # ❌ HTTPS 환경인데 false
    sam-site: Lax     # ❌ 크로스 도메인인데 Lax
    max-age: 2592000  # ✅ 30일 (정상)
</span></code></pre></div></div>

<h3 id="2-samsite-쿠키-정책-이해하기">2. SamSite 쿠키 정책 이해하기</h3>

<h4 id="samsite-속성이란">SamSite 속성이란?</h4>

<ul>
  <li>
    <p>CSRF(Cross-Site Request Forgery) 공격을 방어하기 위해 도입된 쿠키 정책으로, 언제 쿠키를 전송할지를 제어</p>

    <blockquote>
      <p>CSRF공격 이란?</p>

      <blockquote>
        <p>사용자가 자신의 의지와는 상관없이 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 하는 공격
공격자가 사용자의 세션을 가로채는 방식으로 일어난다.</p>
      </blockquote>
    </blockquote>
  </li>
  <li>
    <p>SamSite 3가지 값</p>
    <ol>
      <li>Strict
        <ul>
          <li>동일 사이트에서만 쿠키 전공</li>
          <li>모든 크로스 사이트 요청에서 차단</li>
          <li>최고 수준 보안이 필요한 경우에 사용 (매우 엄격해서 잘 안씀)</li>
        </ul>
      </li>
      <li>Lax (기본값)
        <ul>
          <li>TOP-LEVEL 네비게이션 + GET 요청만 허용</li>
          <li>POST, PUT, DELETE 등은 차단</li>
          <li>일반적인 Sam-Site 환경 (프론트엔드와 벡엔드가 같은 도메인)</li>
        </ul>
      </li>
      <li>None
        <ul>
          <li>모든 크로스 사이트 요청에서 쿠키전송</li>
          <li>단, <code class="language-plaintext highlighter-rouge">Secure=true</code> 필수 (HTTPS)</li>
          <li>크로스 도메인 환경 (프론트엔트와 백엔드 도메인 다름)</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h4 id="브라우서의-samsitelax-동작-분석">브라우서의 SamSite=Lax 동작 분석</h4>

<h4 id="시나리오-1-로그인-시-최초-요청">시나리오 1: 로그인 시 (최초 요청)</h4>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">POST https://your-backend.com/api/v1/auth/login
Origin: https://your-frontend.com
Content-Type: application/json

{"email": "user@example.com", "password": "..."}
</span></code></pre></div></div>

<p>백엔드 응답:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
Set-Cookie: refreshToken=eyJhbGc...;
            Path=/;
            Max-Age=2592000;
            HttpOnly;
            Secure;
            SameSite=Lax  ← 여기가 문제! ❌
Access-Control-Allow-Origin: https://chingoo-frontend.vercel.app
Access-Control-Allow-Credentials: true
</code></pre></div></div>

<ul>
  <li>쿠키는 설정됨 (브라우저가 Set-Cookie 헤더를 받아서 저장)</li>
  <li>개발자 도구에서 쿠키 확인 가능</li>
  <li>Expires/Max-Age도 30일로 정상</li>
</ul>

<h4 id="시나리오-2-새로고침-시-두번째-요청">시나리오 2: 새로고침 시 (두번째 요청)</h4>

<ul>
  <li>사용자가 새로고침 또는 페이지 이동 시, 프론트엔드가 자동으로 사용자 정보를 가져오는 API 호출:</li>
</ul>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">// 프론트엔드 코드 (자동 실행)
useEffect(() =&gt; {
  axios.get('https://your-backend.com/api/v1/users/me', {
    withCredentials: true  // 쿠키 전송 요청
  });
}, []);
</span></code></pre></div></div>

<p>브라우저의 요청:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET https://your-backend.com/api/v1/users/me
Origin: https://your-frontend.com
Cookie: (없음!) &lt;- SamSite=Lax가 쿠키 전송을 차단!
</code></pre></div></div>

<ul>
  <li>TOP-LEVEL 네비게이션이 아니고 JavaScript 요청이기 때문에 쿠키 전송이 안됌
    <blockquote>
      <p>TOP-LEVEL 네비게이션은 아래와 같다.</p>

      <blockquote>
        <ol>
          <li>주소창에 URL을 직접 입력</li>
          <li><code class="language-plaintext highlighter-rouge">&lt;a href = "..."&gt;</code> 링크 클릭</li>
          <li><code class="language-plaintext highlighter-rouge">window.location.href</code> 변경
            <blockquote>
              <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   // ❌ 이런 JavaScript 요청은 TOP-LEVEL 네비게이션이 아님
   axios.get('https://api.example.com/user');

   // ✅ 이런 요청만 TOP-LEVEL 네비게이션으로 인정
   window.location.href = 'https://api.example.com/user';
   &lt;a href="https://api.example.com/user"&gt;클릭&lt;/a&gt;
</code></pre></div>              </div>
            </blockquote>
          </li>
        </ol>
      </blockquote>
    </blockquote>
  </li>
</ul>

<h4 id="시나리오-3-post-요청">시나리오 3: POST 요청</h4>

<ul>
  <li>사용자가 폼을 제출하는 등 POST 요청을 보낼 때:</li>
</ul>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">POST https://your-backend.com/api/v1/some-action
Origin: https://your-frontend.com
Cookie: (없음!) &lt;- SamSite=Lax가 쿠키 전송을 차단
</span></code></pre></div></div>

<p>결과:</p>

<ul>
  <li>Refresh Token 쿠키가 전송되지 않음</li>
  <li>백엔드에서 인증 실패 (401 Unauthorized)</li>
  <li>사용자는 다시 로그인해야함</li>
</ul>

<h2 id="해결">해결</h2>

<ul>
  <li>application-prod.yml 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>app:
  cookie:
    secure: true       # HTTPS 필수
    same-site: None    # 크로스 도메인 허용
    max-age: 2592000   # 30일
</code></pre></div></div>

<ul>
  <li>이로 인한 CSRF 공격에 대한 방어는 다음 편에서 다루기로 한다.</li>
</ul>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite">MDN: SamSite cookies</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[백엔드, 프론트 도메인이 다른 크로스 도메인의 Production 환경에서 Refresh Token이 사라지는 문제에 대해 정리해보았습니다! (해결은 다음편)]]></summary></entry></feed>