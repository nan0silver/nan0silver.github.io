<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-10-14T05:30:55+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[친구하자] Redis 데이터 초기화 트러블 슈팅</title><link href="https://nan0silver.github.io/projectdiary/2025-10-14-diary/" rel="alternate" type="text/html" title="[친구하자] Redis 데이터 초기화 트러블 슈팅" /><published>2025-10-14T00:00:00+00:00</published><updated>2025-10-14T05:30:08+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-10-14-diary/"><![CDATA[<ul>
  <li><a href="#문제-상황">문제 상황</a></li>
  <li><a href="#원인">원인</a></li>
  <li><a href="#해결-방법">해결방법</a></li>
  <li><a href="#참고-사항">참고사항</a></li>
</ul>

<h2 id="redis-데이터-초기화-트러블슈팅">Redis 데이터 초기화 트러블슈팅</h2>

<ul>
  <li>
    <p>나는 로컬 환경에서 Docker Compose로 Redis, MySQL룰 컨테이너화해서 실행하고 있다.</p>

    <blockquote>
      <p>Redis 7 Alpine 이미지 기반의 컨테이너를 오케스트레이션</p>
    </blockquote>
  </li>
  <li>Redis(인메모리 캐시)는 실시간 매칭 대기열 관리에 사용되고,</li>
  <li>
    <p>MySQL은 매칭 결과 및 사용자 정보 저장에 사용된다.</p>

    <blockquote>
      <p>매칭 대기열에서 Redis를 사용한 플로우와 이유에 대해서는 다음 게시글에서 다루겠다.</p>
    </blockquote>
  </li>
  <li>Spring Boot로 로컬 개발을 하며 매칭 - 통화 - 통화 평가 프로세스 구축에 시간을 많이 썼다.</li>
  <li>Redis, WebSocke을 이용한 개발이 처음이기도 하고, 공부하면서 개발했기 때문에 시행착오를 많이 거쳤다.</li>
  <li>이 과정에서 계속 DB를 초기화 하고.. 로직을 엎고.. 하는 일들이 많았는데</li>
  <li>
    <p>여러번 반복적으로 Redis를 초기화 할때는 외워서 했지만 프론트와 연동하며 오랜만에 매칭 관련 코드를 뜯어보다 문제가 생겨 Redis를 초기화 하려니 생각이 하나도 안나는 것이다!!</p>
  </li>
  <li>그래서 그냥 정리해두기로 했다.</li>
</ul>

<h2 id="문제-상황">문제 상황</h2>

<ul>
  <li>Spring Boot 애플리케이션에서 매칭 대기열에 사용자가 계속 남아있는 문제가 발생하였다.</li>
  <li>
    <p>MySQL은 초기화 한 상황, user가 한명도 없는데도 userID만 redis에 계속 저장되어있는 상황</p>

    <ul>
      <li>MySQL은 spring boot 재실행만으로도 초기화가 쉽게 되는데 redis는 어떻게 했더라.. 문제 발생</li>
    </ul>
  </li>
  <li><img src="image.png" alt="계속 남아있는 매칭 대기열의 유령들" />
    <blockquote>
      <p>계속 남아있는 매칭 대기열의 유령들</p>
    </blockquote>
  </li>
</ul>

<h2 id="원인">원인</h2>

<ul>
  <li>위에도 말했지만 Docker Compose로 MySQL 컨테이너를 재시작해서 데이터베이스는 초기화됨</li>
  <li>하지만 Redis는 인메모리 데이터베이스이면서도 <code class="language-plaintext highlighter-rouge">redis_data</code>볼륨애 데이터를 영구 저장</li>
  <li>컨테이너를 재시작해도 볼륨에 저장된 데이터는 유지됨..</li>
  <li>결과적으로 DB에는 없는 사용자가 Redis에만 남아있는 불일치 상태 발생</li>
</ul>

<h2 id="해결-방법">해결 방법</h2>

<h3 id="방법-1--redis-cli로-데이터-삭제">방법 1 : Redis CLI로 데이터 삭제</h3>

<blockquote>
  <p>나는 이걸로 해결</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Redis 컨테이너에 접속
docker exec -it &lt;내 redis 이름&gt; redis-cli

# 모든 데이터 삭제
127.0.0.1:6379&gt; FLUSHALL

# 삭제 확인
127.0.0.1:6379&gt; KEYS *

# 종료
127.0.0.1:6379&gt; exit
</code></pre></div></div>

<p><img src="image-1.png" alt="캡쳐 사진" /></p>

<p>-&gt; 금방 해결!</p>

<h3 id="방법-2--명령어-한줄로-실행">방법 2 : 명령어 한줄로 실행</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker exec -it chingoo-redis redis-cli FLUSHALL
</code></pre></div></div>

<h3 id="방법-3--docker-볼륨까지-완전-삭제">방법 3 : Docker 볼륨까지 완전 삭제</h3>

<ul>
  <li>더 확실한 초기화 방법</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># docker 디렉토리로 이동
cd docker

# 컨테이너 중지 및 볼륨 삭제
docker-compose down -v

# 컨테이너 재시작
docker-compose up -d
</code></pre></div></div>

<ul>
  <li>볼륨까지 삭제되므로 Redis 데이터가 완전히 초기화됨</li>
  <li>‼ <code class="language-plaintext highlighter-rouge">-v</code>옵션은 MySQL 데이터도 삭제하므로 주의가 필요!</li>
</ul>

<h2 id="해결">해결</h2>

<p>이렇게 하면
<img src="image-2.png" alt="alt text" /></p>

<blockquote>
  <p>매칭 대기열이 깨끗해진 모습
이렇게 유령들이 사라진다.</p>
</blockquote>

<h2 id="참고-사항">참고 사항</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FLUSHALL</code>: 모든 데이터베이스의 모든 키 삭제</li>
  <li><code class="language-plaintext highlighter-rouge">FLUSHDB</code>: 현재 선택된 데이터베이스의 키만 삭제</li>
  <li>Redis는 기본적으로 데이터베이스 0~15번까지 16개를 제공</li>
  <li>운영환경에서는 절대 <code class="language-plaintext highlighter-rouge">FLUSHALL</code>을 실행하면 안됨!</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[가끔 발생했던 Redis 데이터 초기화 방법과 관련해 정리]]></summary></entry><entry><title type="html">[친구하자] WebRTC란 무엇일까?</title><link href="https://nan0silver.github.io/projectdiary/2025-09-30-diary/" rel="alternate" type="text/html" title="[친구하자] WebRTC란 무엇일까?" /><published>2025-09-30T00:00:00+00:00</published><updated>2025-10-14T05:30:08+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-09-30-diary/"><![CDATA[<ul>
  <li><a href="#-1-webrtc의-정의">1. WebRTC의 정의</a></li>
  <li><a href="#-2-webrtc의-주요-구성-요소">2. WebRTC의 주요 구성 요소</a></li>
  <li><a href="#️-3-동작-흐름-signaling-포함">3. 동작 흐름 (Signaling 포함)</a></li>
  <li><a href="#-4-왜-agora를-사용하는가">4. 왜 Agora를 사용하는가</a></li>
  <li><a href="#-5-보안-측면">5. 보안 측면</a></li>
  <li><a href="#-6-오늘의-정리">6. 오늘의 정리</a></li>
</ul>

<hr />

<h2 id="-1-webrtc의-정의">🧩 1. WebRTC의 정의</h2>

<p><strong>WebRTC (Web Real-Time Communication)</strong>는
웹 브라우저나 모바일 앱끼리 <strong>실시간 음성, 영상, 데이터</strong>를 직접 주고받을 수 있게 해주는 오픈소스 기술이다.
즉, 중간 서버를 거치지 않고 <strong>클라이언트 간 P2P 통신</strong>을 가능하게 만든다.</p>

<p>브라우저끼리 “전화기처럼” 연결된다고 생각하면 쉽다.
별도 플러그인이나 설치 과정 없이 JavaScript API로 바로 통화 기능을 구현할 수 있다.</p>

<hr />

<h2 id="-2-webrtc의-주요-구성-요소">🌐 2. WebRTC의 주요 구성 요소</h2>

<table>
  <thead>
    <tr>
      <th>구성 요소</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>MediaStream (getUserMedia)</strong></td>
      <td>사용자의 카메라, 마이크 데이터를 캡처하는 API</td>
    </tr>
    <tr>
      <td><strong>RTCPeerConnection</strong></td>
      <td>실제 P2P 연결을 담당. 네트워크 경로 설정, 코덱 협상, 암호화 등을 수행</td>
    </tr>
    <tr>
      <td><strong>RTCDataChannel</strong></td>
      <td>파일 전송, 채팅 등 실시간 데이터 교환용 채널</td>
    </tr>
    <tr>
      <td><strong>ICE (Interactive Connectivity Establishment)</strong></td>
      <td>NAT(공유기 등) 환경에서도 통신이 가능하도록 IP 후보 탐색 및 연결 시도</td>
    </tr>
    <tr>
      <td><strong>STUN / TURN 서버</strong></td>
      <td>STUN: 공용 IP 확인용 / TURN: 직접 연결이 안될 때 중계 서버 역할</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="️-3-동작-흐름-signaling-포함">🛰️ 3. 동작 흐름 (Signaling 포함)</h2>

<ol>
  <li>
    <p><strong>Signaling 단계</strong></p>

    <ul>
      <li>두 클라이언트가 연결 정보를 교환 (SDP, ICE candidates 등)</li>
      <li>이 단계는 WebRTC 외부에서 처리해야 하며, 보통 WebSocket, Socket.io, REST API 등을 사용</li>
    </ul>
  </li>
  <li>
    <p><strong>P2P 연결</strong></p>

    <ul>
      <li>서로의 연결 정보를 받은 뒤 <code class="language-plaintext highlighter-rouge">RTCPeerConnection</code>으로 직접 연결 시도</li>
      <li>STUN 서버로 외부 IP 탐색, 필요 시 TURN 서버를 통한 중계</li>
    </ul>
  </li>
  <li>
    <p><strong>미디어 스트림 전송</strong></p>

    <ul>
      <li>연결이 완료되면 오디오/비디오/데이터 스트림이 실시간으로 교환됨</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="️-4-왜-agora를-사용하는가">⚙️ 4. 왜 Agora를 사용하는가</h2>

<p>WebRTC 자체는 “기술 표준”일 뿐, 실서비스에는 <strong>보완이 필요</strong>하다.
예를 들어,</p>

<ul>
  <li>TURN 서버 트래픽 비용과 관리 부담</li>
  <li>네트워크 불안정 시 끊김</li>
  <li>다자간 통화 (SFU/Mesh 방식) 구현 복잡성</li>
</ul>

<p>이 때문에 Agora, Twilio, Daily 같은 <strong>WebRTC 기반 클라우드 SDK</strong>를 이용하면
복잡한 signaling, TURN 운영, QoS 튜닝을 대신 처리해준다.</p>

<p>👉 <strong>친구하자 서비스</strong>에서도 Agora를 이용해</p>

<ul>
  <li>빠른 1:1 매칭 통화</li>
  <li>안정적인 통화 품질</li>
  <li>통화 종료 후 감정분석 AI 연결</li>
</ul>

<p>까지 구현할 수 있다.</p>

<blockquote>
  <p>여러 SDK를 비교한 후, 가격 성능 서비스 부분에서 Agora를 선택했다.</p>
</blockquote>

<hr />

<h2 id="-5-보안-측면">🔐 5. 보안 측면</h2>

<ul>
  <li>모든 WebRTC 통신은 <strong>DTLS (Datagram Transport Layer Security)</strong> 로 암호화</li>
  <li>미디어 스트림은 <strong>SRTP (Secure RTP)</strong> 로 암호화되어 안전하게 전송</li>
  <li>HTTPS 환경에서만 동작 (브라우저 정책상 보안 채널 필수)</li>
</ul>

<hr />

<h2 id="-6-오늘의-정리">💡 6. 오늘의 정리</h2>

<table>
  <thead>
    <tr>
      <th>키워드</th>
      <th>요약</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>WebRTC</strong></td>
      <td>브라우저 간 실시간 통신 기술</td>
    </tr>
    <tr>
      <td><strong>Signaling</strong></td>
      <td>SDP/ICE 교환을 위한 외부 과정</td>
    </tr>
    <tr>
      <td><strong>STUN/TURN</strong></td>
      <td>NAT 환경에서도 연결을 돕는 서버</td>
    </tr>
    <tr>
      <td><strong>Agora</strong></td>
      <td>WebRTC 기반 실시간 통화 SDK</td>
    </tr>
    <tr>
      <td><strong>보안</strong></td>
      <td>DTLS + SRTP 기반 암호화</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="️-7-개인-메모">✍️ 7. 개인 메모</h2>

<blockquote>
  <p>Agora SDK를 직접 사용하며 느낀 점</p>
</blockquote>

<ul>
  <li>브라우저 단에서 PeerConnection을 직접 제어하는 것보다 훨씬 안정적이다.</li>
  <li>특히 네트워크 품질이 낮은 환경에서 TURN 관리가 자동화되어 있다는 점이 큰 장점.</li>
  <li>이후 자체 STUN/TURN 구축을 통해 비용 절감을 검토할 예정.</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[친구하자 프로젝트 개발 중 Agora WebRTC 통화 구현 전 이해하기!]]></summary></entry><entry><title type="html">[JAVA] Java 알고리즘 문제 풀이 시, 자주 쓰이는 Steam API 함수들</title><link href="https://nan0silver.github.io/java/2025-09-12-stream/" rel="alternate" type="text/html" title="[JAVA] Java 알고리즘 문제 풀이 시, 자주 쓰이는 Steam API 함수들" /><published>2025-09-12T00:00:00+00:00</published><updated>2025-10-14T05:30:08+00:00</updated><id>https://nan0silver.github.io/java/stream</id><content type="html" xml:base="https://nan0silver.github.io/java/2025-09-12-stream/"><![CDATA[<ul>
  <li><a href="#1-배열--스트림">1. 배열 → 스트림</a></li>
  <li><a href="#2-형-변환-mapping">2. 형 변환 (Mapping)</a></li>
  <li><a href="#3-집계-연산-aggregation">3. 집계 연산 (Aggregation)</a></li>
  <li><a href="#4-정렬--수집">4. 정렬 / 수집</a></li>
  <li><a href="#5-foreach--joining">5. forEach / joining</a></li>
</ul>

<hr />

<h1 id="자주-쓰이는-stream-api-함수들">자주 쓰이는 Stream API 함수들</h1>

<h3 id="1-배열--스트림">1. <strong>배열 → 스트림</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Arrays.stream(arr)</code> : <code class="language-plaintext highlighter-rouge">int[]</code>, <code class="language-plaintext highlighter-rouge">double[]</code>, <code class="language-plaintext highlighter-rouge">long[]</code> 같은 <strong>primitive 배열</strong>을 스트림으로 변환</li>
  <li><code class="language-plaintext highlighter-rouge">Stream.of(array)</code> : <code class="language-plaintext highlighter-rouge">String[]</code> 같은 <strong>객체 배열</strong>을 스트림으로 변환</li>
</ul>

<p>예:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>

<span class="nc">String</span><span class="o">[]</span> <span class="n">strArr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">};</span>
<span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">strArr</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<h3 id="2-형-변환-mapping">2. <strong>형 변환 (Mapping)</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">mapToInt(Integer::parseInt)</code> : 문자열 스트림 → 정수 스트림</li>
  <li><code class="language-plaintext highlighter-rouge">map(String::length)</code> : 문자열 스트림 → 문자열 길이 스트림</li>
</ul>

<p>예:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">};</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">intArr</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">).</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">parseInt</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<h3 id="3-집계-연산-aggregation">3. <strong>집계 연산 (Aggregation)</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.min().getAsInt()</code> / <code class="language-plaintext highlighter-rouge">.max().getAsInt()</code> : 최솟값 / 최댓값</li>
  <li><code class="language-plaintext highlighter-rouge">.sum()</code> : 합계</li>
  <li><code class="language-plaintext highlighter-rouge">.average().getAsDouble()</code> : 평균</li>
</ul>

<p>예:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
<span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">).</span><span class="na">min</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">).</span><span class="na">max</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<h3 id="4-정렬--수집">4. <strong>정렬 / 수집</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.sorted()</code> : 정렬</li>
  <li><code class="language-plaintext highlighter-rouge">.toArray()</code> : 배열로 다시 변환</li>
  <li><code class="language-plaintext highlighter-rouge">.collect(Collectors.toList())</code> : 리스트로 변환</li>
</ul>

<p>예:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"3"</span><span class="o">,</span> <span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">};</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">parseInt</span><span class="o">)</span>
        <span class="o">.</span><span class="na">sorted</span><span class="o">()</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<hr />

<h3 id="5-foreach--joining">5. <strong>forEach / joining</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.forEach(System.out::println)</code> : 요소 출력</li>
  <li><code class="language-plaintext highlighter-rouge">.collect(Collectors.joining(" "))</code> : 문자열 합치기</li>
</ul>

<p>예:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">};</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">(</span><span class="s">", "</span><span class="o">));</span>  <span class="c1">// "a, b, c"</span>
</code></pre></div></div>

<hr />

<h2 id="-이-문제를-stream으로-풀면-이렇게도-가능">🎯 이 문제를 Stream으로 풀면 이렇게도 가능</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">String</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">IntSummaryStatistics</span> <span class="n">stats</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">))</span>
            <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">parseInt</span><span class="o">)</span>
            <span class="o">.</span><span class="na">summaryStatistics</span><span class="o">();</span>  <span class="c1">// count, min, max, sum, average 한번에</span>

    <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="na">getMin</span><span class="o">()</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">stats</span><span class="o">.</span><span class="na">getMax</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>👉 <code class="language-plaintext highlighter-rouge">IntSummaryStatistics</code>를 쓰면 <strong>최소값/최대값/합계/평균</strong>을 다 구할 수 있어서 깔끔!</p>

<hr />

<p>💡 정리
비슷한 문제에서 빠르게 풀고 싶으면 최소한 아래 3개는 꼭 익혀두자:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">mapToInt(Integer::parseInt)</code></li>
  <li><code class="language-plaintext highlighter-rouge">min() / max() / sum() / average()</code></li>
  <li><code class="language-plaintext highlighter-rouge">summaryStatistics()</code></li>
</ol>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="java" /><summary type="html"><![CDATA[알고리즘 문제풀이 시, 코드를 예쁘고 빠르게 만들어주는 Steam API를 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자] 매칭 대기열 만들면서 정리한 Redis 명령어 치트시트 (SET/ZSET편)</title><link href="https://nan0silver.github.io/projectdiary/2025-09-03-diary/" rel="alternate" type="text/html" title="[친구하자] 매칭 대기열 만들면서 정리한 Redis 명령어 치트시트 (SET/ZSET편)" /><published>2025-09-03T00:00:00+00:00</published><updated>2025-10-14T05:30:08+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-09-03-diary/"><![CDATA[<blockquote>
  <p>카테고리별 2인 매칭을 구현하며 실제로 쓴(또는 고민했던) 명령어들을 짧게 정리.
예시 키는 <code class="language-plaintext highlighter-rouge">{cat:123}</code> 해시태그로 Redis Cluster 슬롯을 고정하는 패턴을 사용.</p>
</blockquote>

<hr />

<h2 id="zset-sorted-set--순번대기시간우선순위가-필요할-때">ZSET (Sorted Set) — 순번/대기시간/우선순위가 필요할 때</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZADD key score member [score member ...]</code>
멤버 추가/갱신. <strong>score</strong>가 작을수록 앞쪽.</p>

    <pre><code class="language-redis">ZADD wait:z:{cat:123} 1725430000123 101
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZRANGE key start stop [WITHSCORES | REV | BYSCORE ...]</code>
<strong>정렬 순서대로 조회</strong>. 삭제는 아님!</p>

    <pre><code class="language-redis">ZRANGE wait:z:{cat:123} 0 1              # 가장 오래 기다린 2명
ZRANGE wait:z:{cat:123} 0 9 WITHSCORES    # 상위 10명 + score
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZRANK key member</code>
멤버의 <strong>순위(0-base)</strong>.</p>

    <pre><code class="language-redis">ZRANK wait:z:{cat:123} 101               # 0이면 1번째
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZSCORE key member</code>
멤버의 score(대기 시작 시각 등).</p>

    <pre><code class="language-redis">ZSCORE wait:z:{cat:123} 101
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZCARD key</code>
멤버 수.</p>

    <pre><code class="language-redis">ZCARD wait:z:{cat:123}
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZREM key member [member ...]</code>
멤버 삭제.</p>

    <pre><code class="language-redis">ZREM wait:z:{cat:123} 101 205
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZRANDMEMBER key [count] [WITHSCORES]</code> <em>(6.2+)</em>
<strong>무작위 조회</strong>(삭제 아님).</p>

    <pre><code class="language-redis">ZRANDMEMBER wait:z:{cat:123} 2
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZPOPMIN key [count]</code> / <code class="language-plaintext highlighter-rouge">ZPOPMAX</code>
<strong>꺼내며 삭제</strong>(원자). 대기순 매칭에 유용.</p>

    <pre><code class="language-redis">ZPOPMIN wait:z:{cat:123} 2
</code></pre>
  </li>
</ul>

<hr />

<h2 id="set-집합--중복-없는-랜덤-풀">SET (집합) — 중복 없는 랜덤 풀</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SADD key member [member ...]</code> / <code class="language-plaintext highlighter-rouge">SREM key member [...]</code>
추가/삭제 (중복 불가).</p>

    <pre><code class="language-redis">SADD matching:queue:{cat:123} 101
SREM matching:queue:{cat:123} 101
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SPOP key [count]</code>
<strong>무작위 추출+삭제</strong>(원자). 랜덤 매칭에 간단·빠름.</p>

    <pre><code class="language-redis">SPOP matching:queue:{cat:123} 2
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SCARD key</code>
멤버 수.</p>

    <pre><code class="language-redis">SCARD matching:queue:{cat:123}
</code></pre>
  </li>
</ul>

<hr />

<h2 id="ttl키-유틸-대기-상태-자동-청소용">TTL/키 유틸 (대기 상태 자동 청소용)</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SET key value EX &lt;sec&gt; NX</code>
<strong>선점 + TTL</strong>(중복 입장 방지).</p>

    <pre><code class="language-redis">SET user:index:42 "cat=123|queue=q_..." EX 600 NX
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">EXPIRE key &lt;sec&gt;</code> / <code class="language-plaintext highlighter-rouge">TTL key</code>
키 만료/조회.
<strong>주의:</strong> TTL은 <strong>키 전체</strong>에 붙음(멤버 단위 X).</p>
  </li>
</ul>

<blockquote>
  <p>베스트 프랙티스: <strong>대기열 컬렉션(SET/ZSET)엔 TTL 금지</strong>, 개별 사용자 상태 키에만 TTL.</p>
</blockquote>

<hr />

<h2 id="매칭에서-자주-쓰는-레시피">매칭에서 자주 쓰는 <strong>레시피</strong></h2>

<h3 id="1-대기순공정성-매칭">1) 대기순(공정성) 매칭</h3>

<ul>
  <li>
    <p>방법 A(2단계): <code class="language-plaintext highlighter-rouge">ZRANGE</code>로 상위 N 조회 → <strong><code class="language-plaintext highlighter-rouge">ZREM</code>로 제거</strong></p>

    <pre><code class="language-redis">ZRANGE wait:z:{cat:123} 0 1         # 후보 조회
ZREM   wait:z:{cat:123} 101 205     # 확정 후 제거
</code></pre>
  </li>
  <li>
    <p>방법 B(원자): <code class="language-plaintext highlighter-rouge">ZPOPMIN wait:z:{cat:123} 2</code>
(조회+삭제가 한 번에)</p>
  </li>
</ul>

<h3 id="2-랜덤-매칭">2) 랜덤 매칭</h3>

<ul>
  <li>
    <p>ZSET만 쓸 때(원자화는 Lua 추천):</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">ZRANDMEMBER</code>로 조회 → <strong>같은 로직 안에서 <code class="language-plaintext highlighter-rouge">ZREM</code></strong></li>
    </ul>
  </li>
  <li>
    <p>SET을 함께 쓸 때:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">SPOP matching:queue:{cat:123} 2</code> (원자 랜덤 추출)</li>
    </ul>
  </li>
</ul>

<h3 id="3-하이브리드랜덤-80--대기순-20">3) 하이브리드(랜덤 80% + 대기순 20%)</h3>

<ul>
  <li>
    <p>하나의 <strong>Lua/Functions</strong>에서 분기:</p>

    <ul>
      <li>랜덤: <code class="language-plaintext highlighter-rouge">ZRANDMEMBER</code> → <code class="language-plaintext highlighter-rouge">ZREM</code></li>
      <li>대기순: <code class="language-plaintext highlighter-rouge">ZRANGE</code> → <code class="language-plaintext highlighter-rouge">ZREM</code> (또는 <code class="language-plaintext highlighter-rouge">ZPOPMIN</code>)</li>
    </ul>
  </li>
</ul>

<h3 id="4-원자성-보장동시성-안전">4) 원자성 보장(동시성 안전)</h3>

<ul>
  <li>
    <p><strong>조회(선정)와 삭제를 한 덩어리로</strong>: Lua/Functions로 감싸기</p>

    <ul>
      <li>“이미 다른 워커가 먼저 가져간” 케이스를 **<code class="language-plaintext highlighter-rouge">ZREM</code> 반환값(0/1)**로 판단해 필터링.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="흔한-실수--주의">흔한 실수 &amp; 주의</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ZRANGE</code>/<code class="language-plaintext highlighter-rouge">ZRANDMEMBER</code> <strong>만</strong> 호출하고 <code class="language-plaintext highlighter-rouge">ZREM</code>을 빼먹음 → 큐에 그대로 남아 <strong>중복 매칭</strong> 발생.</li>
  <li><strong>컬렉션 키에 TTL</strong>을 걸어 전체 대기열이 사라짐.
TTL은 <strong>개별 사용자 키</strong>(예: <code class="language-plaintext highlighter-rouge">user:queued:{cat:123}:42</code>)에만.</li>
  <li>Redis Cluster 사용 시, <strong>스크립트 KEYS는 같은 해시태그</strong>(<code class="language-plaintext highlighter-rouge">{cat:123}</code>)로 묶기. 전역 키는 Lua에서 다루지 말고 자바에서만.</li>
</ul>

<hr />

<h2 id="시간-복잡도">시간 복잡도</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ZADD/ZREM/ZRANK</code> ≈ <strong>O(log N)</strong></li>
  <li><code class="language-plaintext highlighter-rouge">ZRANGE</code> ≈ <strong>O(k)</strong> (반환 수)</li>
  <li><code class="language-plaintext highlighter-rouge">ZPOPMIN/MAX</code> ≈ <strong>O(k log N)</strong></li>
  <li><code class="language-plaintext highlighter-rouge">SADD/SREM/SPOP</code> ≈ <strong>평균 O(1)</strong></li>
</ul>

<hr />

<h2 id="미니-예시-대기열-입장--매칭">미니 예시: 대기열 입장 &amp; 매칭</h2>

<pre><code class="language-redis"># 입장
ZADD wait:z:{cat:123} 1725430000456 101          # 대기 시작 시각(밀리초)
SET  user:queued:{cat:123}:101 q_101_123 EX 600   # 개별 TTL

# 대기순 매칭 2명 (원자)
ZPOPMIN wait:z:{cat:123} 2                        # -&gt; [101,score],[205,score]

# 랜덤 매칭 2명 (Lua로 원자화 권장)
-- 조회
ZRANDMEMBER wait:z:{cat:123} 2
-- 같은 로직 안에서 제거
ZREM wait:z:{cat:123} 101 205
</code></pre>

<hr />

<h2 id="한-줄-정리">한 줄 정리</h2>

<ul>
  <li><strong>ZSET = 순번/대기시간/공정성</strong>, <strong>SET = 단순 랜덤 풀</strong></li>
  <li><code class="language-plaintext highlighter-rouge">ZRANGE/ZRANDMEMBER</code>(조회) 뒤엔 <strong>반드시 <code class="language-plaintext highlighter-rouge">ZREM</code>(삭제)</strong></li>
  <li>경쟁 환경에선 <strong>Lua로 “조회→삭제”를 원자화</strong></li>
  <li><strong>TTL은 개별 상태 키에만</strong>, 대기열 컬렉션엔 금지</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[친구하자 프로젝트 개발 중 랜덤 매칭 대기열을 만들면서 정리한 Redis 명령어 모음집입니다.]]></summary></entry><entry><title type="html">[친구하자] 배치 스케줄러에서 @Transactional(REQUIRES_NEW)를 선택하기까지</title><link href="https://nan0silver.github.io/projectdiary/2025-08-29-diary/" rel="alternate" type="text/html" title="[친구하자] 배치 스케줄러에서 @Transactional(REQUIRES_NEW)를 선택하기까지" /><published>2025-08-29T00:00:00+00:00</published><updated>2025-10-14T05:30:08+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-08-29-diary/"><![CDATA[<blockquote>
  <p>“카테고리별 2인 랜덤 매칭”을 스케줄러로 돌리는데, 한 카테고리에서 예외가 나면 <strong>전체 루프가 롤백</strong>될 수 있다는 얘기를 듣고 시작된 고민.
그 결과 <code class="language-plaintext highlighter-rouge">@Transactional(propagation = REQUIRES_NEW)</code>를 채택했고, 다시 <strong>self-invocation</strong> 문제를 만나 리팩터링까지 갔던 과정을 정리했습니다.</p>
</blockquote>

<hr />

<h2 id="배경-매칭-스케줄러의-요구사항">배경: 매칭 스케줄러의 요구사항</h2>

<ul>
  <li>여러 <strong>카테고리</strong>를 순회하며 매칭을 수행한다.</li>
  <li>어떤 카테고리에서 실패해도 <strong>나머지는 정상 커밋</strong>되어야 한다(부분 성공).</li>
  <li>DB에 매칭 세션을 만들고, Redis 대기열을 정리하고, 알림을 보낸다.</li>
</ul>

<p>처음엔 스케줄러 전체를 <code class="language-plaintext highlighter-rouge">@Transactional</code>로 감싸는 걸 고민했지만, 그러면 <strong>카테고리 하나의 실패가 전체 롤백</strong>으로 번질 수 있다. 그래서 트랜잭션 경계를 <strong>카테고리 단위로 쪼개야</strong> 했다.</p>

<hr />

<h2 id="옵션-검토-왜-requires_new인가">옵션 검토: 왜 <code class="language-plaintext highlighter-rouge">REQUIRES_NEW</code>인가</h2>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">REQUIRED</code></strong>: 바깥 트랜잭션이 있으면 <strong>같이 묶인다</strong> → 부분 실패가 전체 롤백으로 확장될 위험.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">NESTED</code></strong>: 세이브포인트 기반. <strong>바깥이 롤백되면 내부도 함께 롤백</strong> → 부분 성공 보장 X.</li>
  <li><strong>비트랜잭션</strong>(<code class="language-plaintext highlighter-rouge">NOT_SUPPORTED</code> 등): DB 원자성 보장 X.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">REQUIRES_NEW</code></strong>: <strong>항상 새 트랜잭션 시작</strong>, 외부 트랜잭션은 <strong>일시 중단</strong> → <strong>카테고리별 독립 커밋</strong>을 정확히 충족.</li>
</ul>

<p>결론: 내 요구(카테고리별 완결·부분 성공)를 가장 잘 만족시키는 건 <strong><code class="language-plaintext highlighter-rouge">REQUIRES_NEW</code></strong>.</p>

<hr />

<h2 id="첫-번째-벽-self-invocation-경고">첫 번째 벽: “self-invocation” 경고</h2>

<p>스케줄러 코드 초안:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedDelay</span> <span class="o">=</span> <span class="o">...)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processMatching</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Category</span> <span class="n">category</span> <span class="o">:</span> <span class="n">activeCategories</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">processMatchingForCategory</span><span class="o">(</span><span class="n">category</span><span class="o">);</span> <span class="c1">// 내부 메서드 호출</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="nc">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">processMatchingForCategory</span><span class="o">(</span><span class="nc">Category</span> <span class="n">category</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>경고 메시지:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">@Transactional self-invocation ... does not lead to an actual transaction at runtime</code></p>
</blockquote>

<h3 id="왜-이런가">왜 이런가?</h3>

<p>Spring의 <code class="language-plaintext highlighter-rouge">@Transactional</code>은 <strong>프록시 기반 AOP</strong>다.
<strong>같은 객체 내부에서 자기 메서드를 직접 호출하면</strong> 프록시를 <strong>우회</strong>하므로 <strong>트랜잭션이 적용되지 않는다</strong>. 접근 제어자(private→protected) 변경으로는 해결되지 않는다. 본질은 <strong>프록시를 타느냐</strong>이다.</p>

<hr />

<h2 id="해결-트랜잭션-경계를-다른-빈의-public-메서드로-분리">해결: 트랜잭션 경계를 “다른 빈의 public 메서드”로 분리</h2>

<h3 id="리팩터링-전후">리팩터링 전/후</h3>

<p><strong>Before</strong>: 스케줄러 클래스 내부에서 <code class="language-plaintext highlighter-rouge">processMatchingForCategory</code> 호출 → 프록시 미적용</p>

<p><strong>After</strong>: <strong>별도의 서비스 빈</strong>으로 분리 + <code class="language-plaintext highlighter-rouge">public</code> 메서드에 <code class="language-plaintext highlighter-rouge">@Transactional(REQUIRES_NEW)</code>
스케줄러는 “그 빈을 주입 받아 호출” → <strong>프록시를 경유</strong>하므로 트랜잭션 정상 적용</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A. 카테고리 단위 워커 (새 트랜잭션 경계)</span>
<span class="nd">@Service</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CategoryMatchWorker</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RedisMatchingQueueService</span> <span class="n">redisMatchingQueueService</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CallRepository</span> <span class="n">callRepository</span><span class="o">;</span>
    <span class="c1">// ... 필요한 의존성</span>

    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="nc">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processCategory</span><span class="o">(</span><span class="nc">Category</span> <span class="n">category</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 카테고리 하나에 대한 모든 DB 작업 (예외 → 이 트랜잭션만 롤백)</span>
        <span class="c1">// 1) 대기 인원 확인 → 2) 하이브리드 매칭 → 3) 사용자 조회 검증</span>
        <span class="c1">// 4) Call 생성/저장 → 5) 큐 상태 업데이트 → 6) 알림 예약(afterCommit)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// B. 스케줄러 (비트랜잭션; 실패해도 루프 계속)</span>
<span class="nd">@Service</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MatchingSchedulerService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CategoryMatchWorker</span> <span class="n">categoryMatchWorker</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CategoryRepository</span> <span class="n">categoryRepository</span><span class="o">;</span>

    <span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedDelay</span> <span class="o">=</span> <span class="o">...)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processMatching</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">categories</span> <span class="o">=</span> <span class="n">categoryRepository</span><span class="o">.</span><span class="na">findByIsActiveTrueOrderByName</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Category</span> <span class="n">category</span> <span class="o">:</span> <span class="n">categories</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">categoryMatchWorker</span><span class="o">.</span><span class="na">processCategory</span><span class="o">(</span><span class="n">category</span><span class="o">);</span> <span class="c1">// 프록시 경유 OK</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"카테고리 {} 처리 실패 - 다음으로 진행"</span><span class="o">,</span> <span class="n">category</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>대안으로 <strong><code class="language-plaintext highlighter-rouge">TransactionTemplate</code></strong>(프로그래매틱 트랜잭션)도 있다. 카테고리마다 <code class="language-plaintext highlighter-rouge">PROPAGATION_REQUIRES_NEW</code>로 실행 블록을 감싸는 방식. 프록시 우회 이슈가 없다.</p>
</blockquote>

<hr />

<h2 id="redis와의-경계-한-트랜잭션이-아니다">Redis와의 경계: “한 트랜잭션이 아니다”</h2>

<ul>
  <li>DB와 Redis는 <strong>동일 트랜잭션 경계가 아님</strong>(2PC 안 쓰는 한).</li>
  <li>
    <p>안전한 순서:</p>

    <ol>
      <li><strong>DB 커밋 성공 후</strong>(트랜잭션 경계 밖) Redis/PubSub/WebSocket 등 <strong>사이드 이펙트 수행</strong></li>
      <li>Spring에선 <code class="language-plaintext highlighter-rouge">TransactionSynchronizationManager.registerSynchronization(... afterCommit)</code> 훅으로 구현 가능</li>
    </ol>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TransactionSynchronizationManager</span><span class="o">.</span><span class="na">registerSynchronization</span><span class="o">(</span><span class="k">new</span> <span class="nc">TransactionSynchronization</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterCommit</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// DB 커밋이 확정된 뒤에만 알림/이벤트 발행</span>
        <span class="n">webSocketEventService</span><span class="o">.</span><span class="na">notifyMatchingSuccess</span><span class="o">(...);</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div></div>

<hr />

<h2 id="내가-얻은-체크리스트">내가 얻은 체크리스트</h2>

<ol>
  <li><strong>부분 성공</strong>이 목표면 트랜잭션을 **처리 단위(여기선 카테고리)**로 쪼갠다.</li>
  <li><code class="language-plaintext highlighter-rouge">REQUIRES_NEW</code>는 외부와 <strong>분리된 커밋/롤백</strong>을 보장한다.</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">@Transactional</code>은 <strong>프록시 기반</strong> → <strong>자기 자신 호출은 적용되지 않는다</strong>.</p>

    <ul>
      <li>트랜잭션 메서드는 <strong>public</strong> + <strong>다른 빈</strong>으로 분리해 호출.</li>
      <li>또는 <strong>TransactionTemplate</strong>로 명시 제어.</li>
    </ul>
  </li>
  <li><strong>롤백 규칙</strong>을 의도대로: 체크 예외까지 롤백이면 <code class="language-plaintext highlighter-rouge">rollbackFor = Exception.class</code>.</li>
  <li><strong>Redis/메시징</strong>은 DB 트랜잭션과 별개 → <strong>afterCommit</strong>에 배치.</li>
  <li>멱등성·재시도·처리상태 플래그를 준비(일부 성공/일부 실패가 정상인 아키텍처).</li>
</ol>

<hr />

<h2 id="최종-결론">최종 결론</h2>

<ul>
  <li>스케줄러 루프 전체를 하나의 트랜잭션으로 묶는 대신, **카테고리별로 <code class="language-plaintext highlighter-rouge">REQUIRES_NEW</code>**를 적용해 <strong>부분 성공</strong>과 <strong>격리</strong>를 확보한다.</li>
  <li>이때 <code class="language-plaintext highlighter-rouge">@Transactional</code>이 실제로 동작하려면 <strong>프록시를 타야 하므로</strong>, 트랜잭션 메서드는 <strong>다른 빈의 public 메서드</strong>로 분리한다.</li>
  <li>DB 커밋 이후에만 외부 부작용(알림/Redis)을 발생시키는 흐름으로 <strong>정합성</strong>을 지킨다.</li>
</ul>

<p>이 과정을 거치면서 “왜 <code class="language-plaintext highlighter-rouge">REQUIRES_NEW</code>인가?”에 더해 “<strong>어디에, 어떻게 붙여야 실제로 동작하는가</strong>”를 체득했다. 스프링의 트랜잭션은 <strong>어노테이션 한 줄</strong>이 아니라, <strong>경계 설계 + 호출 구조</strong>까지 포함한 문제였다.</p>

<blockquote>
  <p>Redis.. 어렵다..</p>
</blockquote>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://redis.io/docs/latest/develop/programmability/">Redis programmability</a></li>
  <li><a href="https://redis.io/blog/you-dont-need-transaction-rollbacks-in-redis/?utm_source=chatgpt.com">You Don’t Need Transaction Rollbacks in Redis</a></li>
  <li><a href="https://devoong2.tistory.com/entry/Spring-Transactional-REQUIRESNEW-%EC%98%B5%EC%85%98%EC%97%90%EC%84%9C%EC%9D%98-%EC%98%88%EC%99%B8-%EB%B0%8F-Rollback">Transactional REQUIRES_NEW 옵션에서 예외 및 Rollback</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[친구하자 프로젝트 개발 중 랜덤 매칭 배치 스케줄러를 구현하다가 생긴 고민을 정리해보았습니다.]]></summary></entry><entry><title type="html">[JAVA] Queue는 왜 안되고 Queue는 왜 될까?</title><link href="https://nan0silver.github.io/java/2025-08-25-queue-int/" rel="alternate" type="text/html" title="[JAVA] Queue는 왜 안되고 Queue는 왜 될까?" /><published>2025-08-25T00:00:00+00:00</published><updated>2025-10-14T05:30:08+00:00</updated><id>https://nan0silver.github.io/java/queue-int</id><content type="html" xml:base="https://nan0silver.github.io/java/2025-08-25-queue-int/"><![CDATA[<ul>
  <li><a href="#-record란-java-14">record란?</a></li>
  <li><a href="#1️⃣-record의-특징">record의 특징</a></li>
  <li><a href="#2️⃣-기존-클래스-vs-record-비교">기존 클래스 vs record 비교</a></li>
  <li><a href="#3️⃣-record의-내부-동작">record 내부 동작</a></li>
  <li><a href="#4️⃣-record의-주요-기능">record 주요 기능</a></li>
  <li><a href="#5️⃣-record를-언제-사용할까">record 사용 방법</a></li>
  <li><a href="#6️⃣-정리">정리</a></li>
</ul>

<hr />

<h1 id="왜-queueint는-안-되고-queueinteger는-될까">왜 <code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code>는 안 되고 <code class="language-plaintext highlighter-rouge">Queue&lt;Integer&gt;</code>는 될까?</h1>

<p>Java 제네릭을 쓰다 보면 한 번씩 멈칫하게 되는 질문입니다. “왜 <code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code>는 안 되는데 <code class="language-plaintext highlighter-rouge">Queue&lt;Integer&gt;</code>는 되지?” 이 글은 그 이유를 **타입 소거(type erasure)**와 <strong>참조 타입만 허용하는 제네릭 규칙</strong>에서 차근차근 풀어 설명합니다. 실전 성능 팁과 BFS 같은 알고리즘 코드 패턴도 함께 담았습니다.</p>

<hr />

<h2 id="정리">정리</h2>

<ul>
  <li><strong>제네릭 타입 인자(T)는 참조 타입만 가능</strong>합니다. (<code class="language-plaintext highlighter-rouge">T extends Object</code>가 암묵적 전제)</li>
  <li><strong>타입 소거</strong>로 인해 런타임에는 제네릭 정보가 지워지고, 메서드 시그니처가 사실상 <code class="language-plaintext highlighter-rouge">Object</code> 기반으로 동작합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">int</code> 같은 <strong>원시 타입(primitive)</strong> 은 <code class="language-plaintext highlighter-rouge">Object</code>가 아니므로 <strong>제네릭 인자로 쓸 수 없습니다.</strong> ⇒ <code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code> 금지</li>
  <li><strong>배열은 참조 타입</strong>이므로 <code class="language-plaintext highlighter-rouge">Queue&lt;int[]&gt;</code>는 가능합니다. (배열 자체는 객체)</li>
  <li>알고리즘 큐에는 <strong><code class="language-plaintext highlighter-rouge">int[]</code> 또는 <code class="language-plaintext highlighter-rouge">record/class</code>로 상태를 묶어</strong> 넣으면 <strong>박싱 없이</strong> 빠르고 메모리 친화적입니다.</li>
</ul>

<hr />

<h2 id="1-제네릭은-왜-쓰나">1) 제네릭은 왜 쓰나?</h2>

<p>컴파일 타임에 타입을 체크해 <strong>타입 안전성</strong>을 높이고, 캐스트를 없애 <strong>가독성</strong>과 <strong>유지보수성</strong>을 올리기 위해서입니다.
<a href="https://nan0silver.github.io/java/2025-01-29-generic/">제네릭에 대해 정리한 블로그 글 참고</a></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 제네릭 없음: 캐스트 필요</span>
<span class="nc">List</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">();</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"hi"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

<span class="c1">// 제네릭 사용: 컴파일 타임에 체크, 캐스트 제거</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">list2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"hi"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">y</span> <span class="o">=</span> <span class="n">list2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<h2 id="2-타입-소거type-erasure란">2) 타입 소거(type erasure)란?</h2>

<p>자바의 제네릭은 <strong>런타임에 사라집니다.</strong> 컴파일러가 제네릭 코드를 검사·보정한 뒤, <strong>실행 시점에는 타입 매개변수를 지운(Object로 대체한)</strong> 형태로 동작합니다.</p>

<p>개념적으로 다음과 같습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 원본</span>
<span class="kd">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="no">T</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
  <span class="no">T</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// (개념적) 컴파일 후 - T가 지워지고 Object 중심으로</span>
<span class="kd">class</span> <span class="nc">Box</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Object</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
  <span class="nc">Object</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>컴파일러가 <strong>캐스트 삽입</strong>과 <strong>오토박싱/언박싱</strong>으로 타입 안전을 보정해 줍니다(필요 시 브리지 메서드도 생성).</p>

<hr />

<h2 id="3-t는-왜-참조-타입만-될-수-있나">3) T는 왜 ‘참조 타입’만 될 수 있나?</h2>

<p>자바 언어 규칙상 **모든 타입 매개변수는 암묵적으로 <code class="language-plaintext highlighter-rouge">T extends Object</code>**로 취급됩니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Integer</code>, <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">MyClass</code> 같은 <strong>참조 타입(reference type)</strong> 은 <code class="language-plaintext highlighter-rouge">Object</code>의 하위 타입이므로 OK.</li>
  <li><code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">boolean</code> 같은 <strong>원시 타입(primitive)</strong> 은 <code class="language-plaintext highlighter-rouge">Object</code>가 아니므로 <strong>제네릭 타입 인자로 금지</strong>됩니다.</li>
</ul>

<p>즉, <code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code>는 <strong>언어 차원에서 성립하지 않습니다.</strong></p>

<blockquote>
  <p>포인트: <strong>타입 소거 후의 세계는 <code class="language-plaintext highlighter-rouge">Object</code> 중심</strong>이라, 그 세계로 들어올 수 있는 타입(=참조 타입)만 제네릭 인자가 될 수 있습니다.</p>
</blockquote>

<hr />

<h2 id="4-그렇다면-queueinteger는-왜-되나">4) 그렇다면 <code class="language-plaintext highlighter-rouge">Queue&lt;Integer&gt;</code>는 왜 되나?</h2>

<p><code class="language-plaintext highlighter-rouge">Integer</code>는 <code class="language-plaintext highlighter-rouge">int</code>의 <strong>래퍼 클래스</strong>(참조 타입)입니다. 제네릭 인자로 쓸 수 있고, <code class="language-plaintext highlighter-rouge">q.offer(1)</code>처럼 쓰면 <strong>오토박싱</strong>이 자동으로 일어나 <code class="language-plaintext highlighter-rouge">int -&gt; Integer</code>가 됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>      <span class="c1">// int가 Integer로 오토박싱</span>
<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span> <span class="c1">// Integer가 int로 언박싱</span>
</code></pre></div></div>

<p>단, 이 과정은 <strong>객체 할당/GC 비용</strong>이 들 수 있습니다. 대량 연산에서는 체감될 수 있어요.</p>

<hr />

<h2 id="5-queueint는-왜-가능한가">5) <code class="language-plaintext highlighter-rouge">Queue&lt;int[]&gt;</code>는 왜 가능한가?</h2>

<p>배열은 <strong>항상 참조 타입</strong>입니다. 원소가 원시 타입이든 말든, <strong>배열 자체는 힙 객체</strong>니까 제네릭 인자로 사용 가능해요.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">});</span> <span class="c1">// 배열 참조를 넣음</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<h2 id="6-성능메모리-관점-오토박싱을-피하자">6) 성능·메모리 관점: 오토박싱을 피하자</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Queue&lt;Integer&gt;</code>는 <strong>원소마다 <code class="language-plaintext highlighter-rouge">Integer</code> 객체</strong>가 생길 수 있어</p>

    <ul>
      <li>오토박싱/언박싱 비용</li>
      <li>객체 헤더 + 포인터 오버헤드</li>
      <li>GC 부담
이 발생합니다.</li>
    </ul>
  </li>
  <li>
    <p>알고리즘(특히 BFS/DFS, 다익스트라 등)에서는 <strong>박싱을 피하는 게 유리</strong>합니다.</p>
  </li>
</ul>

<h3 id="권장-1-int로-상태-묶기-가볍고-빠름">권장 1) <code class="language-plaintext highlighter-rouge">int[]</code>로 상태 묶기 (가볍고 빠름)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// {r, c, breakUsed, dist}</span>
<span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">});</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</code></pre></div></div>

<h3 id="권장-2-record로-가독성--java-16">권장 2) <code class="language-plaintext highlighter-rouge">record</code>로 가독성 ↑ (Java 16+)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">State</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{}</span>
<span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">State</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
<span class="nc">State</span> <span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</code></pre></div></div>

<blockquote>
  <p>팁: 큐 구현체는 **<code class="language-plaintext highlighter-rouge">ArrayDeque</code>**가 일반적으로 <code class="language-plaintext highlighter-rouge">LinkedList</code>보다 빠르고 메모리 효율적입니다.</p>
</blockquote>

<hr />

<h2 id="7-실전-faq">7) 실전 FAQ</h2>

<p><strong>Q1. “런타임에 진짜 <code class="language-plaintext highlighter-rouge">Queue&lt;Object&gt;</code>로 동작하나요?”</strong>
개념적으로는 <strong>그와 유사</strong>합니다(타입 소거). 실제로는 컴파일러가 캐스트/브리지 메서드 등으로 타입 안전을 맞춰 줍니다. 핵심은 <strong>런타임에 타입 인자 정보가 없고 <code class="language-plaintext highlighter-rouge">Object</code> 중심으로 호출</strong>된다는 점입니다.</p>

<p><strong>Q2. 그렇다면 왜 컴파일러가 <code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code>도 자동으로 <code class="language-plaintext highlighter-rouge">Queue&lt;Integer&gt;</code>로 바꿔주지 않나요?</strong>
언어 규칙상 <strong>제네릭 인자는 참조 타입만</strong> 허용합니다. 타입 인자 자체를 바꾸는 묵시적 변환은 <strong>설계상 모호성과 함정</strong>(예: <code class="language-plaintext highlighter-rouge">T</code>가 원시로 선언됐는데 실제론 참조로 다뤄짐)을 낳기에 금지됩니다. 명시적으로 <code class="language-plaintext highlighter-rouge">Integer</code>를 써 주세요.</p>

<p><strong>Q3. 원시 타입 컬렉션이 꼭 필요합니다. 방법이 없나요?</strong>
표준 라이브러리는 제공하지 않지만, <strong>전용 라이브러리</strong>가 있습니다.</p>

<ul>
  <li>fastutil (<code class="language-plaintext highlighter-rouge">IntArrayList</code>, <code class="language-plaintext highlighter-rouge">IntOpenHashSet</code>, …)</li>
  <li>HPPC (High Performance Primitive Collections)</li>
  <li>Eclipse Collections (primitive collections)
대량 데이터·고성능 시나리오에서 유용합니다.</li>
</ul>

<hr />

<h2 id="8-bfs-예시-박싱-없이-깔끔하게">8) BFS 예시: 박싱 없이 깔끔하게</h2>

<p>아래는 “벽을 한 번만 부술 수 있는” BFS 패턴입니다. <code class="language-plaintext highlighter-rouge">int[]</code>로 상태를 묶어 <strong>박싱을 회피</strong>합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dc</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="no">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">boolean</span><span class="o">[][][]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">});</span> <span class="c1">// r, c, breakUsed, dist</span>
        <span class="n">visited</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">b</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="n">d</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="no">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="no">M</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">d</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span> <span class="o">}</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">dr</span><span class="o">[</span><span class="n">k</span><span class="o">],</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">dc</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nr</span> <span class="o">&gt;=</span> <span class="no">N</span> <span class="o">||</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nc</span> <span class="o">&gt;=</span> <span class="no">M</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">nr</span><span class="o">][</span><span class="n">nc</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">nr</span><span class="o">][</span><span class="n">nc</span><span class="o">][</span><span class="n">b</span><span class="o">])</span> <span class="o">{</span> <span class="n">visited</span><span class="o">[</span><span class="n">nr</span><span class="o">][</span><span class="n">nc</span><span class="o">][</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nr</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">});</span> <span class="o">}</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="o">[</span><span class="n">nr</span><span class="o">][</span><span class="n">nc</span><span class="o">][</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">visited</span><span class="o">[</span><span class="n">nr</span><span class="o">][</span><span class="n">nc</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nr</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">});</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ans</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="9-한눈에-요약-체크리스트">9) 한눈에 요약 체크리스트</h2>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />제네릭 인자 = <strong>참조 타입만</strong> (암묵적 <code class="language-plaintext highlighter-rouge">T extends Object</code>)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />런타임 = <strong>타입 소거</strong> (제네릭 정보 없음, <code class="language-plaintext highlighter-rouge">Object</code> 중심)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code> ❌, <code class="language-plaintext highlighter-rouge">Queue&lt;Integer&gt;</code> ⭕</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><code class="language-plaintext highlighter-rouge">Queue&lt;int[]&gt;</code> ⭕ (배열은 참조 타입)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />성능 중요: <strong>박싱 피하기</strong> (가능하면 <code class="language-plaintext highlighter-rouge">int[]</code>/<code class="language-plaintext highlighter-rouge">record</code> 사용)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />큐 구현체는 보통 <strong><code class="language-plaintext highlighter-rouge">ArrayDeque</code></strong> 추천</li>
</ul>

<hr />

<h2 id="마무리">마무리</h2>

<p><code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code>가 금지되는 이유는 단순히 “문법이 그렇다”가 아니라, <strong>타입 소거라는 실행 모델</strong>과 <strong>참조 타입만 허용하는 제네릭 설계</strong>가 맞물린 결과입니다. 오늘부터는 알고리즘에서 <strong>박싱 없는 상태 표현</strong>으로 깔끔하고 빠른 코드를 써 보세요!</p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="java" /><summary type="html"><![CDATA["왜 Queue는 안 되는데 Queue는 되지?"에 대한 이유를 설명합니다.]]></summary></entry><entry><title type="html">[친구하자] 매칭 대기열 설계 기록 : 왜 DB + Redis 하이브리드로 갔나</title><link href="https://nan0silver.github.io/projectdiary/2025-08-25-diary/" rel="alternate" type="text/html" title="[친구하자] 매칭 대기열 설계 기록 : 왜 DB + Redis 하이브리드로 갔나" /><published>2025-08-25T00:00:00+00:00</published><updated>2025-10-14T05:30:08+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-08-25-diary/"><![CDATA[<ul>
  <li><a href="#문제-배경">문제 배경</a></li>
  <li><a href="#tldr">TL;DR</a></li>
  <li><a href="#1-내가-왜-이런-고민을-하게-됐나-맥락">1. 내가 왜 이런 고민을 하게 됐나</a></li>
  <li><a href="#2-현재-구현의-문제-정리-redis-단독일-때">2. 현재 구현의 문제 정리 (Redis 단독일 때)</a></li>
  <li><a href="#3-하이브리드-설계-원칙">3. 하이브리드 설계 원칙</a></li>
  <li><a href="#4-개선된-데이터-흐름">4. 개선된 데이터 흐름</a></li>
  <li><a href="#5-redis-자료구조-선택과-이유">5. Redis 자료구조 선택과 이유</a></li>
  <li><a href="#6-원자적-매칭-lua-스크립트-예시개념">6. 원자적 매칭: Lua 스크립트 예시(개념)</a></li>
  <li><a href="#7-복구-메커니즘서버-재기동장애-대비">7. 복구 메커니즘(서버 재기동/장애 대비)</a></li>
  <li><a href="#8-스키마인덱스-설계">8. 스키마/인덱스 설계</a></li>
  <li><a href="#9-시스템-구성개념-아키텍처">9. 시스템 구성(개념 아키텍처)</a></li>
  <li><a href="#10-실무에서의-선택지-비교">10. 실무에서의 선택지 비교</a></li>
  <li><a href="#11-테스트운영-시나리오">11. 테스트/운영 시나리오</a></li>
  <li><a href="#12-내가-배운-점--선택의-근거">12. 내가 배운 점 &amp; 선택의 근거</a></li>
  <li><a href="#13-next-steps-로드맵">13. Next Steps (로드맵)</a></li>
  <li><a href="#부록-a-코드-스니펫개념">부록 A. 코드 스니펫(개념)</a></li>
</ul>

<blockquote>
  <p>“대기열=실시간성, 기록/분석/복구=영속성.”
이 두 욕심을 동시에 만족시키려다 보니 하이브리드(DB+Redis)가 자연스럽게 답이 되었다.</p>
</blockquote>

<hr />

<h2 id="문제-배경">문제 배경</h2>

<ul>
  <li>친구하자 구현 중 핵심인 통화 매칭 부분을 구현하는 중이였다.</li>
  <li>초반 설계에서는 Redis만 사용해서 구현하기로 하여 하고있었는데, 이렇게 하면 대기열 기록이 되지않아 나중에 시스템 분석 및 복구에 어려움이 있어보였다.</li>
  <li>따라서 DB와 함께 구현하는 방식이 많이 사용되는 방식인지, 어떤 부분에 장단점이 있고 고려해야하는 부분은 어떤 것인지 궁금했다.</li>
  <li>또한 관련되서 더 심화된 기술은 어떤 것이 있는지 알아보고싶었다.</li>
</ul>

<hr />

<h2 id="tldr">TL;DR</h2>

<ul>
  <li><strong>문제의식</strong>: Redis만 쓰면 빠르지만 휘발성·운영/분석/복구가 약하다. DB만 쓰면 영속적이지만 지연·경합에 취약하다.</li>
  <li><strong>결론</strong>: <strong>DB(사실의 원천, 이력/분석/복구) + Redis(실시간 대기열/매칭)</strong> 를 분리한 하이브리드 구조.</li>
  <li><strong>실무 팁</strong>: 아웃박스 패턴으로 <strong>이중 쓰기 일관성</strong>, Redis <strong>ZSET</strong>+<strong>Lua</strong>로 <strong>원자적 매칭</strong>, <strong>멱등키/TTL/청소잡/AOF+복제</strong>로 운영 내구성 확보.</li>
  <li><strong>대안</strong>: 규모·요구사항에 따라 Redis Streams, RabbitMQ, Kafka, SQS, Postgres SKIP LOCKED도 선택지.</li>
</ul>

<hr />

<h2 id="1-내가-왜-이런-고민을-하게-됐나-맥락">1) 내가 왜 이런 고민을 하게 됐나 (맥락)</h2>

<p>친구하자는 <strong>1분 내 매칭</strong> 같은 <strong>저지연 실시간성</strong>이 핵심이다. 그래서 처음엔 <strong>Redis 단독</strong>이 끌렸다.
하지만 곧바로 다음 현실에 부딪혔다.</p>

<ul>
  <li><strong>휘발성 vs 영속성</strong>: Redis는 빠르지만(메모리) 장애/재시작 시 <strong>데이터 유실</strong> 리스크.</li>
  <li><strong>운영/디버깅</strong>: 매칭 실패/타임아웃/취소 이슈를 <strong>재현</strong>하고 <strong>원인 추적</strong>하려면 <strong>이력 테이블</strong>이 꼭 필요.</li>
  <li><strong>통계/제품개선</strong>: 카테고리별 대기시간·매칭률·시간대 부하 같은 <strong>지표</strong>는 DB가 편하다.</li>
  <li><strong>복구 시나리오</strong>: 서버/Redis 재기동 시 <strong>“누가 줄에 서 있었나?”</strong> 를 복원하려면 DB에 근거가 있어야 한다.</li>
</ul>

<p>결국 “<strong>실시간 처리=Redis</strong>”, “<strong>이력/분석/복구=DB</strong>”로 역할을 나누는 하이브리드가 합리적이라는 결론에 도달했다.</p>

<hr />

<h2 id="2-현재-구현의-문제-정리-redis-단독일-때">2) 현재 구현의 문제 정리 (Redis 단독일 때)</h2>

<ol>
  <li><strong>데이터 영속성</strong>: 서버/Redis 재시작 시 대기열 유실 가능</li>
  <li><strong>통계/분석 취약</strong>: 매칭 히스토리/패턴 분석이 어려움</li>
  <li><strong>디버깅 곤란</strong>: 실패 재현·CS 대응 근거 부족</li>
  <li><strong>복구 어려움</strong>: 장애 시 대기열/상태 재구성이 힘듦</li>
</ol>

<hr />

<h2 id="3-하이브리드-설계-원칙">3) 하이브리드 설계 원칙</h2>

<h3 id="1-단일-출처single-source-of-truth-sot-명확화">(1) 단일 출처(Single Source of Truth, SOT) 명확화</h3>

<ul>
  <li><strong>대기열의 SOT = Redis</strong> (실시간 기준)</li>
  <li><strong>이력/상태의 SOT = DB</strong> (사실 기준)</li>
</ul>

<h3 id="2-일관성-경계-정의">(2) 일관성 경계 정의</h3>

<ul>
  <li>두 저장소에 <strong>언제/어떤 순서로</strong> 쓸지 고정.</li>
  <li>권장: <strong>DB 트랜잭션</strong>으로 <code class="language-plaintext highlighter-rouge">matching_queue(WAITING)</code> + <strong>아웃박스 이벤트</strong>를 함께 기록 → 워커가 <strong>Redis에 enqueue</strong> (재시도 가능)</li>
</ul>

<h3 id="3-멱등성중복-방지">(3) 멱등성/중복 방지</h3>

<ul>
  <li>사용자 중복 등록 방지: <code class="language-plaintext highlighter-rouge">SET user:{id}:queued 1 NX EX 600</code></li>
  <li>매칭 결과 멱등 업데이트: <code class="language-plaintext highlighter-rouge">match_id</code> <strong>UNIQUE</strong> 제약 등</li>
</ul>

<hr />

<h2 id="4-개선된-데이터-흐름">4) 개선된 데이터 흐름</h2>

<ol>
  <li>
    <p><strong>참가(Enqueue)</strong>:</p>

    <ul>
      <li>DB 트랜잭션: <code class="language-plaintext highlighter-rouge">matching_queue(WAITING)</code> + <code class="language-plaintext highlighter-rouge">outbox(enqueue_event)</code></li>
      <li>Outbox Consumer가 Redis <strong>ZSET</strong>에 등록</li>
    </ul>
  </li>
  <li>
    <p><strong>매칭(Match)</strong>:</p>

    <ul>
      <li>Redis에서 <strong>원자적으로 두 명을 Pop</strong> (Lua 스크립트)</li>
      <li>DB에 <code class="language-plaintext highlighter-rouge">MATCHING → MATCHED</code> 상태 전이(멱등)</li>
    </ul>
  </li>
  <li>
    <p><strong>통계/리포트</strong>:</p>

    <ul>
      <li>DB 이력 기반 분석/대시보드</li>
    </ul>
  </li>
  <li>
    <p><strong>실시간 조회</strong>:</p>
    <ul>
      <li>Redis 대기열 길이, 평균 대기시간(샘플링) 즉시 응답</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="5-redis-자료구조-선택과-이유">5) Redis 자료구조 선택과 이유</h2>

<ul>
  <li>
    <p><strong>ZSET(정렬집합)</strong> 권장</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">score = 대기 시작 시각 or 우선순위</code></li>
      <li><strong>공정성(FCFS)/우선순위</strong>/타임아웃 처리 쉽다.</li>
      <li>꺼낼 때 <strong>원자성</strong>을 위해 Lua 스크립트 사용.</li>
    </ul>
  </li>
  <li>
    <p><strong>덧붙임</strong></p>

    <ul>
      <li><strong>SET NX</strong>로 중복 등록 방지</li>
      <li><strong>HASH</strong>(<code class="language-plaintext highlighter-rouge">queue:{queueId}</code>)로 사용자·카테고리·TTL 메타 저장</li>
      <li><strong>TTL + 정리잡</strong>으로 고아 항목 청소</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>단순 리스트(LLEN/LPOP)는 쉽지만 공정성·타임아웃·중복 제어를 구조적으로 풀기 어렵다.
<strong>Streams</strong>는 컨슈머 그룹/ACK로 내구성이 좋지만 매칭 “쌍짓기”엔 별도 설계가 필요.</p>
</blockquote>

<hr />

<h2 id="6-원자적-매칭-lua-스크립트-예시개념">6) 원자적 매칭: Lua 스크립트 예시(개념)</h2>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- KEYS[1]=zset key, ARGV[1]=score(복원용)</span>
<span class="kd">local</span> <span class="n">k</span> <span class="o">=</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="kd">local</span> <span class="n">a</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'ZRANGE'</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">if</span> <span class="o">#</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span> <span class="k">return</span> <span class="p">{}</span> <span class="k">end</span>
<span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'ZREM'</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="kd">local</span> <span class="n">b</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'ZRANGE'</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">if</span> <span class="o">#</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span>
  <span class="c1">-- 짝이 없으면 되돌리기</span>
  <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'ZADD'</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">return</span> <span class="p">{}</span>
<span class="k">end</span>
<span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'ZREM'</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="c1">-- 필요 시 락/마킹/TTL 등 추가</span>
<span class="k">return</span> <span class="p">{</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
</code></pre></div></div>

<blockquote>
  <p>실전에서는 <strong>되돌리기/락/타임아웃/카테고리 필터</strong>까지 넣어야 한다.</p>
</blockquote>

<hr />

<h2 id="7-복구-메커니즘서버-재기동장애-대비">7) 복구 메커니즘(서버 재기동/장애 대비)</h2>

<ul>
  <li>Redis는 <strong>AOF(append-only)</strong> + <strong>영속 볼륨</strong> + <strong>복제/센티넬</strong>로 내구성 강화</li>
  <li>그래도 안전망으로 <strong>“최근 WAITING만 DB→Redis 재적재”</strong> 수행</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 서버 기동 시 안전 복구(개념)</span>
<span class="nd">@PostConstruct</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">recoverQueuesFromDatabase</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">active</span> <span class="o">=</span> <span class="n">matchingQueueRepository</span><span class="o">.</span><span class="na">findByQueueStatusAndCreatedAtAfter</span><span class="o">(</span>
        <span class="nc">QueueStatus</span><span class="o">.</span><span class="na">WAITING</span><span class="o">,</span>
        <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">minusMinutes</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
    <span class="o">);</span>
    <span class="n">active</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">queue</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="c1">// Redis 재적재 로직(ZSET + 메타 HSET 등)</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>운영에선 <strong>ApplicationRunner + 분산락</strong>으로 <strong>중복 복구 방지</strong>를 권장.</p>
</blockquote>

<hr />

<h2 id="8-스키마인덱스-설계">8) 스키마/인덱스 설계</h2>

<p><strong>matching_queue</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">id, user_id, category, status(WAITING/MATCHING/MATCHED/EXPIRED/CANCELLED), created_at, updated_at</code></li>
  <li>인덱스: <code class="language-plaintext highlighter-rouge">(status, created_at)</code>, <code class="language-plaintext highlighter-rouge">(user_id, status)</code></li>
</ul>

<p><strong>match_events</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">match_id(UNIQUE), user_a, user_b, started_at, ended_at, result, reason</code></li>
  <li>멱등키: <code class="language-plaintext highlighter-rouge">match_id UNIQUE</code></li>
</ul>

<p><strong>outbox</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">event_id, type, payload, created_at, processed_at NULLABLE</code></li>
  <li>워커가 <code class="language-plaintext highlighter-rouge">processed_at IS NULL</code>만 읽고 성공 시 채움(재시도 가능)</li>
</ul>

<hr />

<h2 id="9-시스템-구성개념-아키텍처">9) 시스템 구성(개념 아키텍처)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[API] ──(Tx)──&gt; [DB] ──(Outbox)──&gt; [Outbox Consumer] ──&gt; [Redis ZSET]
  │                                              │
  └──────────────(조회/이력)──────────────────────┘

[Matching Worker] &lt;──&gt; [Redis ZSET + Lua + TTL]
      │                            │
      └────(멱등 업데이트)──────&gt; [DB: 상태/이력]
</code></pre></div></div>

<p>운영 필수 체크:</p>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Redis <strong>AOF + 복제/센티넬</strong></li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>아웃박스/재시도</strong>로 DB↔Redis <strong>일관성 보장</strong></li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>SET NX/TTL/청소잡/분산락</strong></li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>대기열 길이/평균 대기시간/타임아웃률/매칭 성공률</strong> 메트릭</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>enqueue/match/cancel/timeout</strong> 이벤트 로깅</li>
</ul>

<hr />

<h2 id="10-실무에서의-선택지-비교">10) 실무에서의 선택지 비교</h2>

<table>
  <thead>
    <tr>
      <th>시나리오</th>
      <th>권장 스택</th>
      <th>핵심 포인트</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>저지연 실시간 매칭 (MVP~중규모)</strong></td>
      <td><strong>Redis (ZSET/Streams) + DB</strong></td>
      <td>속도·복잡도 밸런스 좋음</td>
    </tr>
    <tr>
      <td><strong>내구성 높은 큐/재처리/다중소비자</strong></td>
      <td><strong>Redis Streams</strong> or <strong>RabbitMQ</strong> + DB</td>
      <td>ACK/리트라이/가시성 타임아웃 쉬움</td>
    </tr>
    <tr>
      <td><strong>대규모 분산/리플레이</strong></td>
      <td><strong>Kafka</strong> (+ Redis 캐시)</td>
      <td>파티셔닝·재처리 강점, 매칭 로직은 앱에서</td>
    </tr>
    <tr>
      <td><strong>아주 단순/저QPS</strong></td>
      <td><strong>Postgres</strong> (<code class="language-plaintext highlighter-rouge">FOR UPDATE SKIP LOCKED</code>)</td>
      <td>운영 단순, 지연·경합은 감수</td>
    </tr>
    <tr>
      <td><strong>관리형 간단 큐</strong></td>
      <td><strong>SQS</strong></td>
      <td>쉬움+내구성, 초저지연 매칭은 보완 필요</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>친구하자의 <strong>“1분 내 매칭·공정성·운영 용이성”</strong> 기준에선 현재 <strong>Redis ZSET + DB</strong>가 가장 적합. 추후 트래픽 급증 시 <strong>Streams/Kafka</strong>로 확장 가능.</p>
</blockquote>

<hr />

<h2 id="11-테스트운영-시나리오">11) 테스트/운영 시나리오</h2>

<ul>
  <li><strong>부하 테스트</strong>: 카테고리별 동시 1k~5k 등록, 평균/95p 대기시간, 매칭 성공률 측정</li>
  <li><strong>경합 테스트</strong>: 동시 매칭 워커 2~10개, 중복 매칭/유실 여부</li>
  <li><strong>장애 시나리오</strong>: Redis 재시작, 네트워크 분리, DB 쓰기 실패 시 재시도 동작</li>
  <li><strong>복구 리허설</strong>: DB→Redis 재적재 로직의 <strong>멱등성/중복 방지</strong> 검증</li>
</ul>

<hr />

<h2 id="12-내가-배운-점--선택의-근거">12) 내가 배운 점 &amp; 선택의 근거</h2>

<ul>
  <li>실시간성만 보면 Redis 단독이 매력적이지만, <strong>운영·분석·복구</strong>까지 생각하면 <strong>DB 하이브리드</strong>가 필수.</li>
  <li><strong>단일 출처</strong>를 나누고(<strong>대기열=Redis, 이력=DB</strong>), <strong>이중 쓰기 일관성</strong>(아웃박스/재시도)을 확보하면 MVP 이후에도 <strong>확장 가능한 길</strong>이 열린다.</li>
  <li>Redis에선 <strong>ZSET + Lua</strong>가 <strong>공정성/타임아웃/원자성</strong>을 한 번에 잡는 실전 해법이었다.</li>
</ul>

<hr />

<h2 id="13-next-steps-로드맵">13) Next Steps (로드맵)</h2>

<ol>
  <li><strong>아웃박스 컨슈머</strong> 도입 및 재시도/백오프</li>
  <li><strong>Lua 스크립트</strong>에 락/타임아웃/복원 로직 보강</li>
  <li><strong>AOF+복제/센티넬</strong> 운영화</li>
  <li><strong>메트릭/알람</strong>: 대기열 길이·대기시간·타임아웃률·에러율</li>
  <li>트래픽 증가 시 <strong>Streams</strong> 도입 검토(컨슈머 그룹 기반), 더 커지면 <strong>Kafka</strong> 병행</li>
</ol>

<hr />

<h3 id="부록-a-코드-스니펫개념">부록 A. 코드 스니펫(개념)</h3>

<p><strong>DB → Outbox 트랜잭션</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">enqueue</span><span class="o">(</span><span class="nc">Long</span> <span class="n">userId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">category</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">MatchingQueue</span> <span class="n">q</span> <span class="o">=</span> <span class="n">matchingQueueRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span>
        <span class="nc">MatchingQueue</span><span class="o">.</span><span class="na">waiting</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">category</span><span class="o">)</span>
    <span class="o">);</span>
    <span class="n">outboxRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="nc">OutboxEvent</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">category</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>Outbox Consumer → Redis</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">OutboxEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"mq:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getCategory</span><span class="o">();</span>
    <span class="c1">// 중복 방지</span>
    <span class="nc">Boolean</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="na">setIfAbsent</span><span class="o">(</span><span class="s">"user:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getUserId</span><span class="o">()</span> <span class="o">+</span> <span class="s">":queued"</span><span class="o">,</span> <span class="s">"1"</span><span class="o">,</span> <span class="nc">Duration</span><span class="o">.</span><span class="na">ofMinutes</span><span class="o">(</span><span class="mi">10</span><span class="o">));</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">Boolean</span><span class="o">.</span><span class="na">TRUE</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ok</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">redis</span><span class="o">.</span><span class="na">zAdd</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getEnqueuedAt</span><span class="o">().</span><span class="na">toEpochSecond</span><span class="o">(</span><span class="nc">ZoneOffset</span><span class="o">.</span><span class="na">UTC</span><span class="o">),</span> <span class="n">e</span><span class="o">.</span><span class="na">getQueueId</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="n">outboxRepository</span><span class="o">.</span><span class="na">markProcessed</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="마무리">마무리</h2>

<p>이번 설계는 “<strong>현재 요구(저지연)</strong>”와 “<strong>미래 요구(운영/분석/복구/확장)</strong>”를 동시에 충족시키기 위한 <strong>균형점</strong>을 찾는 과정이었다.
<strong>DB+Redis 하이브리드</strong>는 그 균형점 위에서 <strong>실무적으로 검증된 길</strong>이며, MVP에서 시작해 <strong>Streams/Kafka</strong>로 확장 가능한 <strong>진화 경로</strong>를 갖는다.
친구하자의 성격(실시간 매칭 + 장기 운영/분석 필요)에 <strong>정합한 선택</strong>이라고 생각한다.</p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[친구하자 프로젝트 개발 중 매칭 대기열을 구현하다가 생긴 고민을 정리해보았습니다.]]></summary></entry><entry><title type="html">[TIL] A/B 테스트</title><link href="https://nan0silver.github.io/til/2025-08-23-til/" rel="alternate" type="text/html" title="[TIL] A/B 테스트" /><published>2025-08-23T00:00:00+00:00</published><updated>2025-08-23T00:36:49+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-08-23-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
📅 <strong>작성일</strong>: 2025-08-23<br />
🔄 <strong>최종 수정</strong>: 2025년 08월 25일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h1 id="ab-테스트란">A/B 테스트란?</h1>

<ul>
  <li><strong>정의</strong>: 같은 목표를 두고 <strong>두 버전(A=기준, B=변경안)</strong> 을 <strong>동시에 무작위로</strong> 사용자에게 나눠 보여준 뒤, <strong>어느 쪽이 더 성과가 좋은지</strong> 통계적으로 비교하는 실험.</li>
  <li><strong>목적</strong>: 느낌/감이 아니라 <strong>데이터로 의사결정</strong>. 버튼 문구, 화면 배치, 가격 제안, 푸시 타이밍 등 “실제로” 지표가 개선되는지 검증.</li>
</ul>

<h1 id="기본-용어">기본 용어</h1>

<ul>
  <li><strong>변수(Variant)</strong>: A(컨트롤) vs B(실험안). 3개 이상이면 A/B/n.</li>
  <li><strong>지표(Metric)</strong>: 실험의 <strong>목표</strong>(예: 등록 전환율, 1일차 잔존, 통화 완료율).</li>
  <li><strong>유의수준 α</strong>: 오탐 허용(보통 0.05).</li>
  <li><strong>검정력 Power(1−β)</strong>: 진짜 차이가 있을 때 잡아낼 확률(보통 0.8).</li>
  <li><strong>MDE</strong>(최소 검출 가능 효과): “이 정도 차이는 나야 성공이라 본다” 최소 개선 폭(예: +2%p).</li>
</ul>

<h1 id="어떻게-하는가-실전-절차-7단계">어떻게 하는가 (실전 절차 7단계)</h1>

<ol>
  <li>
    <p><strong>가설 세우기</strong></p>

    <ul>
      <li>예) “대기시간 안내 문구를 바꾸면 <strong>매칭 시작 클릭률</strong>이 ↑한다.”</li>
    </ul>
  </li>
  <li>
    <p><strong>지표 딱 하나만 주지표로</strong></p>

    <ul>
      <li>주지표: 매칭 시작 클릭률</li>
      <li>보조지표(가드레일): 이탈률, 고객불만 접수율 등 “부작용 체크”</li>
    </ul>
  </li>
  <li>
    <p><strong>표본수(기간) 계획</strong></p>

    <ul>
      <li>대략의 규칙: <strong>차이를 작게 보고 싶을수록, 베이스 전환율이 낮을수록 → 더 많은 트래픽/기간</strong>이 필요.</li>
      <li>
        <p>(참고 공식 – <strong>이해만</strong>):</p>

        <ul>
          <li>
            <p>비율형 지표의 각 그룹 표본수 n ≈ <code class="language-plaintext highlighter-rouge">2 * (zα/2 + zβ)^2 * p̄(1-p̄) / Δ^2</code></p>

            <ul>
              <li><code class="language-plaintext highlighter-rouge">p̄</code>: 기준 전환율 추정, <code class="language-plaintext highlighter-rouge">Δ</code>: 검증하고 싶은 차이(절대값)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>무작위 배정 &amp; 고정</strong></p>

    <ul>
      <li><strong>사용자 단위</strong>로 50/50 랜덤 분배(세션/페이지뷰 단위 X).</li>
      <li>실험 중엔 <strong>변형하지 말기</strong>(중간에 디자인을 또 바꾸지 않기).</li>
    </ul>
  </li>
  <li>
    <p><strong>정확한 로깅</strong></p>

    <ul>
      <li>모든 이벤트에 <code class="language-plaintext highlighter-rouge">experiment_id</code>, <code class="language-plaintext highlighter-rouge">variant</code>(A/B) 파라미터를 함께 로깅.</li>
      <li><strong>SRM</strong>(sample ratio mismatch) 체크: 50/50이 크게 깨지면(예: 60/40) 실험 무효.</li>
    </ul>
  </li>
  <li>
    <p><strong>기간 고정 &amp; ‘엿보기’ 금지</strong></p>

    <ul>
      <li><strong>종료 조건 전</strong>에 유의성만 보고 중단하면 거짓 양성↑.</li>
      <li>꼭 필요하면 <strong>사전 정의된 순차검정</strong>(group-sequential)이나 <strong>베이즈 접근</strong>을 사용.</li>
    </ul>
  </li>
  <li>
    <p><strong>해석 &amp; 롤아웃</strong></p>

    <ul>
      <li>통계 유의 + <strong>실무 유의</strong>(임팩트/비용/부작용) 함께 본 뒤, 점진적 롤아웃(예: 10%→30%→100%).</li>
    </ul>
  </li>
</ol>

<h1 id="ga4앱에서-바로-쓰는-구성-팁">GA4/앱에서 바로 쓰는 구성 팁</h1>

<ul>
  <li>
    <p>이벤트 설계 예:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">event_name: start_match_click</code></li>
      <li>
        <p>파라미터:</p>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">experiment_id: "wait_copy_v1"</code></li>
          <li><code class="language-plaintext highlighter-rouge">variant: "A"|"B"</code></li>
          <li>사용자 ID 또는 설치 ID(사용자 기준 배정 유지)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>빅쿼리 연동</strong> 시 쿼리로 <code class="language-plaintext highlighter-rouge">variant</code>별 전환율 비교가 쉬워짐.</li>
  <li><strong>SRM 빠른 체킹</strong>: 실시간 대시보드에서 A/B 트래픽이 49–51% 근처인지 확인.</li>
</ul>

<h1 id="ab-테스트-3가지-예시">A/B 테스트 3가지 예시</h1>

<ol>
  <li>
    <p><strong>대기시간 안내 문구</strong></p>

    <ul>
      <li>A: “곧 연결됩니다”</li>
      <li>B: “평균 30초 내 연결됩니다 · 취소 가능”</li>
      <li>주지표: <code class="language-plaintext highlighter-rouge">start_match_click / 방문자</code></li>
      <li>가드레일: 즉시 이탈률, 고객불만</li>
    </ul>
  </li>
  <li>
    <p><strong>통화 후 피드백 수집 방식</strong></p>

    <ul>
      <li>A: 5점 척도만</li>
      <li>B: 5점 + “칭찬 한마디” 한줄 텍스트</li>
      <li>주지표: 피드백 제출률</li>
      <li>가드레일: 피드백 작성 시간, 다음날 재방문율</li>
    </ul>
  </li>
  <li>
    <p><strong>안심케어(유료) 소개 타이밍</strong></p>

    <ul>
      <li>A: 첫 3회 통화 후 페이월</li>
      <li>B: 첫 1회 통화 후 페이월</li>
      <li>주지표: 7일 내 결제 전환율</li>
      <li>가드레일: 7일 유지율, 평균 통화시간 변화</li>
    </ul>
  </li>
</ol>

<h1 id="설계-체크리스트-붙여넣어-쓰기">설계 체크리스트 (붙여넣어 쓰기)</h1>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />가설과 <strong>주지표 1개</strong> 명확</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>MDE</strong>와 <strong>기간/표본수</strong> 사전 정의</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>사용자 단위 랜덤</strong> 배정 + 고정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>experiment_id / variant</strong> 로깅</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>SRM</strong> 모니터링</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />중도 엿보기 금지(혹은 순차검정 채택)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />통계 유의 + <strong>비즈니스 유의</strong> 함께 판단</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />롤아웃/롤백 플랜 준비</li>
</ul>

<h1 id="자주-하는-실수">자주 하는 실수</h1>

<ul>
  <li>여러 요소를 한꺼번에 바꾸기 → <strong>원인 분리 불가</strong></li>
  <li>주지표를 여러 개로 두기 → 해석 혼란</li>
  <li>세션/페이지뷰 단위 랜덤화 → 사용자 경험이 섞여 <strong>오염</strong></li>
  <li>주중/주말, 마케팅 캠페인 겹침 <strong>시즌성 영향</strong> 무시</li>
  <li>결과가 좋게 나올 때까지만 <strong>계속 엿보기</strong></li>
</ul>

<h1 id="참고-빈도주의-vs-베이즈">(참고) 빈도주의 vs 베이즈</h1>

<ul>
  <li><strong>빈도주의</strong>: p-value/신뢰구간, 고정 표본 설계에 적합.</li>
  <li><strong>베이즈</strong>: “B가 A보다 좋을 확률”처럼 <strong>직관적 해석</strong>과 <strong>순차적 의사결정</strong>에 유리.
둘 다 장단점 있어요—팀의 익숙함/툴링에 따라 선택.</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><category term="Git" /><category term="ML" /><summary type="html"><![CDATA[2025-08-23 TIL]]></summary></entry><entry><title type="html">[친구하자] Hidden Technical Debt in Machine Learning Systems</title><link href="https://nan0silver.github.io/projectdiary/2025-08-17-diary/" rel="alternate" type="text/html" title="[친구하자] Hidden Technical Debt in Machine Learning Systems" /><published>2025-08-17T00:00:00+00:00</published><updated>2025-10-14T05:30:08+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-08-17-diary/"><![CDATA[<ul>
  <li><a href="#1-오늘-읽은-내용-요약">1. 오늘 읽은 내용 요약</a></li>
  <li><a href="#2-나에게-필요했던-이유--친구하자-적용-사례">2. 나에게 필요했던 이유 — <strong>친구하자</strong> 적용 사례</a></li>
  <li><a href="#3-느낀-점--인사이트">3. 느낀 점 &amp; 인사이트</a></li>
  <li><a href="#4-다음-액션-아이템">4. 다음 액션 아이템</a></li>
  <li><a href="#-핵심-요약">💡 핵심 요약</a></li>
</ul>

<hr />

<blockquote>
  <p>이번에는 서울 AI 허브 특강을 듣다가 알게 된 ML관련 논문을 읽고 지금 하고있는 “친구하자” 프로젝트의 어떤 부분에서 도움을 받을 수 있을지에 대해 알아보았다.</p>
</blockquote>

<p><strong>논문</strong>: [Hidden Technical Debt in Machine Learning Systems (NIPS 2015)]
<strong>작성자</strong>: D. Sculley외 10인 (Google, Inc.)</p>

<ul>
  <li><a href="https://nan0silver.github.io/til/2025-08-16-til/">논문에 대한 TIL 작성</a></li>
</ul>

<hr />

<h3 id="1-오늘-읽은-내용-요약">1. 오늘 읽은 내용 요약</h3>

<blockquote>
  <p><strong>핵심 주제</strong>: 머신러닝 시스템에서는 단순히 모델 성능을 높이는 것보다 <strong>데이터 흐름 관리, 파이프라인 구조, 의존성 관리</strong>가 더 중요하다는 점을 강조.</p>
</blockquote>

<ul>
  <li>
    <p><strong>기술 부채(Technical Debt)</strong></p>

    <ul>
      <li>ML 시스템은 빠르게 개발 가능하지만, 장기 유지보수 비용은 전통적인 소프트웨어보다 훨씬 높음.</li>
      <li>숨은 부채는 코드 수준이 아니라 <strong>시스템 수준</strong>에서 쌓이기 때문에 발견하기 어렵고 비용이 급격히 커짐.</li>
    </ul>
  </li>
  <li>
    <p><strong>주요 이슈와 원인</strong></p>

    <ol>
      <li>
        <p><strong>CACE 원칙</strong> <em>(Changing Anything Changes Everything)</em></p>

        <ul>
          <li>피처, 하이퍼파라미터, 데이터셋 중 하나만 바꿔도 전체 모델 성능이 예측 불가능하게 바뀜.</li>
        </ul>
      </li>
      <li>
        <p><strong>데이터 의존성</strong></p>

        <ul>
          <li>불안정한 입력 신호, 중복 피처, 과도한 데이터 연결은 장애 가능성을 높임.</li>
        </ul>
      </li>
      <li>
        <p><strong>Pipeline Jungle</strong></p>

        <ul>
          <li>데이터 전처리 단계가 쌓이면 유지보수가 어려워지고 에러 포인트가 증가.</li>
        </ul>
      </li>
      <li>
        <p><strong>모델 간 숨은 피드백 루프</strong></p>

        <ul>
          <li>하나의 모델 변경이 다른 시스템의 입력 데이터에 간접적으로 영향을 미침.</li>
        </ul>
      </li>
      <li>
        <p><strong>실시간 모니터링 부족</strong></p>

        <ul>
          <li>모델 업데이트 후 이상 징후를 늦게 발견하면 복구 비용이 기하급수적으로 커짐.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="2-나에게-필요했던-이유--친구하자-적용-사례">2. 나에게 필요했던 이유 — <strong>친구하자</strong> 적용 사례</h3>

<h4 id="1-발화화행-분석-모델-파이프라인-설계-시-고려할-점">(1) 발화/화행 분석 모델 파이프라인 설계 시 고려할 점</h4>

<ul>
  <li>
    <p><strong>현재 시나리오</strong></p>

    <ul>
      <li>통화 음성 → 스펙트로그램 변환 → 감정/화행 분석 모델 → 사용자 인지 지표 산출</li>
      <li>향후 <strong>AI 기반 발화 분석 모델</strong>을 도입해 지남력, 유창성, 어휘력, 주의집중력 등의 점수를 자동 산출할 계획.</li>
    </ul>
  </li>
  <li>
    <p><strong>적용 포인트</strong></p>

    <ul>
      <li>
        <p><strong>데이터 버저닝 필요성</strong></p>

        <ul>
          <li>예: 스펙트로그램 생성 방식을 바꿀 경우, 기존 학습 데이터와 호환성이 깨질 수 있음.</li>
          <li>→ DVC나 MLflow 같은 도구를 도입해 음성 데이터, 스펙트로그램, 학습된 모델을 <strong>버전 단위로 관리</strong>해야 함.</li>
        </ul>
      </li>
      <li>
        <p><strong>Pipeline Jungle 방지</strong></p>

        <ul>
          <li>현재는 음성 → 텍스트 → 감정 점수 산출이라는 단순 구조지만, 향후 발화 분석, 화행 분석, 치매 위험 예측까지 추가되면 <strong>중간 파이프라인이 폭발적으로 늘어남</strong>.</li>
          <li>→ 파이프라인을 계층적으로 나누고, 데이터 입출력 포맷을 표준화하는 설계가 필요.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="2-실시간-통화-분석-시스템-설계-시-고려할-점">(2) 실시간 통화 분석 시스템 설계 시 고려할 점</h4>

<ul>
  <li>
    <p><strong>현재 시나리오</strong></p>

    <ul>
      <li>WebRTC 기반 통화 → 통화 녹음 → 분석 API 호출 → 사용자/보호자 알림</li>
      <li>향후 실시간 음성 분석을 통해 <strong>통화 중 인지 저하, 우울감 등 감지</strong> 시 알림을 제공하는 기능을 목표.</li>
    </ul>
  </li>
  <li>
    <p><strong>적용 포인트</strong></p>

    <ul>
      <li>
        <p><strong>실시간 피처 드리프트 모니터링</strong></p>

        <ul>
          <li>예: 고령 사용자들의 발화 속도나 어휘 다양성이 계절, 이벤트에 따라 달라질 수 있음.</li>
          <li>→ 실시간으로 <strong>데이터 분포 변화를 감시</strong>해 학습 데이터와 입력 데이터의 괴리를 탐지하는 모니터링 필요.</li>
        </ul>
      </li>
      <li>
        <p><strong>모델 업데이트 전략(A/B Testing)</strong></p>

        <ul>
          <li>새로운 화행 분석 모델을 도입할 때, <strong>전체 사용자에게 바로 적용</strong>하면 위험.</li>
          <li>→ 전체 롤아웃 전 <strong>소규모 샘플 그룹</strong>에서 먼저 성능을 검증하고, 이상 징후 시 자동 롤백하는 시스템 필요.</li>
        </ul>
      </li>
      <li>
        <p><strong>경계 침식 문제 해결</strong></p>

        <ul>
          <li>통화 감정 분석 결과가 <strong>다른 추천 시스템</strong>(예: 대화 주제 추천)에도 입력될 경우, 모델 간 강한 의존성이 생김.</li>
          <li>→ API 수준에서 <strong>의존성 추적 및 제어</strong> 기능을 설계해 시스템 분리를 유지해야 함.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="3-느낀-점--인사이트">3. 느낀 점 &amp; 인사이트</h3>

<ul>
  <li>발화/화행 분석 모델처럼 <strong>실시간 데이터 기반 ML 시스템</strong>은 전통적인 오프라인 예측 모델보다 훨씬 <strong>기술 부채 리스크</strong>가 큼.</li>
  <li>
    <p>특히 이 논문에서 제시한 <strong>CACE 원칙</strong>을 그대로 체감할 수 있음:</p>

    <blockquote>
      <p>“스펙트로그램 해상도만 살짝 바꿨는데 전체 감정 분석 성능이 붕괴될 수도 있다.”</p>
    </blockquote>
  </li>
  <li>결론적으로, <strong>친구하자</strong>에서는 모델 성능 향상보다 <strong>데이터/파이프라인 안정성</strong>을 우선시해야 함.</li>
  <li><strong>모델 버저닝</strong>, <strong>실시간 모니터링</strong>, <strong>A/B 테스트</strong>, <strong>피처 관리 자동화</strong>는 반드시 초기에 설계해야 장기 비용을 줄일 수 있음.</li>
</ul>

<hr />

<h3 id="4-다음-액션-아이템">4. 다음 액션 아이템</h3>

<ul>
  <li><strong>DVC/MLflow</strong> 도입 → 발화/화행 분석 모델, 음성 데이터, 스펙트로그램 버전 관리</li>
  <li>데이터 파이프라인 표준화 → 입력/출력 포맷 및 계층 구조 설계</li>
  <li><strong>실시간 데이터 분포 모니터링</strong> 및 알림 시스템 구축</li>
  <li><strong>A/B 테스트 기반 모델 롤아웃 전략</strong> 설계 및 자동 롤백 기능 구현</li>
  <li>서비스 아키텍처에 <strong>모델 간 의존성 추적 기능</strong> 추가</li>
</ul>

<hr />

<h3 id="-핵심-요약">💡 핵심 요약</h3>

<blockquote>
  <p><strong>친구하자</strong>의 실시간 발화/화행 분석 시스템에서 기술 부채를 최소화하려면:</p>

  <p><strong>버전 관리</strong>: 데이터·모델·파이프라인을 모두 버전 단위로 관리
<strong>모니터링</strong>: 실시간 데이터 드리프트 및 예측 이상 징후 자동 탐지
<strong>분리 설계</strong>: 모델 간 강한 의존성 최소화
<strong>안전한 업데이트</strong>: A/B 테스트 기반 롤아웃 + 자동 롤백 전략 필수</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[친구하자 프로젝트 개발 중 논문 내용을 읽고 프로젝트 개발을 구체화한 내용입니다.]]></summary></entry><entry><title type="html">[TIL] Hidden Technical Debt in Machine Learning Systems</title><link href="https://nan0silver.github.io/til/2025-08-16-til/" rel="alternate" type="text/html" title="[TIL] Hidden Technical Debt in Machine Learning Systems" /><published>2025-08-16T00:00:00+00:00</published><updated>2025-08-16T00:36:49+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-08-16-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
📅 <strong>작성일</strong>: 2025-08-16<br />
🔄 <strong>최종 수정</strong>: 2025년 08월 16일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<p><strong>논문</strong>: [Hidden Technical Debt in Machine Learning Systems (NIPS 2015)]
<strong>작성자</strong>: D. Sculley외 10인 (Google, Inc.)</p>

<h3 id="1-오늘-읽은-내용-요약">1. 오늘 읽은 내용 요약</h3>

<blockquote>
  <p><strong>핵심 주제</strong>: 머신러닝 시스템에서 발생하는 <strong>숨은 기술 부채(hidden technical debt)</strong> 문제를 설명하고, 시스템 설계 단계에서 고려해야 할 위험 요소를 다룸.</p>
</blockquote>

<ul>
  <li>
    <p><strong>기술 부채(Technical Debt) 개념</strong></p>

    <ul>
      <li>ML 시스템은 개발과 배포는 빠르지만 <strong>유지보수가 어렵고 비용이 많이 드는 구조적 특성</strong>을 가짐.</li>
      <li>코드 수준의 문제보다 <strong>시스템 전반에서의 복잡성</strong>이 더 큰 원인.</li>
      <li>숨은 부채는 누적되며, 발견 시에는 비용이 급격히 커짐.</li>
    </ul>
  </li>
  <li>
    <p><strong>ML 시스템에서 기술 부채가 생기는 주요 원인</strong></p>

    <ol>
      <li><strong>경계 침식(Boundary Erosion)</strong>: 모델이 여러 신호를 섞어 사용하기 때문에 한 부분을 바꾸면 전체가 변함 (<strong>CACE 원칙: Changing Anything Changes Everything</strong>).</li>
      <li><strong>데이터 의존성(Data Dependencies)</strong>: 불안정하거나 과도한 데이터 의존성으로 인해 작은 변화가 큰 장애를 일으킴.</li>
      <li><strong>피드백 루프(Feedback Loops)</strong>: 모델이 자신의 입력 데이터를 간접적으로 바꾸는 경우 → 예측 정확도에 예기치 못한 영향을 미침.</li>
      <li>
        <p><strong>시스템 안티패턴(System Anti-Patterns)</strong>:</p>

        <ul>
          <li><strong>Glue Code</strong>: 다양한 패키지를 연결하는 코드가 과도해져 유지보수 비용 증가.</li>
          <li><strong>Pipeline Jungles</strong>: 데이터 처리 파이프라인이 점점 복잡해져 관리가 어려워짐.</li>
          <li><strong>Dead Experimental Codepaths</strong>: 실험을 위해 만든 코드가 방치되어 예기치 못한 오류를 유발.</li>
        </ul>
      </li>
      <li><strong>구성(Configuration) 부채</strong>: 피처, 하이퍼파라미터, 로깅 설정 등 방대한 설정이 누적되어 관리가 어려워짐.</li>
      <li><strong>외부 세계 변화</strong>: 환경, 사용자 행동, 시장 조건의 변화가 모델 성능에 직접적인 영향을 미침.</li>
    </ol>
  </li>
  <li>
    <p><strong>해결 방안</strong></p>

    <ul>
      <li>데이터 및 모델 <strong>의존성 관리 도구</strong> 구축 (버저닝, 자동화된 피처 관리 등).</li>
      <li><strong>모니터링 &amp; 자동화 대응</strong> 필수.</li>
      <li>실험적 코드 정리 및 중복 제거.</li>
      <li>연구팀과 엔지니어링팀 간 <strong>하이브리드 협업 구조</strong> 필요.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="2-나에게-필요했던-이유">2. 나에게 필요했던 이유</h3>

<blockquote>
  <p>이에 대한 자세한 내용은 (깃블로그)[링크]에서 볼 수 있습니다.</p>
</blockquote>

<ul>
  <li>
    <p>현재 진행 중인 <strong>AI 기반 발화/화행 분석 모델</strong>과 <strong>친구하자</strong> 서비스의 ML 시스템에 적용할 수 있음:</p>

    <ul>
      <li><strong>데이터 버저닝</strong> 필요성 → 감정 분석 모델 학습 시 <strong>피처 변경</strong>이 있을 경우 예기치 못한 성능 저하 방지.</li>
      <li><strong>파이프라인 관리</strong> 중요성 → 통화 음성 데이터 → 스펙트로그램 변환 → 감정 분석 → 저장 단계에서 발생할 수 있는 <strong>Pipeline Jungle</strong> 방지.</li>
      <li><strong>모델 업데이트 전략</strong> → 모델 개선이 실제 서비스에서 <strong>사용자 경험을 악화시킬 수 있는 위험</strong> 방지 필요.</li>
      <li><strong>실시간 모니터링</strong> 필요 → 모델 성능 저하나 데이터 분포 변화에 빠르게 대응 가능해야 함.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="3-느낀-점--인사이트">3. 느낀 점 &amp; 인사이트</h3>

<ul>
  <li>단순히 모델 성능을 높이는 것보다, <strong>시스템 전반의 유지보수성</strong>과 <strong>데이터 흐름 관리</strong>가 훨씬 중요하다는 걸 깨달음.</li>
  <li>
    <p>특히 <strong>CACE 원칙</strong>은 실무에서 체감할 가능성이 큼:</p>

    <blockquote>
      <p>“하나 바꾸면 다 바뀐다” → 모델 입력 피처 변경 시 전체 시스템의 예측 성능이 흔들릴 수 있음.</p>
    </blockquote>
  </li>
  <li>앞으로 <strong>AI 모델 성능 향상보다 안정적인 시스템 아키텍처 설계</strong>에 우선순위를 둬야겠다고 느낌.</li>
  <li>
    <p><strong>친구하자</strong> 서비스에서도:</p>

    <ul>
      <li>데이터 파이프라인 설계를 단순하게 유지.</li>
      <li>모델을 <strong>엔드 투 엔드로 한 번에 학습</strong>하는 방법과 <strong>서브모델 앙상블 방식</strong>의 트레이드오프를 고려해야 함.</li>
      <li>장기적으로 <strong>모델 버저닝 + 모니터링 시스템</strong>을 도입해 기술 부채를 최소화할 필요 있음.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="4-다음-액션-아이템">4. 다음 액션 아이템</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />데이터 버저닝 전략 조사 및 설계 (e.g., DVC, MLflow)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />음성 데이터 파이프라인 단순화 → Glue Code 최소화</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />실시간 성능 모니터링 및 알림 시스템 설계</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />모델 업데이트 시 A/B 테스트 기반 롤아웃 전략 도입</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><category term="Git" /><category term="ML" /><summary type="html"><![CDATA[2025-08-16 TIL]]></summary></entry></feed>