<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-05-28T01:08:51+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[컨퍼런스] AI Tech 2025 참석 후기</title><link href="https://nan0silver.github.io/projectdiary/2025-05-15-diary/" rel="alternate" type="text/html" title="[컨퍼런스] AI Tech 2025 참석 후기" /><published>2025-05-15T00:00:00+00:00</published><updated>2025-05-28T01:08:08+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-05-15-diary/"><![CDATA[<blockquote>
  <p>실무자 중심의 AI 도입 이후 전략, 오케스트레이션 구조, 에이전트 협업 사례 중심</p>
</blockquote>

<hr />

<h2 id="1-행사-개요">1. 행사 개요</h2>

<p><strong>AI Tech 2025</strong>는 단순한 모델 개발이나 비전 소개를 넘어서,<br />
<strong>“AI를 어떻게 현업에 도입하고 운영할 것인가”</strong>를 주제로 구성된 실무 중심의 컨퍼런스였다.<br />
다양한 기업과 기술 리더들이 실제 적용 사례, 인프라 설계, 오케스트레이션 전략을 공유했으며,<br />
AI 도입 이후 단계에서 실질적인 생산성을 확보하기 위한 전략들이 인상 깊었다.</p>

<hr />

<h2 id="2-키노트-요약-embodied-ai와-기술-진화-방향">2. 키노트 요약: Embodied AI와 기술 진화 방향</h2>

<p>서울대 장병탁 교수의 기조연설에서는 <strong>AI의 진화 방향</strong>이 강조되었다.</p>

<ul>
  <li>기존: 디지털 정보 공간 내 추론 중심의 AI</li>
  <li>변화: <strong>실세계와 상호작용하며 학습·판단·행동하는 Embodied AI</strong></li>
</ul>

<blockquote>
  <p>Embodied AI는 물리적 환경을 인식하고 그에 반응할 수 있는 에이전트로, 강화학습 및 체화 학습을 통해 자율성을 확보한다.</p>
</blockquote>

<p><img src="https://github-production-user-asset-6210df.s3.amazonaws.com/82145661/448164887-76d2879b-b852-4e1e-95b9-715a1a9c824a.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250528%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20250528T010443Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=3e1da1f9900847a113d2f60899f7bde3f20244757464ad5a77b3ec544728e0ed&amp;X-Amz-SignedHeaders=host" alt="Embodied AI 개념 이미지" /><br />
<em>Figure: Embodied AI – 환경 인지, 판단, 행동이 통합된 AI 시스템</em></p>

<hr />

<h2 id="3-a2a-시대의-도래-agent-협업-구조">3. A2A 시대의 도래: Agent 협업 구조</h2>

<h3 id="-a2aagent-to-agent-protocol">🔍 A2A(Agent-to-Agent Protocol)</h3>

<p>이번 행사에서 가장 빈번하게 언급된 개념 중 하나는 <strong>A2A</strong>였다.</p>

<ul>
  <li><strong>의미</strong>: 에이전트 간 데이터 공유 및 협업을 위한 통신 프로토콜</li>
  <li><strong>기능</strong>: 목적 지향형 대화, 작업 분담, 협업형 워크플로우 구성</li>
  <li><strong>사례</strong>: 문서 요약 에이전트 → 일정 정리 에이전트로 결과 전달</li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>요약 에이전트 → 분석 결과 전달 → 일정 에이전트가 회의 제안 자동화
</code></pre></div></div>

<h3 id="-관련-개념">🧩 관련 개념</h3>

<ul>
  <li>
    <p><strong>Agent Hub</strong>: 에이전트 설계/운영 통합 플랫폼</p>

    <ul>
      <li>ADK: Agent Design Kit</li>
      <li>Agent Engine: 배포 및 실행 환경</li>
      <li>Agent Garden: 에이전트 레지스트리/관리</li>
    </ul>
  </li>
</ul>

<p>이와 같은 구조는 기존 **MSA(마이크로서비스 아키텍처)**와 유사하게,
AI 시스템에서도 <strong>다수의 특화 에이전트가 상호작용하는 구조적 전환</strong>을 의미한다.</p>

<hr />

<h2 id="4-ai는-이제-운영의-시대">4. AI는 이제 운영의 시대</h2>

<p>기술보다 중요한 건 <strong>운영과 조율</strong>이다. 특히 다음과 같은 통찰이 강조되었다.</p>

<ul>
  <li>AGI는 단일 모델이 아닌, <strong>여러 특화 에이전트의 조합</strong></li>
  <li>이 조합을 조율하는 <strong>AI 오케스트레이션 계층</strong>이 핵심</li>
  <li>개발자는 모델 사용자에서 <strong>AI 아키텍처 설계자</strong>로 역할 확장 필요</li>
</ul>

<p>A2A는 단순한 API 호출이 아니라, <strong>에이전트 간 협업 흐름을 구성하는 전략적 도구</strong>로 자리잡고 있다.</p>

<hr />

<h2 id="5-실무-적용-사례-및-전략">5. 실무 적용 사례 및 전략</h2>

<h3 id="-주요-사례">📌 주요 사례</h3>

<ul>
  <li><strong>한화생명</strong>: 보험 상담 자동화 (LLM + RAG 기반 챗봇 운영)</li>
  <li><strong>KT</strong>: 기관 문서 기반 검색 시스템 구축</li>
  <li><strong>MARA</strong>: 자산 시장 분석 자동화</li>
  <li><strong>Nota AI</strong>: 엣지 디바이스용 AI 모델 경량화 및 배포</li>
</ul>

<p>이 외에도 다양한 기업들이 AI를 ‘기능’으로서가 아닌,
<strong>문제 해결 도구</strong>로서 어떻게 전략적으로 운영하고 있는지를 소개했다.</p>

<hr />

<h2 id="6-기술-인사이트">6. 기술 인사이트</h2>

<h3 id="️-실용-기술">🛠️ 실용 기술</h3>

<ul>
  <li><strong>Structured Pruning</strong>: 불필요한 파라미터 제거로 경량화</li>
  <li><strong>Filter Decomposition</strong>: 병렬 연산을 직렬화하여 성능 최적화</li>
  <li><strong>RAG 기반 검색</strong>: 문서 기반 답변 정확도 향상</li>
  <li><strong>Agent Workflow</strong>: 도메인 특화 다중 에이전트 협업 구성</li>
</ul>

<hr />

<h2 id="7-결론">7. 결론</h2>

<p>AI 시스템은 이제 단일 모델의 정확도보다,
<strong>어떻게 운영되고 협업 구조를 갖추는가</strong>가 더 중요해지고 있다.</p>

<p>이번 컨퍼런스를 통해 확인한 핵심은 다음과 같다:</p>

<ul>
  <li><strong>AI는 플랫폼이다</strong>: 단일 모델보다 다중 에이전트의 구조화된 조율이 핵심</li>
  <li><strong>A2A는 미래의 기본 요소</strong>: 마이크로서비스처럼 에이전트 협업이 표준화될 것</li>
  <li><strong>운영 전략이 곧 성패를 가른다</strong>: 기술보다 프로덕션 환경 최적화가 우선시됨</li>
</ul>

<blockquote>
  <p>기술을 넘어 전략으로서의 AI를 고민하게 된 의미 있는 자리였다.</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[AI Tech 2025 컨퍼런스에서 확인한 LLMOps, A2A, Embodied AI 등 최신 AI 시스템 운영 전략]]></summary></entry><entry><title type="html">[Spring] DTO를 나누는 기준은 어떻게 고려해야할까?</title><link href="https://nan0silver.github.io/spring/2025-04-30-dto-division/" rel="alternate" type="text/html" title="[Spring] DTO를 나누는 기준은 어떻게 고려해야할까?" /><published>2025-04-30T00:00:00+00:00</published><updated>2025-05-28T01:08:08+00:00</updated><id>https://nan0silver.github.io/spring/dto-division</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-30-dto-division/"><![CDATA[<ul>
  <li><a href="#-api-응답을-위한-dto는-왜-나눠야-하는가">API 응답을 위한 DTO는 왜 나눠야 하는가?</a></li>
  <li><a href="#1️⃣-하나의-도메인-여러-개의-응답-목적">1. 하나의 도메인, 여러 개의 응답 목적</a></li>
  <li><a href="#2️⃣-필드-수가-아니라-의도로-판단해야-한다">2. “필드 수”가 아니라 “의도”로 판단해야 한다</a></li>
  <li><a href="#3️⃣-dto-설계는-view-기반이어야-한다">3. DTO 설계는 “View 기반”이어야 한다</a></li>
  <li><a href="#4️⃣-dto-분리의-장점--실무-중심으로-요약">4. DTO 분리의 장점 – 실무 중심으로 요약</a></li>
  <li><a href="#-결론-api-목적--dto-목적">결론</a></li>
</ul>

<hr />

<h2 id="-api-응답을-위한-dto는-왜-나눠야-하는가">✅ API 응답을 위한 DTO는 왜 나눠야 하는가?</h2>

<p>서비스 개발을 하다 보면 DTO(Data Transfer Object)를 여러 개 만들게 된다.
처음에는 같은 도메인 모델에서 파생되는 응답 DTO라면 <strong>하나로 통일할 수 있지 않을까?</strong> 하는 생각이 들기도 한다.
하지만 실제로 API를 설계하고 클라이언트와 연동하는 과정을 겪어보면, <strong>DTO를 목적에 따라 나눠야 하는 이유</strong>가 분명히 보이기 시작한다.</p>

<hr />

<h3 id="1️⃣-하나의-도메인-여러-개의-응답-목적">1️⃣ 하나의 도메인, 여러 개의 응답 목적</h3>

<p>실제로 <code class="language-plaintext highlighter-rouge">PeerReview</code>라는 동일한 도메인을 기반으로 하더라도, API마다 응답 목적이 전혀 다르다.</p>

<table>
  <thead>
    <tr>
      <th>클래스</th>
      <th>목적</th>
      <th>사용되는 API</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">PeerReviewDetailResponse</code></td>
      <td>단일 리뷰의 상세 정보 제공</td>
      <td>리뷰 생성 응답, 리뷰 상세 조회</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UserReviewSummaryResponse</code></td>
      <td>특정 사용자의 리뷰 통계 요약</td>
      <td>사용자 리뷰 평균 조회</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ProjectReviewStatusResponse</code></td>
      <td>프로젝트 리뷰 진행 상태 확인</td>
      <td>프로젝트별 리뷰 완료 여부 확인</td>
    </tr>
  </tbody>
</table>

<p>이처럼 <strong>동일한 도메인 모델이더라도 응답의 대상, 범위, 표현 방식이 다르면 DTO는 분리되어야 한다</strong>.
하나의 <code class="language-plaintext highlighter-rouge">PeerReviewResponse</code>에 모든 필드를 때려넣고 공통으로 쓰다 보면,</p>

<ul>
  <li>어떤 API는 <strong>불필요한 데이터</strong>가 너무 많이 오가고,</li>
  <li>어떤 API는 <strong>필요한 정보가 빠져 있어</strong> 클라이언트가 혼란을 겪는다.</li>
</ul>

<blockquote>
  <p>❗️ <em>“DTO 하나로 합쳐도 되지 않나요?”</em> → 되긴 하지만, <strong>API의 명확한 역할과 응답 일관성</strong>을 해친다.</p>
</blockquote>

<hr />

<h3 id="2️⃣-필드-수가-아니라-의도로-판단해야-한다">2️⃣ “필드 수”가 아니라 “의도”로 판단해야 한다</h3>

<p>DTO를 나눌 때 흔히 하는 실수 중 하나가</p>

<blockquote>
  <p>“필드가 너무 적은데 굳이 따로 DTO로 만들어야 해?”
라는 의문이다.</p>

  <blockquote>
    <p>내가 프로젝트를 하며 이런 고민을 계속 하고, 실제로 다른 사람들은 어떤 기준을 가지는지 찾아보다 이 글을 작성하게 되었다.</p>
  </blockquote>
</blockquote>

<p>하지만 <strong>DTO는 포함된 데이터의 양이 아니라, 응답의 의도에 따라 나뉘어야 한다</strong>.</p>

<h4 id="예시-비교">예시 비교</h4>

<table>
  <thead>
    <tr>
      <th>클래스</th>
      <th>주요 필드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UserReviewSummaryResponse</code></td>
      <td>평균 점수, 리뷰 개수</td>
      <td>사용자 요약 통계</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">PeerReviewDetailResponse</code></td>
      <td>리뷰 항목별 점수, 작성자 정보, 날짜</td>
      <td>상세 정보 조회용</td>
    </tr>
  </tbody>
</table>

<p>이 두 DTO는 필드 수만 보면 합칠 수 있을 것 같지만,</p>

<blockquote>
  <p>하나는 <strong>요약 정보 (Summary)</strong>,
하나는 <strong>상세 정보 (Detail)</strong> 제공이라는 <strong>근본적인 목적이 다르다.</strong></p>
</blockquote>

<p>또한, Summary는 추후 <code class="language-plaintext highlighter-rouge">차트</code>, <code class="language-plaintext highlighter-rouge">히스토그램</code>, <code class="language-plaintext highlighter-rouge">트렌드</code> 같은 <strong>집계 데이터를 추가하기에 더 적합한 형태</strong>이고,
Detail은 사용자 경험 개선을 위한 <strong>리치한 UI 렌더링</strong>에 최적화된 형태로 확장될 수 있다.</p>

<hr />

<h3 id="3️⃣-dto-설계는-view-기반이어야-한다">3️⃣ DTO 설계는 “View 기반”이어야 한다</h3>

<p>DTO는 도메인을 있는 그대로 노출하는 것이 아니라,
<strong>API View Layer의 역할과 책임에 맞게 정보를 재가공해 전달</strong>하는 것이 목적이다.</p>

<p>즉, “어떤 정보를 어떻게 보여줄지”에 따라 설계되어야 한다.</p>

<h4 id="잘못된-설계-예">잘못된 설계 예</h4>

<ul>
  <li>불필요하게 내부 ID, 시스템 시간, 관리자용 정보 등을 포함한 DTO</li>
  <li>클라이언트에 노출되면 혼란을 주거나, 보안상 문제될 수 있는 필드 포함</li>
</ul>

<h4 id="좋은-설계-예">좋은 설계 예</h4>

<ul>
  <li>사용자에게 필요한 정보만 간결하게 포함</li>
  <li>실제 프론트 UI와 일치하는 정보 구조</li>
  <li>데이터의 “의미”와 “구성 방식”이 API 목적과 맞아떨어짐</li>
</ul>

<blockquote>
  <p>🧠 DTO는 단순히 데이터를 전달하는 구조체가 아니라,
**“API 응답 설계 그 자체”**라는 것을 항상 기억해야 한다.</p>
</blockquote>

<hr />

<h3 id="4️⃣-dto-분리의-장점--실무-중심으로-요약">4️⃣ DTO 분리의 장점 – 실무 중심으로 요약</h3>

<table>
  <thead>
    <tr>
      <th>이유</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>명확한 책임 분리</strong></td>
      <td>각 API의 목적에 따라 DTO도 명확히 구분되어 유지보수가 쉬움</td>
    </tr>
    <tr>
      <td><strong>클라이언트 연동 안정성</strong></td>
      <td>응답 구조가 고정되기 때문에 프론트엔드와의 계약(Contract)이 안정됨</td>
    </tr>
    <tr>
      <td><strong>확장성</strong></td>
      <td>새로운 요구사항이 생겼을 때 불필요한 필드 추가 없이 필요한 DTO만 수정하면 됨</td>
    </tr>
    <tr>
      <td><strong>성능 최적화</strong></td>
      <td>불필요한 필드 제거로 응답 크기 감소 → 네트워크 비용 감소</td>
    </tr>
    <tr>
      <td><strong>테스트 단순화</strong></td>
      <td>DTO 단위 테스트, API 응답 테스트가 더 명확하고 간결해짐</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-결론-api-목적--dto-목적">✅ 결론: API 목적 = DTO 목적</h2>

<ul>
  <li>하나의 API가 명확한 역할을 가지듯,</li>
  <li>그 API가 사용하는 DTO도 <strong>명확한 책임</strong>을 가져야 한다.</li>
</ul>

<p>DTO는 설계의 산물이면서, 동시에 클라이언트와의 약속이다.
따라서 <strong>필드 개수가 적다고 DTO를 합치는 건 설계적 실수</strong>일 수 있으며,
<strong>응답 데이터는 목적, 의미, 유지보수, 확장성 관점에서 설계</strong>되어야 한다.</p>

<hr />

<h2 id="️-마무리-한-줄-요약">✍️ 마무리 한 줄 요약</h2>

<blockquote>
  <p><strong>DTO는 “얼마나 많은 데이터를 담는가”보다 “어떤 목적의 데이터를 담는가”가 더 중요하다.</strong></p>
</blockquote>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[DTO를 나누는 기준에 대해 알아보자.]]></summary></entry><entry><title type="html">[버티] 버티 서비스를 위한 Spring Boot MSA 구현 방식 조사</title><link href="https://nan0silver.github.io/projectdiary/2025-04-28-diary/" rel="alternate" type="text/html" title="[버티] 버티 서비스를 위한 Spring Boot MSA 구현 방식 조사" /><published>2025-04-28T00:00:00+00:00</published><updated>2025-05-28T01:08:08+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-04-28-diary/"><![CDATA[<ul>
  <li><a href="#1-현재-버티-서비스-상황-분석">1. 현재 버티 서비스 상황 분석</a></li>
  <li><a href="#2-msa-구현-방안">2. MSA 구현 방안</a></li>
  <li><a href="#21-api-gateway-패턴-도입">2.1 API Gateway 패턴 도입</a></li>
  <li><a href="#22-회원-정보-공유-방식">2.2 회원 정보 공유 방식</a></li>
  <li><a href="#3-render-프리티어-환경-최적화-방안">3. Render 프리티어 환경 최적화 방안</a></li>
  <li><a href="#4-단계적-구현-전략">4. 단계적 구현 전략</a></li>
  <li><a href="#5-결론">5. 결론</a></li>
</ul>

<hr />

<blockquote>
  <p>현재 버티 서비스는 백엔드 서버의 도메인이 2개로 되어있다. 프론트와 연동을 하기 직전 과정에서 CORS 문제 해결과 이 과정에서 Render배포의 리소스 제약 문제를 어떤 식으로 해결하는 것이 좋은지 아래 내용과 같이 조사해보았다.</p>
</blockquote>

<h2 id="1-현재-버티-서비스-상황-분석">1. 현재 버티 서비스 상황 분석</h2>

<ul>
  <li><strong>서버 구조</strong>: 서버 도메인 URL이 2개 (회원 정보는 한쪽에만 존재)</li>
  <li><strong>프론트엔드</strong>: 도메인 URL이 1개</li>
  <li><strong>인증 방식</strong>: JWT 기반 인증 구현 중</li>
  <li><strong>문제점</strong>:
    <ul>
      <li>사용자 프로필 업데이트 기능이 있어 JWT에 프로필 정보 포함 어려움</li>
      <li>프론트엔드와 백엔드 간 CORS 이슈 발생 가능</li>
      <li>Render 프리티어 환경으로 리소스 제약 존재</li>
    </ul>
  </li>
</ul>

<h2 id="2-msa-구현-방안">2. MSA 구현 방안</h2>

<h3 id="21-api-gateway-패턴-도입">2.1 API Gateway 패턴 도입</h3>

<ul>
  <li><strong>목적</strong>: 프론트엔드에 단일 진입점 제공, CORS 문제 해결</li>
  <li><strong>구현 방식</strong>: Spring Cloud Gateway 활용</li>
  <li><strong>장점</strong>:
    <ul>
      <li>단일 도메인으로 프론트엔드 요청 처리</li>
      <li>중앙화된 인증/인가 처리</li>
      <li>요청 라우팅 관리 용이</li>
    </ul>
  </li>
</ul>

<h3 id="22-회원-정보-공유-방식">2.2 회원 정보 공유 방식</h3>

<p>현재 버티 서비스는 JWT에 프로필 정보를 포함하기 어려운 상황이므로:
(로그인 후 사용자 프로필을 업데이트 하기 때문)</p>

<h4 id="서비스-간-직접-통신-방식">서비스 간 직접 통신 방식</h4>

<ul>
  <li><strong>기본 개념</strong>: 회원 정보가 필요할 때 회원 서비스의 API를 직접 호출하여 최신 정보를 가져오는 방식</li>
  <li><strong>구현 내용</strong>:
    <ul>
      <li>회원 서비스에 내부용 API 엔드포인트 추가 (예: <code class="language-plaintext highlighter-rouge">/api/internal/users/{userId}</code>)</li>
      <li>이 API는 외부 접근이 아닌 서비스 간 통신용으로만 사용</li>
      <li>기능 서비스에서 특정 사용자 정보가 필요할 때 이 API를 호출하여 최신 정보 획득</li>
      <li>내부 API 키를 사용해 인증 (서비스 간 통신이 안전하게 이루어지도록)</li>
    </ul>
  </li>
</ul>

<h4 id="캐싱-전략-적용">캐싱 전략 적용</h4>

<ul>
  <li><strong>문제점</strong>: 매번 API를 호출하면 Render 프리티어 환경에서 성능 저하 발생</li>
  <li><strong>해결책</strong>:
    <ul>
      <li>자주 조회되는 회원 정보를 메모리에 임시 저장(캐싱)</li>
      <li>첫 번째 조회 시에만 API 호출, 이후에는 캐시에서 빠르게 조회</li>
      <li>정해진 시간(예: 15분) 후 캐시 만료하여 일정 주기로 최신 정보 반영</li>
      <li>사용자가 프로필을 업데이트하면 해당 사용자의 캐시만 즉시 무효화하는 API 호출</li>
    </ul>
  </li>
</ul>

<h4 id="장애-대응-방안">장애 대응 방안</h4>

<ul>
  <li><strong>문제점</strong>: 회원 서비스가 일시적으로 장애가 발생하면 기능 서비스도 영향 받음</li>
  <li><strong>해결책</strong>:
    <ul>
      <li>Circuit Breaker 패턴: 회원 서비스 장애 감지 시 API 호출을 일시 중단하고 기본 정보 반환</li>
      <li>예를 들어, 회원 이름을 조회할 수 없으면 “Guest”와 같은 기본값 사용</li>
      <li>재시도 제한 및 타임아웃 설정으로 불필요한 대기 시간 방지</li>
    </ul>
  </li>
</ul>

<p>이 방식을 통해 JWT에 모든 회원 정보를 담지 않아도 최신 정보를 안전하게 공유하고, 성능과 안정성을 확보할 수 있습니다.</p>

<h2 id="3-render-프리티어-환경-최적화-방안">3. Render 프리티어 환경 최적화 방안</h2>

<p>리소스 제약이 있는 Render 프리티어 환경에 맞춘 최적화 전략:</p>

<ul>
  <li>
    <p><strong>경량화된 MSA 구조</strong>:</p>

    <ul>
      <li>필수적인 도메인만 분리 (회원 서비스 + 기능 서비스)</li>
      <li>최소한의 서비스 디스커버리 구조 사용</li>
    </ul>
  </li>
  <li>
    <p><strong>성능 최적화</strong>:</p>

    <ul>
      <li>데이터베이스 커넥션 풀 크기 제한 (5-10개)</li>
      <li>API 요청 타임아웃 짧게 설정 (3초 내외)</li>
      <li>캐시 크기 제한 (500 항목 이내)</li>
      <li>Lazy Loading 적용하여 필요한 데이터만 로딩</li>
    </ul>
  </li>
  <li>
    <p><strong>에러 처리 강화</strong>:</p>
    <ul>
      <li>서비스 간 통신 실패 시 폴백(fallback) 메커니즘 구현</li>
      <li>재시도 횟수 제한 (최대 3회)</li>
    </ul>
  </li>
</ul>

<h2 id="4-단계적-구현-전략">4. 단계적 구현 전략</h2>

<p>Burty 서비스에 MSA를 점진적으로 도입하기 위한 단계:</p>

<h3 id="41-1단계-api-gateway-구현">4.1 1단계: API Gateway 구현</h3>

<ul>
  <li>Spring Cloud Gateway 기반 게이트웨이 서비스 구축</li>
  <li>라우팅 규칙 설정 (회원/기능 서비스 분리)</li>
  <li>JWT 토큰 검증 필터 구현</li>
  <li>CORS 설정 적용</li>
</ul>

<h3 id="42-2단계-서비스-간-통신-구현">4.2 2단계: 서비스 간 통신 구현</h3>

<ul>
  <li>회원 서비스에 내부 API 엔드포인트 추가</li>
  <li>기능 서비스에 RestTemplate 설정</li>
  <li>서비스 간 인증 메커니즘 적용</li>
</ul>

<h3 id="43-3단계-캐싱-적용">4.3 3단계: 캐싱 적용</h3>

<ul>
  <li>인메모리 캐시 설정</li>
  <li>회원 정보 캐싱 서비스 구현</li>
  <li>캐시 무효화 API 구현</li>
</ul>

<h3 id="44-4단계-장애-대응-패턴-적용">4.4 4단계: 장애 대응 패턴 적용</h3>

<ul>
  <li>Circuit Breaker 패턴 구현</li>
  <li>재시도 메커니즘 추가</li>
  <li>로깅 및 모니터링 강화</li>
</ul>

<h2 id="5-결론">5. 결론</h2>

<p>Burty 서비스의 현재 상황과 Render 프리티어 환경을 고려할 때:</p>

<ol>
  <li>
    <p>JWT만으로는 회원 정보 공유에 한계가 있으므로, 서비스 간 API 통신과 캐싱을 조합하는 것이 적합</p>
  </li>
  <li>
    <p>API Gateway 패턴을 통해 프론트엔드의 CORS 문제 해결 및 단일 진입점 제공</p>
  </li>
  <li>
    <p>리소스 제약을 고려한 경량화된 MSA 구조와 성능 최적화 필요</p>
  </li>
  <li>
    <p>단계적 구현을 통해 점진적으로 MSA 아키텍처로 전환</p>
  </li>
</ol>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Spring Boot MSA 구현 방식 조사]]></summary></entry><entry><title type="html">[Spring] PATCH vs PUT</title><link href="https://nan0silver.github.io/spring/2025-04-21-patch-put/" rel="alternate" type="text/html" title="[Spring] PATCH vs PUT" /><published>2025-04-21T00:00:00+00:00</published><updated>2025-05-28T01:08:08+00:00</updated><id>https://nan0silver.github.io/spring/patch-put</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-21-patch-put/"><![CDATA[<ul>
  <li><a href="#-1-기본-개념">1. 기본 개념</a></li>
  <li><a href="#-2-예시로-비교해보기">2. 예시로 비교해보기</a></li>
  <li><a href="#-3-핵심-차이-정리">3. 핵심 차이 정리</a></li>
  <li><a href="#-4-비유로-이해하기">4. 비유로 이해하기</a></li>
  <li><a href="#-5-실무-팁">5. 실무 팁</a></li>
</ul>

<hr />

<blockquote>
  <p>둘 다 리소스를 수정할 때 사용하는 HTTP 메서드이지만 차이점이 있다.</p>
</blockquote>

<h2 id="-1-기본-개념">✅ 1. 기본 개념</h2>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>의미</th>
      <th>리소스를 어떻게 수정?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>PUT</strong></td>
      <td>리소스를 “통째로 교체”</td>
      <td>전체를 새 값으로 <strong>대체</strong></td>
    </tr>
    <tr>
      <td><strong>PATCH</strong></td>
      <td>리소스를 “부분만 수정”</td>
      <td>바뀐 부분만 <strong>업데이트</strong></td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-2-예시로-비교해보기">✅ 2. 예시로 비교해보기</h2>

<h3 id="-가상의-리소스--사용자-프로필">📦 가상의 리소스 – 사용자 프로필</h3>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Sungwoo"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w">
  </span><span class="nl">"email"</span><span class="p">:</span><span class="w"> </span><span class="s2">"sungwoo@example.com"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="-put-요청-예시">🟩 PUT 요청 예시</h3>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">PUT /users/1
Content-Type: application/json

{
  "name": "Sungwoo",
  "age": 28,
  "email": "sungwoo@example.com"
}
</span></code></pre></div></div>

<ul>
  <li>이 요청은 <strong>기존 리소스를 통째로 대체</strong>함.</li>
  <li>기존 값 중 하나라도 빠지면, 그 필드는 <strong>삭제된 것으로 간주</strong>될 수 있다.</li>
</ul>

<h3 id="-patch-요청-예시">🟦 PATCH 요청 예시</h3>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">PATCH /users/1
Content-Type: application/json

{
  "age": 28
}
</span></code></pre></div></div>

<ul>
  <li>이 요청은 <strong>age 필드만 수정</strong>하고 나머지(<code class="language-plaintext highlighter-rouge">name</code>, <code class="language-plaintext highlighter-rouge">email</code>)는 그대로 유지된다.</li>
</ul>

<hr />

<h2 id="-3-핵심-차이-정리">✅ 3. 핵심 차이 정리</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>PUT</th>
      <th>PATCH</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>전체 or 일부</strong></td>
      <td>전체 대체</td>
      <td>일부만 수정</td>
    </tr>
    <tr>
      <td><strong>누락된 필드</strong></td>
      <td>삭제될 수 있음</td>
      <td>무시하고 유지됨</td>
    </tr>
    <tr>
      <td><strong>멱등성(Idempotent)</strong></td>
      <td>있음 (여러 번 해도 같은 결과)</td>
      <td>보장 X (실행 방식에 따라 달라질 수 있음)</td>
    </tr>
    <tr>
      <td><strong>용도</strong></td>
      <td>새로운 리소스 생성 or 전체 업데이트</td>
      <td>부분 업데이트에 특화됨</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-4-비유로-이해하기">🎨 4. 비유로 이해하기</h2>

<h3 id="-비유-이력서-제출하기">📘 비유: “이력서 제출하기”</h3>

<ul>
  <li>
    <p><strong>PUT</strong>은 새로운 이력서 전체를 회사에 제출해서 기존 이력서를 <strong>완전히 교체</strong>하는 것.</p>

    <blockquote>
      <p>회사에 제출한 파일을 통째로 새로 바꾸는 느낌!</p>
    </blockquote>
  </li>
  <li>
    <p><strong>PATCH</strong>는 기존 이력서에서 <strong>전화번호 한 줄만 수정해서 보낸다</strong>고 생각하면 됨.</p>

    <blockquote>
      <p>“전화번호 바뀌었어요” 라고 알리는 식.</p>
    </blockquote>
  </li>
</ul>

<hr />

<h2 id="-5-실무-팁">✅ 5. 실무 팁</h2>

<ul>
  <li><strong>클라이언트가 전체 데이터를 항상 알고 있고, 전체 리소스를 대체해야 할 경우 → <code class="language-plaintext highlighter-rouge">PUT</code></strong></li>
  <li><strong>일부 필드만 수정할 때 → <code class="language-plaintext highlighter-rouge">PATCH</code></strong></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[PATCH와 PUT의 공통점과 차이점에 대해 알아보자.]]></summary></entry><entry><title type="html">[버티] 프로젝트 개발 중 마주한 사소한 이슈들</title><link href="https://nan0silver.github.io/projectdiary/2025-04-17-diary/" rel="alternate" type="text/html" title="[버티] 프로젝트 개발 중 마주한 사소한 이슈들" /><published>2025-04-17T00:00:00+00:00</published><updated>2025-05-28T01:08:08+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-04-17-diary/"><![CDATA[<ul>
  <li><a href="#1-jjwt-라이브러리-버전에-따른-변경-사항">JJWT 라이브러리 버전에 따른 변경 사항</a></li>
  <li><a href="#2-카카오-소셜-로그인-이메일-누락-문제">카카오 소셜 로그인 이메일 누락 문제</a></li>
  <li><a href="#3-oauth2-인증-요청-정보-손실-문제">OAuth2 인증 요청 정보 손실 문제</a></li>
</ul>

<hr />

<p>이 문서는 “버티” 프로젝트를 개발하면서 마주쳤던 비교적 사소하지만, 실제 구현 과정에서는 꽤나 시간을 잡아먹거나 시행착오를 유발했던 문제들을 기록해두는 공간입니다.</p>

<p>단순한 에러라기보다는 “한 번쯤은 헷갈릴 수 있는 포인트들”을 중심으로 정리하여, 나중에 유지보수하거나 다른 프로젝트에서 재사용할 때 참고할 수 있도록 작성합니다.</p>

<hr />

<h2 id="1-jjwt-라이브러리-버전에-따른-변경-사항">1. JJWT 라이브러리 버전에 따른 변경 사항</h2>

<p>JJWT 라이브러리의 업데이트로 인해 토큰 생성 및 파싱 방식이 크게 변경되었습니다. 기존 방식으로 작성된 코드는 더 이상 컴파일되지 않거나 실행 시 에러가 발생할 수 있습니다.</p>

<h3 id="-기존-코드-구버전-jjwt">🔧 기존 코드 (구버전 JJWT)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">secretKey</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">secretKey</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
<span class="nc">Claims</span> <span class="n">claims</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">claims</span><span class="o">().</span><span class="na">setSubject</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getNickname</span><span class="o">());</span>
<span class="nc">String</span> <span class="n">accessToken</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
                <span class="o">.</span><span class="na">setHeaderParam</span><span class="o">(</span><span class="nc">Header</span><span class="o">.</span><span class="na">TYPE</span><span class="o">,</span> <span class="nc">Header</span><span class="o">.</span><span class="na">JWT_TYPE</span><span class="o">)</span>
                <span class="o">.</span><span class="na">setClaims</span><span class="o">(</span><span class="n">claims</span><span class="o">)</span>
                <span class="o">.</span><span class="na">setIssuedAt</span><span class="o">(</span><span class="n">now</span><span class="o">)</span>
                <span class="o">.</span><span class="na">setExpiration</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">getTime</span><span class="o">()</span> <span class="o">+</span> <span class="no">ACCESS_TOKEN_VALID_MILLISECOND</span><span class="o">))</span>
                <span class="o">.</span><span class="na">signWith</span><span class="o">(</span><span class="nc">SignatureAlgorithm</span><span class="o">.</span><span class="na">HS256</span><span class="o">,</span> <span class="n">secretKey</span><span class="o">)</span>
                <span class="o">.</span><span class="na">compact</span><span class="o">();</span>
<span class="nc">Claims</span> <span class="n">parsedClaims</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">parser</span><span class="o">().</span><span class="na">setSigningKey</span><span class="o">(</span><span class="n">secretKey</span><span class="o">).</span><span class="na">parseClaimsJws</span><span class="o">(</span><span class="n">accessToken</span><span class="o">).</span><span class="na">getBody</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="-변경-코드-최신-jjwt">✅ 변경 코드 (최신 JJWT)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SecretKey</span> <span class="n">secretKey</span> <span class="o">=</span> <span class="nc">Keys</span><span class="o">.</span><span class="na">hmacShaKeyFor</span><span class="o">(</span><span class="n">secretKeyStr</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
<span class="nc">Claims</span> <span class="n">claims</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">claims</span><span class="o">().</span><span class="na">subject</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getNickname</span><span class="o">()).</span><span class="na">build</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">accessToken</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
                <span class="o">.</span><span class="na">claims</span><span class="o">(</span><span class="n">claims</span><span class="o">)</span>
                <span class="o">.</span><span class="na">header</span><span class="o">()</span>
                <span class="o">.</span><span class="na">type</span><span class="o">(</span><span class="s">"JWT"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span>
                <span class="o">.</span><span class="na">issuedAt</span><span class="o">(</span><span class="n">now</span><span class="o">)</span>
                <span class="o">.</span><span class="na">expiration</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">getTime</span><span class="o">()</span> <span class="o">+</span> <span class="no">ACCESS_TOKEN_VALID_MILLISECOND</span><span class="o">))</span>
                <span class="o">.</span><span class="na">signWith</span><span class="o">(</span><span class="n">secretKey</span><span class="o">,</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">SIG</span><span class="o">.</span><span class="na">HS256</span><span class="o">)</span>
                <span class="o">.</span><span class="na">compact</span><span class="o">();</span>
<span class="nc">Claims</span> <span class="n">parsedClaims</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">parser</span><span class="o">()</span>
                <span class="o">.</span><span class="na">verifyWith</span><span class="o">(</span><span class="n">secretKey</span><span class="o">)</span>
                <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                <span class="o">.</span><span class="na">parseSignedClaims</span><span class="o">(</span><span class="n">accessToken</span><span class="o">)</span>
                <span class="o">.</span><span class="na">getPayload</span><span class="o">();</span>
</code></pre></div></div>

<p>참고 :</p>

<ul>
  <li><a href="https://myeongju00.tistory.com/112">Jwt.parserBuilder() Deprecated</a></li>
  <li><a href="https://stackoverflow.com/questions/78805779/issue-with-parserbuilder-method-in-jjwt-library-for-jwt-token-validation">stack overflow</a></li>
</ul>

<hr />

<h2 id="2-카카오-소셜-로그인-이메일-누락-문제">2. 카카오 소셜 로그인 이메일 누락 문제</h2>

<h3 id="-문제-상황">🧩 문제 상황</h3>

<p>카카오 로그인 시 사용자 이메일이 제공되지 않아 <code class="language-plaintext highlighter-rouge">InternalAuthenticationServiceException</code> 이 발생하는 문제가 있었습니다.</p>

<h3 id="-해결-방법">✅ 해결 방법</h3>

<p>카카오 계정에 이메일 정보가 없을 경우 자동으로 생성된 이메일을 부여하도록 로직을 보완했습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// KakaoOAuth2UserInfo 클래스</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getEmail</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">attributes</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="s">"kakao_account"</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">kakaoAccount</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;)</span> <span class="n">attributes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"kakao_account"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">kakaoAccount</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">kakaoAccount</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="s">"email"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">kakaoAccount</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"email"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 상위 메소드에서 처리</span>
<span class="o">}</span>

<span class="c1">// OAuth2UserService 클래스</span>
<span class="kd">private</span> <span class="nc">OAuth2User</span> <span class="nf">processOAuth2User</span><span class="o">(...)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">email</span> <span class="o">=</span> <span class="n">oAuth2UserInfo</span><span class="o">.</span><span class="na">getEmail</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">email</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">email</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">email</span> <span class="o">=</span> <span class="n">registrationId</span> <span class="o">+</span> <span class="s">"_"</span> <span class="o">+</span> <span class="n">oAuth2UserInfo</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">+</span> <span class="s">"@example.com"</span><span class="o">;</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"이메일 정보가 없어 생성된 이메일: {}"</span><span class="o">,</span> <span class="n">email</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 나머지 사용자 생성/업데이트 로직</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="3-oauth2-인증-요청-정보-손실-문제">3. OAuth2 인증 요청 정보 손실 문제</h2>

<h3 id="-문제-상황-1">🧩 문제 상황</h3>

<p>로그인 시 다음과 같은 오류가 발생했습니다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>oauth2LoginException: authorization_request_not_found
</code></pre></div></div>

<p>이유는 Security 설정에서 다음과 같이 세션 생성을 완전히 차단했기 때문입니다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">http</span><span class="o">.</span><span class="na">sessionManagement</span><span class="o">().</span><span class="na">sessionCreationPolicy</span><span class="o">(</span><span class="nc">SessionCreationPolicy</span><span class="o">.</span><span class="na">STATELESS</span><span class="o">);</span>
</code></pre></div></div>

<p>OAuth2 로그인 과정은 내부적으로 세션에 인증 요청 정보를 저장하여 인증을 이어가는데, 해당 설정으로 인해 정보가 손실되었습니다.</p>

<h3 id="-해결-방법-1">✅ 해결 방법</h3>

<p>개발 초기에는 단순화를 위해 다음과 같이 설정을 변경했습니다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">http</span><span class="o">.</span><span class="na">sessionManagement</span><span class="o">().</span><span class="na">sessionCreationPolicy</span><span class="o">(</span><span class="nc">SessionCreationPolicy</span><span class="o">.</span><span class="na">IF_REQUIRED</span><span class="o">);</span>
</code></pre></div></div>

<p>이를 통해 OAuth2 인증 플로우 중 세션을 사용할 수 있도록 하여 문제를 해결했습니다.</p>

<h3 id="-추가-구현-리프레시-토큰">💡 추가 구현: 리프레시 토큰</h3>

<p>보안성과 사용자 경험을 위해 리프레시 토큰도 함께 구현했습니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RefreshToken</code> 엔티티 및 리포지토리 생성</li>
  <li>토큰 갱신 서비스 및 API 엔드포인트 구현</li>
  <li>액세스 토큰과 리프레시 토큰을 분리 관리하여 보안성 강화</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[버티 프로젝트 개발 중 마주한 사소한 이슈들 정리]]></summary></entry><entry><title type="html">[Spring] JPA Query Method</title><link href="https://nan0silver.github.io/spring/2025-04-17-query-method/" rel="alternate" type="text/html" title="[Spring] JPA Query Method" /><published>2025-04-17T00:00:00+00:00</published><updated>2025-05-28T01:08:08+00:00</updated><id>https://nan0silver.github.io/spring/query-method</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-17-query-method/"><![CDATA[<ul>
  <li><a href="#jparepository-상속">JpaRepository 상속</a></li>
  <li><a href="#-그렇다면-커스텀-쿼리는-어떻게-할까">그렇다면 커스텀 쿼리는 어떻게 할까?</a></li>
  <li><a href="#-개발자-관점-팁">개발자 관점 팁</a></li>
</ul>

<hr />

<h2 id="jparepository-상속"><code class="language-plaintext highlighter-rouge">JpaRepository</code> 상속</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">JpaRepository</code>를 상속한 Repository 인터페이스는 여러 기능이 내장된 상태가 된다.
    <ul>
      <li>예시 : <code class="language-plaintext highlighter-rouge">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {}</code></li>
    </ul>
  </li>
  <li>이 경우, <code class="language-plaintext highlighter-rouge">findById()</code> 같은 기능은 이미 내장되어 편리하게 사용할 수 있다.</li>
  <li>
    <p>내장 함수</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">JpaReposiroty</code>가 상속하고 있는 인터페이스 중, <code class="language-plaintext highlighter-rouge">CrudRepository</code>가 아래와 같이 기본 CRUD 메서드를 가지고 있어 직접 구현하지 않아도 사용할 수 있음.</li>
      <li>
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">CrudRepository</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">ID</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Repository</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">ID</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="o">&lt;</span><span class="no">S</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="no">S</span> <span class="nf">save</span><span class="o">(</span><span class="no">S</span> <span class="n">entity</span><span class="o">);</span>

    <span class="o">&lt;</span><span class="no">S</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="nf">saveAll</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="n">entities</span><span class="o">);</span>

    <span class="nc">Optional</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">findById</span><span class="o">(</span><span class="no">ID</span> <span class="n">id</span><span class="o">);</span>

    <span class="kt">boolean</span> <span class="nf">existsById</span><span class="o">(</span><span class="no">ID</span> <span class="n">id</span><span class="o">);</span>

    <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">findAll</span><span class="o">();</span>

    <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">findAllById</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">ID</span><span class="o">&gt;</span> <span class="n">ids</span><span class="o">);</span>

    <span class="kt">long</span> <span class="nf">count</span><span class="o">();</span>

    <span class="kt">void</span> <span class="nf">deleteById</span><span class="o">(</span><span class="no">ID</span> <span class="n">id</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="no">T</span> <span class="n">entity</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">deleteAllById</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">ID</span><span class="o">&gt;</span> <span class="n">ids</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">deleteAll</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">entities</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">deleteAll</span><span class="o">();</span>
   <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="-그렇다면-커스텀-쿼리는-어떻게-할까">🤔 그렇다면 커스텀 쿼리는 어떻게 할까?</h2>

<ul>
  <li>Spring Data JPA는 메서드 이름만으로 쿼리를 만들어줌
    <ul>
      <li><code class="language-plaintext highlighter-rouge">List&lt;User&gt; findByAgeGreaterThan(int n);</code> -&gt; age &gt; n인 유저들</li>
    </ul>
  </li>
</ul>

<h3 id="예시">예시:</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="nf">findByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 메서드를 호출하면 JPA는 이런 SQL을 자동으로 만든다:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<hr />

<h3 id="1-다양한-조건-연산자">1. 다양한 조건 연산자</h3>

<ul>
  <li>사용 가능한 키워드들:</li>
</ul>

<table>
  <thead>
    <tr>
      <th>키워드</th>
      <th>의미</th>
      <th>예시</th>
      <th>SQL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">And</code></td>
      <td>AND 조건</td>
      <td><code class="language-plaintext highlighter-rouge">findByNameAndAge</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE name=? AND age=?</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Or</code></td>
      <td>OR 조건</td>
      <td><code class="language-plaintext highlighter-rouge">findByNameOrEmail</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE name=? OR email=?</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Between</code></td>
      <td>사이 값</td>
      <td><code class="language-plaintext highlighter-rouge">findByAgeBetween(int a, int b)</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE age BETWEEN ? AND ?</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LessThan</code> / <code class="language-plaintext highlighter-rouge">GreaterThan</code></td>
      <td>부등호</td>
      <td><code class="language-plaintext highlighter-rouge">findByAgeGreaterThan(20)</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE age &gt; 20</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">IsNull</code> / <code class="language-plaintext highlighter-rouge">IsNotNull</code></td>
      <td>널 여부</td>
      <td><code class="language-plaintext highlighter-rouge">findByEmailIsNull()</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE email IS NULL</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">In</code></td>
      <td>여러 값</td>
      <td><code class="language-plaintext highlighter-rouge">findByNameIn(List&lt;String&gt; names)</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE name IN (?, ?, ...)</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Like</code></td>
      <td>부분일치</td>
      <td><code class="language-plaintext highlighter-rouge">findByNameLike("%woo%")</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE name LIKE ?</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">StartingWith</code> / <code class="language-plaintext highlighter-rouge">EndingWith</code> / <code class="language-plaintext highlighter-rouge">Containing</code></td>
      <td>문자열 검색</td>
      <td><code class="language-plaintext highlighter-rouge">findByNameStartingWith("s")</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE name LIKE 's%'</code></td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="2-정렬과-페이징도-가능">2. 정렬과 페이징도 가능!</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="nf">findByAgeGreaterThanOrderByNameAsc</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>SQL: <code class="language-plaintext highlighter-rouge">SELECT * FROM user WHERE age &gt; ? ORDER BY name ASC</code></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Page</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="nf">findByNameContaining</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>페이징 처리까지 자동으로 해줌!</li>
</ul>

<hr />

<h3 id="3-존재-여부만-알고-싶다면">3. 존재 여부만 알고 싶다면?</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="nf">existsByEmail</span><span class="o">(</span><span class="nc">String</span> <span class="n">email</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>SQL: <code class="language-plaintext highlighter-rouge">SELECT COUNT(*) FROM user WHERE email = ?</code></li>
  <li>결과: 해당 이메일이 존재하면 <code class="language-plaintext highlighter-rouge">true</code>, 없으면 <code class="language-plaintext highlighter-rouge">false</code></li>
</ul>

<hr />

<h3 id="4-리턴-타입도-다양하게-지원한다">4. 리턴 타입도 다양하게 지원한다.</h3>

<table>
  <thead>
    <tr>
      <th>리턴 타입</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">User</code></td>
      <td>단일 객체 (없으면 <code class="language-plaintext highlighter-rouge">null</code>)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Optional&lt;User&gt;</code></td>
      <td>단일 객체 (안전하게 Optional로 감쌈)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">List&lt;User&gt;</code></td>
      <td>여러 개</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Page&lt;User&gt;</code></td>
      <td>페이징 결과</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">boolean</code></td>
      <td>존재 여부 확인</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="5-규칙을-안-지키면-어떻게-될까">5. 규칙을 안 지키면 어떻게 될까?</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">findByWhatIsThis</span><span class="o">()</span> <span class="c1">// ← 엔티티에 없는 필드명이면 컴파일은 되지만 실행 시 에러</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">No property whatIsThis found for type User!</code> 같은 예외 발생</li>
</ul>

<hr />

<h2 id="-개발자-관점-팁">🧠 개발자 관점 팁</h2>

<ul>
  <li>메서드 이름이 너무 길어지면 <strong><code class="language-plaintext highlighter-rouge">@Query</code>를 써서 직접 JPQL 작성</strong>하는 게 낫다.</li>
  <li><strong>자동 생성 쿼리 → 빠르게 CRUD 만들 때 유용</strong></li>
  <li><strong>복잡한 조건</strong> → <code class="language-plaintext highlighter-rouge">@Query</code> 또는 <code class="language-plaintext highlighter-rouge">QueryDSL</code>, <code class="language-plaintext highlighter-rouge">Specification</code> 권장</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[JPA의 Query Method에 대해 알아보자.]]></summary></entry><entry><title type="html">[버티] JWT로 로그인을 구현했을 때 로그아웃 방법을 어떻게 해야할까?</title><link href="https://nan0silver.github.io/projectdiary/2025-04-16-diary/" rel="alternate" type="text/html" title="[버티] JWT로 로그인을 구현했을 때 로그아웃 방법을 어떻게 해야할까?" /><published>2025-04-16T00:00:00+00:00</published><updated>2025-05-28T01:08:08+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-04-16-diary/"><![CDATA[<blockquote>
  <p>저번 프로젝트에서는 로그아웃을 구현하지 않고, 토큰 만료를 사용했는데 로그아웃을 구현해달라는 요청이 있었어서 이번 프로젝트에서는 제대로 알아보고 구현해보기로 하였다.</p>
</blockquote>

<ul>
  <li>JWT는 기본적으로 상태를 저장하지 않아(stateless) 로그아웃 처리에 어려움이 있다.</li>
  <li>
    <p>로그아웃을 구현하는 방법에는 크게 3가지가 있다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 프론트엔트에서 토큰 삭제
   - 가장 구현이 간단하다.
   - 클라이언트 측에서 토큰을 삭제하여 로그아웃을 구현하는 방법
   - 이 방법이 토큰의 `Stateless`한 특징을 최대한 살린 방식
     &gt; 'Stateful` : 데이터베이스에 정보를 저장하고 조회하는 경우
</code></pre></div>    </div>

    <p>‘Stateless`: 데이터베이스를 사용하지 않는 방식</p>

    <blockquote>
      <blockquote>
        <p>JWT는 데이터베이스에 저장 및 조회가 필요없기 때문에<code class="language-plaintext highlighter-rouge">Stateless</code>한 특징을 가지고 있다.</p>
      </blockquote>
    </blockquote>

    <ul>
      <li>단점 : 서버에선 토큰이 유효하기 때문에, 토큰이 노출되면 보안 문제가 생길 수 있음.</li>
    </ul>

    <ol>
      <li>토큰 블랙리스트 관리
        <ul>
          <li>JWT가 만료되지 않은 상태에서 로그아웃 요청이 오는 경우, 서버에서 해당 토큰을 블랙리스트 DB에 넣어 처리</li>
          <li>인증 필터에서 매 요청마다 토큰이 블랙리스트에 해당하는 토큰인지 확인해야한다.</li>
          <li>서버에서 토큰을 효과적으로 관리할 수 있지만, 매 요청마다 블랙리스트를 확인해야하기 때문에 <code class="language-plaintext highlighter-rouge">stateless</code>한 JWT의 장점이 없어진다.</li>
        </ul>
      </li>
      <li>Refresh Token 기간 만료 처리
        <ul>
          <li>사용자가 로그아웃을 요청할 때 리프레시 토큰을 무효화해 해당 사용자가 더 이상 새로운 엑세스 토큰을 발급받지 못하도록 하는 방식</li>
          <li>사용자의 로그아웃 요청에 대해 서버 측에서 적극적으로 대응할 수 있다는 장점이 있다.</li>
          <li>엑세스 토큰 재발급의 연속성을 차단해 보안을 강화할 수도 있다.</li>
          <li>하지만 리프레시 토큰 확인 과정에서 JWT의 <code class="language-plaintext highlighter-rouge">Stateless</code>한 장점이 사라진다.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>2번 VS 3번 비교
    <ul>
      <li>2번의 경우, 블랙리스트 DB 혹은 Redis를 사용해 서버 상태를 관리해야 한다.</li>
      <li>또한 <code class="language-plaintext highlighter-rouge">Stateless</code>성이 완전히 깨지고 (모은 요청 시 DB확인이 필요하기 때문에!) 성능 이슈가 생길 수 있다.</li>
      <li>하지만 3번의 경우, 리프레시 토큰만 관리하면 되기 때문에 상대적으로 가볍다.
        <ul>
          <li>리프레시 토큰만 서버 저장 및 관리하면 된다!</li>
        </ul>
      </li>
      <li>또한 3번은 <code class="language-plaintext highlighter-rouge">Stateless</code>를 부분적으로 유지 가능하다. (액세스 토큰은 여전히 <code class="language-plaintext highlighter-rouge">Stateless</code>)</li>
    </ul>
  </li>
  <li>일단은 3번 방법을 선택해서 로그아웃을 구현해보기로 결정하였다.
    <ul>
      <li>어플리케이션이 그렇게 무거운 프로젝트가 아니기 때문에, 블랙 리스트 방식처럼 서버 자원을 지속적으로 소모하는 설계보다는 토큰 생명주기를 명확히 관리할 수 있는 방식이 더 적합할 것 같다고 판단했다.</li>
      <li>또한 리프레시 토큰 구현으로 토큰의 생명 주기에 대해 이해해볼 수 있을 것 같아 선택하게 되었다.</li>
      <li>이번 프로젝트는 데이터베이스 사용이 많은 구조이기 때문에, 불필요한 토큰 상태 관리를 피하고 전체 시스템의 부하를 줄이기 위한 의도도 있었다.
        <blockquote>
          <p>리프레시 토큰의 발급 및 만료 흐름을 직접 설계함으로써, JWT 기반 인증 시스템의 구조와 보안 설계에 대한 이해도를 높이는 기회로 삼고자 한다.</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<p>참고 :</p>

<ul>
  <li><a href="https://upcurvewave.tistory.com/611">JWT 토큰 기반의 상태 관리시 로그아웃 처리 문제</a></li>
  <li><a href="https://engineerinsight.tistory.com/232#google_vignette">[우테코] JWT 방식에서 로그아웃, Refresh Token 만들기(1)</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[JWT 로그인 구현 시 로그아웃 방법 고민..]]></summary></entry><entry><title type="html">[버티] Spring Security와 Swagger 통합 시 발생한 이슈 해결기</title><link href="https://nan0silver.github.io/projectdiary/2025-04-15-diary/" rel="alternate" type="text/html" title="[버티] Spring Security와 Swagger 통합 시 발생한 이슈 해결기" /><published>2025-04-15T00:00:00+00:00</published><updated>2025-05-28T01:08:08+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-04-15-diary/"><![CDATA[<ul>
  <li><a href="#1-swagger-문서-접근-제한-및-인증-설정-이슈">1. Swagger 문서 접근 제한 및 인증 설정 이슈</a></li>
  <li><a href="#2-oauth2-엔드포인트가-swagger에-표시되지-않는-문제">2. OAuth2 엔드포인트가 Swagger에 표시되지 않는 문제</a></li>
  <li><a href="#3-swagger-ui-그룹명-default-표시-이슈">3. Swagger UI 그룹명 ‘default’ 표시 이슈</a></li>
  <li><a href="#4-swagger-ui에-authorization-설정-추가">4. Swagger UI에 Authorization 설정 추가</a></li>
  <li><a href="#5-실무-관점에서의-swagger-접근-관리-전략">5. 실무 관점에서의 Swagger 접근 관리 전략</a></li>
  <li><a href="#6-정리하며">6. 정리하며</a></li>
</ul>

<hr />

<p>Spring Boot와 Spring Security, 그리고 Swagger(OpenAPI)를 함께 사용하기 위해 공부하고 구현하며 여러 이슈가 발생했습니다. 따라서 제가 프로젝트를 수행하며 “소셜 로그인 기능을 구현하면서 Swagger와 관련된 문제들을 어떻게 인지하고 해결했는지”를 기록해 보았습니다.</p>

<hr />

<h2 id="1-swagger-문서-접근-제한-및-인증-설정-이슈">1. Swagger 문서 접근 제한 및 인증 설정 이슈</h2>

<h3 id="11-문제-상황">1.1. 문제 상황</h3>

<p>Spring Security 환경에서 Swagger 문서(<code class="language-plaintext highlighter-rouge">/swagger-ui/index.html</code>, <code class="language-plaintext highlighter-rouge">/v3/api-docs</code>)에 접근하려면 인증이 필요한 상황이 발생하였습니다. 이는 프론트엔드 개발자와 API 명세를 공유하고 협업하는 데 불편을 초래할 것이라 판단했습니다. 로그인 과정을 거치지 않으면 Swagger UI 자체가 열리지 않았기 때문에, 프론트엔드가 API 테스트를 원활히 진행할 수 없었습니다.</p>

<p>그래서 <strong>개발 환경(dev profile)</strong> 에 한해 Swagger 관련 인증을 해제했습니다. 이렇게 하니 Swagger 문서를 보다 자유롭게 접근할 수 있었고, API 확인과 테스트 속도도 한결 빨라졌습니다.</p>

<p>다만 이러한 설정을 그대로 운영 환경에 적용할 경우, 민감한 정보 노출의 위험이 있기 때문에, <strong>배포 시에는 Swagger 접근을 차단하거나 관리자만 접근 가능하도록 제한</strong>할 계획입니다. 이처럼 환경에 따라 적절하게 보안 수준을 조절하는 방식은 실제 현업에서도 자주 사용하는 전략이기도 합니다.</p>

<p>추가적으로, 설정 과정 중 다음과 같은 오류가 발생했습니다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IllegalStateException: Can't configure mvcMatchers after anyRequest.
</code></pre></div></div>

<h3 id="12--원인-분석">1.2. 👀 원인 분석</h3>

<ol>
  <li>Spring Security는 기본적으로 모든 요청에 대해 보안 필터를 적용하여, 인증되지 않은 사용자의 접근을 차단합니다. Swagger 문서 관련 URL 또한 별도의 예외 처리를 하지 않으면 일반적인 보호 대상 경로로 인식되어 접근이 제한됩니다.</li>
  <li>Spring Security에서 <code class="language-plaintext highlighter-rouge">.anyRequest()</code> 호출 이후 <code class="language-plaintext highlighter-rouge">.requestMatchers()</code>를 선언한 것이 문제
    <ul>
      <li>URL 매칭 규칙상 구체적인 경로를 먼저 선언하고, 마지막에 <code class="language-plaintext highlighter-rouge">anyRequest()</code>를 사용해야 합니다</li>
    </ul>
  </li>
</ol>

<h3 id="13-해결-방법">1.3. 해결 방법</h3>

<p><code class="language-plaintext highlighter-rouge">SecurityConfig</code> 클래스에서 Swagger 관련 경로에 대한 접근을 허용하도록 다음과 같이 설정했습니다:</p>

<ul>
  <li>Swagger 관련 경로를 먼저 선언한 후, 마지막에 <code class="language-plaintext highlighter-rouge">anyRequest()</code>를 설정하는 방식으로 해결했습니다:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Bean</span>
<span class="kd">public</span> <span class="nc">SecurityFilterChain</span> <span class="nf">securityFilterChain</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">http</span>
        <span class="o">.</span><span class="na">authorizeHttpRequests</span><span class="o">(</span><span class="n">authorize</span> <span class="o">-&gt;</span> <span class="n">authorize</span>
            <span class="o">.</span><span class="na">requestMatchers</span><span class="o">(</span>
                <span class="s">"/swagger-ui/**"</span><span class="o">,</span>
                <span class="s">"/swagger-resources/**"</span><span class="o">,</span>
                <span class="s">"/v2/api-docs"</span><span class="o">,</span>
                <span class="s">"/v3/api-docs"</span><span class="o">,</span>
                <span class="s">"/webjars/**"</span>
            <span class="o">).</span><span class="na">permitAll</span><span class="o">()</span>
            <span class="o">.</span><span class="na">anyRequest</span><span class="o">().</span><span class="na">authenticated</span><span class="o">()</span>
        <span class="o">);</span>

    <span class="k">return</span> <span class="n">http</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 설정으로 인해 Swagger 문서에 로그인 없이 접근 가능하게 되었으며, 프론트엔드와의 협업도 원활해졌습니다.</p>

<blockquote>
  <p>“개발 생산성과 보안의 균형”이라는 관점에 대해 생각하게 되었습니다.</p>
</blockquote>

<hr />

<h2 id="2-oauth2-엔드포인트가-swagger에-표시되지-않는-문제">2. OAuth2 엔드포인트가 Swagger에 표시되지 않는 문제</h2>

<h3 id="21-문제-상황">2.1. 문제 상황</h3>

<p>Spring Security가 자동으로 생성해주는 OAuth2 엔드포인트(<code class="language-plaintext highlighter-rouge">/oauth2/authorize/{provider}</code>, <code class="language-plaintext highlighter-rouge">/login/oauth2/code/{provider}</code>)는 컨트롤러 기반이 아니기 때문에 Swagger 문서에 자동으로 포함되지 않았습니다.</p>

<h3 id="22--원인">2.2. 👀 원인</h3>

<p>Swagger는 기본적으로 <code class="language-plaintext highlighter-rouge">@RestController</code> 및 <code class="language-plaintext highlighter-rouge">@RequestMapping</code> 애노테이션이 붙은 메서드를 기준으로 API 문서를 생성합니다. 하지만 Spring Security의 OAuth2 로그인 경로는 Security 설정 내부에서 동적으로 구성되기 때문에 Swagger가 자동으로 인식할 수 없습니다.</p>

<h3 id="23-해결-방법">2.3. 해결 방법</h3>

<p>SwaggerConfig에서 수동으로 OpenAPI 객체에 경로를 등록하여 문서화했습니다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SwaggerConfig</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">OpenAPI</span> <span class="nf">customOpenAPI</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">OpenAPI</span> <span class="n">openAPI</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OpenAPI</span><span class="o">()</span>
                <span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="k">new</span> <span class="nc">Info</span><span class="o">()</span>
                        <span class="o">.</span><span class="na">title</span><span class="o">(</span><span class="s">"Burty Server API"</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="s">"1.0.0"</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">description</span><span class="o">(</span><span class="s">"버티 서버 API 문서"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">paths</span><span class="o">(</span><span class="k">new</span> <span class="nc">Paths</span><span class="o">());</span>

        <span class="n">openAPI</span><span class="o">.</span><span class="na">getPaths</span><span class="o">().</span><span class="na">addPathItem</span><span class="o">(</span><span class="s">"/oauth2/authorize/{provider}"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">PathItem</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="k">new</span> <span class="nc">Operation</span><span class="o">().</span><span class="na">summary</span><span class="o">(</span><span class="s">"OAuth2 인증 요청"</span><span class="o">)));</span>
        <span class="n">openAPI</span><span class="o">.</span><span class="na">getPaths</span><span class="o">().</span><span class="na">addPathItem</span><span class="o">(</span><span class="s">"/login/oauth2/code/{provider}"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">PathItem</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="k">new</span> <span class="nc">Operation</span><span class="o">().</span><span class="na">summary</span><span class="o">(</span><span class="s">"OAuth2 로그인 콜백"</span><span class="o">)));</span>

        <span class="k">return</span> <span class="n">openAPI</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="3-swagger-ui-그룹명-default-표시-이슈">3. Swagger UI 그룹명 ‘default’ 표시 이슈</h2>

<h3 id="31-문제-상황">3.1. 문제 상황</h3>

<p>Swagger UI에서 각 API가 <code class="language-plaintext highlighter-rouge">default</code>라는 그룹으로 묶여 가독성이 떨어졌습니다.</p>

<h3 id="32--원인">3.2. 👀 원인</h3>

<p>Swagger는 명시적으로 <code class="language-plaintext highlighter-rouge">@Tag</code> 애노테이션이 부여되지 않은 컨트롤러의 경우, 자동으로 <code class="language-plaintext highlighter-rouge">default</code>라는 태그로 묶어 표시합니다. 이는 다양한 기능의 API가 하나의 그룹으로 합쳐져 구분이 어렵게 됩니다.</p>

<h3 id="33-해결-방법">3.3. 해결 방법</h3>

<p>컨트롤러에 <code class="language-plaintext highlighter-rouge">@Tag</code> 애노테이션을 추가하고, 각 API에 <code class="language-plaintext highlighter-rouge">tags</code>를 명시함으로써 그룹을 명확하게 분리했습니다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Tag</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"인증"</span><span class="o">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s">"사용자 인증 관련 API"</span><span class="o">)</span>
<span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/auth"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthController</span> <span class="o">{</span>

    <span class="nd">@Operation</span><span class="o">(</span><span class="n">summary</span> <span class="o">=</span> <span class="s">"카카오 로그인 URL 반환"</span><span class="o">,</span> <span class="n">tags</span> <span class="o">=</span> <span class="o">{</span><span class="s">"인증"</span><span class="o">})</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/kakao"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">kakaoLogin</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="4-swagger-ui에-authorization-설정-추가">4. Swagger UI에 Authorization 설정 추가</h2>

<h3 id="41-문제-상황">4.1. 문제 상황</h3>

<p>프론트엔드에서 JWT 인증이 필요한 API를 Swagger UI로 테스트하고자 했으나, Authorization 정보를 입력할 수 있는 UI가 없었습니다.</p>

<h3 id="42--원인-분석">4.2. 👀 원인 분석</h3>

<ul>
  <li>Swagger 기본 설정에는 Authorization 헤더 입력 기능이 포함되어 있지 않습니다.
    <ul>
      <li>JWT 기반 인증이 필요한 API에도 별도의 인증 설정을 명시하지 않으면 Swagger UI에서 테스트가 불가능합니다.</li>
    </ul>
  </li>
  <li>
    <p>따라서 개발 및 테스트 과정에서 프론트엔드가 토큰을 포함한 요청을 손쉽게 재현할 수 있도록 하기 위해 보안 스키마 설정이 필요했습니다.</p>
  </li>
  <li>프론트엔드에서 JWT 인증이 필요한 API를 Swagger UI로 테스트하고자 했으나, Authorization 정보를 입력할 수 있는 UI가 없었습니다.</li>
</ul>

<h3 id="43-해결-방법">4.3. 해결 방법</h3>

<h4 id="1-전역-보안-스키마-정의">1) 전역 보안 스키마 정의</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@SecurityScheme</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"bearerAuth"</span><span class="o">,</span>
        <span class="n">type</span> <span class="o">=</span> <span class="nc">SecuritySchemeType</span><span class="o">.</span><span class="na">HTTP</span><span class="o">,</span>
        <span class="n">scheme</span> <span class="o">=</span> <span class="s">"bearer"</span><span class="o">,</span>
        <span class="n">bearerFormat</span> <span class="o">=</span> <span class="s">"JWT"</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OpenApiConfig</span> <span class="o">{</span>
    <span class="c1">// 어노테이션으로 설정</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="2-개별-api에-적용">2) 개별 API에 적용</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Operation</span><span class="o">(</span><span class="n">security</span> <span class="o">=</span> <span class="o">{</span> <span class="nd">@SecurityRequirement</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"bearerAuth"</span><span class="o">)</span> <span class="o">})</span>
<span class="nd">@PutMapping</span><span class="o">(</span><span class="s">"/profile"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;?&gt;</span> <span class="n">updateUserProfile</span><span class="o">(...)</span> <span class="o">{</span>
    <span class="c1">// 메서드 구현</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 설정을 통해 Swagger UI에서도 인증이 필요한 API를 명확히 구분하고, 테스트 시 토큰을 직접 입력할 수 있도록 구성할 수 있었습니다.</p>

<hr />

<h2 id="5-실무-관점에서의-swagger-접근-관리-전략">5. 실무 관점에서의 Swagger 접근 관리 전략</h2>

<ul>
  <li>개발 환경에서는 Swagger 접근을 자유롭게 열어두고 프론트엔드 테스트를 용이하게 함</li>
  <li>운영 환경에서는 보안을 위해 관리자 인증 또는 방화벽 제한을 적용하는 것이 일반적</li>
  <li>JWT 기반 인증 API는 Swagger UI에서도 Authorization 헤더를 통해 테스트할 수 있도록 설정</li>
</ul>

<hr />

<h2 id="6-정리하며">6. 정리하며</h2>

<p>Swagger와 Spring Security를 함께 사용할 때 마주친 실제적인 문제들을 해결하면서, 보안과 개발 편의성 사이에서 균형을 맞추는 경험을 할 수 있었습니다. 특히 프론트엔드 협업 관점에서 Swagger 인증 해제와 JWT 연동 설정은 협업 효율을 높이는 핵심 포인트였습니다.</p>

<p>이러한 설정 경험은 포트폴리오에 실질적인 문제 해결 능력으로 정리할 수 있었고, 실무에서도 유용하게 활용될 수 있는 기반이 되었습니다.</p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Spring Security와 Swagger 통합 이슈]]></summary></entry><entry><title type="html">[버티] 프로젝트 구조 설계 고민과 선택</title><link href="https://nan0silver.github.io/projectdiary/2025-04-14-diary/" rel="alternate" type="text/html" title="[버티] 프로젝트 구조 설계 고민과 선택" /><published>2025-04-14T00:00:00+00:00</published><updated>2025-05-28T01:08:08+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-04-14-diary/"><![CDATA[<hr />

<p>프로젝트를 처음 시작할 때 가장 고민했던 부분 중 하나는 <strong>전체 구조를 어떻게 잡을 것인가</strong>였습니다. 단순한 CRUD를 넘어서 소셜 로그인, 커뮤니티, AI 기반 정착 리포트 등 다양한 기능을 포함할 예정이었기 때문에, 기능이 늘어나더라도 유지보수가 쉽고, 각 도메인이 명확하게 분리되도록 설계하고 싶었습니다.</p>

<p>처음엔 기능 중심으로 폴더를 나눌까도 생각했지만, 여러 기능이 얽혀 있을 때 책임이 명확하지 않고 코드가 뒤섞일 우려가 있었습니다. 그래서 고민 끝에 <strong>도메인 주도 설계(Domain-Driven Design, DDD)</strong> 와 <strong>MVC 구조</strong>, 그리고 <strong>레이어드 아키텍처(Layered Architecture)</strong> 를 조합한 형태로 프로젝트 구조를 설계하기로 했습니다.</p>

<h3 id="-도메인-주도-설계란">💡 도메인 주도 설계란?</h3>

<p>DDD는 비즈니스의 복잡한 요구사항을 도메인 중심으로 풀어가는 소프트웨어 설계 방법입니다. 코드 구조가 실제 도메인 모델과 맞닿아 있어 유지보수가 용이하고, 비즈니스 개념을 중심으로 기능을 구현할 수 있도록 도와줍니다. 핵심은 <strong>‘도메인을 기준으로 책임을 분리’</strong>하는 것입니다.</p>

<p>또한 레이어드 아키텍처는 기능을 계층별로 나누어 역할을 분리함으로써 각 계층 간의 결합도를 낮추고 테스트와 유지보수를 용이하게 합니다. 대표적으로는 Controller → Service → Repository 계층 구조를 따릅니다.</p>

<hr />

<p>최종적으로 다음과 같은 구조를 구성했습니다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>org.example.burtyserver/
 ├── domain/                  # 도메인 중심 패키지
 │   ├── auth/                # 인증 관련 기능
 │   │   ├── controller/      # API 컨트롤러 (Presentation Layer)
 │   │   └── dto/             # 데이터 전송 객체
 │   │
 │   └── user/                # 사용자 관련 기능
 │       ├── entity/          # 엔티티 클래스 (Domain Layer)
 │       ├── repository/      # 데이터 접근 계층 (Persistence Layer)
 │       └── service/         # 비즈니스 로직 (Application Layer)
 │
 ├── global/                  # 공통/전역 기능
 │   ├── config/              # 설정 클래스
 │   ├── exception/           # 예외 처리
 │   └── security/            # 보안 관련 클래스
 │       ├── jwt/             # JWT 관련 클래스
 │       ├── oauth2/          # OAuth2 관련 클래스
 │       └── dto/             # 보안 관련 DTO
 │
 └── BurtyServerApplication.java   # 애플리케이션 진입점
</code></pre></div></div>

<p>-&gt; 아직 개발중!</p>

<p>이 구조는 기능별 분리보다 도메인별 분리를 우선시했으며, 각 도메인이 자신의 책임과 역할에 따라 나뉘도록 구성했습니다. 공통 설정이나 보안 로직처럼 여러 도메인에서 공유되는 요소들은 <code class="language-plaintext highlighter-rouge">global</code>이라는 전역 패키지에 따로 관리하여 관심사 분리를 명확히 했습니다.</p>

<p>실제로 프로젝트를 진행하면서 새로운 기능이 추가될 때마다 이 구조 덕분에 확장이 훨씬 수월했습니다. 예를 들어 AI 정착 리포트 기능을 추가할 때도 <code class="language-plaintext highlighter-rouge">settlement</code>라는 도메인을 추가해 기존 구조에 영향을 주지 않고도 자연스럽게 통합할 수 있었습니다.</p>

<p>도메인 주도 설계를 기반으로 구조를 잡는 과정은 단순히 코드를 예쁘게 나누는 것을 넘어서, 기능과 비즈니스 로직의 맥락(Context)을 코드 레벨에서 표현하는 데 큰 도움이 되었습니다. 또한 레이어드 아키텍처를 통해 각 계층의 역할이 명확해져 협업 시 작업 분담이나 코드 리뷰도 훨씬 효율적으로 이루어졌습니다.</p>

<p>이 경험은 제가 프로젝트를 단순히 “만드는 것”을 넘어서, “운영 가능한 구조로 설계한다”는 감각을 키우는 데 결정적인 계기가 되었습니다.</p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[버티 프로젝트 구조 설계 고민과 선택]]></summary></entry><entry><title type="html">[Spring] 논블로킹(Non-blocking) vs 비동기 (Asynchronous)</title><link href="https://nan0silver.github.io/spring/2025-04-09-non-blocking/" rel="alternate" type="text/html" title="[Spring] 논블로킹(Non-blocking) vs 비동기 (Asynchronous)" /><published>2025-04-09T00:00:00+00:00</published><updated>2025-05-28T01:08:08+00:00</updated><id>https://nan0silver.github.io/spring/non-blocking</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-09-non-blocking/"><![CDATA[<ul>
  <li><a href="#-논블로킹non-blocking이란">논블로킹이란?</a></li>
  <li><a href="#-실생활-비유로-논블로킹-이해하기">실생활 비유로 논블로킹 이해하기</a></li>
  <li><a href="#-블로킹-vs-논블로킹-기술적-요점-정리">블로킹 vs 논블로킹 기술적 요점 정리</a></li>
  <li><a href="#-논블로킹이-중요한-이유">논블로킹이 중요한 이유</a></li>
  <li><a href="#️-어디서-논블로킹이-쓰이냐">어디서 논블로킹이 쓰이냐?</a></li>
  <li><a href="#논블로킹non-blocking이랑-비동기asynchronous-비교">논블로킹(Non-blocking) 비동기(Asynchronous) 비교</a></li>
  <li><a href="#completablefuture-webclient-코드-예시">CompletableFuture, WebClient 코드 예시</a></li>
</ul>

<hr />

<h2 id="-논블로킹non-blocking이란">✅ 논블로킹(Non-blocking)이란?</h2>

<h3 id="먼저-블로킹blocking이-뭔지부터-알아보자">먼저, 블로킹(Blocking)이 뭔지부터 알아보자</h3>

<ul>
  <li><strong>블로킹 방식</strong>은 어떤 작업이 끝날 때까지 프로그램이 <strong>멈춰서 기다리는 것</strong></li>
  <li>웹 서버라면, DB 응답이나 외부 API 요청이 끝날 때까지 <strong>쓰레드가 잡혀서 못 움직임.</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 블로킹 방식 (예: RestTemplate)</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="s">"http://api.example.com"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// → 이 줄에서 응답이 올 때까지 멈춤</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"응답 받음!"</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<h3 id="-논블로킹-방식은">🚀 논블로킹 방식은?</h3>

<ul>
  <li><strong>기다리지 않는다.</strong> 요청을 보내고, 바로 다음 작업을 처리한다.</li>
  <li>응답이 나중에 오면, 그때 콜백(또는 리액티브 스트림)을 통해 처리</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 논블로킹 방식 (예: WebClient)</span>
<span class="n">webClient</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">"http://api.example.com"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
    <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">result</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"응답 받음! → "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">});</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"바로 다음 코드 실행됨!"</span><span class="o">);</span>
</code></pre></div></div>

<p>👆 여기서 중요한 건:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">subscribe()</code> 안에 있는 코드만 나중에 실행되고</li>
  <li>서버 쓰레드는 그동안 다른 요청을 처리할 수 있다는 것</li>
</ul>

<hr />

<h2 id="-실생활-비유로-논블로킹-이해하기">🍜 실생활 비유로 논블로킹 이해하기</h2>

<h3 id="-블로킹-방식-짜장면집-주방장-1명">✅ 블로킹 방식: 짜장면집 주방장 1명</h3>

<blockquote>
  <p>손님이 주문 → 짜장면 끓이는 동안 주방장이 다음 주문을 못 받음<br />
5명 동시에 오면? 4명은 그냥 기다림 (쓰레드 낭비, 느림)</p>
</blockquote>

<h3 id="-논블로킹-방식-주방장--자동면로봇">✅ 논블로킹 방식: 주방장 + 자동면로봇</h3>

<blockquote>
  <p>손님이 주문 → 기계에 넣고 대기표 발급 → 주방장은 다른 주문 처리<br />
→ 주문 100개가 와도 효율적으로 동시에 처리 가능! (고성능, 확장성)</p>
</blockquote>

<hr />

<h2 id="-블로킹-vs-논블로킹-기술적-요점-정리">🧠 블로킹 vs 논블로킹 기술적 요점 정리</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>블로킹 방식</th>
      <th>논블로킹 방식</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>처리 방식</td>
      <td>요청 → 대기 → 응답</td>
      <td>요청 → 바로 다음 처리 → 응답 오면 콜백</td>
    </tr>
    <tr>
      <td>쓰레드 사용</td>
      <td><strong>요청 1건당 쓰레드 1개</strong></td>
      <td><strong>요청 수백건도 쓰레드 몇 개</strong>로 처리 가능</td>
    </tr>
    <tr>
      <td>성능</td>
      <td>낮은 동시성 처리</td>
      <td>높은 동시성, 고성능</td>
    </tr>
    <tr>
      <td>코드</td>
      <td>간단하고 직관적</td>
      <td>콜백이나 리액티브 스트림 필요</td>
    </tr>
    <tr>
      <td>예시</td>
      <td>RestTemplate, JDBC</td>
      <td>WebClient, R2DBC, Netty 등</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-논블로킹이-중요한-이유">💡 논블로킹이 중요한 이유</h2>

<h3 id="️-1-고성능-서버-만들기">✔️ 1. 고성능 서버 만들기</h3>

<ul>
  <li>수천~수만 명이 동시에 요청을 보내도 효율적으로 처리 가능</li>
</ul>

<h3 id="️-2-외부-api-많이-쓰는-서비스에서-유리">✔️ 2. 외부 API 많이 쓰는 서비스에서 유리</h3>

<ul>
  <li>다른 서비스의 응답을 기다리는 동안, 서버 리소스를 낭비하지 않음</li>
</ul>

<h3 id="️-3-msa-마이크로서비스-아키텍처에서-필수">✔️ 3. MSA (마이크로서비스 아키텍처)에서 필수</h3>

<ul>
  <li>서로 요청 주고받는 일이 많기 때문에 <strong>논블로킹 API가 매우 효율적</strong></li>
</ul>

<hr />

<h2 id="️-어디서-논블로킹이-쓰이냐">🛠️ 어디서 논블로킹이 쓰이냐?</h2>

<table>
  <thead>
    <tr>
      <th>기술</th>
      <th>논블로킹 여부</th>
      <th>비고</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">WebClient</code></td>
      <td>✅</td>
      <td>REST API 호출</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Reactor Netty</code></td>
      <td>✅</td>
      <td>웹서버 / 클라이언트 엔진</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">R2DBC</code></td>
      <td>✅</td>
      <td>논블로킹 DB 클라이언트 (JDBC는 블로킹)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Spring WebFlux</code></td>
      <td>✅</td>
      <td>전체 논블로킹 웹 프레임워크</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="논블로킹non-blocking이랑-비동기asynchronous-비교">“논블로킹(Non-blocking)”이랑 “비동기(Asynchronous)” 비교</h2>

<blockquote>
  <p>❌ <strong>같은 말 아님</strong>.<br />
✅ <strong>서로 관련 있지만, 개념적으로 다르다.</strong></p>
</blockquote>

<h3 id="-핵심-차이-요약">🔍 핵심 차이 요약</h3>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>비동기 (Asynchronous)</th>
      <th>논블로킹 (Non-blocking)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>개념</td>
      <td><strong>작업을 요청하고 바로 다음 코드 실행</strong> (응답 기다리지 않음)</td>
      <td><strong>리소스(쓰레드 등)를 점유하지 않음</strong></td>
    </tr>
    <tr>
      <td>초점</td>
      <td><strong>시간(언제 실행될지 모름)</strong></td>
      <td><strong>리소스 사용 여부</strong></td>
    </tr>
    <tr>
      <td>예시</td>
      <td>콜백, Future, Promise, Mono</td>
      <td><code class="language-plaintext highlighter-rouge">read()</code> 호출 시 즉시 리턴</td>
    </tr>
    <tr>
      <td>관련성</td>
      <td>비동기 처리는 대부분 논블로킹 방식으로 구현됨</td>
      <td>논블로킹이 항상 비동기인 건 아님</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-비유로-설명">🎯 비유로 설명</h3>

<h4 id="-비동기란">🍜 비동기란?</h4>

<blockquote>
  <p>“너 짜장면 하나, 그리고 바로 다음 손님 주세요~”</p>
</blockquote>

<ul>
  <li>주문 받고 <strong>즉시 다음 손님 주문을 받는</strong> 방식</li>
  <li>짜장면이 나올 때까지 <strong>기다리지 않음</strong></li>
  <li>나중에 “주문하신 짜장면 나왔습니다~” 하고 <strong>알림이 옴 (콜백)</strong></li>
</ul>

<p>✅ 즉, “작업이 완료될 때까지 기다리지 않고 <strong>나중에 처리</strong>“가 핵심</p>

<hr />

<h4 id="-논블로킹이란">🥡 논블로킹이란?</h4>

<blockquote>
  <p>“면 삶는 동안 <strong>주방 공간을 계속 점유하지 않음</strong>”</p>
</blockquote>

<ul>
  <li>요리를 맡긴 뒤 주방 공간을 <strong>즉시 다른 요리사에게 넘겨줌</strong></li>
  <li>결과가 나올 때까지 그 <strong>리소스를 점유하지 않음</strong></li>
</ul>

<p>✅ 즉, <strong>요청을 처리 중인 동안에도 시스템 리소스를 점유하지 않음</strong>이 핵심</p>

<hr />

<h2 id="-코드-예시-비교">🧠 코드 예시 비교</h2>

<h3 id="-블로킹--동기-가장-기본">🧱 블로킹 + 동기 (가장 기본)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 이 줄에서 서버 응답이 올 때까지 기다림 (쓰레드 점유 O, 시간도 대기 O)</span>
</code></pre></div></div>

<hr />

<h3 id="-논블로킹--동기">🧱 논블로킹 + 동기</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">readNonBlocking</span><span class="o">();</span>  <span class="c1">// 지금 읽을 수 있는 데이터만 읽고 즉시 리턴</span>
</code></pre></div></div>

<ul>
  <li>당장 읽을 게 없으면 빈 값만 주고 <strong>쓰레드는 곧바로 다음 작업 가능</strong></li>
  <li>하지만 <strong>이 결과로 바로 처리함</strong> → <strong>동기적</strong></li>
</ul>

<hr />

<h3 id="-논블로킹--비동기-진짜-고성능-시스템-핵심">🧱 논블로킹 + 비동기 (진짜 고성능 시스템 핵심!)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">webClient</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">"/data"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
    <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"데이터 도착: "</span> <span class="o">+</span> <span class="n">data</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>

<ul>
  <li>요청 후 <strong>바로 다음 코드 실행됨</strong> (비동기)</li>
  <li><strong>쓰레드를 점유하지 않음</strong> (논블로킹)</li>
  <li>응답이 왔을 때만 콜백으로 실행됨</li>
</ul>

<hr />

<h3 id="-정리하자면">💡 정리하자면</h3>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>설명</th>
      <th>예</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>비동기</td>
      <td>요청 → 응답 기다리지 않고 다른 작업함</td>
      <td>콜백, <code class="language-plaintext highlighter-rouge">subscribe</code>, <code class="language-plaintext highlighter-rouge">Future</code>, <code class="language-plaintext highlighter-rouge">CompletableFuture</code></td>
    </tr>
    <tr>
      <td>논블로킹</td>
      <td>시스템 리소스를 점유하지 않음</td>
      <td>WebClient, R2DBC, Netty</td>
    </tr>
    <tr>
      <td>블로킹</td>
      <td>결과 나올 때까지 멈춤</td>
      <td>RestTemplate, JDBC</td>
    </tr>
    <tr>
      <td>비동기 + 논블로킹</td>
      <td>성능 최상 조합</td>
      <td>WebFlux + Netty + R2DBC</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="completablefuture-webclient-코드-예시">CompletableFuture, WebClient 코드 예시</h2>

<h3 id="-1-completablefuture로-비동기-스레드는-점유함--논블로킹-아님">✅ 1. <code class="language-plaintext highlighter-rouge">CompletableFuture</code>로 비동기 (스레드는 점유함 = 논블로킹 아님)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.CompletableFuture</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutionException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsyncWithCompletableFuture</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ExecutionException</span><span class="o">,</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"비동기 시작"</span><span class="o">);</span>

        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="c1">// 시간이 오래 걸리는 작업 (예: API 호출 시뮬레이션)</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span> <span class="c1">// 2초 대기 (스레드 점유)</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="s">"API 결과값"</span><span class="o">;</span>
        <span class="o">});</span>

        <span class="c1">// 다른 작업 수행</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"다른 작업 수행 중..."</span><span class="o">);</span>

        <span class="c1">// 결과 기다리기</span>
        <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="c1">// 여기서 block됨</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"결과: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="-포인트">📌 포인트:</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture</code>는 비동기처럼 보이지만 <strong>실제로는 별도 스레드를 점유</strong>함.</li>
  <li><code class="language-plaintext highlighter-rouge">.get()</code>을 호출하면 <strong>결과를 기다리는 동안 block</strong>됨.</li>
</ul>

<hr />

<h2 id="-2-webclient로-진짜-논블로킹--비동기">🛸 2. <code class="language-plaintext highlighter-rouge">WebClient</code>로 진짜 논블로킹 + 비동기</h2>

<blockquote>
  <p>의존성 필요:
<a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-webflux">mvn repository</a></p>
</blockquote>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- build.gradle 혹은 pom.xml --&gt;</span>
implementation 'org.springframework.boot:spring-boot-starter-webflux'
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.web.reactive.function.client.WebClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">reactor.core.publisher.Mono</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsyncWithWebClient</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">WebClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">WebClient</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"WebClient 비동기 호출 시작"</span><span class="o">);</span>

        <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
                <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">"https://jsonplaceholder.typicode.com/todos/1"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
                <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

        <span class="n">response</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">body</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"응답 도착: "</span> <span class="o">+</span> <span class="n">body</span><span class="o">));</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"다른 작업 수행 중..."</span><span class="o">);</span>

        <span class="c1">// 실제로 메인 스레드가 먼저 종료될 수 있어서 약간 대기</span>
        <span class="k">try</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">3000</span><span class="o">);</span> <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="-포인트-1">📌 포인트:</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">WebClient</code>는 진짜 논블로킹 (스레드 점유 X)</li>
  <li><code class="language-plaintext highlighter-rouge">.subscribe()</code>로 <strong>콜백 기반 응답 처리</strong></li>
  <li><strong>메인 스레드는 응답 기다리지 않음</strong>, 논블로킹 체험 가능</li>
</ul>

<hr />

<h2 id="️-비교-요약">⚖️ 비교 요약</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th><code class="language-plaintext highlighter-rouge">CompletableFuture</code></th>
      <th><code class="language-plaintext highlighter-rouge">WebClient</code> (WebFlux)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>스레드 점유</td>
      <td>O (다른 스레드가 일 함)</td>
      <td>X (논블로킹 방식)</td>
    </tr>
    <tr>
      <td>비동기 처리 방식</td>
      <td>Future 기반</td>
      <td>리액티브 스트림 (Mono/Flux)</td>
    </tr>
    <tr>
      <td>논블로킹 체험 가능 여부</td>
      <td>부분적으로 (Thread 풀에 의존)</td>
      <td>O (진짜 논블로킹)</td>
    </tr>
    <tr>
      <td>사용 목적</td>
      <td>간단한 비동기 로직</td>
      <td>고성능, 동시성 높은 네트워크 호출</td>
    </tr>
  </tbody>
</table>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[논블로킹과 비동기에 대해 알아보자.]]></summary></entry></feed>