<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-12-29T09:32:07+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[Algorithm] 플로이드-워셜 알고리즘</title><link href="https://nan0silver.github.io/algorithm/2025-12-29-floyd-warshall/" rel="alternate" type="text/html" title="[Algorithm] 플로이드-워셜 알고리즘" /><published>2025-12-29T00:00:00+00:00</published><updated>2025-12-29T09:31:20+00:00</updated><id>https://nan0silver.github.io/algorithm/floyd-warshall</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2025-12-29-floyd-warshall/"><![CDATA[<ol>
  <li><a href="#-1️⃣-플로이드-워셜이란">플로이드-워셜이란?</a></li>
  <li><a href="#-2️⃣-핵심-개념-이해하기">핵심 개념 이해하기</a></li>
  <li><a href="#-3️⃣-k-i-j의-정확한-의미">k, i, j의 의미</a></li>
  <li><a href="#-4️⃣-동작-과정-시각화">동작 과정 시각화</a></li>
  <li><a href="#-5️⃣-코드-구현">코드 구현</a></li>
  <li><a href="#-6️⃣-시간복잡도와-공간복잡도">시간복잡도와 공간복잡도</a></li>
  <li><a href="#-7️⃣-다익스트라와의-비교">다익스트라와의 비교</a></li>
  <li><a href="#-8️⃣-실전-문제-적용">실전 문제 적용</a></li>
</ol>

<hr />

<h2 id="-1️⃣-플로이드-워셜이란">🎯 1️⃣ 플로이드-워셜이란?</h2>

<h3 id="-한-문장-정의">💡 한 문장 정의</h3>

<p><strong>“모든 정점 쌍 사이의 최단 경로를 한 번에 구하는 알고리즘”</strong></p>

<h3 id="-언제-사용하는가">💡 언제 사용하는가?</h3>

<ul>
  <li>“A 도시에서 B 도시로 가는 최단 거리는?” → 모든 도시 쌍에 대해 물어볼 때</li>
  <li>“경유지를 거쳐가는 것이 더 빠른가?” → 중간 노드를 허용하며 최적 경로를 찾을 때</li>
  <li>그래프의 모든 쌍 최단 거리를 구해야 할 때</li>
</ul>

<h3 id="-특징">💡 특징</h3>

<table>
  <thead>
    <tr>
      <th>특징</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>시간복잡도</strong></td>
      <td>O(V³) - 정점 개수의 세제곱</td>
    </tr>
    <tr>
      <td><strong>공간복잡도</strong></td>
      <td>O(V²) - 2차원 배열</td>
    </tr>
    <tr>
      <td><strong>음수 간선</strong></td>
      <td>처리 가능 (단, 음수 사이클은 불가)</td>
    </tr>
    <tr>
      <td><strong>그래프 종류</strong></td>
      <td>방향/무방향 모두 가능</td>
    </tr>
    <tr>
      <td><strong>구현 난이도</strong></td>
      <td>매우 쉬움 (3중 for문)</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-2️⃣-핵심-개념-이해하기">🧠 2️⃣ 핵심 개념 이해하기</h2>

<h3 id="-알고리즘의-본질">💡 알고리즘의 본질</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"도시 i에서 도시 j로 갈 때,
k번 도시를 중간에 한 번 거쳐도 되는지를
매 단계마다 허용해가며 최소 비용을 갱신하는 알고리즘"
</code></pre></div></div>

<h3 id="-distij의-의미">💡 dist[i][j]의 의미</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">지금까지</span> <span class="n">허용된</span> <span class="n">중간</span> <span class="n">도시들만</span> <span class="n">이용해서</span>
             <span class="n">i</span> <span class="err">→</span> <span class="n">j로</span> <span class="n">가는</span> <span class="n">최소</span> <span class="n">비용</span>
</code></pre></div></div>

<p>여기서 “지금까지 허용된”이 핵심이다. k값에 따라 허용 범위가 달라진다.</p>

<h3 id="-동적-계획법dp으로서의-플로이드-워셜">💡 동적 계획법(DP)으로서의 플로이드-워셜</h3>

<p>플로이드-워셜의 본질적인 점화식:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DP[k][i][j] = 중간 도시를 1~k까지만 써서 i→j로 가는 최소 비용

DP[k][i][j] = min(
    DP[k-1][i][j],           // k를 거치지 않는 경우
    DP[k-1][i][k] + DP[k-1][k][j]  // k를 거치는 경우
)
</code></pre></div></div>

<p>실제 코드는 3차원 배열 대신 2차원 배열을 덮어쓰면서 k 단계를 확장한다.</p>

<hr />

<h2 id="-3️⃣-k-i-j의-정확한-의미">🔑 3️⃣ k, i, j의 정확한 의미</h2>

<h3 id="-기본-구조">💡 기본 구조</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>        <span class="c1">// 중간 노드</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>    <span class="c1">// 출발 노드</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 도착 노드</span>
            <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
                <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span>
                <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">+</span> <span class="n">dist</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>
            <span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="-각-변수의-의미">💡 각 변수의 의미</h3>

<table>
  <thead>
    <tr>
      <th>변수</th>
      <th>의미</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>k</strong></td>
      <td>중간에 거쳐도 되는 도시 번호</td>
      <td>k=1일 때는 1번만, k=2일 때는 1,2번까지 허용</td>
    </tr>
    <tr>
      <td><strong>i</strong></td>
      <td>출발 도시</td>
      <td>모든 출발지를 순회</td>
    </tr>
    <tr>
      <td><strong>j</strong></td>
      <td>도착 도시</td>
      <td>모든 도착지를 순회</td>
    </tr>
  </tbody>
</table>

<h3 id="-핵심-로직의-의미">💡 핵심 로직의 의미</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
    <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span>          <span class="c1">// 원래 알고 있던 i → j 최단 경로</span>
    <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">+</span> <span class="n">dist</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>  <span class="c1">// i → k → j로 가는 새로운 경로</span>
<span class="o">);</span>
</code></pre></div></div>

<p>이 코드가 묻는 질문:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"i에서 j로 바로 가는 게 낫나?"
"아니면 k를 한 번 들렀다 가는 게 낫나?"
</code></pre></div></div>

<p>시각적 표현:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i ─────────▶ j  (직접)
│
│
▼
k
</code></pre></div></div>

<h3 id="-왜-k가-가장-바깥-루프인가">💡 왜 k가 가장 바깥 루프인가?</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ 올바른 순서</span>
<span class="k">for</span> <span class="n">k</span>
  <span class="k">for</span> <span class="n">i</span>
    <span class="k">for</span> <span class="n">j</span>

<span class="c1">// ❌ 잘못된 순서</span>
<span class="k">for</span> <span class="n">i</span>
  <span class="k">for</span> <span class="n">j</span>
    <span class="k">for</span> <span class="n">k</span>
</code></pre></div></div>

<p><strong>이유</strong>: k는 “중간 도시로 k까지 허용한 상태에서 모든 i→j 최단거리를 갱신”한다는 의미다. 만약 i나 j가 바깥에 있으면 아직 허용되지 않은 중간 도시를 사용하게 되어 DP의 단계적 의미가 깨진다.</p>

<hr />

<h2 id="-4️⃣-동작-과정-시각화">📊 4️⃣ 동작 과정 시각화</h2>

<h3 id="-예시-그래프">💡 예시 그래프</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1 ──(4)── 2
    │         │
   (3)       (2)
    │         │
    3 ──(5)── 4
</code></pre></div></div>

<h3 id="-초기-상태-k--0-중간-노드-허용-안-함">💡 초기 상태 (k = 0, 중간 노드 허용 안 함)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dist[i][j] = 직접 연결된 간선만 사용

      1    2    3    4
1  [  0    4   INF  INF ]
2  [  4    0   INF   2  ]
3  [ INF  INF   0    5  ]
4  [ INF   2    5    0  ]
</code></pre></div></div>

<h3 id="-k--1-1번-노드를-중간에-사용-가능">💡 k = 1 (1번 노드를 중간에 사용 가능)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"1번을 거쳐가면 더 빠른 경로가 있나?"

i=2, j=3일 때:
dist[2][3] = min(INF, dist[2][1] + dist[1][3])
           = min(INF, 4 + INF) = INF

i=3, j=2일 때:
dist[3][2] = min(INF, dist[3][1] + dist[1][2])
           = min(INF, INF + 4) = INF
</code></pre></div></div>

<h3 id="-k--2-12번-노드를-중간에-사용-가능">💡 k = 2 (1,2번 노드를 중간에 사용 가능)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"2번을 거쳐가면 더 빠른 경로가 있나?"

i=1, j=4일 때:
dist[1][4] = min(INF, dist[1][2] + dist[2][4])
           = min(INF, 4 + 2) = 6
</code></pre></div></div>

<h3 id="-최종-결과-k--4-모든-노드-허용">💡 최종 결과 (k = 4, 모든 노드 허용)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      1    2    3    4
1  [  0    4    8    6  ]
2  [  4    0    7    2  ]
3  [  8    7    0    5  ]
4  [  6    2    5    0  ]
</code></pre></div></div>

<hr />

<h2 id="-5️⃣-코드-구현">💻 5️⃣ 코드 구현</h2>

<h3 id="-기본-템플릿">💡 기본 템플릿</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">FloydWarshall</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">INF</span> <span class="o">=</span> <span class="mi">987654321</span><span class="o">;</span>  <span class="c1">// 충분히 큰 값</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// 1. 초기화</span>

        <span class="c1">// 2. 간선 정보 입력</span>

        <span class="c1">// 3. 플로이드-워셜 알고리즘</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">!=</span> <span class="no">INF</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="no">INF</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span>
                                              <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">+</span> <span class="n">dist</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 4. 결과 출력</span>
        <span class="n">printDistances</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="-6️⃣-시간복잡도와-공간복잡도">📈 6️⃣ 시간복잡도와 공간복잡도</h2>

<h3 id="-시간복잡도">💡 시간복잡도</h3>

<table>
  <thead>
    <tr>
      <th>연산</th>
      <th>복잡도</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>플로이드-워셜</strong></td>
      <td>O(V³)</td>
      <td>3중 for문</td>
    </tr>
    <tr>
      <td><strong>초기화</strong></td>
      <td>O(V²)</td>
      <td>2차원 배열 초기화</td>
    </tr>
    <tr>
      <td><strong>전체</strong></td>
      <td>O(V³)</td>
      <td>플로이드-워셜이 지배적</td>
    </tr>
  </tbody>
</table>

<h3 id="-공간복잡도">💡 공간복잡도</h3>

<table>
  <thead>
    <tr>
      <th>자료구조</th>
      <th>크기</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>거리 배열</strong></td>
      <td>O(V²)</td>
      <td>dist[n][n]</td>
    </tr>
    <tr>
      <td><strong>경로 배열</strong></td>
      <td>O(V²)</td>
      <td>next[n][n] (선택적)</td>
    </tr>
    <tr>
      <td><strong>전체</strong></td>
      <td>O(V²)</td>
      <td>2차원 배열</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="️-7️⃣-다익스트라와의-비교">⚖️ 7️⃣ 다익스트라와의 비교</h2>

<h3 id="-핵심-차이점">💡 핵심 차이점</h3>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>플로이드-워셜</th>
      <th>다익스트라</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>목적</strong></td>
      <td>모든 쌍 최단 경로</td>
      <td>한 정점에서 모든 정점으로</td>
    </tr>
    <tr>
      <td><strong>시간복잡도</strong></td>
      <td>O(V³)</td>
      <td>O((V+E)logV)</td>
    </tr>
    <tr>
      <td><strong>공간복잡도</strong></td>
      <td>O(V²)</td>
      <td>O(V)</td>
    </tr>
    <tr>
      <td><strong>음수 간선</strong></td>
      <td>가능 (음수 사이클 제외)</td>
      <td>불가능</td>
    </tr>
    <tr>
      <td><strong>구현 난이도</strong></td>
      <td>매우 쉬움</td>
      <td>중간 (우선순위 큐)</td>
    </tr>
    <tr>
      <td><strong>적용 상황</strong></td>
      <td>정점이 적을 때 (V ≤ 500)</td>
      <td>정점이 많을 때, 특정 출발점</td>
    </tr>
  </tbody>
</table>

<h3 id="-언제-무엇을-쓸까">💡 언제 무엇을 쓸까?</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ 플로이드-워셜을 쓸 때</span>
<span class="k">if</span> <span class="o">(</span><span class="n">모든</span> <span class="n">정점</span> <span class="n">쌍의</span> <span class="n">최단</span> <span class="n">거리가</span> <span class="n">필요</span> <span class="o">&amp;&amp;</span> <span class="n">정점</span> <span class="n">수</span> <span class="err">≤</span> <span class="mi">500</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">플로이드워셜</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// ✅ 다익스트라를 쓸 때</span>
<span class="k">if</span> <span class="o">(</span><span class="n">특정</span> <span class="n">출발점에서</span> <span class="n">모든</span> <span class="n">정점까지</span> <span class="o">&amp;&amp;</span> <span class="n">음수</span> <span class="n">간선</span> <span class="n">없음</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">다익스트라</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// ✅ 벨만-포드를 쓸 때</span>
<span class="k">if</span> <span class="o">(</span><span class="n">음수</span> <span class="n">간선</span> <span class="n">있음</span> <span class="o">&amp;&amp;</span> <span class="n">음수</span> <span class="n">사이클</span> <span class="n">감지</span> <span class="n">필요</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">벨만포드</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="-8️⃣-실전-문제-적용">🎯 8️⃣ 실전 문제 적용</h2>

<h3 id="-대표-문제-유형">💡 대표 문제 유형</h3>

<table>
  <thead>
    <tr>
      <th>유형</th>
      <th>설명</th>
      <th>예시 문제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>모든 쌍 최단 경로</strong></td>
      <td>모든 도시 간 최단 거리</td>
      <td>백준 11404 플로이드</td>
    </tr>
    <tr>
      <td><strong>경유지 문제</strong></td>
      <td>특정 경유지를 거쳐야 할 때</td>
      <td>프로그래머스 순위</td>
    </tr>
    <tr>
      <td><strong>연결성 판단</strong></td>
      <td>모든 노드가 연결되어 있는가?</td>
      <td>백준 1389 케빈 베이컨</td>
    </tr>
    <tr>
      <td><strong>최단 경로 개수</strong></td>
      <td>최단 경로가 몇 개인가?</td>
      <td>백준 1613 역사</td>
    </tr>
  </tbody>
</table>

<h3 id="-체크리스트">💡 체크리스트</h3>

<p>플로이드-워셜 문제를 풀 때 확인할 것:</p>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />정점 수가 500 이하인가? (아니면 다익스트라 고려)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />모든 쌍의 최단 거리가 필요한가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />음수 간선이 있는가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />음수 사이클을 감지해야 하는가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />INF 값을 충분히 크게 설정했는가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />중복 간선 처리를 했는가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />k가 가장 바깥 루프인가?</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[플로이드-워셜 알고리즘에 대해 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자 2025 회고] 실시간 음성 매칭 서비스, 왜 이 기술들을 선택했나</title><link href="https://nan0silver.github.io/projectdiary/2025-12-20-diary/" rel="alternate" type="text/html" title="[친구하자 2025 회고] 실시간 음성 매칭 서비스, 왜 이 기술들을 선택했나" /><published>2025-12-20T00:00:00+00:00</published><updated>2025-12-29T09:31:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-12-20-diary/"><![CDATA[<ul>
  <li><a href="#들어가며">들어가며</a></li>
  <li><a href="#1-전체-그림-우리-서비스가-필요한-것">1. 전체 그림: 우리 서비스가 필요한 것</a></li>
  <li><a href="#2-backend-spring-boot--webflux를-선택한-이유">2. Backend: Spring Boot + WebFlux를 선택한 이유</a></li>
  <li><a href="#3-database-mysql을-선택한-이유">3. Database: MySQL을 선택한 이유</a></li>
  <li><a href="#4-cache--queue-redis를-선택한-이유">4. Cache &amp; Queue: Redis를 선택한 이유</a></li>
  <li><a href="#5-webrtc-agora를-선택한-이유">5. WebRTC: Agora를 선택한 이유</a></li>
  <li><a href="#6-file-storage-firebase-storage를-선택한-이유">6. File Storage: Firebase Storage를 선택한 이유</a></li>
  <li><a href="#7-frontend-react--capacitor를-선택한-이유">7. Frontend: React + Capacitor를 선택한 이유</a></li>
  <li><a href="#8-배포-환경-aws--vercel">8. 배포 환경: AWS + Vercel</a></li>
  <li><a href="#9-기술-선택의-원칙">9. 기술 선택의 원칙</a></li>
  <li><a href="#10-마치며">10. 마치며</a></li>
</ul>

<hr />

<h2 id="들어가며">들어가며</h2>

<p>“관심사 기반 1:1 랜덤 음성 통화”라는 아이디어를 떠올렸을 때, 가장 먼저 든 생각은 “어떻게 구현하지?”였다. 학부와 석사 과정에서 배운 이론과 토이 프로젝트 경험은 있었지만, 실제 사용자가 쓸 서비스를 만드는 것은 처음이었다.</p>

<p>기술 스택을 선택하는 과정에서 수많은 블로그 글을 읽었고, 여러 서비스를 비교했다. 하지만 결국 깨달은 건 <strong>“정답은 없다”</strong>는 것이었다. 각 기술은 장단점이 있고, 중요한 건 우리 서비스의 맥락에서 어떤 게 적합한가였다.</p>

<p>이 글에서는 내가 왜 이런 선택을 했는지, 어떤 고민을 했는지를 솔직하게 공유해보려 한다.</p>

<hr />

<h2 id="1-전체-그림-우리-서비스가-필요한-것">1. 전체 그림: 우리 서비스가 필요한 것</h2>

<p>기술을 선택하기 전에, 먼저 우리 서비스의 특성을 정리했다.</p>

<h3 id="핵심-요구사항">핵심 요구사항</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 실시간성
   - 매칭 대기 시간을 최소화 (목표: 1분 이내)
   - 매칭 완료 즉시 알림
   - 끊김 없는 음성 통화

2. 확장성
   - 초기엔 소규모지만, 사용자 증가에 대응 가능해야 함
   - 트래픽 급증 시나리오 고려

3. 운영 편의성
   - 문제 발생 시 빠른 파악과 대응
   - 모니터링과 로깅
   - 배포 자동화

4. 비용 효율성
   - MVP 단계에서 과도한 인프라 비용 지양
   - 사용량에 따른 탄력적 비용 구조
</code></pre></div></div>

<p>이 네 가지 축을 기준으로 모든 기술 선택을 평가했다.</p>

<hr />

<h2 id="2-backend-spring-boot--webflux를-선택한-이유">2. Backend: Spring Boot + WebFlux를 선택한 이유</h2>

<h3 id="왜-비동기가-필요했나">왜 비동기가 필요했나?</h3>

<p>처음에는 익숙한 Spring MVC를 쓸까 고민했다. 하지만 우리 서비스의 특성을 생각해보니 WebFlux가 더 적합해 보였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 시나리오: 통화 종료 후 녹음 저장</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">endCall</span><span class="o">(</span><span class="nc">Long</span> <span class="n">callId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 1. 통화 종료 처리</span>
    <span class="n">callService</span><span class="o">.</span><span class="na">endCall</span><span class="o">(</span><span class="n">callId</span><span class="o">);</span>

    <span class="c1">// 2. Agora API 호출 (외부 API, 2-3초 소요)</span>
    <span class="n">agoraService</span><span class="o">.</span><span class="na">stopRecording</span><span class="o">(</span><span class="n">callId</span><span class="o">);</span>  <span class="c1">// ← 여기서 블로킹!</span>

    <span class="c1">// 3. 평가 페이지로 리다이렉트</span>
    <span class="k">return</span> <span class="s">"redirect:/evaluation"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>동기 방식의 문제는 Agora API 응답을 기다리는 2-3초 동안 스레드가 블로킹된다는 거였다. 200개 스레드로 동시 200명만 처리 가능하고, 대기 시간이 증가하면 사용자 경험이 저하된다.</p>

<p>비동기 방식을 쓰면:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">endCall</span><span class="o">(</span><span class="nc">Long</span> <span class="n">callId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">callService</span><span class="o">.</span><span class="na">endCall</span><span class="o">(</span><span class="n">callId</span><span class="o">)</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">agoraService</span><span class="o">.</span><span class="na">stopRecording</span><span class="o">(</span><span class="n">callId</span><span class="o">))</span>  <span class="c1">// 논블로킹</span>
        <span class="o">.</span><span class="na">then</span><span class="o">();</span>
    <span class="c1">// 스레드가 즉시 다른 요청 처리 가능</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="실제-경험-webflux의-학습-곡선">실제 경험: WebFlux의 학습 곡선</h3>

<p>솔직히 말하면, WebFlux는 쉽지 않았다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ 이렇게 하면 안 됨</span>
<span class="kd">public</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="nf">getUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">).</span><span class="na">block</span><span class="o">();</span>  <span class="c1">// 블로킹!</span>
    <span class="k">return</span> <span class="nc">Mono</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ✅ 올바른 방법</span>
<span class="kd">public</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="nf">getUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>  <span class="c1">// 논블로킹 체인</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">block()</code>을 쓰는 순간 비동기의 의미가 사라진다. “Reactive하게 생각하기”까지 시간이 필요했지만, 익숙해지니 외부 API 호출이 많은 우리 서비스에 딱 맞았다.</p>

<h3 id="언제-webflux를-쓰면-좋을까">언제 WebFlux를 쓰면 좋을까?</h3>

<p>내 경험상 이런 경우 WebFlux가 적합하다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ WebFlux 추천:
- 외부 API 호출이 많은 서비스
- WebSocket 등 실시간 통신 필요
- I/O 대기 시간이 긴 작업
- 동시 접속자가 많은 서비스

❌ WebFlux 비추천:
- CPU 집약적 작업 (이미지 처리, 암호화 등)
- 간단한 CRUD 중심 서비스
- 팀이 Spring MVC에 익숙하고, 학습 시간이 부족한 경우
</code></pre></div></div>

<hr />

<h2 id="3-database-mysql을-선택한-이유">3. Database: MySQL을 선택한 이유</h2>

<h3 id="mysql-vs-nosql-고민">MySQL vs NoSQL 고민</h3>

<p>“요즘 트렌드는 NoSQL 아닌가?”라는 생각도 했다. MongoDB를 쓸까 진지하게 고민했다.</p>

<p>우리 데이터의 특성을 분석해봤다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User ←→ Friendships ←→ User
  ↓
Calls ←→ CallRecordings
  ↓
CallEvaluations
</code></pre></div></div>

<p>친구 관계는 양방향이고 상태 관리가 필요하다 (요청중/수락/차단). 통화 이력은 두 사용자 간의 연결이고, 평가는 통화와 1:1 관계다.</p>

<p>이런 구조를 보니 관계형 데이터베이스가 더 자연스러웠다.</p>

<h3 id="데이터-일관성의-중요성">데이터 일관성의 중요성</h3>

<p>특히 친구 관계에서 일관성이 중요했다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 친구 요청은 반드시 양쪽 모두 저장되어야 함</span>
<span class="k">BEGIN</span> <span class="n">TRANSACTION</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">friendships</span> <span class="p">(</span><span class="n">user_a_id</span><span class="p">,</span> <span class="n">user_b_id</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'PENDING'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">friendships</span> <span class="p">(</span><span class="n">user_b_id</span><span class="p">,</span> <span class="n">user_a_id</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'REQUESTED'</span><span class="p">);</span>
<span class="k">COMMIT</span><span class="p">;</span>

<span class="c1">-- 하나라도 실패하면 전체 롤백</span>
</code></pre></div></div>

<p>NoSQL에서는 이런 트랜잭션 보장이 상대적으로 약하다.</p>

<h3 id="쿼리-복잡도">쿼리 복잡도</h3>

<p>통화 이력 조회 같은 경우, JOIN이 필요했다:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 내 통화 이력 + 상대방 정보 + 친구 상태</span>
<span class="k">SELECT</span>
    <span class="k">c</span><span class="p">.</span><span class="o">*</span><span class="p">,</span>
    <span class="n">u</span><span class="p">.</span><span class="n">nickname</span> <span class="k">as</span> <span class="n">partner_name</span><span class="p">,</span>
    <span class="n">f</span><span class="p">.</span><span class="n">status</span> <span class="k">as</span> <span class="n">friend_status</span>
<span class="k">FROM</span> <span class="n">calls</span> <span class="k">c</span>
<span class="k">JOIN</span> <span class="n">users</span> <span class="n">u</span> <span class="k">ON</span> <span class="p">(</span><span class="k">c</span><span class="p">.</span><span class="n">user_a_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span> <span class="k">OR</span> <span class="k">c</span><span class="p">.</span><span class="n">user_b_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">AND</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span> <span class="o">!=</span> <span class="p">:</span><span class="n">myId</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">friendships</span> <span class="n">f</span> <span class="k">ON</span> <span class="n">f</span><span class="p">.</span><span class="n">friend_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">f</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="p">:</span><span class="n">myId</span>
<span class="k">WHERE</span> <span class="k">c</span><span class="p">.</span><span class="n">user_a_id</span> <span class="o">=</span> <span class="p">:</span><span class="n">myId</span> <span class="k">OR</span> <span class="k">c</span><span class="p">.</span><span class="n">user_b_id</span> <span class="o">=</span> <span class="p">:</span><span class="n">myId</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="k">c</span><span class="p">.</span><span class="n">created_at</span> <span class="k">DESC</span><span class="p">;</span>
</code></pre></div></div>

<p>NoSQL에서 이런 쿼리는 애플리케이션 레벨에서 여러 번 조회해야 한다.</p>

<h3 id="그럼-nosql은-언제">그럼 NoSQL은 언제?</h3>

<p>내가 생각하는 NoSQL 적합 케이스:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ NoSQL 추천:
- 스키마가 자주 변하는 경우
- 단순 Key-Value 조회가 대부분
- 대용량 로그/이벤트 데이터
- 수평 확장이 필수적인 경우

❌ NoSQL 비추천:
- 복잡한 관계와 트랜잭션 필요
- JOIN 쿼리가 많은 경우
- 데이터 일관성이 중요한 비즈니스 로직
</code></pre></div></div>

<p>결론은 MySQL로 시작하고, 필요시 캐시(Redis)와 조합하기로 했다.</p>

<hr />

<h2 id="4-cache--queue-redis를-선택한-이유">4. Cache &amp; Queue: Redis를 선택한 이유</h2>

<h3 id="redis의-세-가지-역할">Redis의 세 가지 역할</h3>

<p>우리 서비스에서 Redis는 단순 캐시를 넘어 세 가지 역할을 한다:</p>

<ol>
  <li><strong>매칭 대기열</strong> - 카테고리별로 대기 중인 사용자 관리</li>
  <li><strong>실시간 세션 관리</strong> - WebSocket 연결 정보</li>
  <li><strong>캐시</strong> - 자주 조회되는 카테고리 정보</li>
</ol>

<h3 id="자료구조-선택-zset-vs-set-vs-list">자료구조 선택: ZSET vs SET vs List</h3>

<p>매칭 대기열을 어떤 자료구조로 구현할지 고민이 많았다.</p>

<h4 id="시도-1-list-lpushrpop">시도 1: List (LPUSH/RPOP)</h4>

<pre><code class="language-redis"># 입장
LPUSH wait:music userId_101

# 매칭 (2명 추출)
RPOP wait:music  # userId_101
RPOP wait:music  # userId_205
</code></pre>

<p>문제점은 대기 순서는 보장되지만, 타임아웃 처리가 어렵고 랜덤 매칭이 불가능했다.</p>

<h4 id="시도-2-set-saddspop">시도 2: Set (SADD/SPOP)</h4>

<pre><code class="language-redis"># 입장
SADD wait:music userId_101

# 매칭 (랜덤 2명)
SPOP wait:music 2
</code></pre>

<p>랜덤은 쉽지만 대기 순서를 알 수 없어서 공정성이 없었다.</p>

<h4 id="최종-선택-zset-sorted-set">최종 선택: ZSET (Sorted Set)</h4>

<pre><code class="language-redis"># 입장 (점수 = 대기 시작 시각)
ZADD wait:music 1725430000456 userId_101
ZADD wait:music 1725430001234 userId_205

# 대기순 매칭
ZPOPMIN wait:music 2

# 랜덤 매칭
ZRANDMEMBER wait:music 2
</code></pre>

<p>장점이 명확했다:</p>

<ul>
  <li>대기 시간 기준 정렬 ✅</li>
  <li>대기순/랜덤 모두 가능 ✅</li>
  <li>타임아웃 쉬움 (점수 기준 삭제) ✅</li>
</ul>

<h3 id="왜-별도의-메시지-큐를-안-썼나">왜 별도의 메시지 큐를 안 썼나?</h3>

<p>RabbitMQ, Kafka 같은 전문 메시지 큐도 고려했다.</p>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Redis</th>
      <th>RabbitMQ</th>
      <th>Kafka</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>학습 곡선</td>
      <td>낮음</td>
      <td>중간</td>
      <td>높음</td>
    </tr>
    <tr>
      <td>운영 복잡도</td>
      <td>낮음</td>
      <td>중간</td>
      <td>높음</td>
    </tr>
    <tr>
      <td>성능 (우리 규모)</td>
      <td>충분</td>
      <td>충분</td>
      <td>과함</td>
    </tr>
    <tr>
      <td>비용</td>
      <td>낮음</td>
      <td>중간</td>
      <td>높음</td>
    </tr>
  </tbody>
</table>

<p>초기 단계에서는 Redis로 충분하다고 판단했다. 트래픽이 늘면 그때 전환을 고려하기로 했다. “과도한 엔지니어링”을 경계해야 한다고 생각했다.</p>

<hr />

<h2 id="5-webrtc-agora를-선택한-이유">5. WebRTC: Agora를 선택한 이유</h2>

<h3 id="직접-구현-vs-saas">직접 구현 vs SaaS</h3>

<p>WebRTC를 직접 구현할지, SaaS를 쓸지 고민했다.</p>

<p>직접 구현 시나리오를 생각해보니:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>필요한 것:
- STUN/TURN 서버 구축 및 운영
- Signaling 서버 개발
- NAT Traversal 처리
- 통화 품질 모니터링
- 녹음 기능 구현

예상 개발 시간: 2-3개월
예상 운영 부담: 높음
</code></pre></div></div>

<p>SaaS 사용 시나리오:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>필요한 것:
- SDK 통합 (1-2주)
- 설정 및 테스트

예상 개발 시간: 2주
예상 운영 부담: 낮음
</code></pre></div></div>

<p>MVP는 빠르게 검증하는 게 중요하다고 생각해서 SaaS를 선택했다.</p>

<h3 id="agora-vs-twilio-vs-daily">Agora vs Twilio vs Daily</h3>

<p>WebRTC SaaS를 비교 분석했다.</p>

<p>비교 기준:</p>

<ol>
  <li><strong>통화 품질</strong> - 모두 우수한 수준, 한국 리전 지원 여부가 중요</li>
  <li><strong>Cloud Recording</strong> - 우리 서비스에 필수 기능</li>
  <li><strong>가격</strong> - 초기 단계라 비용 민감</li>
  <li><strong>문서 및 커뮤니티</strong> - 문제 해결이 쉬운가</li>
</ol>

<p>최종적으로 Agora를 선택한 이유:</p>

<ul>
  <li>Cloud Recording 기능이 강력 (Individual Mode 지원)</li>
  <li>Firebase Storage 직접 연동 가능</li>
  <li>가격 경쟁력</li>
  <li>한국어 문서와 한국 리전 지원</li>
</ul>

<p>다만 Twilio보다 커뮤니티가 작고, 일부 고급 기능은 Twilio가 우세하다는 점은 고려사항이었다.</p>

<h3 id="실제-사용-후기">실제 사용 후기</h3>

<p>Agora를 6개월간 사용한 경험을 정리하면:</p>

<p>만족스러운 점:</p>

<ul>
  <li>SDK 통합이 생각보다 쉬움</li>
  <li>녹음 기능이 안정적</li>
  <li>통화 품질 좋음</li>
</ul>

<p>아쉬운 점:</p>

<ul>
  <li>일부 에러 메시지가 불친절</li>
  <li>고급 설정 시 영어 문서 의존도 높음</li>
</ul>

<hr />

<h2 id="6-file-storage-firebase-storage를-선택한-이유">6. File Storage: Firebase Storage를 선택한 이유</h2>

<h3 id="왜-aws-s3가-아닌가">왜 AWS S3가 아닌가?</h3>

<p>통화 녹음 파일을 저장할 곳이 필요했다. 가장 먼저 떠오른 건 AWS S3였다.</p>

<p>고민한 점:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AWS S3:
✅ 업계 표준
✅ 많은 레퍼런스
✅ 강력한 기능

Firebase Storage:
✅ 이미 프로필 이미지에 사용 중
✅ GCS 기반 (Agora와 호환성 좋음)
✅ Firebase 생태계 활용 가능
</code></pre></div></div>

<h3 id="실용적-판단">실용적 판단</h3>

<p>결정적이었던 건 <strong>이미 사용하고 있다</strong>는 점이었다.</p>

<p>새로운 기술을 도입하면:</p>

<ul>
  <li>학습 시간</li>
  <li>설정 및 테스트</li>
  <li>운영 노하우 축적</li>
  <li>문제 해결 경험</li>
</ul>

<p>이 모든 비용이 든다.</p>

<p>기존 기술을 활용하면:</p>

<ul>
  <li>즉시 사용 가능</li>
  <li>이미 익숙함</li>
  <li>통합 관리 편함</li>
</ul>

<p>“최신/유명 != 우리에게 최선”이라는 걸 다시 한번 깨달았다.</p>

<h3 id="agora와의-통합">Agora와의 통합</h3>

<p>특히 Agora Cloud Recording이 GCS(Google Cloud Storage)와 직접 연동된다는 점이 좋았다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Agora → Firebase Storage (GCS 기반)
- HMAC 인증으로 직접 업로드
- 별도의 파일 전송 서버 불필요
- 자동 업로드 (15초마다 segment)
</code></pre></div></div>

<hr />

<h2 id="7-frontend-react--capacitor를-선택한-이유">7. Frontend: React + Capacitor를 선택한 이유</h2>

<h3 id="웹인가-앱인가">웹인가, 앱인가?</h3>

<p>처음부터 모바일 앱을 목표로 했다. 음성 통화 특성상 앱이 더 자연스럽다고 판단했다.</p>

<p>선택지를 정리하면:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 웹 (React)만 개발
   → 빠르지만 접근성 낮음

2. React Native
   → 네이티브 성능, 웹 코드 재사용 불가

3. Flutter
   → 성능 좋음, Dart 새로 학습 필요

4. Capacitor (선택!)
   → 웹 코드 100% 재사용, WebView 기반
</code></pre></div></div>

<h3 id="capacitor의-장점">Capacitor의 장점</h3>

<p>가장 큰 장점은 빠른 개발이었다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기존 React 웹 코드</span>
<span class="kd">const</span> <span class="nx">CallPage</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">setChannel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="dl">''</span><span class="p">);</span>
  <span class="c1">// Agora WebRTC 로직</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// Capacitor 추가 후</span>
<span class="nx">npm</span> <span class="nx">install</span> <span class="p">@</span><span class="nd">capacitor</span><span class="sr">/cor</span><span class="err">e
</span><span class="nx">npx</span> <span class="nx">cap</span> <span class="nx">add</span> <span class="nx">android</span> <span class="nx">ios</span>

<span class="c1">// 앱 빌드 완료!</span>
</code></pre></div></div>

<p>단일 코드베이스로 관리할 수 있다는 것도 큰 장점이었다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/
  components/
    CallPage.tsx      ← 웹, Android, iOS 모두 사용
    MatchingButton.tsx
  lib/
    agora.ts          ← 한 번만 작성
    websocket.ts
</code></pre></div></div>

<h3 id="네이티브-기능-접근">네이티브 기능 접근</h3>

<p>Capacitor 플러그인으로 네이티브 기능도 사용 가능했다:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 카카오 네이티브 로그인</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">KakaoLoginPlugin</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">capacitor-kakao-login-plugin</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">KakaoLoginPlugin</span><span class="p">.</span><span class="nx">goLogin</span><span class="p">();</span>

<span class="c1">// 구글 네이티브 로그인</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">GoogleAuth</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@codetrix-studio/capacitor-google-auth</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">GoogleAuth</span><span class="p">.</span><span class="nx">signIn</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="한계와-트레이드오프">한계와 트레이드오프</h3>

<p>WebView 제약이 있다:</p>

<ul>
  <li>네이티브 앱보다 성능 떨어짐</li>
  <li>일부 브라우저 제약 (CORS, Cookie 등)</li>
  <li>플랫폼별 차이 (iOS vs Android)</li>
</ul>

<p>그럼에도 선택한 이유는:</p>

<ul>
  <li><strong>속도:</strong> 2-3개월 단축</li>
  <li><strong>유지보수:</strong> 하나의 코드베이스</li>
  <li><strong>검증:</strong> MVP 빠르게 출시</li>
</ul>

<p>초기에는 Capacitor로 시작하고, 성장하면 부분적으로 네이티브 전환을 고려하기로 했다.</p>

<hr />

<h2 id="8-배포-환경-aws--vercel">8. 배포 환경: AWS + Vercel</h2>

<h3 id="backend-aws-ec2">Backend: AWS EC2</h3>

<p>“왜 컨테이너(ECS, EKS)가 아닌가?”라는 질문을 받을 수 있는데:</p>

<p>우리 상황:</p>

<ul>
  <li>단일 서버로 충분</li>
  <li>오토 스케일링 아직 불필요</li>
  <li>운영 복잡도 최소화</li>
</ul>

<p>선택:</p>

<ul>
  <li>EC2 단일 인스턴스</li>
  <li>Nginx 리버스 프록시</li>
  <li>Let’s Encrypt SSL</li>
</ul>

<p>비용도 고려했다. ECS/EKS는 추가 비용이 들고, Elastic Load Balancer도 고정 비용이 든다. EC2 단독이 가장 경제적이었다.</p>

<h3 id="frontend-vercel">Frontend: Vercel</h3>

<p>왜 Vercel인가?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ 장점:
- Git push → 자동 배포
- HTTPS 기본 제공
- CDN 자동 설정
- 무료 플랜으로 충분

vs

AWS S3 + CloudFront:
- 직접 설정 필요
- 비용 발생
- CI/CD 직접 구축
</code></pre></div></div>

<p>프론트엔드는 정적 파일이므로 Vercel이 훨씬 편했다.</p>

<hr />

<h2 id="9-기술-선택의-원칙">9. 기술 선택의 원칙</h2>

<p>6개월간의 경험을 돌아보니, 내게는 몇 가지 원칙이 생겼다.</p>

<h3 id="원칙-1-맥락이-가장-중요하다">원칙 1: “맥락”이 가장 중요하다</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❌ "요즘 A가 대세니까 A를 써야지"
✅ "우리 상황에서는 B가 더 적합해"
</code></pre></div></div>

<p>예시:</p>

<ul>
  <li>Kafka는 강력하지만 우리 규모에는 과함 → Redis 선택</li>
  <li>React Native는 좋지만 웹 코드 재사용 중요 → Capacitor 선택</li>
</ul>

<h3 id="원칙-2-mvp는-빠르게-확장은-점진적으로">원칙 2: MVP는 빠르게, 확장은 점진적으로</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>처음부터 완벽한 설계 (X)
빠른 검증 → 점진적 개선 (O)
</code></pre></div></div>

<p>실제 적용:</p>

<ul>
  <li>단일 EC2로 시작 → 트래픽 증가 시 확장 고려</li>
  <li>Redis 대기열 → 필요시 Kafka 전환</li>
  <li>Capacitor → 성장하면 부분 네이티브</li>
</ul>

<h3 id="원칙-3-익숙함도-중요한-가치">원칙 3: “익숙함”도 중요한 가치</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>새로운 기술 학습 비용 vs 익숙한 기술 활용

학부/석사에서 Spring 사용 경험
→ Spring Boot 선택이 자연스러움
</code></pre></div></div>

<h3 id="원칙-4-비용은-현실적-제약">원칙 4: 비용은 현실적 제약</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기 단계의 인프라 비용:
- EC2, RDS, Redis, Agora, Firebase
→ 월 수십 달러 수준으로 통제

vs

이상적 아키텍처:
- ECS, ELB, CloudFront, Kafka...
→ 월 수백 달러
</code></pre></div></div>

<p>서비스 검증이 우선이고, 인프라는 필요 시 확장하기로 했다.</p>

<hr />

<h2 id="10-마치며">10. 마치며</h2>

<p>기술 선택은 트레이드오프의 연속이었다.</p>

<ul>
  <li>성능 vs 개발 속도</li>
  <li>이상 vs 현실</li>
  <li>최신 기술 vs 익숙한 기술</li>
  <li>비용 vs 확장성</li>
</ul>

<p>중요한 건 “정답”을 찾는 게 아니라, “우리에게 맞는 답”을 찾는 것이었다.</p>

<p>6개월간 이 기술들로 서비스를 만들고 운영하며 정말 많이 배웠다.
선택이 완벽하진 않았지만, 후회는 없다.
각 선택의 이유를 명확히 알고 있고, 필요하면 언제든 바꿀 수 있다는 확신이 있기 때문이다!</p>

<p><strong>“왜?”라는 질문을 끊임없이 던지자. 그 답이 쌓이면, 그게 바로 우리의 기술 철학이 된다.</strong></p>

<hr />

<p><strong>시리즈:</strong></p>

<ol>
  <li><strong>왜 이 기술들을 선택했나</strong> ← 현재 글</li>
  <li>실시간 매칭 시스템 설계 (작성 예정)</li>
  <li>운영하며 겪은 문제들 (작성 예정)</li>
  <li>성능 최적화 여정 (작성 예정)</li>
</ol>

<hr />

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://docs.spring.io/spring-framework/reference/web/webflux.html">Spring WebFlux 공식 문서</a></li>
  <li><a href="https://redis.io/docs/data-types/">Redis 자료구조 가이드</a></li>
  <li><a href="https://docs.agora.io/en/cloud-recording">Agora Cloud Recording</a></li>
  <li><a href="https://capacitorjs.com/docs">Capacitor 공식 문서</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[컴퓨터공학 석사 출신 개발자가 첫 실전 프로젝트에서 마주한 기술 선택의 기록]]></summary></entry><entry><title type="html">[친구하자] Agora Cloud Recording과 Firebase Storage로 음성 통화 녹음 구현하기</title><link href="https://nan0silver.github.io/projectdiary/2025-11-24-diary/" rel="alternate" type="text/html" title="[친구하자] Agora Cloud Recording과 Firebase Storage로 음성 통화 녹음 구현하기" /><published>2025-11-24T00:00:00+00:00</published><updated>2025-12-29T09:31:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-24-diary/"><![CDATA[<p>‘친구하자’를 개발하며 통화 녹음 기능을 구현해야 했다. AI 개발과 통화 분석 등 추후 기능들을 위해 통화를 녹음하는 것을 전제로 구현을 시작했다.</p>

<p>처음에는 단순할 줄 알았는데, 생각보다 에러도 많이 나고 시행착오가 많아서 MVP에서 제외하고 개발했다. 이 글에서는 어떤 문제들을 겪었고, 어떻게 해결했는지를 정리하려고 한다.</p>

<h2 id="목차">목차</h2>

<ul>
  <li><a href="#1-기술-스택-선택">1. 기술 스택 선택</a></li>
  <li><a href="#2-구현-과정에서-만난-문제들">2. 구현 과정에서 만난 문제들</a></li>
  <li><a href="#3-최종-구조">3. 최종 구조</a></li>
  <li><a href="#4-배운-점">4. 배운 점</a></li>
  <li><a href="#5-운영-지표">5. 운영 지표</a></li>
  <li><a href="#6-마치며">6. 마치며</a></li>
  <li><a href="#참고-자료">참고 자료</a></li>
</ul>

<hr />

<h2 id="1-기술-스택-선택">1. 기술 스택 선택</h2>

<h3 id="11-왜-agora-cloud-recording을-선택했나">1.1. 왜 Agora Cloud Recording을 선택했나?</h3>

<p>처음에 WebRTC 서비스를 선택하기에 앞서 Recording 구현을 고려했다. WebRTC 중에는 recording을 지원하는 서비스가 있고, 아닌 서비스가 있었다. 그중 Agora는 Recording 지원이 가장 다양했고, 가격도 저렴했다.</p>

<p>Recording을 저장하는 것에도 많은 선택지가 있었다:</p>

<ol>
  <li><strong>Agora 백업 저장소</strong>
    <ul>
      <li>제3자 스토리지 설정이 실패하면 백업 서버에 <strong>24시간 동안만</strong> 임시 저장</li>
      <li>운영용이 아니므로 반드시 외부 저장소 연동 필요</li>
    </ul>
  </li>
  <li><strong>AWS S3 직접 연동</strong>
    <ul>
      <li>가장 일반적이고 안정적인 방법</li>
    </ul>
  </li>
  <li><strong>Firebase Storage (GCS 기반)</strong>
    <ul>
      <li>이미 프로젝트에서 사용 중 (프로필 이미지 등)</li>
    </ul>
  </li>
</ol>

<p>고민 끝에 <strong>Firebase Storage</strong>를 선택했다:</p>

<ul>
  <li>이미 프로젝트에서 사용 중이어서 익숙함</li>
  <li>GCS(Google Cloud Storage) 기반이라 Agora와 호환성이 좋음</li>
  <li>Firebase의 다른 기능들과도 잘 통합됨</li>
  <li>AWS S3와 비용이 비슷한 수준 (월 1,000분 통화 기준 약 80원 차이)</li>
</ul>

<h3 id="12-individual-recording-mode-선택">1.2. Individual Recording Mode 선택</h3>

<p>Agora Cloud Recording에는 여러 모드가 있다:</p>

<ul>
  <li><strong>Composite Mode</strong>: 모든 사람의 음성을 하나로 합침</li>
  <li><strong>Individual Mode</strong>: 각 사용자별로 별도 녹음</li>
</ul>

<p>나는 <strong>Individual Mode</strong>를 선택했다. 추후 각 사용자의 음성을 따로 분석할 수도 있고, 더 유연하기 때문이다.</p>

<h2 id="2-구현-과정에서-만난-문제들">2. 구현 과정에서 만난 문제들</h2>

<h3 id="21-비동기-처리-설정-문제">2.1. 비동기 처리 설정 문제</h3>

<p>녹음 시작/중지는 시간이 걸리는 작업이기 때문에 비동기로 처리해야 했다. 그런데 Spring에서 이런 경고가 떴다:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>More than one TaskExecutor bean found within the context,
and none is named <span class="s1">'taskExecutor'</span>
</code></pre></div></div>

<p><strong>문제:</strong></p>

<p><code class="language-plaintext highlighter-rouge">@Async</code>만 쓰면 Spring이 <code class="language-plaintext highlighter-rouge">SimpleAsyncTaskExecutor</code>를 사용한다. 이는 매번 새 스레드를 생성하기 때문에 매우 비효율적이다.</p>

<p>내 경우, 애플리케이션 컨텍스트에 이미 여러 개의 <code class="language-plaintext highlighter-rouge">TaskExecutor</code> 빈이 존재했는데 (<code class="language-plaintext highlighter-rouge">recordingTaskExecutor</code>, <code class="language-plaintext highlighter-rouge">matchingTaskExecutor</code> 등), 어느 것도 <code class="language-plaintext highlighter-rouge">taskExecutor</code>라는 이름을 가지고 있지 않았다. Executor를 지정하지 않고 <code class="language-plaintext highlighter-rouge">@Async</code>만 작성하니 Spring에서 경고를 보냈다.</p>

<p><strong>해결:</strong></p>

<p>용도별로 Executor를 분리하고, 기본 <code class="language-plaintext highlighter-rouge">taskExecutor</code>를 명시적으로 지정했다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableAsync</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsyncConfig</span> <span class="kd">implements</span> <span class="nc">AsyncConfigurer</span> <span class="o">{</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"taskExecutor"</span><span class="o">)</span>
    <span class="nd">@Primary</span>
    <span class="kd">public</span> <span class="nc">Executor</span> <span class="nf">taskExecutor</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ThreadPoolTaskExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolTaskExecutor</span><span class="o">();</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setCorePoolSize</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setMaxPoolSize</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setQueueCapacity</span><span class="o">(</span><span class="mi">25</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setThreadNamePrefix</span><span class="o">(</span><span class="s">"Async-"</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">executor</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"recordingTaskExecutor"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Executor</span> <span class="nf">recordingTaskExecutor</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ThreadPoolTaskExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolTaskExecutor</span><span class="o">();</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setCorePoolSize</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setMaxPoolSize</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setQueueCapacity</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setThreadNamePrefix</span><span class="o">(</span><span class="s">"Recording-"</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">executor</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 하면 스레드 풀을 재사용해서 성능이 훨씬 좋아진다:</p>

<ul>
  <li>스레드 생성 비용: ~1-2ms → ~0.01ms</li>
  <li>리소스 제한: 무제한 → 최대 5개로 제어</li>
</ul>

<h3 id="22-firebase-storage-저장-실패">2.2. Firebase Storage 저장 실패</h3>

<p>드디어 녹음이 시작되었다! 로그에도 성공 메시지가 떴다. 그런데 Firebase Storage를 확인해보니… 파일이 없었다. 😱</p>

<p><strong>문제의 핵심: <code class="language-plaintext highlighter-rouge">uploadingStatus=backuped</code></strong></p>

<p><code class="language-plaintext highlighter-rouge">uploadingStatus</code>에는 두 가지 값이 있다:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">uploaded</code></strong>: 제3자 스토리지(Firebase)에 업로드 성공</li>
  <li><strong><code class="language-plaintext highlighter-rouge">backuped</code></strong>: Agora 자체 백업 서버에 저장 (24시간 후 삭제)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">backuped</code>가 나왔다는 건 Firebase에 업로드가 실패했다는 의미였다.</p>

<p><strong>원인: HMAC 키가 없었다!</strong></p>

<p>Agora가 GCS(Google Cloud Storage)에 파일을 올리려면 <strong>HMAC 인증 키</strong>가 필요하다. Firebase Console → Storage → Settings → Interoperability를 확인해보니 아무것도 없었다.</p>

<p><strong>해결 과정:</strong></p>

<ol>
  <li>
    <p><strong>Google Cloud Console 접속</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cloud Console → Storage → Settings → Interoperability
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>HMAC 키 생성</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Service account HMAC 섹션
→ Create a key for a service account
→ firebase-adminsdk-xxxxx@프로젝트명.iam.gserviceaccount.com 선택
→ CREATE KEY
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Access Key와 Secret 복사</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Access Key: GOOG1E...로 시작하는 긴 문자열
Secret: 한 번만 보여주니 즉시 복사!
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>application.yml 설정</strong></p>
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">app</span><span class="pi">:</span>
  <span class="na">agora</span><span class="pi">:</span>
    <span class="na">recording-region</span><span class="pi">:</span> <span class="m">0</span> <span class="c1"># GCS Multi-region US</span>
    <span class="na">recording-storage-vendor</span><span class="pi">:</span> <span class="s2">"</span><span class="s">6"</span> <span class="c1"># 6 = GCS</span>
    <span class="na">recording-storage-bucket</span><span class="pi">:</span> <span class="s">프로젝트명.appspot.com</span>
    <span class="na">recording-storage-access-key</span><span class="pi">:</span> <span class="s">${AGORA_STORAGE_ACCESS_KEY}</span>
    <span class="na">recording-storage-secret-key</span><span class="pi">:</span> <span class="s">${AGORA_STORAGE_SECRET_KEY}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>이렇게 설정하고 다시 녹음을 시작했더니… 드디어 성공! 🎉</p>

<h2 id="3-최종-구조">3. 최종 구조</h2>

<p>모든 삽질을 마치고 완성된 구조는 다음과 같다:</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-24-pic1.png?raw=true" alt="이미지1" /></p>

<h3 id="31-주요-특징">3.1. 주요 특징</h3>

<ol>
  <li><strong>Individual Recording Mode</strong>: 각 사용자별로 별도 녹음</li>
  <li><strong>Audio Only</strong>: 비용 절감 (비디오 없음)</li>
  <li><strong>자동 업로드</strong>: Agora → Firebase Storage 직접 저장</li>
  <li><strong>파일 구조화</strong>: 날짜/Call ID별 폴더 정리</li>
  <li><strong>비동기 처리</strong>: 녹음 시작/중지가 메인 스레드를 블로킹하지 않음</li>
</ol>

<h2 id="4-배운-점">4. 배운 점</h2>

<h3 id="41-공식-문서를-꼼꼼히-읽자">4.1. 공식 문서를 꼼꼼히 읽자</h3>

<p>Agora 공식 문서에 Individual Mode와 Composite Mode의 차이가 명확하게 나와 있었다. 처음부터 제대로 읽었으면 불필요한 시행착오를 줄일 수 있었을 것이다.</p>

<h3 id="42-클라우드-서비스는-인증이-핵심">4.2. 클라우드 서비스는 인증이 핵심</h3>

<p>Firebase Storage에 파일이 안 올라가는 이유가 HMAC 키 때문이었다. 클라우드 간 연동에서는 항상 <strong>인증 설정을 먼저 확인</strong>해야 한다.</p>

<h3 id="43-비동기-처리는-제대로-설정하자">4.3. 비동기 처리는 제대로 설정하자</h3>

<p><code class="language-plaintext highlighter-rouge">@Async</code>만 쓰고 넘어가면 안 된다. 제대로 된 <code class="language-plaintext highlighter-rouge">ThreadPoolTaskExecutor</code>를 설정해야 운영에서 안정적이다.</p>

<h2 id="5-운영-지표">5. 운영 지표</h2>

<p>현재 운영 중인 시스템의 주요 지표:</p>

<ul>
  <li><strong>녹음 시작 시간</strong>: 평균 2-3초</li>
  <li><strong>파일 업로드</strong>: Agora가 자동 처리 (15초마다)</li>
  <li><strong>DB 저장</strong>: 비동기 처리로 메인 로직에 영향 없음</li>
  <li><strong>스레드 풀</strong>: 최대 5개 스레드로 제한되어 안정적</li>
</ul>

<p><strong>비용 최적화:</strong></p>

<ul>
  <li>Audio Only로 비디오 대비 비용 1/5 수준</li>
  <li>maxIdleTime 설정으로 30초 무음 시 자동 종료</li>
  <li>streamMode: standard (Agora 권장)</li>
</ul>

<h2 id="6-마치며">6. 마치며</h2>

<p>처음엔 “그냥 녹음만 하면 되는 거 아니야?”라고 쉽게 생각했는데, 실제로는 정말 많은 함정이 있었다:</p>

<ul>
  <li>Individual vs Composite Mode 이해</li>
  <li>HMAC 키 설정</li>
  <li>비동기 처리 구성</li>
  <li>에러 핸들링</li>
</ul>

<p>하나하나 해결하면서 많이 배웠다. 특히 클라우드 서비스 간 연동에서 <strong>인증과 권한 설정</strong>이 얼마나 중요한지 깨달았다.</p>

<p>이 글이 Agora Cloud Recording과 Firebase Storage를 연동하려는 누군가에게 도움이 되었으면 좋겠다. 😅</p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://docs.agora.io/en/cloud-recording/develop/individual-mode">Agora Individual Recording 공식 문서</a></li>
  <li><a href="https://docs.agora.io/en/cloud-recording/reference/region-vendor">Agora Cloud Storage 설정</a></li>
  <li><a href="https://cloud.google.com/storage/docs/authentication/hmackeys">Google Cloud HMAC 키 생성</a></li>
  <li><a href="https://spring.io/guides/gs/async-method">Spring Async 설정</a></li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Agora Cloud Recording을 통한 통화 녹음과 이를 Firebase Storage에 저장하는 기능을 구현하면서 경험한 것과 느낀 점을 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor 앱 Custom Splash Screen 구현하기</title><link href="https://nan0silver.github.io/projectdiary/2025-11-20-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor 앱 Custom Splash Screen 구현하기" /><published>2025-11-20T00:00:00+00:00</published><updated>2025-12-29T09:31:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-20-diary/"><![CDATA[<ul>
  <li>이번 포스팅에선 Capacitor로 빌드한 앱에서 여러 아이콘이 순차적으로 표시되는 커스텀 스플래시 스크린을 구현하는 방법을 정리했다.</li>
  <li>왜 Custom splash screen이 필요했나?
    <ul>
      <li>Capacitor의 기본 splash screen은 단일 정적 이미지만 지원한다.<a href="https://capacitorjs.com/docs/apis/splash-screen">🔗링크</a></li>
      <li>나는 여러 아이콘을 순차적으로 보여주는 애니메이션을 구현하고 싶어 React 컴포넌트로 직접 구현하였다!</li>
    </ul>
  </li>
</ul>

<h2 id="목차">목차</h2>

<ul>
  <li><a href="#1-필요한-패키지-설치">1. 필요한 패키지 설치</a></li>
  <li><a href="#2-capacitor-설정">2. Capacitor 설정</a></li>
  <li><a href="#3-커스텀-스플래시-스크린-컴포넌트-생성">3. 커스텀 스플래시 스크린 컴포넌트 생성</a></li>
  <li><a href="#4-apptsx에-통합">4. App.tsx에 통합</a></li>
  <li><a href="#핵심-구현-포인트">핵심 구현 포인트</a></li>
  <li><a href="#주의사항">주의사항</a></li>
  <li><a href="#참고-문헌">참고 문헌</a></li>
</ul>

<hr />

<h2 id="1-필요한-패키지-설치">1. 필요한 패키지 설치</h2>

<p>먼저 스플래시 스크린 관련 패키지를 설치하자.</p>

<blockquote>
  <p>나는 pnpm을 사용하고 있었으므로 pnpm으로 설치했다.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pnpm add @capacitor/splash-screen
pnpm add <span class="nt">-D</span> @capacitor/assets
</code></pre></div></div>

<h2 id="2-capacitor-설정">2. Capacitor 설정</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">capacitor.config.ts</code> 파일에 스플래시 스크린 설정을 추가하자.</li>
  <li>‼️ 커스텀 스플래시를 사용하므로 네이티브 스플래시는 최소화!</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// &lt;reference types="@capacitor/splash-screen" /&gt;</span>

<span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">CapacitorConfig</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@capacitor/cli</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">config</span><span class="p">:</span> <span class="nx">CapacitorConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ... 기타 설정</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">SplashScreen</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">launchShowDuration</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// 커스텀 스플래시를 사용하므로 0으로 설정</span>
      <span class="na">launchAutoHide</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 자동으로 숨길지 여부</span>
      <span class="na">launchFadeOutDuration</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// 페이드 아웃 애니메이션 시간 (커스텀 스플래시에서 처리)</span>
      <span class="na">backgroundColor</span><span class="p">:</span> <span class="dl">"</span><span class="s2">#ffffff</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 배경색 (hex 형식) - 커스텀 스플래시와 동일하게 설정</span>
      <span class="c1">// ... 기타 설정</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">config</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="3-커스텀-스플래시-스크린-컴포넌트-생성">3. 커스텀 스플래시 스크린 컴포넌트 생성</h2>

<p><code class="language-plaintext highlighter-rouge">client/components/CustomSplashScreen.tsx</code> 파일을 생성한다.</p>

<h3 id="props-정의">Props 정의</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">CustomSplashScreenProps</span> <span class="p">{</span>
  <span class="nl">onComplete</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span> <span class="c1">// 스플래시 완료 시 콜백</span>
  <span class="nl">icons</span><span class="p">?:</span> <span class="kr">string</span><span class="p">[];</span> <span class="c1">// 표시할 아이콘 배열</span>
  <span class="nl">iconDuration</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// 각 아이콘 표시 시간(ms)</span>
  <span class="nl">minDisplayDuration</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// 최소 표시 시간(ms)</span>
  <span class="nl">animationType</span><span class="p">?:</span> <span class="dl">"</span><span class="s2">slide-up</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">fade</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">none</span><span class="dl">"</span><span class="p">;</span>
  <span class="nl">backgroundColor</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="핵심-로직">핵심 로직</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">CustomSplashScreen</span> <span class="o">=</span> <span class="p">({</span>
  <span class="nx">onComplete</span><span class="p">,</span>
  <span class="nx">icons</span> <span class="o">=</span> <span class="p">[],</span>
  <span class="nx">iconDuration</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
  <span class="nx">minDisplayDuration</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
  <span class="nx">animationType</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">slide-up</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">backgroundColor</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">#ffffff</span><span class="dl">"</span><span class="p">,</span>
<span class="p">}:</span> <span class="nx">CustomSplashScreenProps</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">currentIconIndex</span><span class="p">,</span> <span class="nx">setCurrentIconIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">isVisible</span><span class="p">,</span> <span class="nx">setIsVisible</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

  <span class="c1">// 1. 네이티브 스플래시 스크린 즉시 숨기기</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">hideNativeSplash</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="k">await</span> <span class="nx">SplashScreen</span><span class="p">.</span><span class="nx">hide</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 웹 환경에서는 에러가 발생할 수 있으므로 무시</span>
      <span class="p">}</span>
    <span class="p">};</span>
    <span class="nx">hideNativeSplash</span><span class="p">();</span>
  <span class="p">},</span> <span class="p">[]);</span>

  <span class="c1">// 2. 아이콘 순차 표시 로직</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">icons</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">setIsVisible</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">onComplete</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
      <span class="p">},</span> <span class="nx">minDisplayDuration</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 아이콘 전환 인터벌</span>
    <span class="kd">const</span> <span class="nx">iconInterval</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setCurrentIconIndex</span><span class="p">((</span><span class="nx">prev</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">prev</span> <span class="o">&lt;</span> <span class="nx">icons</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">prev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">prev</span><span class="p">;</span>
      <span class="p">});</span>
    <span class="p">},</span> <span class="nx">iconDuration</span><span class="p">);</span>

    <span class="c1">// 총 표시 시간 계산</span>
    <span class="kd">const</span> <span class="nx">totalAnimationDuration</span> <span class="o">=</span> <span class="nx">icons</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="nx">iconDuration</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">actualDuration</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">totalAnimationDuration</span><span class="p">,</span> <span class="nx">minDisplayDuration</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">completeTimer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setIsVisible</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
      <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">onComplete</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
    <span class="p">},</span> <span class="nx">actualDuration</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">iconInterval</span><span class="p">);</span>
      <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">completeTimer</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">},</span> <span class="p">[</span><span class="nx">icons</span><span class="p">,</span> <span class="nx">iconDuration</span><span class="p">,</span> <span class="nx">minDisplayDuration</span><span class="p">,</span> <span class="nx">onComplete</span><span class="p">]);</span>

  <span class="c1">// ... 렌더링 로직</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li>아이콘 슬라이드 애니메이션과 텍스트 추가 등 개인의 디자인에 맞게 React 코드를 수정해서 꾸며주면 된다!!</li>
</ul>

<h2 id="4-apptsx에-통합">4. App.tsx에 통합</h2>

<p>메인 앱 컴포넌트에 커스텀 스플래시 스크린을 통합합니다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">CustomSplashScreen</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./components/CustomSplashScreen</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">AppRoutes</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">showSplash</span><span class="p">,</span> <span class="nx">setShowSplash</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

  <span class="c1">// 스플래시 스크린에 표시할 아이콘들</span>
  <span class="kd">const</span> <span class="nx">splashIcons</span> <span class="o">=</span> <span class="p">[</span>
    <span class="dl">"</span><span class="s2">/splash-icons/icon1.png</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">/splash-icons/icon2.png</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">/splash-icons/icon3.png</span><span class="dl">"</span><span class="p">,</span>
    <span class="c1">// ... 더 많은 아이콘</span>
  <span class="p">];</span>

  <span class="kd">const</span> <span class="nx">handleSplashComplete</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setShowSplash</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">showSplash</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">CustomSplashScreen</span>
        <span class="nx">onComplete</span><span class="o">=</span><span class="p">{</span><span class="nx">handleSplashComplete</span><span class="p">}</span>
        <span class="nx">icons</span><span class="o">=</span><span class="p">{</span><span class="nx">splashIcons</span><span class="p">}</span>
        <span class="nx">iconDuration</span><span class="o">=</span><span class="p">{</span><span class="mi">400</span><span class="p">}</span>
        <span class="nx">minDisplayDuration</span><span class="o">=</span><span class="p">{</span><span class="mi">2000</span><span class="p">}</span>
        <span class="nx">animationType</span><span class="o">=</span><span class="dl">"</span><span class="s2">slide-up</span><span class="dl">"</span>
      <span class="o">/&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ... 나머지 앱 로직</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="-핵심-구현-포인트-">🍎 핵심 구현 포인트 🍎</h2>

<h3 id="1-네이티브-스플래시와-커스텀-스플래시-분리">1. 네이티브 스플래시와 커스텀 스플래시 분리</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">launchShowDuration: 0</code>으로 설정하여 네이티브 스플래시를 즉시 숨김</li>
  <li><code class="language-plaintext highlighter-rouge">SplashScreen.hide()</code>를 컴포넌트 마운트 시 호출</li>
</ul>

<h3 id="2-텍스트-깜빡임-방지">2. 텍스트 깜빡임 방지</h3>

<p>아이콘과 텍스트를 별도의 <code class="language-plaintext highlighter-rouge">div</code>로 렌더링하여 아이콘이 변경될 때 텍스트가 깜빡이지 않도록 구현</p>

<h3 id="3-부드러운-애니메이션">3. 부드러운 애니메이션</h3>

<p>CSS <code class="language-plaintext highlighter-rouge">transition</code>과 <code class="language-plaintext highlighter-rouge">cubic-bezier</code> 타이밍 함수를 사용하여 자연스러운 전환 효과 구현</p>

<h3 id="4-최소-표시-시간-보장">4. 최소 표시 시간 보장</h3>

<p><code class="language-plaintext highlighter-rouge">minDisplayDuration</code>을 설정하여 애니메이션이 너무 빨리 끝나도 최소 시간은 보장</p>

<h3 id="5-이미지-준비">5. 이미지 준비</h3>

<p>아이콘 이미지는 <code class="language-plaintext highlighter-rouge">public/splash-icons/</code> 디렉토리에 저장합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public/
  splash-icons/
    icon1.png
    icon2.png
    icon3.png
</code></pre></div></div>

<h2 id="️-주의사항">‼️ 주의사항</h2>

<ul>
  <li>이미지는 반드시 <code class="language-plaintext highlighter-rouge">public</code> 폴더에 저장 (빌드 시 자동 포함)</li>
  <li>웹 환경에서는 <code class="language-plaintext highlighter-rouge">SplashScreen.hide()</code>가 에러를 발생시킬 수 있으므로 try-catch 처리 필요</li>
  <li>Android 12 이상에서는 네이티브 스플래시 API가 강제 적용되므로 초기 0.5초는 네이티브 스플래시가 보일 수 있음</li>
</ul>

<h2 id="-참고-문헌">🍀 참고 문헌</h2>

<ul>
  <li><a href="https://github.com/ionic-team/capacitor-assets">Capacitor assets github page</a></li>
  <li><a href="https://capacitorjs.com/docs/apis/splash-screen">@capacitor/splash-screen DOCS</a></li>
  <li><a href="https://capacitorjs.com/docs/guides/splash-screens-and-icons">Splash Screens and Icons DOCS</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 앱에서 Splash Screen을 React로 직접 구현한 내용에 대해 다룹니다.]]></summary></entry><entry><title type="html">[친구하자] SockJS Transport와 JSONP: 2025년에 만난 레거시 기술</title><link href="https://nan0silver.github.io/projectdiary/2025-11-18-diary/" rel="alternate" type="text/html" title="[친구하자] SockJS Transport와 JSONP: 2025년에 만난 레거시 기술" /><published>2025-11-18T00:00:00+00:00</published><updated>2025-12-29T09:31:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-18-diary/"><![CDATA[<ul>
  <li>이번 포스팅에서는 Capacitor로 빌드한 Android 앱에서 WebSocket 통신 중 발생한 JSONP 에러에 대해 다루었다.</li>
  <li>해결하는 과정에서 공부한 내용에 대해 정리해보았다.</li>
</ul>

<h2 id="목차">목차</h2>

<ul>
  <li><a href="#들어가며">들어가며</a></li>
  <li><a href="#문제-상황">문제 상황</a></li>
  <li><a href="#jsonp란-무엇인가">JSONP란 무엇인가?</a></li>
  <li><a href="#sockjs에서-jsonp가-필요했던-이유">SockJS에서 JSONP가 필요했던 이유</a></li>
  <li><a href="#왜-현대-웹에서는-사용하지-않는가">왜 현대 웹에서는 사용하지 않는가?</a></li>
  <li><a href="#내-프로젝트에서의-문제">내 프로젝트에서의 문제</a></li>
  <li><a href="#해결-방법">해결 방법</a></li>
  <li><a href="#교훈">결론</a></li>
  <li><a href="#참고-자료">참고 자료</a></li>
</ul>

<h2 id="들어가며">들어가며</h2>

<p>Capacitor 기반 Android 앱에서 WebSocket 연결을 구현하던 중, 예상치 못한 에러를 만났다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❌ Refused to execute script from 'https://silverld.site/ws/270/s4swngca/jsonp?c=_jp.a050t2f'
   because its MIME type ('') is not executable
</code></pre></div></div>

<p>JSONP? 분명 WebSocket을 사용하고 있는데 왜 갑자기 JSONP가 등장했을까?</p>

<hr />

<h2 id="문제-상황">문제 상황</h2>

<p>로그를 분석해보니 SockJS가 다음과 같은 순서로 연결을 시도하고 있었다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. WebSocket → 실패
2. xhr-streaming → 응답 없음
3. xhr-polling → 부분 성공
4. jsonp → MIME type 에러 발생!
5. Connection closed → 5초 후 재연결 시도
</code></pre></div></div>

<p>WebSocket 연결이 실패하자 SockJS가 <strong>fallback 메커니즘</strong>을 통해 JSONP까지 시도한 것이었다.</p>

<hr />

<h2 id="jsonp란-무엇인가">JSONP란 무엇인가?</h2>

<h3 id="탄생-배경">탄생 배경</h3>

<p>JSONP(JSON with Padding)는 <strong>2000년대 중반</strong>, CORS가 표준화되기 전에 등장한 크로스 도메인 통신 기법이다.</p>

<p>당시 웹 개발자들은 <strong>같은 출처 정책(Same-Origin Policy)</strong> 때문에 다른 도메인의 데이터를 가져올 수 없었다:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ 다른 도메인 AJAX 요청 → 차단됨</span>
<span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://api.example.com/data</span><span class="dl">"</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">());</span>
<span class="c1">// Error: CORS policy 위반!</span>
</code></pre></div></div>

<h3 id="작동-원리">작동 원리</h3>

<p>JSONP는 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 태그가 <strong>CORS 제약을 받지 않는다</strong>는 점을 활용한다:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- ✅ script 태그는 다른 도메인 로드 가능 --&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://api.example.com/data?callback=handleData"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div>

<p><strong>서버 응답:</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">handleData</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
<span class="p">});</span>
</code></pre></div></div>

<p><strong>클라이언트에서 미리 정의:</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">handleData</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="c1">// { name: "John", age: 30 }</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 서버가 <strong>콜백 함수로 데이터를 감싸서</strong> 반환하면, 브라우저가 이를 실행하면서 데이터를 전달받는 방식이다.</p>

<hr />

<h2 id="sockjs에서-jsonp가-필요했던-이유">SockJS에서 JSONP가 필요했던 이유</h2>

<p><strong>SockJS</strong>는 WebSocket을 지원하지 않는 구형 브라우저(IE8/9 등)를 위한 라이브러리이다.</p>

<p>실시간 양방향 통신을 보장하기 위해 다양한 fallback 전략을 사용한다:</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-18-pic1.png?raw=true" alt="이미지1" /></p>

<p>JSONP는 <strong>가장 오래된 브라우저도 지원</strong>하기 위한 최후의 수단!</p>

<hr />

<h2 id="왜-현대-웹에서는-사용하지-않는가">왜 현대 웹에서는 사용하지 않는가?</h2>

<h3 id="1-cors의-등장">1. CORS의 등장</h3>

<p>2014년 CORS(Cross-Origin Resource Sharing)가 표준화되면서 안전하게 크로스 도메인 통신이 가능해졌다:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 현대적인 방법</span>
<span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://api.example.com/data</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// ✅ POST, PUT, DELETE 모두 가능</span>
  <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">),</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="2-보안-취약점">2. 보안 취약점</h3>

<p>JSONP는 심각한 보안 문제를 갖고 있다:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ XSS 공격에 취약</span>
<span class="o">&lt;</span><span class="nx">script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://malicious.com/data?callback=alert('hacked!')</span><span class="dl">"</span><span class="o">&gt;&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span>
<span class="c1">// ❌ CSRF 공격 가능 (GET 요청만 가능하므로)</span>
<span class="c1">// ❌ 인증 토큰 노출 위험</span>
</code></pre></div></div>

<h3 id="3-기능-제한">3. 기능 제한</h3>

<ul>
  <li><strong>GET 요청만 가능</strong> (POST, PUT, DELETE 불가)</li>
  <li><strong>에러 핸들링 어려움</strong> (HTTP 상태 코드 확인 불가)</li>
  <li><strong>타임아웃 제어 어려움</strong></li>
</ul>

<hr />

<h2 id="내-프로젝트에서의-문제">내 프로젝트에서의 문제</h2>

<p>Capacitor 앱에서 WebSocket 연결이 실패하자, SockJS가 JSONP까지 fallback을 시도했다.</p>

<p>하지만 백엔드(Spring Boot)가 <strong>JSONP 응답에 올바른 MIME type 헤더를 보내지 않아</strong> 브라우저가 스크립트 실행을 거부한 것이다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❌ MIME type ('') is not executable
</code></pre></div></div>

<p><strong>근본 원인:</strong></p>

<ul>
  <li>Capacitor 앱에서는 JSONP가 <strong>전혀 필요 없음</strong> (최신 WebView 사용)</li>
  <li>하지만 SockJS가 기본 설정으로 JSONP를 포함하고 있었음</li>
</ul>

<hr />

<h2 id="해결-방법">해결 방법</h2>

<p>SockJS 초기화 시 <strong>사용할 transport를 명시적으로 제한</strong>했다:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">sockJSOptions</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">transports</span><span class="p">:</span> <span class="p">[</span>
    <span class="dl">"</span><span class="s2">websocket</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 최우선</span>
    <span class="dl">"</span><span class="s2">xhr-streaming</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 2순위</span>
    <span class="dl">"</span><span class="s2">xhr-polling</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 3순위</span>
    <span class="c1">// 'jsonp' 제거! (레거시 transport)</span>
  <span class="p">],</span>
  <span class="na">timeout</span><span class="p">:</span> <span class="mi">20000</span><span class="p">,</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SockJS</span><span class="p">(</span><span class="nx">wsUrl</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">sockJSOptions</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>결과:</strong></p>

<ul>
  <li>✅ JSONP 에러 해결</li>
  <li>✅ 불필요한 fallback 시도 제거</li>
  <li>✅ 연결 속도 향상</li>
</ul>

<hr />

<h2 id="교훈">교훈</h2>

<ol>
  <li>
    <p><strong>레거시 코드는 예상치 못한 곳에 숨어있다</strong></p>

    <ul>
      <li>현대적인 라이브러리도 하위 호환성을 위해 오래된 기술을 포함</li>
    </ul>
  </li>
  <li>
    <p><strong>기본 설정을 맹신하지 말자</strong></p>

    <ul>
      <li>SockJS의 기본 transport 설정은 IE8 시대의 유산</li>
      <li>현대 환경에 맞게 커스터마이징 필요</li>
    </ul>
  </li>
  <li>
    <p><strong>프레임워크의 동작 방식을 이해하자</strong></p>
    <ul>
      <li>“왜 WebSocket을 쓰는데 JSONP가?”라는 의문</li>
      <li>Fallback 메커니즘을 이해하니 해결 방법도 명확해짐</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="마치며">마치며</h2>

<p>JSONP 에러를 처음 마주했다. 하지만 웹의 역사를 이해하고, 현대 기술이 어떻게 발전해왔는지 공부하는 좋은 기회가 되었다.</p>

<p>여러분의 프로젝트에서도 SockJS를 사용한다면, transport 설정을 확인해보시길 추천합니다!
불필요한 레거시 코드를 제거하면 성능과 안정성 모두 향상될 수 있습니다.😊</p>

<hr />

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">SockJS Protocol</a></li>
  <li><a href="https://en.wikipedia.org/wiki/JSONP">JSONP의 작동 원리와 보안 이슈</a></li>
  <li><a href="https://stackoverflow.com/questions/2067472/what-is-jsonp-and-why-was-it-created">CORS vs JSONP</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 Android 앱에서의 웹소켓 오류 중 X-Frame-Options 에러 트러블슈팅을 다룹니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor Android 앱 X-Frame-Options 에러 해결</title><link href="https://nan0silver.github.io/projectdiary/2025-11-17-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor Android 앱 X-Frame-Options 에러 해결" /><published>2025-11-17T00:00:00+00:00</published><updated>2025-12-29T09:31:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-17-diary/"><![CDATA[<ul>
  <li>이번 포스팅에서는 Capacitor로 빌드한 Android 앱에서 WebSocket 통신 중 발생한 X-Frame-Options 에러에 대해 다루었다.</li>
  <li>해결하는 과정에서 공부한 내용에 대해 정리해보았다.</li>
</ul>

<h2 id="문제-상황">문제 상황</h2>

<ul>
  <li>웹에서는 정상적으로 작동하던 <strong>매칭 완료 -&gt; WebSocket 메시지 수신 -&gt; 통화 시작 페이지 이동</strong> 로직이 Android 앱에서 다음과 같은 에러로 실패했다.</li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-17-pic1.png?raw=true" alt="에러 이미지1" /></p>

<ul>
  <li>🔥 이 문제는 <strong>Capacitor의 WebView 환경과 Spring Security의 기본 보안 설정이 충돌</strong>하면서 발생! 🔥</li>
  <li>WebSocket 라이브러리인 SockJS가 fallback 메커니즘으로 iframe을 사용하려 했지만, 서버가 보안상의 이유로 이를 차단했기 때문이다.</li>
  <li>이 글에서는 X-Frame-Options가 무엇인지, iframe이 무엇인지, 그리고 왜 이런 에러가 발생햇는지를 자세히 알아보겠습니다.</li>
</ul>

<h2 id="1-iframe-이란">1. iframe 이란?</h2>

<ul>
  <li><strong>iframe (inline frame)</strong>은 HTML 문서 안에서 다른 HTML 문서를 삽입하는 태그이다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- 예시: 유튜브 영상 삽입 --&gt;
&lt;iframe
    src="https://www.youtube.com/embed/VIDEO_ID"
    width="560"
    height="315"&gt;
&lt;/iframe&gt;
</code></pre></div></div>

<p><strong>시각적 구조:</strong>
<img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-17-pic2.png?raw=true" alt="설명 이미지1" /></p>

<ul>
  <li>실생활 예시 : 유튜브 영상 삽입, 구글 지도 삽입, 페이스북 “좋아요” 버튼 등</li>
</ul>

<h2 id="2-x-frame-options-이란">2. X-Frame-Options 이란?</h2>

<ul>
  <li>
    <p><strong>X-Frame-Options</strong>는 HTTP 응답 헤더로, 내 웹사이트가 다른 사이트의 iframe안에 표시되는 것을 제어하는 보안 메커니즘</p>
  </li>
  <li>
    <p>헤더 값 3가지:</p>
    <ul>
      <li>X-Frame-Options: DENY
        <ul>
          <li>어떤 사이트든 iframe으로 내 페이지를 로드할 수 없음</li>
        </ul>
      </li>
      <li>X-Frame-Options: SAMEORIGIN
        <ul>
          <li>같은 도메인에서만 iframe으로 로드 가능</li>
        </ul>
      </li>
      <li>X-Frame-Options: ALLOW-FROM https://example.com
        <ul>
          <li>특정 도메인에서만 iframe으로 로드 가능 (deprecated)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="왜-x-frame-options가-필요한가">왜 X-Frame-Options가 필요한가?</h3>

<ul>
  <li><strong>Clickjacking 공격 방지</strong>
    <ul>
      <li>악의적인 사이트가 투명한 iframe을 통해 사용자를 속여 원하지 않는 행동을 하게 만드는 공격</li>
    </ul>
  </li>
</ul>

<p><strong>공격 시나리오:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 공격자가 악의적인 사이트 만들기 (evil.com)

2. 투명한 iframe으로 은행 사이트를 숨김
   ┌─────────────────────────────────┐
   │ evil.com                        │
   │                                 │
   │ [무료 iPhone 받기!] 버튼           │
   │        ↑                        │
   │        실제로는 투명한 iframe       │
   │        은행 송금 버튼이 위치         │
   └─────────────────────────────────┘

3. 사용자가 "무료 iPhone 받기!" 클릭
   → 실제로는 은행의 "송금 승인" 버튼 클릭
   → 돈이 공격자에게 전송됨 🥲
</code></pre></div></div>

<p><strong>X-Frame-Options: DENY가 막는 방법:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────────────────────┐
│ evil.com                        │
│                                 │
│ &lt;iframe src="bank.com"&gt;         │
│   ❌ 브라우저가 로드 거부!           │
│   "X-Frame-Options: DENY"       │
│ &lt;/iframe&gt;                       │
└─────────────────────────────────┘
</code></pre></div></div>

<h2 id="️-capacitor로-빌드한-앱에서-이-문제가-발생한-이유">‼️ Capacitor로 빌드한 앱에서 이 문제가 발생한 이유</h2>

<ul>
  <li>Capacitor는 <strong>하이브리드 앱</strong>을 만드는 프레임워크이다.</li>
</ul>

<p><strong>하이브리드 앱 구조</strong>
<img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-17-pic3.png?raw=true" alt="설명 이미지2" /></p>

<ul>
  <li>WebView는 본질적으로 iframe과 유사하다!</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>네이티브 앱 (Android/iOS)
    └── WebView ≈ iframe
         └── React 앱 (https://localhost)
              └── WebSocket 연결 시도 → 백엔드 (https://backend.domain)
</code></pre></div></div>

<h3 id="sockjs의-iframe-transport"><strong>SockJS의 iframe Transport</strong></h3>

<p><strong>SockJS</strong>는 WebSocket이 안 될 때를 대비한 여러 fallback 방법을 제공한다.</p>

<p><strong>SockJS Transport 순서:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. WebSocket (가장 빠르고 효율적)
   ↓ 실패
2. xhr-streaming (HTTP 스트리밍)
   ↓ 실패
3. xhr-polling (HTTP 폴링)
   ↓ 실패
4. iframe-based transports (레거시 브라우저용)
   ↓ 실패
5. jsonp-polling (최후의 수단)
</code></pre></div></div>

<ul>
  <li>iframe-based transport가 하는 일:</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- SockJS가 내부적으로 생성하는 숨겨진 iframe --&gt;</span>
<span class="nt">&lt;iframe</span> <span class="na">src=</span><span class="s">"https://backend.domain/ws/iframe.html"</span> <span class="na">style=</span><span class="s">"display: none;"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/iframe&gt;</span>
</code></pre></div></div>

<h3 id="문제-발생-시나리오"><strong>문제 발생 시나리오:</strong></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Capacitor 앱 (WebView) 시작
   Origin: capacitor://localhost

2. WebSocket 연결 시도 (친구하자 프로젝트의 경우, 통화 매칭시 사용 중)
   → https://backend.domain/ws

3. SockJS가 iframe transport 시도
   ┌─────────────────────────────────┐
   │ Capacitor WebView               │
   │ (capacitor://localhost)         │
   │                                 │
   │ &lt;iframe src="backend.domain/ws"&gt; │
   │   ❌ 차단됨!                     │
   │   "X-Frame-Options: DENY"       │
   │ &lt;/iframe&gt;                       │
   └─────────────────────────────────┘

4. 에러 메시지:
   "Refused to display 'https://backend.domain/'
    in a frame because it set 'X-Frame-Options' to 'deny'"
</code></pre></div></div>

<h3 id="왜-spring-security가-기본적으로-deny를-설정할까">왜 Spring Security가 기본적으로 Deny를 설정할까?</h3>

<ul>
  <li>Spring Security의 보안 우선 철학 :
<img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-17-pic4.png?raw=true" alt="설명 이미지3" /></li>
</ul>

<p><strong>이유</strong></p>

<ol>
  <li><strong>보안 우선주의</strong>: 안전하지 않은 것보다 안전한 것이 낫다</li>
  <li><strong>Clickjacking 방지</strong>: 대부분의 웹 애플리케이션은 iframe에 로드될 필요 없음</li>
  <li><strong>명시적 허용</strong>: 개발자가 필요하면 명시적으로 변경하도록 유도</li>
</ol>

<p><strong>일반적인 웹사이트는 DENY가 맞다:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>은행, 쇼핑몰, 관리자 페이지 등
→ iframe에 로드될 이유가 없음
→ DENY로 보안 강화
</code></pre></div></div>

<p><strong>하지만 우리의 경우:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Capacitor 하이브리드 앱
→ WebView는 iframe과 유사한 환경
→ DENY면 앱 자체가 작동 안 함
→ SAMEORIGIN 또는 특정 origin 허용 필요
</code></pre></div></div>

<h2 id="해결-방법">해결 방법</h2>

<h3 id="방법-1-frameoptionssameorigin-운영-환경-권장">방법 1: frameOptions().sameOrigin() (운영 환경 권장)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">headers</span><span class="o">(</span><span class="n">headers</span> <span class="o">-&gt;</span> <span class="n">headers</span>
    <span class="o">.</span><span class="na">frameOptions</span><span class="o">(</span><span class="n">frameOptions</span> <span class="o">-&gt;</span> <span class="n">frameOptions</span><span class="o">.</span><span class="na">sameOrigin</span><span class="o">())</span>
<span class="o">)</span>
</code></pre></div></div>

<p><strong>의미:</strong></p>

<ul>
  <li>같은 도메인에서만 iframe 허용</li>
  <li><code class="language-plaintext highlighter-rouge">https://backend.domain</code>에서 <code class="language-plaintext highlighter-rouge">https://backend.domain</code>를 iframe으로 로드 가능</li>
  <li>Capacitor WebView는 <code class="language-plaintext highlighter-rouge">capacitor://localhost</code>이지만, WebView 자체가 특수 처리됨</li>
</ul>

<p><strong>왜 이게 Capacitor에서 작동하나?</strong>
WebView는 브라우저 엔진의 특수 모드
→ origin 검사가 일반 웹과 다르게 처리됨
→ SAMEORIGIN이어도 WebView 내부 컨텍스트에서는 허용</p>

<h3 id="방법-2-content-security-policy-추가-최고-보안">방법 2: Content-Security-Policy 추가 (최고 보안)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">headers</span><span class="o">(</span><span class="n">headers</span> <span class="o">-&gt;</span> <span class="n">headers</span>
    <span class="o">.</span><span class="na">frameOptions</span><span class="o">(</span><span class="n">frameOptions</span> <span class="o">-&gt;</span> <span class="n">frameOptions</span><span class="o">.</span><span class="na">sameOrigin</span><span class="o">())</span>
    <span class="o">.</span><span class="na">contentSecurityPolicy</span><span class="o">(</span><span class="n">csp</span> <span class="o">-&gt;</span> <span class="n">csp</span>
        <span class="o">.</span><span class="na">policyDirectives</span><span class="o">(</span><span class="s">"frame-ancestors 'self' capacitor://localhost http://localhost https://localhost"</span><span class="o">)</span>
    <span class="o">)</span>
<span class="o">)</span>
</code></pre></div></div>

<p><strong>의미:</strong></p>

<ul>
  <li>현대적인 보안 헤더 (X-Frame-Options의 후속)</li>
  <li>더 세밀한 제어 가능</li>
  <li>특정 origin만 명시적으로 허용</li>
</ul>

<h2 id="결론">결론</h2>

<ul>
  <li>Capacitor로 앱을 빌드한 다음에 웹에서는 발생하지 않는 에러들이 생겨서 찾아보고, 공부하고, 해결하는 재미가 있다.</li>
  <li>이제 통화연결까지 앱으로 수행할 수 있게 되었다!!</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 Android 앱에서의 웹소켓 오류 중 X-Frame-Options 에러 트러블슈팅을 다룹니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor 앱에서 Kakao/Google 네이티브 로그인 구현 정리</title><link href="https://nan0silver.github.io/projectdiary/2025-11-13-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor 앱에서 Kakao/Google 네이티브 로그인 구현 정리" /><published>2025-11-13T00:00:00+00:00</published><updated>2025-12-29T09:31:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-13-diary/"><![CDATA[<ul>
  <li>Capacitor로 빌드한 React 앱에서 카카오와 구글 네이티브 로그인을 구현하는 방법을 정리해 보았다.</li>
  <li>관련되서 정리되어있는게 없는것 같아서.. 내가 나중에 찾아볼 수 있게 일단 문서를 만들어보았다.</li>
  <li>웹에서는 일반 OAuth 리다이렉트를 사용하지만, 모바일 앱에서는 <strong>네이티브 SDK를 직접 사용</strong>하는 방식으로 구현했다. (kakao, google)
    <ul>
      <li>kakao developer에는 flutter문서에서 크로스 플랫폼에서는 커스텀 URL 스킴을 사용하라고 권장한다. 하지만 나는 플러그인을 사용하는 방식으로 구현해보았다.</li>
    </ul>
  </li>
</ul>

<h3 id="네이티브-sdk-직접-사용-구헌-방식-카카오-구글">네이티브 SDK 직접 사용 구헌 방식 (카카오, 구글)</h3>

<p><strong>네이티브 SDK 로그인 방식이란?</strong></p>

<ul>
  <li>카카오/구글이 제공하는 Android/iOS 전용 SDK를 사용한 로그인 방식</li>
  <li>앱 간 통신 방식을 사용한다.
    <ul>
      <li>즉, 기기에 설치된 카카오톡/구글 앱과 직접 통신하여 인증한다.</li>
    </ul>
  </li>
  <li>WebView를 우회하여 브라우저 리다이렉트 없이 앱 레벨에서 토큰을 교환한다.</li>
</ul>

<p><strong>이 방식이 하이브리드 앱에서 가능한 이유</strong></p>

<ul>
  <li>⭐️<strong>Capacitor의 플러그인 시스템</strong>⭐️이 핵심!</li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-13-pic1.png?raw=true" alt="설명 이미지1" /></p>

<ul>
  <li>WebView의 JavaScript 코드가 네이티브 코드를 호출할 수 있게 해줌</li>
  <li><code class="language-plaintext highlighter-rouge">KakaoLoginPlugin.goLogin()</code>을 통해 실제로 Android의 카카오 SDK 실행</li>
  <li>결과를 다시 JavaScript로 전달</li>
</ul>

<p>*<em>앱 구조 비교</em></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 안드로이드에서 실행 시</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">Capacitor</span><span class="p">.</span><span class="nx">isNativePlatform</span><span class="p">())</span> <span class="p">{</span>
  <span class="c1">// ✅ 네이티브 SDK 사용 (앱간 통신)</span>
  <span class="c1">// 카카오톡 앱 → 내 앱 (빠르고 안정적)</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">KakaoLoginPlugin</span><span class="p">.</span><span class="nx">goLogin</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 웹 브라우저에서 실행 시</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="c1">// ✅ OAuth 리다이렉트 사용 (브라우저 기반)</span>
  <span class="c1">// 브라우저 → 카카오 웹 → 콜백 URL</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">https://kauth.kakao.com/oauth/...</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>이렇게 하는 이유</strong></p>

<ul>
  <li>네이티브 로그인의 장점:
    <ul>
      <li>사용자가 카카오톡이 설치되어 있으면 앱 전환만으로 즉시 로그인</li>
      <li>브라우저 리다이렉트보다 UX가 훨씬 부드러움</li>
      <li>DeepLink, Custom URL Scheme 문제 없음</li>
    </ul>
  </li>
  <li>웹 로그인:
    <ul>
      <li>브라우저에서는 네이티브 SDK를 쓸 수 없으니 전통적인 OAuth 방식 사용</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="1-카카오-네이티브-로그인-구현">1. 카카오 네이티브 로그인 구현</h2>

<h3 id="11-플러그인-설치">1.1 플러그인 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pnpm add capacitor-kakao-login-plugin
npx cap <span class="nb">sync</span>
</code></pre></div></div>

<h3 id="12-android-설정">1.2 Android 설정</h3>

<h4 id="121-kakao-sdk-의존성-추가">1.2.1 Kakao SDK 의존성 추가</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/build.gradle</code>:</p>

<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">dependencies</span> <span class="o">{</span>
    <span class="c1">// ... 기존 의존성 ...</span>
    <span class="n">implementation</span> <span class="s2">"com.kakao.sdk:v2-common:2.20.1"</span>
    <span class="n">implementation</span> <span class="s2">"com.kakao.sdk:v2-auth:2.20.1"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">android/build.gradle</code>:</p>

<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">allprojects</span> <span class="o">{</span>
    <span class="k">repositories</span> <span class="o">{</span>
        <span class="n">google</span><span class="o">()</span>
        <span class="n">mavenCentral</span><span class="o">()</span>
        <span class="n">maven</span> <span class="o">{</span> <span class="n">url</span> <span class="s1">'https://devrepo.kakao.com/nexus/content/groups/public/'</span> <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="122-androidmanifestxml-설정">1.2.2 AndroidManifest.xml 설정</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/src/main/AndroidManifest.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;application&gt;</span>
    <span class="c">&lt;!-- 카카오 SDK 메타데이터 --&gt;</span>
    <span class="nt">&lt;meta-data</span>
        <span class="na">android:name=</span><span class="s">"com.kakao.sdk.AppKey"</span>
        <span class="na">android:value=</span><span class="s">"@string/kakao_app_key"</span> <span class="nt">/&gt;</span>

    <span class="nt">&lt;activity</span>
        <span class="na">android:name=</span><span class="s">".MainActivity"</span>
        <span class="na">android:exported=</span><span class="s">"true"</span><span class="nt">&gt;</span>
        <span class="c">&lt;!-- 카카오 로그인 리다이렉트 --&gt;</span>
        <span class="nt">&lt;intent-filter&gt;</span>
            <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">"android.intent.action.VIEW"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.DEFAULT"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.BROWSABLE"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;data</span> <span class="na">android:host=</span><span class="s">"kakaolink"</span> <span class="na">android:scheme=</span><span class="s">"@string/kakao_scheme"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/intent-filter&gt;</span>
    <span class="nt">&lt;/activity&gt;</span>

    <span class="c">&lt;!-- 카카오 인증 코드 핸들러 --&gt;</span>
    <span class="nt">&lt;activity</span>
        <span class="na">android:name=</span><span class="s">"com.kakao.sdk.auth.AuthCodeHandlerActivity"</span>
        <span class="na">android:exported=</span><span class="s">"true"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;intent-filter&gt;</span>
            <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">"android.intent.action.VIEW"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.DEFAULT"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.BROWSABLE"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;data</span> <span class="na">android:host=</span><span class="s">"oauth"</span> <span class="na">android:scheme=</span><span class="s">"@string/kakao_scheme"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/intent-filter&gt;</span>
    <span class="nt">&lt;/activity&gt;</span>
<span class="nt">&lt;/application&gt;</span>
</code></pre></div></div>

<h4 id="123-stringsxml-설정">1.2.3 strings.xml 설정</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/src/main/res/values/strings.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;resources&gt;</span>
    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">"kakao_app_key"</span><span class="nt">&gt;</span>YOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">"kakao_scheme"</span><span class="nt">&gt;</span>kakaoYOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>
<span class="nt">&lt;/resources&gt;</span>
</code></pre></div></div>

<h4 id="124-mainactivityjava-초기화">1.2.4 MainActivity.java 초기화</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/src/main/java/com/yourpackage/app/MainActivity.java</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">com.kakao.sdk.common.KakaoSdk</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="nc">BridgeActivity</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="nc">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>

        <span class="c1">// 카카오 SDK 초기화</span>
        <span class="nc">KakaoSdk</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">getResources</span><span class="o">().</span><span class="na">getString</span><span class="o">(</span><span class="no">R</span><span class="o">.</span><span class="na">string</span><span class="o">.</span><span class="na">kakao_app_key</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="13-ios-설정">1.3 iOS 설정</h3>

<h4 id="131-infoplist-설정">1.3.1 Info.plist 설정</h4>

<p><code class="language-plaintext highlighter-rouge">ios/App/App/Info.plist</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;key&gt;</span>KAKAO_APP_KEY<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;string&gt;</span>YOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>

<span class="nt">&lt;key&gt;</span>CFBundleURLTypes<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;array&gt;</span>
    <span class="nt">&lt;dict&gt;</span>
        <span class="nt">&lt;key&gt;</span>CFBundleURLSchemes<span class="nt">&lt;/key&gt;</span>
        <span class="nt">&lt;array&gt;</span>
            <span class="nt">&lt;string&gt;</span>kakaoYOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>
            <span class="nt">&lt;string&gt;</span>com.yourapp.bundleid<span class="nt">&lt;/string&gt;</span>
        <span class="nt">&lt;/array&gt;</span>
    <span class="nt">&lt;/dict&gt;</span>
<span class="nt">&lt;/array&gt;</span>

<span class="nt">&lt;key&gt;</span>LSApplicationQueriesSchemes<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;array&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaoYOUR_KAKAO_NATIVE_APP_KEY<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaokompassauth<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>storykompassauth<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaolink<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>storylink<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaotalk<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaotalk-5.9.7<span class="nt">&lt;/string&gt;</span>
    <span class="nt">&lt;string&gt;</span>kakaostory-2.9.0<span class="nt">&lt;/string&gt;</span>
<span class="nt">&lt;/array&gt;</span>
</code></pre></div></div>

<h4 id="132-appdelegateswift-초기화">1.3.2 AppDelegate.swift 초기화</h4>

<p><code class="language-plaintext highlighter-rouge">ios/App/App/AppDelegate.swift</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">KakaoSDKAuth</span>
<span class="kd">import</span> <span class="kt">KakaoSDKCommon</span>

<span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="n">_</span> <span class="nv">application</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="p">,</span> <span class="n">didFinishLaunchingWithOptions</span> <span class="nv">launchOptions</span><span class="p">:</span> <span class="p">[</span><span class="kt">UIApplication</span><span class="o">.</span><span class="kt">LaunchOptionsKey</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]?)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">key</span> <span class="o">=</span> <span class="kt">Bundle</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">infoDictionary</span><span class="p">?[</span><span class="s">"KAKAO_APP_KEY"</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">String</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">kakaoKey</span> <span class="o">=</span> <span class="n">key</span> <span class="p">{</span>
        <span class="kt">KakaoSDK</span><span class="o">.</span><span class="nf">initSDK</span><span class="p">(</span><span class="nv">appKey</span><span class="p">:</span> <span class="n">kakaoKey</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="n">_</span> <span class="nv">app</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="p">,</span> <span class="kd">open</span> <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="kt">UIApplication</span><span class="o">.</span><span class="kt">OpenURLOptionsKey</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:])</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="kt">AuthApi</span><span class="o">.</span><span class="nf">isKakaoTalkLoginUrl</span><span class="p">(</span><span class="n">url</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">AuthController</span><span class="o">.</span><span class="nf">handleOpenUrl</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kt">ApplicationDelegateProxy</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">application</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="nv">open</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="n">options</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="14-프론트엔드-코드">1.4 프론트엔드 코드</h3>

<p><code class="language-plaintext highlighter-rouge">client/lib/auth.ts</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">KakaoLoginPlugin</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">capacitor-kakao-login-plugin</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">startSocialLogin</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">provider</span><span class="p">:</span> <span class="nx">OAuthProvider</span>
<span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isMobile</span> <span class="o">=</span> <span class="nx">Capacitor</span><span class="p">.</span><span class="nx">isNativePlatform</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">isMobile</span> <span class="o">&amp;&amp;</span> <span class="nx">provider</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">kakao</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 카카오 네이티브 로그인 실행</span>
      <span class="kd">const</span> <span class="nx">kakaoResult</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">KakaoLoginPlugin</span><span class="p">.</span><span class="nx">goLogin</span><span class="p">();</span>

      <span class="c1">// 카카오 액세스 토큰을 백엔드로 전달</span>
      <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">processKakaoNativeLogin</span><span class="p">(</span><span class="nx">kakaoResult</span><span class="p">.</span><span class="nx">accessToken</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span>
          <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">"</span><span class="s2">oauth-login-success</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
            <span class="na">detail</span><span class="p">:</span> <span class="p">{</span> <span class="na">userInfo</span><span class="p">:</span> <span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">user_info</span> <span class="p">},</span>
          <span class="p">})</span>
        <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span>
        <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">"</span><span class="s2">oauth-login-error</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
          <span class="na">detail</span><span class="p">:</span> <span class="p">{</span> <span class="na">error</span><span class="p">:</span> <span class="nx">error</span><span class="p">.</span><span class="nx">message</span> <span class="p">},</span>
        <span class="p">})</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 웹: 일반 OAuth 리다이렉트</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="nx">config</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">authorization_url</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 백엔드로 카카오 토큰 전달</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">processKakaoNativeLogin</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">kakaoAccessToken</span><span class="p">:</span> <span class="kr">string</span>
<span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">OAuthLoginResponse</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">getApiUrl</span><span class="p">()}</span><span class="s2">/v1/auth/oauth/kakao/native`</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span> <span class="p">},</span>
    <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
      <span class="na">kakao_access_token</span><span class="p">:</span> <span class="nx">kakaoAccessToken</span><span class="p">,</span>
      <span class="na">device_info</span><span class="p">:</span> <span class="s2">`</span><span class="p">${</span><span class="nb">navigator</span><span class="p">.</span><span class="nx">platform</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nb">navigator</span><span class="p">.</span><span class="nx">userAgent</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
    <span class="p">}),</span>
    <span class="na">credentials</span><span class="p">:</span> <span class="dl">"</span><span class="s2">include</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="15-카카오-개발자-콘솔-설정">1.5 카카오 개발자 콘솔 설정</h3>

<ol>
  <li>
    <p><strong>키 해시 등록</strong> (Android)</p>

    <ul>
      <li>Android Studio Logcat에서 SHA-1, SHA-256 키 해시 확인</li>
      <li>카카오 개발자 콘솔 → 내 애플리케이션 → 플랫폼 → Android → 키 해시 등록</li>
    </ul>
  </li>
  <li>
    <p><strong>리다이렉트 URI 설정</strong></p>
    <ul>
      <li>Android: <code class="language-plaintext highlighter-rouge">kakao{NATIVE_APP_KEY}://oauth</code></li>
      <li>iOS: <code class="language-plaintext highlighter-rouge">kakao{NATIVE_APP_KEY}://oauth</code></li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="2-구글-네이티브-로그인-구현">2. 구글 네이티브 로그인 구현</h2>

<h3 id="21-플러그인-설치">2.1 플러그인 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pnpm add @codetrix-studio/capacitor-google-auth
npx cap <span class="nb">sync</span>
</code></pre></div></div>

<h3 id="22-google-console-설정">2.2 Google Console 설정</h3>

<h4 id="221-웹-클라이언트-id-생성">2.2.1 웹 클라이언트 ID 생성</h4>

<ol>
  <li>Google Console → API 및 서비스 → 사용자 인증 정보</li>
  <li>
    <ul>
      <li>사용자 인증 정보 만들기 → OAuth 2.0 클라이언트 ID</li>
    </ul>
  </li>
  <li>애플리케이션 유형: <strong>웹 애플리케이션</strong></li>
  <li>생성된 클라이언트 ID를 복사</li>
</ol>

<h4 id="222-android-클라이언트-id-생성">2.2.2 Android 클라이언트 ID 생성</h4>

<ol>
  <li>
    <ul>
      <li>사용자 인증 정보 만들기 → OAuth 2.0 클라이언트 ID</li>
    </ul>
  </li>
  <li>애플리케이션 유형: <strong>Android</strong></li>
  <li>패키지 이름: <code class="language-plaintext highlighter-rouge">com.yourapp.bundleid</code></li>
  <li><strong>SHA-1 인증서 지문 등록</strong> (중요!)</li>
</ol>

<p><strong>SHA-1 지문 확인 방법:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 디버그 키스토어</span>
keytool <span class="nt">-list</span> <span class="nt">-v</span> <span class="nt">-keystore</span> ~/.android/debug.keystore <span class="nt">-alias</span> androiddebugkey <span class="nt">-storepass</span> android <span class="nt">-keypass</span> android

<span class="c"># 또는 MainActivity에서 로그로 확인</span>
</code></pre></div></div>

<p>SHA-1 지문을 <strong>콜론 없이</strong> 등록</p>

<h4 id="223-ios-클라이언트-id-생성-선택">2.2.3 iOS 클라이언트 ID 생성 (선택)</h4>

<ol>
  <li>
    <ul>
      <li>사용자 인증 정보 만들기 → OAuth 2.0 클라이언트 ID</li>
    </ul>
  </li>
  <li>애플리케이션 유형: <strong>iOS</strong></li>
  <li>번들 ID: <code class="language-plaintext highlighter-rouge">com.yourapp.bundleid</code></li>
  <li><code class="language-plaintext highlighter-rouge">GoogleService.plist</code> 파일 다운로드</li>
</ol>

<h3 id="23-android-설정">2.3 Android 설정</h3>

<h4 id="231-stringsxml-설정">2.3.1 strings.xml 설정</h4>

<p><code class="language-plaintext highlighter-rouge">android/app/src/main/res/values/strings.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;resources&gt;</span>
    <span class="c">&lt;!-- 웹 클라이언트 ID (server_client_id) --&gt;</span>
    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">"server_client_id"</span><span class="nt">&gt;</span>YOUR_WEB_CLIENT_ID.apps.googleusercontent.com<span class="nt">&lt;/string&gt;</span>
<span class="nt">&lt;/resources&gt;</span>
</code></pre></div></div>

<p><strong>참고</strong>: Android 클라이언트 ID는 코드에 넣을 필요 없습니다. 플러그인이 자동으로 사용합니다.</p>

<h4 id="232-androidmanifestxml-권한-추가">2.3.2 AndroidManifest.xml 권한 추가</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;uses-permission</span> <span class="na">android:name=</span><span class="s">"android.permission.GET_ACCOUNTS"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<h4 id="233-capacitorconfigts-설정">2.3.3 capacitor.config.ts 설정</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">GoogleAuth</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">scopes</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">profile</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">email</span><span class="dl">"</span><span class="p">],</span>
      <span class="na">serverClientId</span><span class="p">:</span> <span class="dl">"</span><span class="s2">YOUR_WEB_CLIENT_ID.apps.googleusercontent.com</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">forceCodeForRefreshToken</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="24-ios-설정">2.4 iOS 설정</h3>

<h4 id="241-googleserviceplist-추가">2.4.1 GoogleService.plist 추가</h4>

<ol>
  <li>Google Console에서 다운로드한 <code class="language-plaintext highlighter-rouge">GoogleService.plist</code> 파일을</li>
  <li><code class="language-plaintext highlighter-rouge">ios/App/App/</code> 폴더에 복사</li>
</ol>

<h4 id="242-infoplist-설정">2.4.2 Info.plist 설정</h4>

<p><code class="language-plaintext highlighter-rouge">ios/App/App/Info.plist</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;key&gt;</span>CFBundleURLTypes<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;array&gt;</span>
    <span class="nt">&lt;dict&gt;</span>
        <span class="nt">&lt;key&gt;</span>CFBundleURLSchemes<span class="nt">&lt;/key&gt;</span>
        <span class="nt">&lt;array&gt;</span>
            <span class="nt">&lt;string&gt;</span>com.yourapp.bundleid<span class="nt">&lt;/string&gt;</span>
            <span class="c">&lt;!-- GoogleService.plist의 REVERSED_CLIENT_ID 값 --&gt;</span>
            <span class="nt">&lt;string&gt;</span>YOUR_REVERSED_CLIENT_ID<span class="nt">&lt;/string&gt;</span>
        <span class="nt">&lt;/array&gt;</span>
    <span class="nt">&lt;/dict&gt;</span>
<span class="nt">&lt;/array&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">REVERSED_CLIENT_ID</code>는 <code class="language-plaintext highlighter-rouge">GoogleService.plist</code> 파일에서 확인할 수 있습니다.</p>

<h3 id="25-프론트엔드-코드">2.5 프론트엔드 코드</h3>

<p><code class="language-plaintext highlighter-rouge">client/lib/auth.ts</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">GoogleAuth</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@codetrix-studio/capacitor-google-auth</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">startSocialLogin</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">provider</span><span class="p">:</span> <span class="nx">OAuthProvider</span>
<span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isMobile</span> <span class="o">=</span> <span class="nx">Capacitor</span><span class="p">.</span><span class="nx">isNativePlatform</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">isMobile</span> <span class="o">&amp;&amp;</span> <span class="nx">provider</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">google</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 구글 플러그인 초기화 (scopes 포함)</span>
      <span class="k">await</span> <span class="nx">GoogleAuth</span><span class="p">.</span><span class="nx">initialize</span><span class="p">({</span>
        <span class="na">scopes</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">profile</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">email</span><span class="dl">"</span><span class="p">],</span>
      <span class="p">});</span>

      <span class="c1">// 구글 네이티브 로그인 실행</span>
      <span class="kd">const</span> <span class="nx">googleResult</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">GoogleAuth</span><span class="p">.</span><span class="nx">signIn</span><span class="p">();</span>

      <span class="c1">// 구글 ID 토큰을 백엔드로 전달</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">googleResult</span><span class="p">.</span><span class="nx">authentication</span><span class="p">?.</span><span class="nx">idToken</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">구글 ID 토큰을 받지 못했습니다.</span><span class="dl">"</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">processGoogleNativeLogin</span><span class="p">(</span>
        <span class="nx">googleResult</span><span class="p">.</span><span class="nx">authentication</span><span class="p">.</span><span class="nx">idToken</span>
      <span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span>
          <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">"</span><span class="s2">oauth-login-success</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
            <span class="na">detail</span><span class="p">:</span> <span class="p">{</span> <span class="na">userInfo</span><span class="p">:</span> <span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">user_info</span> <span class="p">},</span>
          <span class="p">})</span>
        <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span>
        <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">"</span><span class="s2">oauth-login-error</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
          <span class="na">detail</span><span class="p">:</span> <span class="p">{</span> <span class="na">error</span><span class="p">:</span> <span class="nx">error</span><span class="p">.</span><span class="nx">message</span> <span class="p">},</span>
        <span class="p">})</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 웹: 일반 OAuth 리다이렉트</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="nx">config</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">authorization_url</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 백엔드로 구글 ID 토큰 전달</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">processGoogleNativeLogin</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">googleIdToken</span><span class="p">:</span> <span class="kr">string</span>
<span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">OAuthLoginResponse</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">getApiUrl</span><span class="p">()}</span><span class="s2">/v1/auth/oauth/google/native`</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span> <span class="p">},</span>
    <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
      <span class="na">google_id_token</span><span class="p">:</span> <span class="nx">googleIdToken</span><span class="p">,</span>
      <span class="na">device_info</span><span class="p">:</span> <span class="s2">`</span><span class="p">${</span><span class="nb">navigator</span><span class="p">.</span><span class="nx">platform</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nb">navigator</span><span class="p">.</span><span class="nx">userAgent</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
    <span class="p">}),</span>
    <span class="na">credentials</span><span class="p">:</span> <span class="dl">"</span><span class="s2">include</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="26-웹-설정-선택">2.6 웹 설정 (선택)</h3>

<p><code class="language-plaintext highlighter-rouge">index.html</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;meta</span>
  <span class="na">name=</span><span class="s">"google-signin-client_id"</span>
  <span class="na">content=</span><span class="s">"YOUR_WEB_CLIENT_ID.apps.googleusercontent.com"</span>
<span class="nt">/&gt;</span>
</code></pre></div></div>

<hr />

<h2 id="3-백엔드-api-엔드포인트">3. 백엔드 API 엔드포인트</h2>

<h3 id="31-카카오-네이티브-로그인">3.1 카카오 네이티브 로그인</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /v1/auth/oauth/kakao/native
Content-Type: application/json

{
  "kakao_access_token": "카카오_액세스_토큰",
  "device_info": "플랫폼 정보"
}
</code></pre></div></div>

<h3 id="32-구글-네이티브-로그인">3.2 구글 네이티브 로그인</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /v1/auth/oauth/google/native
Content-Type: application/json

{
  "google_id_token": "구글_ID_토큰",
  "device_info": "플랫폼 정보"
}
</code></pre></div></div>

<hr />

<h2 id="4-체크리스트">4. 체크리스트</h2>

<h3 id="카카오-로그인">카카오 로그인</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><code class="language-plaintext highlighter-rouge">capacitor-kakao-login-plugin</code> 설치</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: Kakao SDK 의존성 추가</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code> 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">strings.xml</code>에 앱 키 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">MainActivity.java</code>에서 SDK 초기화</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />iOS: <code class="language-plaintext highlighter-rouge">Info.plist</code> 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />iOS: <code class="language-plaintext highlighter-rouge">AppDelegate.swift</code>에서 SDK 초기화</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />카카오 개발자 콘솔에 키 해시 등록</li>
</ul>

<h3 id="구글-로그인">구글 로그인</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><code class="language-plaintext highlighter-rouge">@codetrix-studio/capacitor-google-auth</code> 설치</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Google Console에 웹 클라이언트 ID 생성</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Google Console에 Android 클라이언트 ID 생성 (SHA-1 지문 등록)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Google Console에 iOS 클라이언트 ID 생성 (선택)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">strings.xml</code>에 웹 클라이언트 ID 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Android: <code class="language-plaintext highlighter-rouge">capacitor.config.ts</code> 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />iOS: <code class="language-plaintext highlighter-rouge">GoogleService.plist</code> 추가</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />iOS: <code class="language-plaintext highlighter-rouge">Info.plist</code>에 <code class="language-plaintext highlighter-rouge">REVERSED_CLIENT_ID</code> 추가</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />웹: <code class="language-plaintext highlighter-rouge">index.html</code>에 meta tag 추가</li>
</ul>

<hr />

<h2 id="5-참고-자료">5. 참고 자료</h2>

<ul>
  <li><a href="https://capacitorjs.com/docs">Capacitor 공식 문서</a></li>
  <li><a href="https://developers.kakao.com/docs/latest/ko/flutter/getting-started#project-scheme">Kakao developer</a></li>
  <li><a href="https://github.com/nerdFrenzs/capacitor-kakao-login-plugin">capacitor-kakao-login-plugin</a></li>
  <li><a href="https://github.com/CodetrixStudio/CapacitorGoogleAuth">@codetrix-studio/capacitor-google-auth</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 Android 앱에서 카카오/구글 네이티브 로그인을 구현한 방법에 대해 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor Android 앱 로그인 연동 CORS 트러블 슈팅</title><link href="https://nan0silver.github.io/projectdiary/2025-11-10-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor Android 앱 로그인 연동 CORS 트러블 슈팅" /><published>2025-11-10T00:00:00+00:00</published><updated>2025-12-29T09:31:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-10-diary/"><![CDATA[<ul>
  <li>지난 글에서는 Capacitor로 Android, iOS 앱 빌드하는 방법에 대해 다뤘다.</li>
  <li>이번 글에서는 Capacitor로 빌드한 Android 앱에서 로그인 연동을 하는 방법에 대해 다뤄보겠다.</li>
  <li>특히 CORS 에러 해결에 대해 다뤄보겠다..
    <blockquote>
      <p>저번에 한번 여기까진 해결을 했었는데,, 다 밀고 다시하는 과정에서 까먹어서.. 이번에도 삽질을 했다..🥲 <del>진짜 울뻔함</del></p>
    </blockquote>
  </li>
</ul>

<h2 id="문제-상황">문제 상황</h2>

<ul>
  <li>일단 내 프로젝트의 상황을 말하자면</li>
</ul>

<ol>
  <li>React로 웹 빌드시 nginx 사용하고 있음</li>
  <li>Android 앱 빌드 (Capacitor로 감싸고 있음)</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>앱/웹] → HTTPS <span class="o">(</span>443<span class="o">)</span> → <span class="o">[</span>Nginx] → HTTP <span class="o">(</span>8080<span class="o">)</span> → <span class="o">[</span>Spring Boot]
</code></pre></div></div>

<ul>
  <li>
    <p>Nginx의 역할은</p>

    <ol>
      <li>SSL 종료
        <ul>
          <li>HTTPS를 HTTP로 변환</li>
        </ul>
      </li>
      <li>리버스 프록시
        <ul>
          <li>요청을 8080포트로 전달</li>
        </ul>
      </li>
      <li>‼️ 문제 : OPTIONS preflight 요청이 여기서 자꾸 막혔다.🤮</li>
    </ol>

    <p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-10-pic1.png?raw=true" alt="에러 이미지" />
<img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-10-pic2.png?raw=true" alt="에러 이미지2" /></p>
  </li>
</ul>

<h3 id="증상">증상</h3>

<p><strong>웹 (https://chingoohaja.app)</strong>: ✅ 로그인 정상 작동<br />
<strong>앱 (https://localhost)</strong>: ❌ CORS 에러 발생</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Access to fetch at 'https://silverld.site/api/v1/auth/refresh'
from origin 'https://localhost' has been blocked by CORS policy
</code></pre></div></div>

<h3 id="왜-웹은-되고-앱은-안될까">왜 웹은 되고 앱은 안될까?</h3>

<ul>
  <li>웹 브라우저와 Capacitor WebView는 preflight OPTIONS 요청을 다르게 보낸다.</li>
</ul>

<ol>
  <li>웹
    <ul>
      <li>Origin이 <code class="language-plaintext highlighter-rouge">https://chingoohaja.app</code> -&gt; Nginx가 통과시킴</li>
    </ul>
  </li>
  <li>앱
    <ul>
      <li>Origin이 <code class="language-plaintext highlighter-rouge">https:/localhost</code> -&gt; Nginx가 의심
        <blockquote>
          <p>Capacitor의 URL/orign은 아래와 같다</p>

          <blockquote>
            <p>iOS: capacitor://localhost
Android: http://localhost</p>
          </blockquote>
        </blockquote>
      </li>
    </ul>
  </li>
</ol>

<ul>
  <li>서버에서 Cors설정과 Security설정은 다 해놨다.</li>
  <li>그런데도 CORS 에러가 해결되지않아서 Nginx 설정 파일을 손을 댔다
    <ul>
      <li>도메인들을 Nginx에서 동적으로 orign 반환하는 형식으로도 수정을 해봤고..</li>
      <li>모든 도메인을 다 허용도 해봤고..</li>
    </ul>
  </li>
  <li>그런데 CORS 문제는 해결이 되지않았다..!</li>
  <li>하지만 해결방법은 생각보다 간단했다..</li>
</ul>

<h2 id="해결-방법">해결 방법</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">capacitor.config.ts</code>파일에 capacitor의 HTTP 플러그인을 추가해준다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plugins: {
    CapacitorHttp: {
      enabled: true,
    },
  },
</code></pre></div></div>

<h3 id="왜-이게-작동하는가">왜 이게 작동하는가?</h3>

<p><strong>일반 fetch API</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>App WebView → Browser CORS Check → ❌ Blocked
</code></pre></div></div>

<p><strong>Capacitor HTTP 플러그인</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>App → Native HTTP Client → 🚀 Direct Connection (CORS 우회)
</code></pre></div></div>

<p>네이티브 HTTP 클라이언트는 브라우저의 CORS 정책을 따르지 않고 <strong>직접 서버와 통신</strong>한다.</p>

<ul>
  <li>
    <p>물론 서버에서 설정을 다 해준 다음 이 코드도 추가해줘야한다.</p>
  </li>
  <li>이틀간의 삽질이 끝났다..</li>
  <li>이제 리다이렉트 지옥이 시작임</li>
</ul>

<h2 id="핵심-교훈">핵심 교훈</h2>

<h3 id="문제-해결-과정에서-배운-것">문제 해결 과정에서 배운 것</h3>

<ol>
  <li>
    <p><strong>레이어별 디버깅의 중요성</strong></p>

    <ul>
      <li>Frontend (Capacitor) → Nginx → Spring Boot 순서로 단계별 확인</li>
      <li>백엔드 로그에 아무것도 안 찍힌다 = 앞단에서 막힌 것</li>
    </ul>
  </li>
  <li>
    <p><strong>브라우저 vs 네이티브의 차이</strong></p>

    <ul>
      <li>WebView의 <code class="language-plaintext highlighter-rouge">fetch</code>는 브라우저 CORS 정책 따름</li>
      <li>네이티브 HTTP는 CORS 우회 가능</li>
    </ul>
  </li>
  <li>
    <p><strong>Mixed Content 정책</strong></p>
    <ul>
      <li>HTTPS 페이지는 HTTP 리소스 차단</li>
      <li>Nginx를 통한 HTTPS 통신 필수</li>
    </ul>
  </li>
</ol>

<h3 id="주의사항">주의사항</h3>

<p>⚠️ <strong>Capacitor HTTP 플러그인 활성화 시</strong>:</p>

<ul>
  <li>기존 <code class="language-plaintext highlighter-rouge">fetch</code> API 동작 변경 가능</li>
  <li>웹과 앱의 네트워크 동작이 달라질 수 있음</li>
  <li>충분한 테스트 필요</li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-10-pic3.png?raw=true" alt="코드래빗의 평" /></p>

<h3 id="참고-문헌">참고 문헌</h3>

<ul>
  <li><a href="https://stackoverflow.com/questions/75192411/cors-in-capacitor-for-android">StackOverFlow가 짱이야</a></li>
  <li><a href="https://capacitorjs.com/docs/apis/http">Capacitor HTTP Plugin 공식 문서</a></li>
  <li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/CORS">MDN - CORS</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 Android 앱 로그인 연동 해보자! - CORS 에러 해결에 대해 다룹니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor로 웹을 앱으로 빌드해보자!</title><link href="https://nan0silver.github.io/projectdiary/2025-11-06-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor로 웹을 앱으로 빌드해보자!" /><published>2025-11-06T00:00:00+00:00</published><updated>2025-12-29T09:31:20+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-06-diary/"><![CDATA[<ul>
  <li>“친구하자”를 웹으로 MVP 완성을 하니, 이걸 앱으로 빌드해서 사용자들이 더 쉽게 사용할 수 있으면 좋겠다고 생각했다.</li>
  <li>원래는.. 개발자의 입장으로 링크로 이동하는 방식이 쉬울꺼라고 생각했는데, 막상 사용자에게 링크를 보내주니까 어려움을 토로하거나 방식에 의문을 가지는 사람들이 많았다..
    <ul>
      <li>링크는 일단 어디 저장해놓고 찾아서 연결해야하고..</li>
      <li>핸드폰에서 링크를 통해 이동하는 방식이 익숙하지 않은 사람들이 더 많았다.. (일회용 링크정도만 다들 사용하는 것 같았다.)</li>
    </ul>
  </li>
  <li>네이티브 앱으로 개발하는건 일단 시간이 많이 드니까 최대한 빠른 방법을 찾아보다가 Capacitor 플러그인을 찾게 되었다.</li>
</ul>

<h2 id="capacitor">Capacitor</h2>

<ul>
  <li><a href="https://capacitorjs.com/">Capacitor</a>는 기존 React웹을 네이티브 앱 컨테이너에 담아주는 플러그인이다.</li>
  <li>기존의 React 코드베이스를 거의 건들이지 않고 모바일 앱을 만들 수 있게 해준다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>기존 React 웹 앱
         ↓
    Capacitor 추가
         ↓
네이티브 WebView에서 실행
(iOS/Android 앱으로 패키징)
</code></pre></div></div>

<ul>
  <li>설치만 해서 간단하게 앱으로 빌드할 수 있다!</li>
  <li>일단 나는 ios로 빌드하는 것을 아래에 보여주겠다.</li>
</ul>

<h2 id="capacitor로-ios-앱-빌드하기">Capacitor로 iOS 앱 빌드하기</h2>

<ul>
  <li>
    <p>일단 내 기존 프론트 프로젝트 스펙을 정리하자면</p>

    <ul>
      <li>많은 의존성을 가짐(특히 @radix-ui/* 패키지들)</li>
      <li>React 18 + TypeScript + Vite 스택</li>
      <li>Express 서버 통합</li>
    </ul>
  </li>
  <li>따라서 npm이 아닌 pnpm을 사용하고 있다.</li>
  <li>capacitor 공식문서에는 npm으로 설명이 나와있는데, 그냥 pnpm 명령어로만 바꿔서 똑같이 진행해줬다.</li>
</ul>

<h3 id="1-capacitor의-메인-의존성-설치">1. Capacitor의 메인 의존성 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pnpm add @capacitor/core @capacitor/cli
</code></pre></div></div>

<p>프로젝트 루트 디렉토리에 위의 명령어를 입력!</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic1.png?raw=true" alt="성공 이미지" /></p>

<h3 id="2-capacitor-config-초기화">2. Capacitor Config 초기화</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npx cap init
</code></pre></div></div>

<ul>
  <li>여기서는 이름과, Project ID를 입력하라고 한다.</li>
  <li>Project ID는 도메인 네임 형태로 적어주면 된다. (예: com.example.app)</li>
  <li>나는 프론트 도메인을 사놓은게 있어서 그대로 넣었다.</li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic2.png?raw=true" alt="성공 이미지2" /></p>

<h3 id="3-플랫폼-추가-android-ios">3. 플랫폼 추가 (android, iOS)</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Android</span>
pnpm add @capacitor/android

<span class="c"># iOS (macOS에서만)</span>
pnpm add @capacitor/android
</code></pre></div></div>

<ul>
  <li>
    <p>나는 맥북에서 작업하고 있기 때문에 둘다 추가해줬다.</p>

    <blockquote>
      <p>ios 만들고 싶어서 3년전에 맥북 샀던 기억..</p>
    </blockquote>
  </li>
  <li>
    <p>성공하면 아래와 같은 메시지가 나온다.</p>
  </li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic3.png?raw=true" alt="성공 이미지3" /></p>

<h3 id="이제-실행해보자">이제 실행해보자!!</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Android</span>
npx cap run android

<span class="c"># iOS</span>
npx cap run ios
</code></pre></div></div>

<p>일단 ios로 아래와 같이 실행 성공!</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic4.png?raw=true" alt="성공 이미지4" height="500" /></p>

<p><br />
다음에 android studio 업데이트를 좀 하고.. (안한지 넘 오래됌..) 아래와 같이 빌드 성공!</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic5.png?raw=true" alt="성공 이미지5" height="500" /></p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[웹을 앱으로 빠르게 빌드하기 위해 Capacitor를 사용해보기]]></summary></entry><entry><title type="html">[Algorithm] 코테에서 자주 쓰이는 Collection 모음</title><link href="https://nan0silver.github.io/algorithm/2025-10-23-collections/" rel="alternate" type="text/html" title="[Algorithm] 코테에서 자주 쓰이는 Collection 모음" /><published>2025-10-23T00:00:00+00:00</published><updated>2025-12-29T09:31:20+00:00</updated><id>https://nan0silver.github.io/algorithm/collections</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2025-10-23-collections/"><![CDATA[<ol>
  <li><a href="#️-1️⃣-hashmapk-v--key-value-형태로-빠르게-찾고-세는-용도">HashMap</a></li>
  <li><a href="#-2️⃣-hashset--중복-없는-데이터-저장">HashSet</a></li>
  <li><a href="#-3️⃣-arraylist--순서-있는-리스트-인덱스-접근-가능">ArrayList</a></li>
  <li><a href="#-4️⃣-priorityqueue--우선순위-큐-힙">PriorityQueue</a></li>
  <li><a href="#-5️⃣-stack--queue-deque--선형-구조">Stack / Queue</a></li>
  <li><a href="#-6️⃣-collections--arrays-유틸리티-메서드">Collections / Arrays</a></li>
  <li><a href="#-추천-연습문제-유형별-활용-예시">추천 연습문제 유형별 활용 예시</a></li>
</ol>

<hr />

<h2 id="️-1️⃣-hashmapk-v--key-value-형태로-빠르게-찾고-세는-용도">🗂️ 1️⃣ HashMap&lt;K, V&gt; — key-value 형태로 빠르게 찾고 세는 용도</h2>

<h3 id="-핵심-활용-상황">💡 핵심 활용 상황</h3>

<ul>
  <li>“이 값이 몇 번 나왔는가?”</li>
  <li>“이 key가 이미 존재하나?”</li>
  <li>“카테고리별 개수 세기 (위장 문제 등)”</li>
</ul>

<h3 id="-자주-쓰는-메서드">🚀 자주 쓰는 메서드</h3>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
      <th>예시 코드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">put(K key, V value)</code></td>
      <td>값 삽입 (덮어씀)</td>
      <td><code class="language-plaintext highlighter-rouge">map.put("apple", 3);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">get(K key)</code></td>
      <td>key로 value 조회</td>
      <td><code class="language-plaintext highlighter-rouge">int v = map.get("apple");</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">getOrDefault(K key, V defaultVal)</code></td>
      <td>key 없으면 기본값 반환</td>
      <td><code class="language-plaintext highlighter-rouge">map.getOrDefault("pear", 0);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">containsKey(K key)</code></td>
      <td>key 존재 여부</td>
      <td><code class="language-plaintext highlighter-rouge">if (map.containsKey("apple"))</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(K key)</code></td>
      <td>key/value 쌍 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">map.remove("apple");</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">keySet()</code></td>
      <td>모든 key 조회</td>
      <td><code class="language-plaintext highlighter-rouge">for (String k : map.keySet())</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">values()</code></td>
      <td>모든 value 조회</td>
      <td><code class="language-plaintext highlighter-rouge">for (int v : map.values())</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">entrySet()</code></td>
      <td>key+value 동시 접근</td>
      <td>`for (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) {</td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> System.out.println(e.getKey() + " → " + e.getValue());
</code></pre></div></div>

<p>}<code class="language-plaintext highlighter-rouge">|
|</code>size()<code class="language-plaintext highlighter-rouge">| 원소 수 |</code>map.size();<code class="language-plaintext highlighter-rouge">|
|</code>clear()<code class="language-plaintext highlighter-rouge">| 모두 삭제 |</code>map.clear();` |</p>

<hr />

<h2 id="-2️⃣-hashset--중복-없는-데이터-저장">🧩 2️⃣ HashSet — 중복 없는 데이터 저장</h2>

<h3 id="-핵심-활용-상황-1">💡 핵심 활용 상황</h3>

<ul>
  <li>“이미 나온 적 있는 값인가?”</li>
  <li>“교집합, 중복 제거”</li>
  <li>“전화번호부 접두사, 참가자 중 완주 못한 사람 찾기 등”</li>
</ul>

<h3 id="-자주-쓰는-메서드-1">🚀 자주 쓰는 메서드</h3>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
      <th>예시 코드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(E e)</code></td>
      <td>원소 추가</td>
      <td><code class="language-plaintext highlighter-rouge">set.add("apple");</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">contains(E e)</code></td>
      <td>포함 여부 확인</td>
      <td><code class="language-plaintext highlighter-rouge">if (set.contains("apple"))</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(E e)</code></td>
      <td>원소 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">set.remove("apple");</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td>원소 개수</td>
      <td><code class="language-plaintext highlighter-rouge">set.size();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">clear()</code></td>
      <td>모두 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">set.clear();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td>비었는지 확인</td>
      <td><code class="language-plaintext highlighter-rouge">if (set.isEmpty())</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">iterator()</code></td>
      <td>순회용 Iterator 생성</td>
      <td><code class="language-plaintext highlighter-rouge">for (String s : set) System.out.println(s);</code></td>
    </tr>
  </tbody>
</table>

<p>or
<code class="language-plaintext highlighter-rouge">Iterator&lt;String&gt; it = set.iterator();
while (it.hasNext()) {
      System.out.println(it.next());
}</code> |</p>

<blockquote>
  <p>💡 참고: HashSet은 내부적으로 HashMap을 사용하므로 add, contains 모두 O(1)입니다.</p>
</blockquote>

<hr />

<h2 id="-3️⃣-arraylist--순서-있는-리스트-인덱스-접근-가능">📋 3️⃣ ArrayList — 순서 있는 리스트 (인덱스 접근 가능)</h2>

<h3 id="-핵심-활용-상황-2">💡 핵심 활용 상황</h3>

<ul>
  <li>“순차적 접근”, “정렬”, “조합/순열 저장”</li>
  <li>BFS/DFS에서 방문 순서 저장 등</li>
</ul>

<h3 id="-자주-쓰는-메서드-2">🚀 자주 쓰는 메서드</h3>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
      <th>예시 코드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(E e)</code></td>
      <td>끝에 추가</td>
      <td><code class="language-plaintext highlighter-rouge">list.add(5);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(int idx, E e)</code></td>
      <td>인덱스에 삽입</td>
      <td><code class="language-plaintext highlighter-rouge">list.add(1, 10);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">get(int idx)</code></td>
      <td>특정 인덱스 조회</td>
      <td><code class="language-plaintext highlighter-rouge">list.get(0);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">set(int idx, E e)</code></td>
      <td>특정 위치 값 수정</td>
      <td><code class="language-plaintext highlighter-rouge">list.set(2, 99);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(int idx)</code></td>
      <td>인덱스로 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">list.remove(1);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">contains(E e)</code></td>
      <td>포함 여부</td>
      <td><code class="language-plaintext highlighter-rouge">if (list.contains(5))</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td>크기 확인</td>
      <td><code class="language-plaintext highlighter-rouge">list.size();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">clear()</code></td>
      <td>모두 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">list.clear();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sort(Comparator&lt;? super E&gt; c)</code></td>
      <td>정렬</td>
      <td>`Arrays.sort(arr, new Comparator<String>() {</String></td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        @Override
        public int compare(String o1, String o2) {
            if (o1.length()==o2.length()) {
                return o1.compareTo(o2);
            } else {
                return o1.length()-o2.length();
            }}});` |
</code></pre></div></div>

<hr />

<h2 id="-4️⃣-priorityqueue--우선순위-큐-힙">🧮 4️⃣ PriorityQueue — 우선순위 큐 (힙)</h2>

<h3 id="-핵심-활용-상황-3">💡 핵심 활용 상황</h3>

<ul>
  <li>“가장 작은/큰 값”을 반복적으로 꺼낼 때 (Dijkstra, HeapSort, 스케줄링 문제 등)</li>
</ul>

<h3 id="-자주-쓰는-메서드-3">🚀 자주 쓰는 메서드</h3>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
      <th>예시 코드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(E e)</code></td>
      <td>원소 추가</td>
      <td><code class="language-plaintext highlighter-rouge">pq.add(10);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">peek()</code></td>
      <td>최상단 원소 확인(삭제 안 함)</td>
      <td><code class="language-plaintext highlighter-rouge">int top = pq.peek();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">poll()</code></td>
      <td>최상단 원소 꺼내기</td>
      <td><code class="language-plaintext highlighter-rouge">int top = pq.poll();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td>비었는지 확인</td>
      <td><code class="language-plaintext highlighter-rouge">if (pq.isEmpty())</code></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>💡 디폴트는 오름차순(최소 힙) → 작은 숫자가 먼저 나옴</p>

  <p>내림차순은 <code class="language-plaintext highlighter-rouge">new PriorityQueue&lt;&gt;(Collections.reverseOrder());</code></p>
</blockquote>

<hr />

<h2 id="-5️⃣-stack--queue-deque--선형-구조">🧰 5️⃣ Stack / Queue (Deque) — 선형 구조</h2>

<h3 id="-queue">💡 Queue</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>

<h3 id="-stack-deque로-대체-권장">💡 Stack (Deque로 대체 권장)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>

<hr />

<h2 id="-6️⃣-collections--arrays-유틸리티-메서드">💎 6️⃣ Collections / Arrays 유틸리티 메서드</h2>

<table>
  <thead>
    <tr>
      <th>클래스</th>
      <th>메서드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Collections.sort(list)</code></td>
      <td>리스트 정렬</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Collections.reverse(list)</code></td>
      <td>역순 정렬</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Collections.max(list)</code></td>
      <td>최댓값</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Collections.min(list)</code></td>
      <td>최솟값</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Arrays.sort(arr)</code></td>
      <td>배열 정렬</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Arrays.equals(arr1, arr2)</code></td>
      <td>배열 비교</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Arrays.toString(arr)</code></td>
      <td>배열 출력용</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-추천-연습문제-유형별-활용-예시">📘 추천 연습문제 유형별 활용 예시</h2>

<table>
  <thead>
    <tr>
      <th>유형</th>
      <th>핵심 자료구조/메서드</th>
      <th>예시 문제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Hash (중복, 완주하지 못한 선수 등)</td>
      <td><code class="language-plaintext highlighter-rouge">HashMap</code>, <code class="language-plaintext highlighter-rouge">HashSet</code></td>
      <td><code class="language-plaintext highlighter-rouge">map.getOrDefault</code>, <code class="language-plaintext highlighter-rouge">set.contains</code></td>
    </tr>
    <tr>
      <td>Stack/Queue</td>
      <td><code class="language-plaintext highlighter-rouge">Deque</code>, <code class="language-plaintext highlighter-rouge">LinkedList</code></td>
      <td>괄호 검사, 기능개발</td>
    </tr>
    <tr>
      <td>정렬</td>
      <td><code class="language-plaintext highlighter-rouge">Arrays.sort</code>, <code class="language-plaintext highlighter-rouge">Collections.sort</code></td>
      <td>H-index, K번째 수</td>
    </tr>
    <tr>
      <td>이중 루프 회피</td>
      <td><code class="language-plaintext highlighter-rouge">HashMap</code> lookup</td>
      <td>전화번호 목록</td>
    </tr>
    <tr>
      <td>우선순위 문제</td>
      <td><code class="language-plaintext highlighter-rouge">PriorityQueue</code></td>
      <td>더 맵게, 디스크 컨트롤러</td>
    </tr>
    <tr>
      <td>그래프/BFS/DFS</td>
      <td><code class="language-plaintext highlighter-rouge">Queue</code>, <code class="language-plaintext highlighter-rouge">ArrayList</code></td>
      <td>미로 탐색, 네트워크</td>
    </tr>
  </tbody>
</table>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[코딩테스트 대비 JAVA Collections의 사용처 및 메서드를 정리해보았습니다.]]></summary></entry></feed>