<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2026-02-18T07:00:47+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[Algorithm] 벨만-포드 알고리즘</title><link href="https://nan0silver.github.io/algorithm/2026-02-09-bellman-ford/" rel="alternate" type="text/html" title="[Algorithm] 벨만-포드 알고리즘" /><published>2026-02-09T00:00:00+00:00</published><updated>2026-02-18T07:00:01+00:00</updated><id>https://nan0silver.github.io/algorithm/bellman-ford</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2026-02-09-bellman-ford/"><![CDATA[<ol>
  <li><a href="#-1️⃣-벨만-포드란">벨만-포드란?</a></li>
  <li><a href="#-2️⃣-핵심-개념-이해하기">핵심 개념 이해하기</a></li>
  <li><a href="#-3️⃣-간선-완화relaxation">간선 완화(Relaxation)</a></li>
  <li><a href="#-4️⃣-음수-사이클-탐지-원리">음수 사이클 탐지 원리</a></li>
  <li><a href="#-5️⃣-코드-구현">코드 구현</a></li>
  <li><a href="#-6️⃣-시간복잡도와-공간복잡도">시간복잡도와 공간복잡도</a></li>
  <li><a href="#-7️⃣-다익스트라와의-비교">다익스트라와의 비교</a></li>
  <li><a href="#-8️⃣-실전-문제-적용">실전 문제 적용</a></li>
</ol>

<hr />

<h2 id="-1️⃣-벨만-포드란">🎯 1️⃣ 벨만-포드란?</h2>

<h3 id="-한-문장-정의">💡 한 문장 정의</h3>

<p><strong>“음수 가중치를 허용하며, 음수 사이클 존재 여부까지 판별할 수 있는 최단 경로 알고리즘”</strong></p>

<h3 id="-언제-사용하는가">💡 언제 사용하는가?</h3>

<ul>
  <li>간선 가중치가 <strong>음수일 수 있을 때</strong></li>
  <li>“이 그래프에 음수 사이클이 존재하는가?”를 판단해야 할 때</li>
  <li>최단 경로 자체보다 <strong>사이클 판별이 중요한 문제</strong>일 때</li>
</ul>

<h3 id="-특징">💡 특징</h3>

<table>
  <thead>
    <tr>
      <th>특징</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>시간복잡도</strong></td>
      <td>O(VE)</td>
    </tr>
    <tr>
      <td><strong>공간복잡도</strong></td>
      <td>O(V)</td>
    </tr>
    <tr>
      <td><strong>음수 간선</strong></td>
      <td>처리 가능</td>
    </tr>
    <tr>
      <td><strong>음수 사이클</strong></td>
      <td>탐지 가능</td>
    </tr>
    <tr>
      <td><strong>그래프 종류</strong></td>
      <td>방향/무방향 모두 가능</td>
    </tr>
    <tr>
      <td><strong>구현 난이도</strong></td>
      <td>중간 (반복 구조 이해 필요)</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-2️⃣-핵심-개념-이해하기">🧠 2️⃣ 핵심 개념 이해하기</h2>

<h3 id="-알고리즘의-본질">💡 알고리즘의 본질</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
"모든 간선을 반복적으로 확인하면서,
더 짧은 경로가 발견되면 거리 정보를 갱신하고,
이 갱신이 끝없이 발생하는지를 확인하는 알고리즘"

</code></pre></div></div>

<h3 id="-distv의-의미">💡 dist[v]의 의미</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dist</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">어떤</span> <span class="n">시작점으로부터</span>
          <span class="n">정점</span> <span class="n">v까지</span> <span class="n">도달할</span> <span class="n">수</span> <span class="n">있는</span> <span class="n">현재까지의</span> <span class="n">최소</span> <span class="n">비용</span>
</code></pre></div></div>

<p>※ 음수 사이클 탐지 문제에서는
dist의 <strong>정확한 값보다 ‘계속 줄어드는지 여부’</strong>가 더 중요하다.</p>

<hr />

<h2 id="-3️⃣-간선-완화relaxation">🔁 3️⃣ 간선 완화(Relaxation)</h2>

<h3 id="-간선-완화란">💡 간선 완화란?</h3>

<p><strong>“간선 u → v를 이용했을 때 더 짧은 경로가 생기면 dist[v]를 갱신하는 과정”</strong></p>

<h3 id="-완화-조건">💡 완화 조건</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">+</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">dist</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">dist</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">+</span> <span class="n">w</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="-왜-반복하는가">💡 왜 반복하는가?</h3>

<ul>
  <li>최단 경로는 최대 <strong>V-1개의 간선</strong>으로 구성됨</li>
  <li>한 번의 완화로는 정보가 충분히 퍼지지 않음</li>
  <li>그래서 <strong>모든 간선을 V-1번 반복해서 완화</strong></li>
</ul>

<hr />

<h2 id="️-4️⃣-음수-사이클-탐지-원리">⚠️ 4️⃣ 음수 사이클 탐지 원리</h2>

<h3 id="-핵심-아이디어">💡 핵심 아이디어</h3>

<ul>
  <li>정상적인 그래프라면
→ <strong>V-1번 완화 이후 더 이상 갱신이 발생하지 않음</strong></li>
  <li>그런데도
→ <strong>V번째 완화에서 갱신 발생?</strong>
→ <strong>음수 사이클 존재</strong></li>
</ul>

<h3 id="-의미-해석">💡 의미 해석</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"같은 경로를 계속 돌수록
비용이 줄어든다"
= 시간 여행이 가능한 루프
</code></pre></div></div>

<hr />

<h2 id="-5️⃣-코드-구현-구조-중심">🧩 5️⃣ 코드 구현 (구조 중심)</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="no">V</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="no">V</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 음수 사이클 발견</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>바깥 루프: <strong>반복 횟수 (라운드)</strong></li>
  <li>안쪽 루프: <strong>모든 간선 완화</strong></li>
  <li>V번째 라운드에서 갱신 발생 여부가 핵심</li>
</ul>

<hr />

<h2 id="️-6️⃣-시간복잡도와-공간복잡도">⏱️ 6️⃣ 시간복잡도와 공간복잡도</h2>

<ul>
  <li><strong>시간복잡도</strong>: O(VE)</li>
  <li><strong>공간복잡도</strong>: O(V)</li>
  <li>정점 수가 크고 간선이 많으면 느릴 수 있음</li>
</ul>

<hr />

<h2 id="️-7️⃣-다익스트라와의-비교">⚖️ 7️⃣ 다익스트라와의 비교</h2>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>벨만-포드</th>
      <th>다익스트라</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>음수 간선</td>
      <td>가능</td>
      <td>불가능</td>
    </tr>
    <tr>
      <td>음수 사이클</td>
      <td>탐지 가능</td>
      <td>불가</td>
    </tr>
    <tr>
      <td>시간복잡도</td>
      <td>느림</td>
      <td>빠름</td>
    </tr>
    <tr>
      <td>사용 목적</td>
      <td>안정성 / 사이클 판별</td>
      <td>빠른 최단경로</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-8️⃣-실전-문제-적용">🧪 8️⃣ 실전 문제 적용</h2>

<ul>
  <li><strong>웜홀 문제</strong></li>
  <li><strong>시간 여행 / 이익 루프 판별</strong></li>
  <li><strong>“되돌아왔을 때 더 이득인가?” 유형</strong></li>
</ul>

<p>👉 핵심 질문이
<strong>“최단거리”보다 “음수 사이클 존재 여부”</strong>라면
벨만-포드를 떠올려야 한다.</p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[벨만-포드 알고리즘에 대해 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자] 실시간 음성 매칭 서비스의 동시성 제어 - 비관적 락 적용기</title><link href="https://nan0silver.github.io/projectdiary/2026-01-22-diary/" rel="alternate" type="text/html" title="[친구하자] 실시간 음성 매칭 서비스의 동시성 제어 - 비관적 락 적용기" /><published>2026-01-22T00:00:00+00:00</published><updated>2026-02-18T07:00:01+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2026-01-22-diary/"><![CDATA[<blockquote>
  <p>동시 요청으로 통화가 두 번 종료되는 문제 해결하기..!</p>
</blockquote>

<ul>
  <li><a href="#서론">서론</a></li>
</ul>

<hr />

<h2 id="서론">서론</h2>

<p>이번 포스트에서는 제가 개발한 실시간 음성 매칭 서비스에서 발생한 동시성 문제를 해결하기 위해 <strong>비관적 락(Pessimistic Lock)</strong> 을 적용한 경험을 공유하고자 한다.</p>

<p>“동시에 두 요청이 들어오면 어떻게 될까?”</p>

<p>실시간 음성 매칭 플랫폼 “친구하자”를 개발하면서 이 질문에 직면했다. 특히 통화 종료는 Agora Cloud Recording 중지, Session 종료, 통화 기록 저장 등 여러 부수 효과를 동반하는 복잡하고 중요한 작업이였다.
초기에는 낙관적락(<code class="language-plaintext highlighter-rouge">@Version</code>)으로 동시성을 제어했다. 하지만 사용성테스트를 하면서 네트워크 불안정이나 사용자의 중복 클릭 등으로 동시 요청이 발생한 경우, 한 요청은 성공하고 다른 요청은 <code class="language-plaintext highlighter-rouge">OptimisticLockException</code>을 발생시키지만, 이미 Recording은 두번 중지 요청을 받은 후였다.</p>

<p>통화 종료는 단 한번만 수행되어야 하는 작업이기 때문에 이를 안전하게 처리할 수 있는 방법을 고민했다.
결국 “충돌이 일어나지 않도록 원천 차단”하는 <strong>비관적 락</strong>을 도입하기로 결정했다.</p>

<p>이 글에서는 두 락 방식의 차이와, 실제 프로젝트에서 비관적 락을 적용한 과정을 정리한다.</p>

<h2 id="1-락lock이란">1. 락(Lock)이란?</h2>

<p>여러 사용자가 동시에 같은 데이터를 수정하려 할 때 <strong>데이터 일관성</strong>을 보장하기 위한 메커니즘이다.</p>

<h3 id="실생활-비유">실생활 비유</h3>

<ul>
  <li><strong>비관적 락</strong>: 화장실 문을 잠그고 들어가기 (다른 사람은 기다려야 함)</li>
  <li><strong>낙관적 락</strong>: 화장실에 그냥 들어가되, 나올 때 다른 사람이 먼저 사용했는지 확인 (충돌 시 재시도)</li>
</ul>

<hr />

<h2 id="2-낙관적-락-optimistic-lock">2. 낙관적 락 (Optimistic Lock)</h2>

<h3 id="개념">개념</h3>

<p>“<strong>충돌은 드물게 일어날 것</strong>“이라고 가정하고, 실제 충돌이 발생했을 때만 처리합니다.</p>

<h3 id="동작-방식">동작 방식</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Call</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Version</span>  <span class="c1">// 👈 낙관적 락의 핵심</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">version</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">CallStatus</span> <span class="n">status</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>시나리오:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>시간 순서:
T1: User1이 Call 조회 (version=0, status=IN_PROGRESS)
T2: User2가 Call 조회 (version=0, status=IN_PROGRESS)
T3: User1이 status=COMPLETED 저장 (version=1로 증가) ✅ 성공
T4: User2가 status=COMPLETED 저장 시도
    → version=0으로 저장하려 함
    → DB의 version은 이미 1
    → OptimisticLockException 발생! ❌
</code></pre></div></div>

<h3 id="장점">장점</h3>

<ul>
  <li><strong>성능 우수</strong>: DB 락을 걸지 않아 대기 시간 없음</li>
  <li><strong>데드락 없음</strong>: 물리적 락이 없어 데드락 불가능</li>
  <li><strong>읽기 작업 많을 때 유리</strong></li>
</ul>

<h3 id="단점">단점</h3>

<ul>
  <li><strong>충돌 시 재시도 필요</strong>: 예외 발생 후 애플리케이션에서 재시도 로직 구현 필요</li>
  <li><strong>충돌 빈번하면 비효율적</strong>: 재시도가 많아지면 오히려 성능 저하</li>
</ul>

<h3 id="예제-코드">예제 코드</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">endCallWithOptimisticLock</span><span class="o">(</span><span class="nc">Long</span> <span class="n">callId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Call</span> <span class="n">call</span> <span class="o">=</span> <span class="n">callRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">callId</span><span class="o">).</span><span class="na">orElseThrow</span><span class="o">();</span>
        <span class="n">call</span><span class="o">.</span><span class="na">endCall</span><span class="o">();</span> <span class="c1">// status 변경</span>
        <span class="n">callRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">call</span><span class="o">);</span> <span class="c1">// version 자동 증가 체크</span>

    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">OptimisticLockException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 다른 사람이 먼저 수정함 → 재시도 필요</span>
        <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"낙관적 락 충돌 - 재시도 필요"</span><span class="o">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">CustomException</span><span class="o">(</span><span class="nc">ErrorCode</span><span class="o">.</span><span class="na">CONCURRENT_UPDATE</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="3-비관적-락-pessimistic-lock">3. 비관적 락 (Pessimistic Lock)</h2>

<h3 id="개념-1">개념</h3>

<p>“<strong>충돌이 자주 일어날 것</strong>“이라고 가정하고, 데이터를 읽는 순간부터 <strong>DB 레벨에서 락</strong>을 걸어 다른 트랜잭션의 접근을 차단합니다.</p>

<h3 id="동작-방식-1">동작 방식</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Lock</span><span class="o">(</span><span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMISTIC_WRITE</span><span class="o">)</span>
<span class="nd">@Query</span><span class="o">(</span><span class="s">"SELECT c FROM Call c WHERE c.id = :callId"</span><span class="o">)</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Call</span><span class="o">&gt;</span> <span class="nf">findByIdWithLock</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">"callId"</span><span class="o">)</span> <span class="nc">Long</span> <span class="n">callId</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>시나리오:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>시간 순서:
T1: User1이 Call 조회 + 락 획득 🔒 (status=IN_PROGRESS)
T2: User2가 Call 조회 시도
    → User1의 락 때문에 대기... ⏳
T3: User1이 status=COMPLETED 저장 후 커밋
    → 락 해제 🔓
T4: User2가 락 획득 🔒 (status=COMPLETED)
    → "이미 종료됨" 확인 후 종료
</code></pre></div></div>

<h3 id="종류">종류</h3>

<h4 id="pessimistic_read-공유-락-s-lock">PESSIMISTIC_READ (공유 락, S Lock)</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Lock</span><span class="o">(</span><span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMISTIC_READ</span><span class="o">)</span>
</code></pre></div></div>

<ul>
  <li><strong>읽기는 허용</strong>, 쓰기는 차단</li>
  <li>여러 트랜잭션이 동시에 읽기 가능</li>
  <li>하나라도 쓰기 시도하면 대기</li>
</ul>

<h4 id="pessimistic_write-배타-락-x-lock--주로-사용">PESSIMISTIC_WRITE (배타 락, X Lock) ⭐ 주로 사용</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Lock</span><span class="o">(</span><span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMISTIC_WRITE</span><span class="o">)</span>
</code></pre></div></div>

<ul>
  <li><strong>읽기/쓰기 모두 차단</strong></li>
  <li>완전히 독점적으로 사용</li>
  <li>상태 변경 작업에 적합</li>
</ul>

<h3 id="장점-1">장점</h3>

<ul>
  <li><strong>충돌 완전 방지</strong>: 동시 수정 100% 차단</li>
  <li><strong>재시도 불필요</strong>: 순차 처리로 예외 발생 안 함</li>
  <li><strong>쓰기 작업 많을 때 유리</strong></li>
</ul>

<h3 id="단점-1">단점</h3>

<ul>
  <li><strong>성능 저하</strong>: 락 대기 시간으로 응답 지연</li>
  <li><strong>데드락 가능성</strong>: 여러 리소스에 락 걸면 순환 대기 발생 가능</li>
  <li><strong>확장성 제한</strong>: 동시 처리량 감소</li>
</ul>

<h3 id="예제-코드-1">예제 코드</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">endCallWithPessimisticLock</span><span class="o">(</span><span class="nc">Long</span> <span class="n">callId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 🔒 이 순간 락 획득 - 다른 트랜잭션 대기</span>
    <span class="nc">Call</span> <span class="n">call</span> <span class="o">=</span> <span class="n">callRepository</span><span class="o">.</span><span class="na">findByIdWithLock</span><span class="o">(</span><span class="n">callId</span><span class="o">).</span><span class="na">orElseThrow</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">call</span><span class="o">.</span><span class="na">getCallStatus</span><span class="o">()</span> <span class="o">==</span> <span class="nc">CallStatus</span><span class="o">.</span><span class="na">COMPLETED</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 이미 종료됨 - 중복 요청 무시</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">call</span><span class="o">.</span><span class="na">endCall</span><span class="o">();</span> <span class="c1">// status 변경</span>
    <span class="n">callRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">call</span><span class="o">);</span>
    <span class="c1">// 🔓 커밋 시점에 락 해제</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="4-내-프로젝트-기존-코드-분석">4. 내 프로젝트 기존 코드 분석</h2>

<h3 id="기존-코드-문제점">기존 코드 (문제점)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// CallStatusService.java - 기존</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="nc">CallStatusResponse</span> <span class="nf">endCall</span><span class="o">(</span><span class="nc">Long</span> <span class="n">callId</span><span class="o">,</span> <span class="nc">Long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// ❌ 일반 조회 - 락 없음</span>
    <span class="nc">Call</span> <span class="n">call</span> <span class="o">=</span> <span class="n">callRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">callId</span><span class="o">)</span>
        <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">CustomException</span><span class="o">(</span><span class="nc">ErrorCode</span><span class="o">.</span><span class="na">CALL_NOT_FOUND</span><span class="o">));</span>

    <span class="c1">// ❌ 상태 체크만으로는 동시성 문제 해결 안 됨</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">call</span><span class="o">.</span><span class="na">getCallStatus</span><span class="o">()</span> <span class="o">==</span> <span class="nc">CallStatus</span><span class="o">.</span><span class="na">COMPLETED</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"이미 종료된 통화"</span><span class="o">);</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>

    <span class="n">callService</span><span class="o">.</span><span class="na">endCall</span><span class="o">(</span><span class="n">callId</span><span class="o">);</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="문제-시나리오">문제 시나리오</h3>

<p><strong>상황: User1과 User2가 거의 동시에 통화 종료 버튼 클릭</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>시간축:
─────────────────────────────────────────────────────
User1 Thread                 User2 Thread
─────────────────────────────────────────────────────
T1: findById(callId)
    → status=IN_PROGRESS
    → version=0
                              T2: findById(callId)
                                  → status=IN_PROGRESS
                                  → version=0

T3: if (status == COMPLETED)
    → false (통과)

                              T4: if (status == COMPLETED)
                                  → false (통과)

T5: call.endCall()
    → status=COMPLETED
    → version=1
    → save() ✅

                              T6: call.endCall()
                                  → status=COMPLETED
                                  → version=2
                                  → save() ✅
─────────────────────────────────────────────────────
</code></pre></div></div>

<h3 id="발생-가능한-문제들">발생 가능한 문제들</h3>

<h4 id="문제-1-중복-종료-처리">문제 1: 중복 종료 처리</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// User1의 call 객체: status=IN_PROGRESS (조회 시점)</span>
<span class="c1">// User2의 call 객체: status=IN_PROGRESS (조회 시점)</span>

<span class="c1">// 둘 다 검증 통과 → 둘 다 endCall() 실행</span>
<span class="c1">// 결과:</span>
<span class="c1">// - Recording 2번 중지 시도</span>
<span class="c1">// - Session 2번 업데이트 시도</span>
<span class="c1">// - 불필요한 리소스 낭비</span>
</code></pre></div></div>

<h4 id="문제-2-낙관적-락만으로는-불완전">문제 2: 낙관적 락만으로는 불완전</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Call</span> <span class="o">{</span>
    <span class="nd">@Version</span>  <span class="c1">// 낙관적 락은 있었음</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">version</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// User1: version=0 → 1로 저장 성공 ✅</span>
<span class="c1">// User2: version=0 → 저장 시도</span>
<span class="c1">//        → OptimisticLockException 발생! ❌</span>
<span class="c1">//        → 하지만 이미 Recording 중지 등의 부수 효과 발생됨</span>
</code></pre></div></div>

<h4 id="문제-3-endat-중복-설정">문제 3: endAt 중복 설정</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// User1이 먼저 저장</span>
<span class="n">call</span><span class="o">.</span><span class="na">endAt</span> <span class="o">=</span> <span class="mi">2025</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">22</span> <span class="mi">10</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mo">00</span>
<span class="n">call</span><span class="o">.</span><span class="na">durationSeconds</span> <span class="o">=</span> <span class="mi">120</span>

<span class="c1">// User2가 나중에 저장 (낙관적 락 실패 안 했다면)</span>
<span class="n">call</span><span class="o">.</span><span class="na">endAt</span> <span class="o">=</span> <span class="mi">2025</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">22</span> <span class="mi">10</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mo">01</span>  <span class="c1">// 1초 차이!</span>
<span class="n">call</span><span class="o">.</span><span class="na">durationSeconds</span> <span class="o">=</span> <span class="mi">121</span>  <span class="c1">// 잘못된 값</span>
</code></pre></div></div>

<hr />

<h2 id="5-비관적-락-적용-후-개선">5. 비관적 락 적용 후 개선</h2>

<h3 id="개선된-코드">개선된 코드</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// CallStatusService.java - 개선</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="nc">CallStatusResponse</span> <span class="nf">endCall</span><span class="o">(</span><span class="nc">Long</span> <span class="n">callId</span><span class="o">,</span> <span class="nc">Long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// ✅ 비관적 락으로 조회 - DB 레벨에서 락 획득</span>
    <span class="nc">Call</span> <span class="n">call</span> <span class="o">=</span> <span class="n">callRepository</span><span class="o">.</span><span class="na">findByIdWithLock</span><span class="o">(</span><span class="n">callId</span><span class="o">)</span>
        <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">CustomException</span><span class="o">(</span><span class="nc">ErrorCode</span><span class="o">.</span><span class="na">CALL_NOT_FOUND</span><span class="o">));</span>

    <span class="c1">// ✅ 이 시점에는 다른 트랜잭션이 접근 불가능</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">call</span><span class="o">.</span><span class="na">getCallStatus</span><span class="o">()</span> <span class="o">==</span> <span class="nc">CallStatus</span><span class="o">.</span><span class="na">COMPLETED</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"이미 종료된 통화 - 중복 요청 무시"</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">createResponse</span><span class="o">(</span><span class="n">call</span><span class="o">);</span> <span class="c1">// 바로 반환</span>
    <span class="o">}</span>

    <span class="n">callService</span><span class="o">.</span><span class="na">endCall</span><span class="o">(</span><span class="n">callId</span><span class="o">);</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="개선된-시나리오">개선된 시나리오</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>시간축:
─────────────────────────────────────────────────────
User1 Thread                 User2 Thread
─────────────────────────────────────────────────────
T1: findByIdWithLock(callId)
    🔒 락 획득
    → status=IN_PROGRESS
                              T2: findByIdWithLock(callId)
                                  ⏳ 대기... (락 때문에 블록)

T3: if (status == COMPLETED)
    → false (통과)

T4: call.endCall()
    → status=COMPLETED
    → save()

T5: 트랜잭션 커밋
    🔓 락 해제

                              T6: 🔒 락 획득 (대기 끝)
                                  → status=COMPLETED (이미 변경됨!)

                              T7: if (status == COMPLETED)
                                  → true
                                  → "이미 종료됨" 반환 ✅
                                  → 중복 처리 없음!
─────────────────────────────────────────────────────
</code></pre></div></div>

<h3 id="핵심-개선-사항">핵심 개선 사항</h3>

<h4 id="1-완전한-순차-처리">1. 완전한 순차 처리</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// User1: 락 획득 → 처리 → 커밋 → 락 해제</span>
<span class="c1">// User2: 대기 → 락 획득 → "이미 종료" 확인 → 종료</span>

<span class="c1">// 결과:</span>
<span class="c1">// ✅ Recording 1번만 중지</span>
<span class="c1">// ✅ Session 1번만 업데이트</span>
<span class="c1">// ✅ endAt 정확히 1번만 설정</span>
</code></pre></div></div>

<h4 id="2-예외-발생-없음">2. 예외 발생 없음</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 낙관적 락: OptimisticLockException 발생 → 재시도 로직 필요</span>
<span class="c1">// 비관적 락: 예외 없음 → 자연스럽게 순차 처리</span>
</code></pre></div></div>

<h4 id="3-데이터-무결성-보장">3. 데이터 무결성 보장</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// endAt: 2025-01-22 10:00:00 (정확히 1번만 설정)</span>
<span class="c1">// durationSeconds: 120 (정확한 값)</span>
<span class="c1">// callStatus: COMPLETED (명확한 상태)</span>
</code></pre></div></div>

<hr />

<h2 id="6-비관적-락--낙관적-락-이중-방어">6. 비관적 락 + 낙관적 락 이중 방어</h2>

<p>현재 코드는 <strong>둘 다 사용</strong>하고 있습니다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Call</span> <span class="o">{</span>
    <span class="nd">@Version</span>  <span class="c1">// 낙관적 락 (보험)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">version</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 비관적 락 (주 방어선)</span>
<span class="nc">Call</span> <span class="n">call</span> <span class="o">=</span> <span class="n">callRepository</span><span class="o">.</span><span class="na">findByIdWithLock</span><span class="o">(</span><span class="n">callId</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="이중-방어의-이유">이중 방어의 이유</h3>

<p><strong>시나리오: 개발자 실수로 일반 findById() 사용</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 실수로 락 없이 조회</span>
<span class="nc">Call</span> <span class="n">call</span> <span class="o">=</span> <span class="n">callRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">callId</span><span class="o">);</span>  <span class="c1">// ❌ 실수!</span>

<span class="c1">// 낙관적 락이 여전히 작동</span>
<span class="n">call</span><span class="o">.</span><span class="na">endCall</span><span class="o">();</span>
<span class="n">callRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">call</span><span class="o">);</span>
<span class="c1">// → 충돌 시 OptimisticLockException 발생 ✅</span>
</code></pre></div></div>

<hr />

<h2 id="7-언제-무엇을-사용할까">7. 언제 무엇을 사용할까?</h2>

<h3 id="낙관적-락-사용-사례">낙관적 락 사용 사례</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ 좋은 경우</span>
<span class="o">-</span> <span class="n">조회가</span> <span class="n">많고</span> <span class="n">수정이</span> <span class="n">적은</span> <span class="n">경우</span>
<span class="o">-</span> <span class="n">충돌이</span> <span class="n">거의</span> <span class="n">없는</span> <span class="n">경우</span>
<span class="o">-</span> <span class="n">성능이</span> <span class="n">최우선인</span> <span class="n">경우</span>

<span class="nl">예시:</span>
<span class="o">-</span> <span class="n">블로그</span> <span class="n">게시글</span> <span class="n">조회수</span> <span class="n">증가</span>
<span class="o">-</span> <span class="n">상품</span> <span class="n">상세</span> <span class="n">정보</span> <span class="n">조회</span>
<span class="o">-</span> <span class="n">사용자</span> <span class="n">프로필</span> <span class="n">업데이트</span>
</code></pre></div></div>

<h3 id="비관적-락-사용-사례">비관적 락 사용 사례</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ 좋은 경우</span>
<span class="o">-</span> <span class="n">충돌이</span> <span class="n">빈번한</span> <span class="n">경우</span>
<span class="o">-</span> <span class="n">데이터</span> <span class="n">정합성이</span> <span class="n">매우</span> <span class="n">중요한</span> <span class="n">경우</span>
<span class="o">-</span> <span class="n">재시도</span> <span class="n">로직</span> <span class="n">구현이</span> <span class="n">복잡한</span> <span class="n">경우</span>

<span class="nl">예시:</span>
<span class="o">-</span> <span class="n">재고</span> <span class="n">차감</span> <span class="o">(</span><span class="n">동시</span> <span class="n">주문</span><span class="o">)</span>
<span class="o">-</span> <span class="n">좌석</span> <span class="n">예약</span> <span class="o">(</span><span class="n">티케팅</span><span class="o">)</span>
<span class="o">-</span> <span class="n">통화</span> <span class="n">종료</span> <span class="o">(</span><span class="n">본</span> <span class="n">프로젝트</span><span class="o">)</span> <span class="err">⭐</span>
<span class="o">-</span> <span class="n">계좌</span> <span class="n">이체</span>
</code></pre></div></div>

<hr />

<h2 id="8-성능-비교">8. 성능 비교</h2>

<h3 id="응답-시간-예상">응답 시간 예상</h3>

<p><strong>낙관적 락 (충돌 없을 때)</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User1: 50ms (조회 10ms + 저장 40ms)
User2: 50ms (조회 10ms + 저장 40ms)
평균: 50ms ✅ 빠름
</code></pre></div></div>

<p><strong>낙관적 락 (충돌 발생 시)</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User1: 50ms (성공)
User2: 150ms (실패 50ms + 재시도 100ms)
평균: 100ms
</code></pre></div></div>

<p><strong>비관적 락</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User1: 50ms (조회+락 10ms + 처리 40ms)
User2: 100ms (락 대기 50ms + 처리 50ms)
평균: 75ms ⭐ 예측 가능
</code></pre></div></div>

<h3 id="내-프로젝트에서는">내 프로젝트에서는?</h3>

<p><strong>통화 종료는 비관적 락이 적합한 이유:</strong></p>

<ol>
  <li>⏰ <strong>충돌 빈도</strong>: 두 사용자가 거의 동시에 종료 버튼 클릭 가능성 높음</li>
  <li>💰 <strong>부수 효과</strong>: Recording 중지, Session 업데이트 등 비용 큰 작업</li>
  <li>🎯 <strong>재시도 불가</strong>: 통화 종료는 “한 번만” 처리되어야 함</li>
  <li>📊 <strong>데이터 정확성</strong>: endAt, durationSeconds 등 정확한 값 필수</li>
</ol>

<hr />

<h2 id="9-요약-비교표">9. 요약 비교표</h2>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>낙관적 락</th>
      <th>비관적 락</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>철학</strong></td>
      <td>충돌 드물 것</td>
      <td>충돌 많을 것</td>
    </tr>
    <tr>
      <td><strong>락 시점</strong></td>
      <td>커밋 시</td>
      <td>조회 시</td>
    </tr>
    <tr>
      <td><strong>DB 락</strong></td>
      <td>없음</td>
      <td>있음</td>
    </tr>
    <tr>
      <td><strong>충돌 처리</strong></td>
      <td>예외 + 재시도</td>
      <td>대기</td>
    </tr>
    <tr>
      <td><strong>성능</strong></td>
      <td>빠름 (충돌 없을 때)</td>
      <td>느림 (항상)</td>
    </tr>
    <tr>
      <td><strong>예측성</strong></td>
      <td>낮음</td>
      <td>높음</td>
    </tr>
    <tr>
      <td><strong>데드락</strong></td>
      <td>없음</td>
      <td>가능</td>
    </tr>
    <tr>
      <td><strong>사용 사례</strong></td>
      <td>조회 많음</td>
      <td>쓰기 많음</td>
    </tr>
  </tbody>
</table>

<p><strong>내 프로젝트 선택: 비관적 락 (PESSIMISTIC_WRITE)</strong></p>

<ul>
  <li>통화 종료는 충돌 가능성 높고</li>
  <li>정확성이 중요하며</li>
  <li>약간의 대기는 허용 가능</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[친구하자를 개발하면서 실시간 음성 매칭 서비스를 개발하면서 비관적 락을 적용하여 동시성을 처리했던 경험에 대해 정리했습니다.]]></summary></entry><entry><title type="html">[친구하자] WebSocket 메시지 핸들러 인증 문제 트러블슈팅 (@AuthenticationPrincipal와 SimpMessageHeaderAccessor)</title><link href="https://nan0silver.github.io/projectdiary/2026-01-19-diary/" rel="alternate" type="text/html" title="[친구하자] WebSocket 메시지 핸들러 인증 문제 트러블슈팅 (@AuthenticationPrincipal와 SimpMessageHeaderAccessor)" /><published>2026-01-19T00:00:00+00:00</published><updated>2026-02-18T07:00:01+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2026-01-19-diary/"><![CDATA[<ul>
  <li><a href="#-문제-발견-배경">문제 발견 배경</a></li>
  <li>
    <p><a href="#-근본-원인-분석">근본 원인 분석</a></p>

    <ul>
      <li><a href="#1-websocket-인증-흐름">1. WebSocket 인증 흐름</a></li>
      <li><a href="#2-authenticationprincipal의-동작-방식">2. <code class="language-plaintext highlighter-rouge">@AuthenticationPrincipal</code>의 동작 방식</a></li>
      <li><a href="#3-문제의-핵심-직렬화역직렬화">3. 문제의 핵심: 직렬화/역직렬화</a></li>
      <li><a href="#4-프로젝트-구현-특성">4. 프로젝트 구현 특성</a></li>
    </ul>
  </li>
  <li><a href="#-해결-방법">해결 방법</a></li>
  <li><a href="#-authenticationprincipal-vs-simpmessageheaderaccessor">@AuthenticationPrincipal vs SimpMessageHeaderAccessor</a></li>
  <li><a href="#-핵심-차이점">핵심 차이점</a></li>
  <li><a href="#-테스트-결과">테스트 결과</a></li>
  <li><a href="#-추가-개선-사항-선택">추가 개선 사항(선택)</a></li>
  <li><a href="#-참고-자료">참고자료</a></li>
  <li><a href="#-결론">결론</a></li>
</ul>

<hr />

<h2 id="-문제-발견-배경">📖 문제 발견 배경</h2>

<p>실시간 음성 매칭 서비스를 개발하던 중, 통화 중 브라우저를 새로고침했을 때 통화가 비정상적으로 종료되는 문제를 발견했다. 이를 해결하기 위해 Grace Period(유예 시간) 기능을 구현하여, 새로고침 후 30초 이내에 재접속하면 기존 통화를 복구할 수 있도록 했다.</p>

<p>Grace Period 기능 구현을 완료하고 서버를 재시작한 뒤, 통화 종료 기능을 테스트하는 순간 예상치 못한 <code class="language-plaintext highlighter-rouge">NullPointerException</code>이 발생했다. 🥲</p>

<p><strong>당황스러웠던 점은:</strong></p>

<ol>
  <li>서버 재시작 전까지는 정상적으로 작동했던 기능이었던 점</li>
  <li>WebSocket CONNECT 시점에는 인증이 완벽하게 성공했는데, MESSAGE 전송 시점에만 에러가 발생했던 점</li>
  <li>로그를 보니 <code class="language-plaintext highlighter-rouge">CustomUserDetails</code> 객체는 존재하는데 내부의 <code class="language-plaintext highlighter-rouge">user</code> 필드만 null이었던 점..</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WebSocket 연결 인증 성공 - userId: xxx  ✅
CustomUserDetails.user is null?: false  ✅
User ID: xxx  ✅

... (통화 종료 버튼 클릭)

User in UserDetails is null  ❌
NullPointerException: Cannot invoke "User.getId()" because "this.user" is null
</code></pre></div></div>

<p>코드를 변경한 것도 아닌데 갑자기 작동하지 않는 이 상황이 매우 혼란스러웠다.
이 글은 이 문제의 원인과 해결 과정을 정리한 트러블슈팅 문서이다.</p>

<hr />

<h2 id="-문제-상황">📋 문제 상황</h2>

<h3 id="증상">증상</h3>

<ul>
  <li>WebSocket CONNECT 시점: 인증 성공 ✅</li>
  <li>WebSocket MESSAGE 전송 시점: <code class="language-plaintext highlighter-rouge">NullPointerException</code> 발생 ❌
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java.lang.NullPointerException: Cannot invoke "com.ldsilver.chingoohaja.domain.user.User.getId()"
because "this.user" is null
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="에러-발생-코드">에러 발생 코드</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@MessageMapping</span><span class="o">(</span><span class="s">"/endpoint/{targetId}"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span>
    <span class="nd">@DestinationVariable</span> <span class="nc">Long</span> <span class="n">targetId</span><span class="o">,</span>
    <span class="nd">@Payload</span> <span class="nc">SomeMessage</span> <span class="n">message</span><span class="o">,</span>
    <span class="nd">@AuthenticationPrincipal</span> <span class="nc">CustomUserDetails</span> <span class="n">userDetails</span>  <span class="c1">// ❌ 문제 발생</span>
<span class="o">)</span> <span class="o">{</span>
    <span class="nc">Long</span> <span class="n">userId</span> <span class="o">=</span> <span class="n">userDetails</span><span class="o">.</span><span class="na">getUserId</span><span class="o">();</span>  <span class="c1">// NullPointerException 발생!</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="로그-분석">로그 분석</h3>

<p><strong>CONNECT 시점 (성공):</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WebSocket 연결 인증 성공 - userId: xxx
Principal is CustomUserDetails?: true
CustomUserDetails.user is null?: false  ✅
User ID: xxx
</code></pre></div></div>

<p><strong>MESSAGE 전송 시점 (실패):</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoking WebSocketController#handleMessage
User in UserDetails is null  ❌
NullPointerException: Cannot invoke "User.getId()" because "this.user" is null
</code></pre></div></div>

<hr />

<h2 id="-근본-원인-분석">🔍 근본 원인 분석</h2>

<h3 id="1-websocket-인증-흐름">1. WebSocket 인증 흐름</h3>

<h4 id="connect-단계">CONNECT 단계</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>클라이언트 CONNECT 요청
    ↓
JwtChannelInterceptor.preSend() 실행
    ↓
토큰 검증 및 User 조회
    ↓
CustomUserDetails 생성 (user 필드 포함)
    ↓
UsernamePasswordAuthenticationToken 생성
    ↓
WebSocket 세션에 Authentication 저장
</code></pre></div></div>

<p>이 시점에는 <code class="language-plaintext highlighter-rouge">CustomUserDetails.user</code>가 <strong>정상적으로 존재</strong></p>

<h4 id="message-전송-단계">MESSAGE 전송 단계</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>클라이언트 MESSAGE 전송
    ↓
Spring이 세션에서 Authentication 조회
    ↓
@AuthenticationPrincipal로 Principal 주입
    ↓
??? CustomUserDetails.user가 null ???
</code></pre></div></div>

<h3 id="2-authenticationprincipal의-동작-방식">2. <code class="language-plaintext highlighter-rouge">@AuthenticationPrincipal</code>의 동작 방식</h3>

<p><code class="language-plaintext highlighter-rouge">@AuthenticationPrincipal</code>는 내부적으로 다음과 같이 동작한다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Spring Security 내부 동작 (의사 코드)</span>
<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">resolveArgument</span><span class="o">(</span><span class="nc">MethodParameter</span> <span class="n">parameter</span><span class="o">,</span> <span class="o">...)</span> <span class="o">{</span>
    <span class="nc">Authentication</span> <span class="n">authentication</span> <span class="o">=</span> <span class="nc">SecurityContextHolder</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getAuthentication</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">authentication</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nc">Object</span> <span class="n">principal</span> <span class="o">=</span> <span class="n">authentication</span><span class="o">.</span><span class="na">getPrincipal</span><span class="o">();</span>

    <span class="c1">// 🔥 문제: principal이 직렬화/역직렬화되었을 수 있음</span>
    <span class="c1">// 🔥 WebSocket 세션 저장소(Redis, 메모리)에서 복원될 때 문제 발생 가능</span>

    <span class="k">return</span> <span class="n">principal</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="3-문제의-핵심-직렬화역직렬화">3. 문제의 핵심: 직렬화/역직렬화</h3>

<p>WebSocket 세션은 메모리나 Redis에 저장될 수 있으며, 이 과정에서:</p>

<ol>
  <li><strong>CONNECT 시점</strong>: <code class="language-plaintext highlighter-rouge">CustomUserDetails</code> 객체가 생성되고 세션에 저장
    <ul>
      <li><code class="language-plaintext highlighter-rouge">User user</code> 필드가 JPA 엔티티로 완전히 로드됨</li>
    </ul>
  </li>
  <li><strong>MESSAGE 전송 시점</strong>: 세션에서 <code class="language-plaintext highlighter-rouge">Authentication</code> 객체 복원
    <ul>
      <li>직렬화/역직렬화 과정에서 <code class="language-plaintext highlighter-rouge">User</code> 객체가 제대로 복원되지 않음</li>
      <li>또는 세션 스토리지가 얕은 복사만 수행</li>
      <li><strong>결과</strong>: <code class="language-plaintext highlighter-rouge">CustomUserDetails.user == null</code></li>
    </ul>
  </li>
</ol>

<h3 id="4-프로젝트-구현-특성">4. 프로젝트 구현 특성</h3>

<h4 id="customuserdetails-구조">CustomUserDetails 구조</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomUserDetails</span> <span class="kd">implements</span> <span class="nc">UserDetails</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">User</span> <span class="n">user</span><span class="o">;</span>  <span class="c1">// JPA Entity</span>

    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">getUserId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">user</span><span class="o">.</span><span class="na">getId</span><span class="o">();</span>  <span class="c1">// user가 null이면 NPE 발생!</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getUsername</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>  <span class="c1">// userId를 String으로 저장</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="user-엔티티">User 엔티티</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="c1">// ... 다양한 필드들</span>
    <span class="c1">// Serializable 구현되지 않음 (문제 요인 중 하나)</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="jwtchannelinterceptor">JwtChannelInterceptor</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">Authentication</span> <span class="nf">authenticateToken</span><span class="o">(</span><span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Long</span> <span class="n">userId</span> <span class="o">=</span> <span class="n">jwtTokenProvider</span><span class="o">.</span><span class="na">getUserIdFromToken</span><span class="o">(</span><span class="n">token</span><span class="o">);</span>
    <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">userId</span><span class="o">).</span><span class="na">orElseThrow</span><span class="o">(...);</span>

    <span class="nc">CustomUserDetails</span> <span class="n">userDetails</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CustomUserDetails</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>

    <span class="c1">// UsernamePasswordAuthenticationToken 생성</span>
    <span class="c1">// 이 객체가 WebSocket 세션에 저장됨</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">UsernamePasswordAuthenticationToken</span><span class="o">(</span>
        <span class="n">userDetails</span><span class="o">,</span>  <span class="c1">// principal</span>
        <span class="kc">null</span><span class="o">,</span>
        <span class="n">userDetails</span><span class="o">.</span><span class="na">getAuthorities</span><span class="o">()</span>
    <span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="-해결-방법">✅ 해결 방법</h2>

<h3 id="simpmessageheaderaccessor-사용">SimpMessageHeaderAccessor 사용</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@MessageMapping</span><span class="o">(</span><span class="s">"/endpoint/{targetId}"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span>
    <span class="nd">@DestinationVariable</span> <span class="nc">Long</span> <span class="n">targetId</span><span class="o">,</span>
    <span class="nd">@Payload</span> <span class="nc">SomeMessage</span> <span class="n">message</span><span class="o">,</span>
    <span class="nc">SimpMessageHeaderAccessor</span> <span class="n">headerAccessor</span>  <span class="c1">// ✅ 변경</span>
<span class="o">)</span> <span class="o">{</span>
    <span class="nc">Long</span> <span class="n">userId</span> <span class="o">=</span> <span class="n">extractUserIdFromPrincipal</span><span class="o">(</span><span class="n">headerAccessor</span><span class="o">);</span>
    <span class="c1">// ...</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="nc">Long</span> <span class="nf">extractUserIdFromPrincipal</span><span class="o">(</span><span class="nc">SimpMessageHeaderAccessor</span> <span class="n">headerAccessor</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Principal</span> <span class="n">principal</span> <span class="o">=</span> <span class="n">headerAccessor</span><span class="o">.</span><span class="na">getUser</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">principal</span> <span class="k">instanceof</span> <span class="nc">Authentication</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Authentication</span> <span class="n">auth</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Authentication</span><span class="o">)</span> <span class="n">principal</span><span class="o">;</span>
        <span class="nc">Object</span> <span class="n">principalObj</span> <span class="o">=</span> <span class="n">auth</span><span class="o">.</span><span class="na">getPrincipal</span><span class="o">();</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">principalObj</span> <span class="k">instanceof</span> <span class="nc">CustomUserDetails</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">CustomUserDetails</span> <span class="n">userDetails</span> <span class="o">=</span> <span class="o">(</span><span class="nc">CustomUserDetails</span><span class="o">)</span> <span class="n">principalObj</span><span class="o">;</span>

            <span class="c1">// user가 null이어도 username(=userId)에서 추출 가능</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">userDetails</span><span class="o">.</span><span class="na">getUser</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">userDetails</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">userDetails</span><span class="o">.</span><span class="na">getUserId</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="-authenticationprincipal-vs-simpmessageheaderaccessor">🔬 @AuthenticationPrincipal vs SimpMessageHeaderAccessor</h2>

<h3 id="authenticationprincipal-방식">@AuthenticationPrincipal 방식</h3>

<h4 id="장점">장점</h4>

<ul>
  <li>✅ 코드가 간결함</li>
  <li>✅ Spring Security의 표준 방식</li>
  <li>✅ HTTP 요청에서 잘 작동</li>
</ul>

<h4 id="단점">단점</h4>

<ul>
  <li>❌ WebSocket 세션 관리에서 불안정</li>
  <li>❌ 직렬화/역직렬화 이슈에 취약</li>
  <li>❌ Principal 객체의 내부 필드가 null일 수 있음</li>
  <li>❌ 디버깅이 어려움 (Spring이 자동으로 주입)</li>
</ul>

<h4 id="동작-방식">동작 방식</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Spring이 내부적으로 수행</span>
<span class="nc">Authentication</span> <span class="n">auth</span> <span class="o">=</span> <span class="nc">SecurityContextHolder</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getAuthentication</span><span class="o">();</span>
<span class="nc">CustomUserDetails</span> <span class="n">principal</span> <span class="o">=</span> <span class="o">(</span><span class="nc">CustomUserDetails</span><span class="o">)</span> <span class="n">auth</span><span class="o">.</span><span class="na">getPrincipal</span><span class="o">();</span>

<span class="c1">// 🔥 이 principal이 직렬화/역직렬화를 거쳤을 수 있음</span>
<span class="c1">// 🔥 user 필드가 null일 가능성</span>
</code></pre></div></div>

<h3 id="simpmessageheaderaccessor-방식">SimpMessageHeaderAccessor 방식</h3>

<h4 id="장점-1">장점</h4>

<ul>
  <li>✅ WebSocket 메시지의 실제 Principal에 직접 접근</li>
  <li>✅ 직렬화 이슈 회피 (Principal 객체를 직접 다룸)</li>
  <li>✅ null 체크 및 fallback 로직 구현 가능</li>
  <li>✅ 디버깅 용이 (명시적인 코드)</li>
</ul>

<h4 id="단점-1">단점</h4>

<ul>
  <li>❌ 코드가 다소 길어짐</li>
  <li>❌ 헬퍼 메서드 필요</li>
</ul>

<h4 id="동작-방식-1">동작 방식</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 직접 메시지 헤더에서 Principal 추출</span>
<span class="nc">Principal</span> <span class="n">principal</span> <span class="o">=</span> <span class="n">headerAccessor</span><span class="o">.</span><span class="na">getUser</span><span class="o">();</span>

<span class="c1">// 이 principal은 JwtChannelInterceptor에서</span>
<span class="c1">// accessor.setUser(authentication)으로 설정한 바로 그 객체</span>
<span class="c1">// 중간에 직렬화/역직렬화를 거치지 않음 (같은 요청 컨텍스트 내)</span>
</code></pre></div></div>

<hr />

<h2 id="-핵심-차이점">🎯 핵심 차이점</h2>

<h3 id="인증-정보-조회-경로">인증 정보 조회 경로</h3>

<p><strong>@AuthenticationPrincipal:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WebSocket 세션 스토리지 (메모리/Redis)
    ↓
직렬화된 Authentication 객체
    ↓
역직렬화 (문제 발생 가능)
    ↓
SecurityContext
    ↓
@AuthenticationPrincipal 주입
</code></pre></div></div>

<p><strong>SimpMessageHeaderAccessor:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>현재 메시지의 StompHeaderAccessor
    ↓
직접 Principal 조회
    ↓
명시적 타입 체크 및 변환
    ↓
안전한 userId 추출
</code></pre></div></div>

<h3 id="세션-관리-관점">세션 관리 관점</h3>

<table>
  <thead>
    <tr>
      <th>측면</th>
      <th>@AuthenticationPrincipal</th>
      <th>SimpMessageHeaderAccessor</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>직렬화 의존성</td>
      <td>높음</td>
      <td>낮음</td>
    </tr>
    <tr>
      <td>세션 저장소 영향</td>
      <td>영향 받음</td>
      <td>영향 적음</td>
    </tr>
    <tr>
      <td>JPA 엔티티 문제</td>
      <td>발생 가능</td>
      <td>회피 가능</td>
    </tr>
    <tr>
      <td>Lazy Loading</td>
      <td>문제 가능</td>
      <td>문제 없음</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-테스트-결과">🧪 테스트 결과</h2>

<h3 id="before-문제-발생">Before (문제 발생)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WebSocket CONNECT: ✅ 성공
WebSocket MESSAGE: ❌ NullPointerException
</code></pre></div></div>

<h3 id="after-해결">After (해결)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WebSocket CONNECT: ✅ 성공
WebSocket MESSAGE: ✅ 성공
userId 추출: ✅ 성공
메시지 처리: ✅ 성공
</code></pre></div></div>

<hr />

<h2 id="-추가-개선-사항-선택">💡 추가 개선 사항 (선택)</h2>

<h3 id="1-user-엔티티를-serializable로-만들기">1. User 엔티티를 Serializable로 만들기</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2-customuserdetails를-serializable로-만들기">2. CustomUserDetails를 Serializable로 만들기</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomUserDetails</span> <span class="kd">implements</span> <span class="nc">UserDetails</span><span class="o">,</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">User</span> <span class="n">user</span><span class="o">;</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="3-websocket-세션-관리-개선">3. WebSocket 세션 관리 개선</h3>

<ul>
  <li>Redis를 사용한다면 직렬화 설정 최적화</li>
  <li>세션 타임아웃 설정 검토</li>
  <li>재연결 시 인증 갱신 로직 구현</li>
</ul>

<hr />

<h2 id="-참고-자료">📚 참고 자료</h2>

<ul>
  <li>Spring WebSocket Documentation: https://docs.spring.io/spring-framework/reference/web/websocket.html</li>
  <li>Spring Security WebSocket Support: https://docs.spring.io/spring-security/reference/servlet/integrations/websocket.html</li>
  <li>STOMP Protocol Specification: https://stomp.github.io/</li>
</ul>

<hr />

<h2 id="-결론">🏁 결론</h2>

<p>WebSocket 환경에서는 HTTP 요청과 달리 <strong>세션 관리 및 직렬화 이슈</strong>가 발생할 수 있다.</p>

<p>특히 <code class="language-plaintext highlighter-rouge">@AuthenticationPrincipal</code>은 편리하지만 WebSocket 세션 저장소를 거치면서 <strong>Principal 객체의 내부 상태가 손실될 위험</strong>이 있다.</p>

<p><code class="language-plaintext highlighter-rouge">SimpMessageHeaderAccessor</code>를 사용하면:</p>

<ul>
  <li>✅ 직접 Principal에 접근하여 안정성 확보</li>
  <li>✅ null 체크 및 fallback 로직 구현 가능</li>
  <li>✅ 명시적 코드로 디버깅 용이</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[친구하자를 개발하면서 통화 중 에러를 처리하던 중 발견한 WebSocket 메시지 핸들러 인증 문제 트러블슈팅입니다.]]></summary></entry><entry><title type="html">[친구하자] SSL 인증서 자동 갱신 설정하기 (Amazon Linux + Let’s Encrypt)</title><link href="https://nan0silver.github.io/projectdiary/2026-01-12-diary/" rel="alternate" type="text/html" title="[친구하자] SSL 인증서 자동 갱신 설정하기 (Amazon Linux + Let’s Encrypt)" /><published>2026-01-12T00:00:00+00:00</published><updated>2026-02-18T07:00:01+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2026-01-12-diary/"><![CDATA[<ul>
  <li><a href="#문제-상황">문제 상황</a></li>
  <li><a href="#ssl-인증서란">SSL 인증서란?</a></li>
  <li><a href="#lets-encrypt와-90일-갱신-주기">Let’s Encrypt와 90일 갱신 주기</a></li>
  <li><a href="#해결-과정">해결 과정</a></li>
</ul>

<hr />

<h2 id="문제-상황">문제 상황</h2>

<p>프로덕션 환경에서 갑자기 로그인이 안 되는 문제가 발생했다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET https://{backend-domain}/api/v1/auth/oauth/kakao/config?platform=web
net::ERR_CERT_DATE_INVALID
</code></pre></div></div>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2026-01-11-pic1.png?raw=true" alt="에러 이미지1" /></p>

<p>브라우저 콘솔에 찍힌 에러 메시지를 보니 <code class="language-plaintext highlighter-rouge">ERR_CERT_DATE_INVALID</code> - SSL 인증서 날짜가 유효하지 않다는 것이었다.</p>

<h2 id="ssl-인증서란">SSL 인증서란?</h2>

<p>SSL(Secure Sockets Layer) 인증서는 웹사이트와 사용자 브라우저 간의 통신을 암호화하는 디지털 인증서이다.
HTTPS 통신을 위해서는 반드시 필요하며, 다음과 같은 역할을 한다:</p>

<ul>
  <li><strong>데이터 암호화</strong>: 사용자와 서버 간 주고받는 데이터를 암호화</li>
  <li><strong>신원 검증</strong>: 해당 도메인이 인증된 소유자에 의해 운영됨을 증명</li>
  <li><strong>데이터 무결성</strong>: 전송 중 데이터가 변조되지 않았음을 보장</li>
</ul>

<p>특히 OAuth 로그인 같은 민감한 정보를 다루는 경우, 카카오나 구글 같은 OAuth 제공자들은 <strong>HTTPS를 필수</strong>로 요구한다.</p>

<h2 id="lets-encrypt와-90일-갱신-주기">Let’s Encrypt와 90일 갱신 주기</h2>

<p>Let’s Encrypt는 무료로 SSL 인증서를 발급해주는 비영리 인증 기관이다. 하지만 한 가지 특징이 있다:</p>

<p><strong>인증서 유효기간이 90일</strong></p>

<p>왜 90일일까?</p>

<ol>
  <li><strong>보안 강화</strong>: 인증서가 탈취되더라도 피해 기간이 짧음</li>
  <li><strong>자동화 유도</strong>: 수동 갱신이 번거로워 자동화를 강제함</li>
  <li><strong>키 교체 주기</strong>: 정기적인 키 교체로 보안성 향상</li>
</ol>

<p>일반 상용 인증서는 1년 단위인데, Let’s Encrypt는 무료 대신 짧은 주기로 설정했다.
결과적으로 <strong>자동 갱신 설정</strong>이 필요했다.</p>

<h2 id="해결-과정">해결 과정</h2>

<h3 id="1-즉시-인증서-갱신">1. 즉시 인증서 갱신</h3>

<p>먼저 만료된 인증서를 갱신해서 서비스를 복구했다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># EC2 서버에 SSH 접속</span>
ssh <span class="nt">-i</span> ~/.ssh/your-key.pem ec2-user@<span class="o">{</span>backend-domain<span class="o">}</span>

<span class="c"># 인증서 확인</span>
<span class="nb">sudo </span>certbot certificates
</code></pre></div></div>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2026-01-11-pic2.png?raw=true" alt="에러 이미지2" /></p>

<ul>
  <li>인증서를 확인하니 어제자로 만료된 것을 확인했다. (오늘은 1월 12일)</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 인증서 갱신</span>
<span class="nb">sudo </span>certbot renew

<span class="c"># Nginx 재시작</span>
<span class="nb">sudo </span>systemctl reload nginx
</code></pre></div></div>

<h3 id="2-자동-갱신-설정">2. 자동 갱신 설정</h3>

<p>하지만 90일마다 수동으로 갱신할 수는 없다고 생각해, cron을 이용해 자동 갱신을 설정했다.</p>

<h4 id="amazon-linux에서-cron-설치">Amazon Linux에서 cron 설치</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># cronie 패키지 설치</span>
<span class="nb">sudo </span>yum <span class="nb">install </span>cronie

<span class="c"># crond 서비스 시작 및 활성화</span>
<span class="nb">sudo </span>systemctl start crond
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>crond

<span class="c"># 상태 확인</span>
<span class="nb">sudo </span>systemctl status crond
</code></pre></div></div>

<p><strong>주의</strong>: Amazon Linux는 <code class="language-plaintext highlighter-rouge">cron</code>이 아니라 <code class="language-plaintext highlighter-rouge">crond</code>를 사용!</p>

<h4 id="crontab-설정">crontab 설정</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># root 계정의 crontab 편집</span>
<span class="nb">sudo </span>crontab <span class="nt">-e</span>
</code></pre></div></div>

<p>다음 내용을 추가한다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 2 * * * /usr/bin/certbot renew --quiet --post-hook "systemctl reload nginx"
</code></pre></div></div>

<p><strong>설정 의미:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0 2 * * *</code>: 매일 새벽 2시에 실행</li>
  <li><code class="language-plaintext highlighter-rouge">certbot renew</code>: 인증서 갱신 체크 (30일 이내 만료 시 자동 갱신)</li>
  <li><code class="language-plaintext highlighter-rouge">--quiet</code>: 출력 최소화</li>
  <li><code class="language-plaintext highlighter-rouge">--post-hook</code>: 갱신 성공 시 Nginx 재시작</li>
</ul>

<p>저장하고 종료:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i           # 입력 모드
(내용 입력)
ESC         # 명령 모드
:wq         # 저장 후 종료
</code></pre></div></div>

<h3 id="3-설정-확인">3. 설정 확인</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># crontab 목록 확인</span>
<span class="nb">sudo </span>crontab <span class="nt">-l</span>

<span class="c"># 갱신 테스트 (실제 갱신 없이 시뮬레이션)</span>
<span class="nb">sudo </span>certbot renew <span class="nt">--dry-run</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">--dry-run</code>으로 테스트하면 실제 갱신 없이 프로세스가 정상 작동하는지 확인할 수 있다.</p>

<h2 id="작동-원리">작동 원리</h2>

<p>설정 후 시스템은 다음과 같이 동작한다:</p>

<ol>
  <li><strong>매일 새벽 2시</strong>, cron이 <code class="language-plaintext highlighter-rouge">certbot renew</code> 실행</li>
  <li>certbot이 인증서 만료일 체크</li>
  <li><strong>만료 30일 이내</strong>인 경우에만 실제 갱신 진행</li>
  <li>갱신 성공 시 자동으로 Nginx 재시작</li>
  <li>갱신 불필요 시 조용히 종료</li>
</ol>

<p>즉, 설정만 해두면 <strong>완전 자동으로</strong> 인증서가 관리된다.</p>

<h2 id="결론">결론</h2>

<p>SSL 인증서 만료로 인한 서비스 장애는 치명적이다. 특히 OAuth 인증을 사용하는 서비스에서는 로그인 자체가 불가능해잔다.</p>

<p>Let’s Encrypt를 사용한다면:</p>

<ul>
  <li>✅ cron 자동 갱신 설정은 필수</li>
  <li>✅ <code class="language-plaintext highlighter-rouge">--dry-run</code>으로 정기적으로 테스트</li>
  <li>✅ 갱신 실패 시 알림 설정 권장 (이메일 등)</li>
</ul>

<p>90일마다 수동 갱신하는 것보다, 한 번 제대로 자동화 설정해두는 것이 훨씬 안전하고 편리하다.</p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://letsencrypt.org/docs/">Let’s Encrypt 공식 문서</a></li>
  <li><a href="https://certbot.eff.org/">Certbot 사용 가이드</a></li>
  <li><a href="https://docs.aws.amazon.com/linux/">Amazon Linux cron 설정</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[SSH 인증서가 만료되어 이에 대해 공부한 내용과 해결한 내용에 대해 정리했습니다.]]></summary></entry><entry><title type="html">[Algorithm] 코딩테스트 알고리즘 선택방법 요약</title><link href="https://nan0silver.github.io/algorithm/2026-01-09-summary/" rel="alternate" type="text/html" title="[Algorithm] 코딩테스트 알고리즘 선택방법 요약" /><published>2026-01-09T00:00:00+00:00</published><updated>2026-02-18T07:00:01+00:00</updated><id>https://nan0silver.github.io/algorithm/summary</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2026-01-09-summary/"><![CDATA[<p>코딩테스트에서 어떤 알고리즘을 선택해야 할지 고민될 때가 많다.
이 글에서는 <strong>코테 기준으로 딱 필요한 만큼만</strong> 정리한다.</p>

<hr />

<h2 id="1️⃣-문제를-읽자마자-던질-5가지-질문">1️⃣ 문제를 읽자마자 던질 5가지 질문</h2>

<table>
  <thead>
    <tr>
      <th>순서</th>
      <th>스스로에게 묻는 질문</th>
      <th>YES면</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Q1</td>
      <td>최단 거리 / 최소 횟수인가?</td>
      <td>👉 아래 Q2</td>
    </tr>
    <tr>
      <td>Q2</td>
      <td>모든 간선 가중치가 같은가?</td>
      <td>👉 <strong>BFS</strong></td>
    </tr>
    <tr>
      <td>Q3</td>
      <td>가중치가 다르지만 음수는 없는가?</td>
      <td>👉 <strong>다익스트라</strong></td>
    </tr>
    <tr>
      <td>Q4</td>
      <td>모든 쌍 (i, j) 최단거리인가?</td>
      <td>👉 <strong>플로이드-워셜</strong></td>
    </tr>
    <tr>
      <td>Q5</td>
      <td>트리(사이클 없음)인가?</td>
      <td>👉 <strong>DFS / 트리 DP</strong></td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="2️⃣-bfs--dfs--다익스트라--플로이드-비교표">2️⃣ BFS / DFS / 다익스트라 / 플로이드 비교표</h2>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>BFS</th>
      <th>DFS</th>
      <th>다익스트라</th>
      <th>플로이드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>목적</td>
      <td>최단 거리(가중치=1)</td>
      <td>탐색/구조</td>
      <td>최단 거리(가중치≠1)</td>
      <td>모든 쌍 최단</td>
    </tr>
    <tr>
      <td>자료구조</td>
      <td>Queue</td>
      <td>재귀 / Stack</td>
      <td>PriorityQueue</td>
      <td>2차원 배열</td>
    </tr>
    <tr>
      <td>시간복잡도</td>
      <td>O(N+M)</td>
      <td>O(N+M)</td>
      <td>O((N+M)logN)</td>
      <td>O(N³)</td>
    </tr>
    <tr>
      <td>거리 배열</td>
      <td>O</td>
      <td>△</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>visited</td>
      <td>O</td>
      <td>O</td>
      <td>△</td>
      <td>X</td>
    </tr>
    <tr>
      <td>대표 문제</td>
      <td>미로, 숨바꼭질</td>
      <td>트리 지름</td>
      <td>최단 비용</td>
      <td>플로이드</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="3️⃣-가중치로-바로-고르는-공식-암기용">3️⃣ “가중치”로 바로 고르는 공식 (암기용)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>최단 거리 + 가중치 = 1  → BFS
최단 거리 + 가중치 다름 → 다익스트라
모든 쌍 최단 거리      → 플로이드
</code></pre></div></div>

<hr />

<h2 id="4️⃣-트리가-나오면-이렇게-생각하자">4️⃣ “트리”가 나오면 이렇게 생각하자</h2>

<table>
  <thead>
    <tr>
      <th>문제 키워드</th>
      <th>거의 정답</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>트리 / 부모 / 자식</td>
      <td>DFS</td>
    </tr>
    <tr>
      <td>가장 긴 경로</td>
      <td>트리 지름</td>
    </tr>
    <tr>
      <td>서브트리</td>
      <td>트리 DP</td>
    </tr>
    <tr>
      <td>루트가 있음</td>
      <td>DFS</td>
    </tr>
    <tr>
      <td>간선 = 노드 - 1</td>
      <td>트리</td>
    </tr>
  </tbody>
</table>

<p>👉 <strong>트리 = DFS 기본값</strong></p>

<hr />

<h2 id="5️⃣-인접-리스트-vs-인접-행렬-선택표">5️⃣ 인접 리스트 vs 인접 행렬 선택표</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>선택</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>N ≥ 1,000</td>
      <td>인접 리스트</td>
    </tr>
    <tr>
      <td>BFS / DFS / 다익스트라</td>
      <td>인접 리스트</td>
    </tr>
    <tr>
      <td>플로이드-워셜</td>
      <td>인접 행렬</td>
    </tr>
    <tr>
      <td>메모리 제한 빡빡</td>
      <td>인접 리스트</td>
    </tr>
  </tbody>
</table>

<p><strong>코테 기본값</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;[]</span> <span class="n">graph</span><span class="o">;</span>
</code></pre></div></div>

<hr />

<h2 id="6️⃣-문제-문장--알고리즘-자동-변환-예시">6️⃣ 문제 문장 → 알고리즘 자동 변환 예시</h2>

<table>
  <thead>
    <tr>
      <th>문제 문장</th>
      <th>바로 떠올릴 것</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>“최소 몇 번 만에”</td>
      <td>BFS</td>
    </tr>
    <tr>
      <td>“최소 비용”</td>
      <td>다익스트라</td>
    </tr>
    <tr>
      <td>“모든 도시 쌍”</td>
      <td>플로이드</td>
    </tr>
    <tr>
      <td>“가장 긴 경로”</td>
      <td>트리 지름</td>
    </tr>
    <tr>
      <td>“연결되어 있는가”</td>
      <td>DFS/BFS</td>
    </tr>
    <tr>
      <td>“K 거리인 노드”</td>
      <td>BFS</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="7️⃣-실전에서-쓰는-판별-한-줄-공식">7️⃣ 실전에서 쓰는 <strong>판별 한 줄 공식</strong></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>최단 거리인가?
→ 가중치가 전부 1인가?
  → YES: BFS
  → NO : 다익스트라
트리인가?
→ DFS / 트리 DP
</code></pre></div></div>

<hr />

<h2 id="8️⃣-너가-자주-헷갈리던-문제들-정답-알고리즘">8️⃣ 너가 자주 헷갈리던 문제들, 정답 알고리즘</h2>

<table>
  <thead>
    <tr>
      <th>문제</th>
      <th>정답 알고리즘</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>특정 거리의 도시 찾기</td>
      <td>BFS</td>
    </tr>
    <tr>
      <td>숨바꼭질</td>
      <td>BFS</td>
    </tr>
    <tr>
      <td>트리의 지름</td>
      <td>DFS (2번 or DP)</td>
    </tr>
    <tr>
      <td>거짓말</td>
      <td>DSU / BFS</td>
    </tr>
    <tr>
      <td>치킨 배달</td>
      <td>조합 + 거리 계산</td>
    </tr>
    <tr>
      <td>플로이드</td>
      <td>플로이드-워셜</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-최종-요약-이-문장만-외워도-됨">🎯 최종 요약 (이 문장만 외워도 됨)</h2>

<blockquote>
  <p><strong>“알고리즘은 외우는 게 아니라,
문제 조건으로 제거하고 남는 하나를 고르는 것”</strong></p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[코딩테스트 알고리즘 선택 방법에 대해 정리해보았습니다.]]></summary></entry><entry><title type="html">[Algorithm] 플로이드-워셜 알고리즘</title><link href="https://nan0silver.github.io/algorithm/2025-12-29-floyd-warshall/" rel="alternate" type="text/html" title="[Algorithm] 플로이드-워셜 알고리즘" /><published>2025-12-29T00:00:00+00:00</published><updated>2026-02-18T07:00:01+00:00</updated><id>https://nan0silver.github.io/algorithm/floyd-warshall</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2025-12-29-floyd-warshall/"><![CDATA[<ol>
  <li><a href="#-1️⃣-플로이드-워셜이란">플로이드-워셜이란?</a></li>
  <li><a href="#-2️⃣-핵심-개념-이해하기">핵심 개념 이해하기</a></li>
  <li><a href="#-3️⃣-k-i-j의-정확한-의미">k, i, j의 의미</a></li>
  <li><a href="#-4️⃣-동작-과정-시각화">동작 과정 시각화</a></li>
  <li><a href="#-5️⃣-코드-구현">코드 구현</a></li>
  <li><a href="#-6️⃣-시간복잡도와-공간복잡도">시간복잡도와 공간복잡도</a></li>
  <li><a href="#-7️⃣-다익스트라와의-비교">다익스트라와의 비교</a></li>
  <li><a href="#-8️⃣-실전-문제-적용">실전 문제 적용</a></li>
</ol>

<hr />

<h2 id="-1️⃣-플로이드-워셜이란">🎯 1️⃣ 플로이드-워셜이란?</h2>

<h3 id="-한-문장-정의">💡 한 문장 정의</h3>

<p><strong>“모든 정점 쌍 사이의 최단 경로를 한 번에 구하는 알고리즘”</strong></p>

<h3 id="-언제-사용하는가">💡 언제 사용하는가?</h3>

<ul>
  <li>“A 도시에서 B 도시로 가는 최단 거리는?” → 모든 도시 쌍에 대해 물어볼 때</li>
  <li>“경유지를 거쳐가는 것이 더 빠른가?” → 중간 노드를 허용하며 최적 경로를 찾을 때</li>
  <li>그래프의 모든 쌍 최단 거리를 구해야 할 때</li>
</ul>

<h3 id="-특징">💡 특징</h3>

<table>
  <thead>
    <tr>
      <th>특징</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>시간복잡도</strong></td>
      <td>O(V³) - 정점 개수의 세제곱</td>
    </tr>
    <tr>
      <td><strong>공간복잡도</strong></td>
      <td>O(V²) - 2차원 배열</td>
    </tr>
    <tr>
      <td><strong>음수 간선</strong></td>
      <td>처리 가능 (단, 음수 사이클은 불가)</td>
    </tr>
    <tr>
      <td><strong>그래프 종류</strong></td>
      <td>방향/무방향 모두 가능</td>
    </tr>
    <tr>
      <td><strong>구현 난이도</strong></td>
      <td>매우 쉬움 (3중 for문)</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-2️⃣-핵심-개념-이해하기">🧠 2️⃣ 핵심 개념 이해하기</h2>

<h3 id="-알고리즘의-본질">💡 알고리즘의 본질</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"도시 i에서 도시 j로 갈 때,
k번 도시를 중간에 한 번 거쳐도 되는지를
매 단계마다 허용해가며 최소 비용을 갱신하는 알고리즘"
</code></pre></div></div>

<h3 id="-distij의-의미">💡 dist[i][j]의 의미</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">지금까지</span> <span class="n">허용된</span> <span class="n">중간</span> <span class="n">도시들만</span> <span class="n">이용해서</span>
             <span class="n">i</span> <span class="err">→</span> <span class="n">j로</span> <span class="n">가는</span> <span class="n">최소</span> <span class="n">비용</span>
</code></pre></div></div>

<p>여기서 “지금까지 허용된”이 핵심이다. k값에 따라 허용 범위가 달라진다.</p>

<h3 id="-동적-계획법dp으로서의-플로이드-워셜">💡 동적 계획법(DP)으로서의 플로이드-워셜</h3>

<p>플로이드-워셜의 본질적인 점화식:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DP[k][i][j] = 중간 도시를 1~k까지만 써서 i→j로 가는 최소 비용

DP[k][i][j] = min(
    DP[k-1][i][j],           // k를 거치지 않는 경우
    DP[k-1][i][k] + DP[k-1][k][j]  // k를 거치는 경우
)
</code></pre></div></div>

<p>실제 코드는 3차원 배열 대신 2차원 배열을 덮어쓰면서 k 단계를 확장한다.</p>

<hr />

<h2 id="-3️⃣-k-i-j의-정확한-의미">🔑 3️⃣ k, i, j의 정확한 의미</h2>

<h3 id="-기본-구조">💡 기본 구조</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>        <span class="c1">// 중간 노드</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>    <span class="c1">// 출발 노드</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 도착 노드</span>
            <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
                <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span>
                <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">+</span> <span class="n">dist</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>
            <span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="-각-변수의-의미">💡 각 변수의 의미</h3>

<table>
  <thead>
    <tr>
      <th>변수</th>
      <th>의미</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>k</strong></td>
      <td>중간에 거쳐도 되는 도시 번호</td>
      <td>k=1일 때는 1번만, k=2일 때는 1,2번까지 허용</td>
    </tr>
    <tr>
      <td><strong>i</strong></td>
      <td>출발 도시</td>
      <td>모든 출발지를 순회</td>
    </tr>
    <tr>
      <td><strong>j</strong></td>
      <td>도착 도시</td>
      <td>모든 도착지를 순회</td>
    </tr>
  </tbody>
</table>

<h3 id="-핵심-로직의-의미">💡 핵심 로직의 의미</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
    <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span>          <span class="c1">// 원래 알고 있던 i → j 최단 경로</span>
    <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">+</span> <span class="n">dist</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>  <span class="c1">// i → k → j로 가는 새로운 경로</span>
<span class="o">);</span>
</code></pre></div></div>

<p>이 코드가 묻는 질문:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"i에서 j로 바로 가는 게 낫나?"
"아니면 k를 한 번 들렀다 가는 게 낫나?"
</code></pre></div></div>

<p>시각적 표현:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i ─────────▶ j  (직접)
│
│
▼
k
</code></pre></div></div>

<h3 id="-왜-k가-가장-바깥-루프인가">💡 왜 k가 가장 바깥 루프인가?</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ 올바른 순서</span>
<span class="k">for</span> <span class="n">k</span>
  <span class="k">for</span> <span class="n">i</span>
    <span class="k">for</span> <span class="n">j</span>

<span class="c1">// ❌ 잘못된 순서</span>
<span class="k">for</span> <span class="n">i</span>
  <span class="k">for</span> <span class="n">j</span>
    <span class="k">for</span> <span class="n">k</span>
</code></pre></div></div>

<p><strong>이유</strong>: k는 “중간 도시로 k까지 허용한 상태에서 모든 i→j 최단거리를 갱신”한다는 의미다. 만약 i나 j가 바깥에 있으면 아직 허용되지 않은 중간 도시를 사용하게 되어 DP의 단계적 의미가 깨진다.</p>

<hr />

<h2 id="-4️⃣-동작-과정-시각화">📊 4️⃣ 동작 과정 시각화</h2>

<h3 id="-예시-그래프">💡 예시 그래프</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1 ──(4)── 2
    │         │
   (3)       (2)
    │         │
    3 ──(5)── 4
</code></pre></div></div>

<h3 id="-초기-상태-k--0-중간-노드-허용-안-함">💡 초기 상태 (k = 0, 중간 노드 허용 안 함)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dist[i][j] = 직접 연결된 간선만 사용

      1    2    3    4
1  [  0    4   INF  INF ]
2  [  4    0   INF   2  ]
3  [ INF  INF   0    5  ]
4  [ INF   2    5    0  ]
</code></pre></div></div>

<h3 id="-k--1-1번-노드를-중간에-사용-가능">💡 k = 1 (1번 노드를 중간에 사용 가능)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"1번을 거쳐가면 더 빠른 경로가 있나?"

i=2, j=3일 때:
dist[2][3] = min(INF, dist[2][1] + dist[1][3])
           = min(INF, 4 + INF) = INF

i=3, j=2일 때:
dist[3][2] = min(INF, dist[3][1] + dist[1][2])
           = min(INF, INF + 4) = INF
</code></pre></div></div>

<h3 id="-k--2-12번-노드를-중간에-사용-가능">💡 k = 2 (1,2번 노드를 중간에 사용 가능)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"2번을 거쳐가면 더 빠른 경로가 있나?"

i=1, j=4일 때:
dist[1][4] = min(INF, dist[1][2] + dist[2][4])
           = min(INF, 4 + 2) = 6
</code></pre></div></div>

<h3 id="-최종-결과-k--4-모든-노드-허용">💡 최종 결과 (k = 4, 모든 노드 허용)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      1    2    3    4
1  [  0    4    8    6  ]
2  [  4    0    7    2  ]
3  [  8    7    0    5  ]
4  [  6    2    5    0  ]
</code></pre></div></div>

<hr />

<h2 id="-5️⃣-코드-구현">💻 5️⃣ 코드 구현</h2>

<h3 id="-기본-템플릿">💡 기본 템플릿</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">FloydWarshall</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">INF</span> <span class="o">=</span> <span class="mi">987654321</span><span class="o">;</span>  <span class="c1">// 충분히 큰 값</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// 1. 초기화</span>

        <span class="c1">// 2. 간선 정보 입력</span>

        <span class="c1">// 3. 플로이드-워셜 알고리즘</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">!=</span> <span class="no">INF</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="no">INF</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span>
                                              <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">+</span> <span class="n">dist</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 4. 결과 출력</span>
        <span class="n">printDistances</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="-6️⃣-시간복잡도와-공간복잡도">📈 6️⃣ 시간복잡도와 공간복잡도</h2>

<h3 id="-시간복잡도">💡 시간복잡도</h3>

<table>
  <thead>
    <tr>
      <th>연산</th>
      <th>복잡도</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>플로이드-워셜</strong></td>
      <td>O(V³)</td>
      <td>3중 for문</td>
    </tr>
    <tr>
      <td><strong>초기화</strong></td>
      <td>O(V²)</td>
      <td>2차원 배열 초기화</td>
    </tr>
    <tr>
      <td><strong>전체</strong></td>
      <td>O(V³)</td>
      <td>플로이드-워셜이 지배적</td>
    </tr>
  </tbody>
</table>

<h3 id="-공간복잡도">💡 공간복잡도</h3>

<table>
  <thead>
    <tr>
      <th>자료구조</th>
      <th>크기</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>거리 배열</strong></td>
      <td>O(V²)</td>
      <td>dist[n][n]</td>
    </tr>
    <tr>
      <td><strong>경로 배열</strong></td>
      <td>O(V²)</td>
      <td>next[n][n] (선택적)</td>
    </tr>
    <tr>
      <td><strong>전체</strong></td>
      <td>O(V²)</td>
      <td>2차원 배열</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="️-7️⃣-다익스트라와의-비교">⚖️ 7️⃣ 다익스트라와의 비교</h2>

<h3 id="-핵심-차이점">💡 핵심 차이점</h3>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>플로이드-워셜</th>
      <th>다익스트라</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>목적</strong></td>
      <td>모든 쌍 최단 경로</td>
      <td>한 정점에서 모든 정점으로</td>
    </tr>
    <tr>
      <td><strong>시간복잡도</strong></td>
      <td>O(V³)</td>
      <td>O((V+E)logV)</td>
    </tr>
    <tr>
      <td><strong>공간복잡도</strong></td>
      <td>O(V²)</td>
      <td>O(V)</td>
    </tr>
    <tr>
      <td><strong>음수 간선</strong></td>
      <td>가능 (음수 사이클 제외)</td>
      <td>불가능</td>
    </tr>
    <tr>
      <td><strong>구현 난이도</strong></td>
      <td>매우 쉬움</td>
      <td>중간 (우선순위 큐)</td>
    </tr>
    <tr>
      <td><strong>적용 상황</strong></td>
      <td>정점이 적을 때 (V ≤ 500)</td>
      <td>정점이 많을 때, 특정 출발점</td>
    </tr>
  </tbody>
</table>

<h3 id="-언제-무엇을-쓸까">💡 언제 무엇을 쓸까?</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ 플로이드-워셜을 쓸 때</span>
<span class="k">if</span> <span class="o">(</span><span class="n">모든</span> <span class="n">정점</span> <span class="n">쌍의</span> <span class="n">최단</span> <span class="n">거리가</span> <span class="n">필요</span> <span class="o">&amp;&amp;</span> <span class="n">정점</span> <span class="n">수</span> <span class="err">≤</span> <span class="mi">500</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">플로이드워셜</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// ✅ 다익스트라를 쓸 때</span>
<span class="k">if</span> <span class="o">(</span><span class="n">특정</span> <span class="n">출발점에서</span> <span class="n">모든</span> <span class="n">정점까지</span> <span class="o">&amp;&amp;</span> <span class="n">음수</span> <span class="n">간선</span> <span class="n">없음</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">다익스트라</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// ✅ 벨만-포드를 쓸 때</span>
<span class="k">if</span> <span class="o">(</span><span class="n">음수</span> <span class="n">간선</span> <span class="n">있음</span> <span class="o">&amp;&amp;</span> <span class="n">음수</span> <span class="n">사이클</span> <span class="n">감지</span> <span class="n">필요</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">벨만포드</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="-8️⃣-실전-문제-적용">🎯 8️⃣ 실전 문제 적용</h2>

<h3 id="-대표-문제-유형">💡 대표 문제 유형</h3>

<table>
  <thead>
    <tr>
      <th>유형</th>
      <th>설명</th>
      <th>예시 문제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>모든 쌍 최단 경로</strong></td>
      <td>모든 도시 간 최단 거리</td>
      <td>백준 11404 플로이드</td>
    </tr>
    <tr>
      <td><strong>경유지 문제</strong></td>
      <td>특정 경유지를 거쳐야 할 때</td>
      <td>프로그래머스 순위</td>
    </tr>
    <tr>
      <td><strong>연결성 판단</strong></td>
      <td>모든 노드가 연결되어 있는가?</td>
      <td>백준 1389 케빈 베이컨</td>
    </tr>
    <tr>
      <td><strong>최단 경로 개수</strong></td>
      <td>최단 경로가 몇 개인가?</td>
      <td>백준 1613 역사</td>
    </tr>
  </tbody>
</table>

<h3 id="-체크리스트">💡 체크리스트</h3>

<p>플로이드-워셜 문제를 풀 때 확인할 것:</p>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />정점 수가 500 이하인가? (아니면 다익스트라 고려)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />모든 쌍의 최단 거리가 필요한가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />음수 간선이 있는가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />음수 사이클을 감지해야 하는가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />INF 값을 충분히 크게 설정했는가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />중복 간선 처리를 했는가?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />k가 가장 바깥 루프인가?</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[플로이드-워셜 알고리즘에 대해 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자 2025 회고] 실시간 매칭 시스템, 생각보다 어려웠던 이야기</title><link href="https://nan0silver.github.io/projectdiary/2025-12-25-diary/" rel="alternate" type="text/html" title="[친구하자 2025 회고] 실시간 매칭 시스템, 생각보다 어려웠던 이야기" /><published>2025-12-25T00:00:00+00:00</published><updated>2026-02-18T07:00:01+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-12-25-diary/"><![CDATA[<ul>
  <li><a href="#들어가며">들어가며</a></li>
  <li><a href="#1-처음-그린-그림">1. 처음 그린 그림</a></li>
  <li><a href="#2-redis-대기열-생각보다-복잡했다">2. Redis 대기열, 생각보다 복잡했다</a></li>
  <li><a href="#3-매칭-알고리즘의-딜레마">3. 매칭 알고리즘의 딜레마</a></li>
  <li><a href="#4-알림이-안-가요">4. “알림이 안 가요”</a></li>
  <li><a href="#5-동시성의-늪">5. 동시성의 늪</a></li>
  <li><a href="#6-db와-redis-사이에서">6. DB와 Redis 사이에서</a></li>
  <li><a href="#7-배운-것들">7. 배운 것들</a></li>
</ul>

<hr />

<h2 id="들어가며">들어가며</h2>

<p>“매칭이요? 그냥 대기열 만들고, 2명 되면 연결하면 되는 거 아니에요?”</p>

<p>처음에 나도 그렇게 생각했다. 버튼 하나 누르면 매칭되고, 바로 통화 시작. 간단하지 않나?</p>

<p>그런데 막상 만들기 시작하니까… 전혀 간단하지 않았다.</p>

<hr />

<h2 id="1-처음-그린-그림">1. 처음 그린 그림</h2>

<p>가장 먼저 그린 건 이런 흐름이었다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 사용자가 "매칭 시작" 버튼 클릭
2. 대기열에 들어감
3. 다른 사람이 들어오면 자동 매칭
4. 통화 시작!
</code></pre></div></div>

<p>어렵지 않아 보였다. 그래서 바로 코딩을 시작했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 첫 번째 시도</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">startMatching</span><span class="o">(</span><span class="nc">Long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">userId</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">User</span> <span class="n">user1</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="nc">User</span> <span class="n">user2</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="n">createCall</span><span class="o">(</span><span class="n">user1</span><span class="o">,</span> <span class="n">user2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>로컬에서 테스트하니까 잘 됐다. “오, 쉽네?” 싶었다.</p>

<p>그런데…</p>

<hr />

<h2 id="2-redis-대기열-생각보다-복잡했다">2. Redis 대기열, 생각보다 복잡했다</h2>

<h3 id="같은-사람이랑-계속-매칭돼요">“같은 사람이랑 계속 매칭돼요”</h3>

<p>첫 번째 문제는 금방 발견됐다. 테스트하던 친구가 말했다.</p>

<p>“어… 나 방금 매칭된 사람이랑 또 매칭됐는데?”</p>

<p>그제야 깨달았다. 그냥 랜덤으로 매칭하면 방금 통화한 사람이랑 또 만날 수 있다는 걸.</p>

<p>“그럼 대기순으로 하면 되겠네!”</p>

<p>List를 써서 먼저 온 사람부터 매칭하도록 바꿨다. 문제 해결!</p>

<h3 id="10분째-기다리고-있는데요">“10분째 기다리고 있는데요”</h3>

<p>그런데 이번엔 다른 문제가 생겼다.</p>

<p>새벽 시간대에 사용자가 적을 때, 한 명이 들어와서 10분을 기다리고 있었다. 상대방이 안 와서.</p>

<p>“아… 타임아웃 처리를 해야 하는구나.”</p>

<p>그런데 List로는 “언제 들어왔는지”를 알 수가 없었다. 그냥 순서만 알 수 있었다.</p>

<p>여기서 Redis의 <strong>Sorted Set(ZSET)</strong> 을 알게 됐다.</p>

<pre><code class="language-redis"># 들어온 시각을 점수로 저장
ZADD queue:music 1734840123456 user_101
ZADD queue:music 1734840125789 user_205
</code></pre>

<p>이제 시간 기준으로 정렬도 되고, 오래된 사람 찾기도 쉬워졌다.</p>

<h3 id="랜덤도-하고-싶은데요">“랜덤도 하고 싶은데요?”</h3>

<p>대기순만 하니까 너무 지루하다는 피드백이 왔다.</p>

<p>“가끔은 랜덤 매칭도 하면 재밌을 것 같아요!”</p>

<p>ZSET의 <code class="language-plaintext highlighter-rouge">ZRANDMEMBER</code> 명령어를 발견했다. 완벽했다.</p>

<p>하지만 여기서 또 고민이 생겼다. 항상 랜덤? 항상 대기순? 어떻게 섞지?</p>

<hr />

<h2 id="3-매칭-알고리즘의-딜레마">3. 매칭 알고리즘의 딜레마</h2>

<h3 id="공정성-vs-다양성">공정성 vs 다양성</h3>

<p>고민을 정리해봤다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>대기순만 하면:
✅ 공정함
❌ 지루함

랜덤만 하면:
✅ 재미있음
❌ 오래 기다린 사람 불공평
</code></pre></div></div>

<p>결국 <strong>하이브리드 방식</strong>을 선택했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 대기순과 랜덤을 적절히 섞기</span>
<span class="kt">boolean</span> <span class="n">useRandom</span> <span class="o">=</span> <span class="n">shouldUseRandom</span><span class="o">();</span>

<span class="k">if</span> <span class="o">(</span><span class="n">useRandom</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 랜덤 매칭</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="c1">// 대기순 매칭</span>
<span class="o">}</span>
</code></pre></div></div>

<p>(비율은 사실 감으로 정했다. 나중에 데이터 보면서 조정할 생각이다.)</p>

<h3 id="스케줄러-vs-실시간">스케줄러 vs 실시간</h3>

<p>또 다른 고민: 누가 들어올 때마다 매칭을 시도할까? 아니면 주기적으로 확인할까?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>실시간 시도:
✅ 빠름
❌ 트래픽 많으면 부하

주기적 확인:
✅ 안정적
❌ 약간 느림
</code></pre></div></div>

<p>일단 <strong>주기적으로 확인하는 스케줄러</strong>로 구현했다. 1분 이내 매칭이 목표였으니까 충분했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedDelay</span> <span class="o">=</span> <span class="mi">30000</span><span class="o">)</span>  <span class="c1">// 30초</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processMatching</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 매칭 로직</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="4-알림이-안-가요">4. “알림이 안 가요”</h2>

<p>매칭은 되는데, 사용자가 모른다는 게 문제였다.</p>

<h3 id="websocket의-등장">WebSocket의 등장</h3>

<p>“알림 어떻게 보내지?”</p>

<p>처음엔 클라이언트가 계속 서버에 물어보는 <strong>폴링</strong> 방식을 생각했다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이렇게?</span>
<span class="nx">setInterval</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">/api/matching/status</span><span class="dl">"</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span> <span class="c1">// 1초마다</span>
</code></pre></div></div>

<p>그런데 이건 너무 비효율적이었다. 서버도 부담스럽고.</p>

<p>그래서 <strong>WebSocket</strong>을 쓰기로 했다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 구독하고 기다리면 알림이 옴</span>
<span class="nx">client</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s2">`/topic/matching/</span><span class="p">${</span><span class="nx">userId</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span> <span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 매칭 완료!</span>
  <span class="nx">navigate</span><span class="p">(</span><span class="dl">"</span><span class="s2">/call</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="타이밍-이슈">타이밍 이슈</h3>

<p>그런데 여기서 또 함정이 있었다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 매칭 완료 → DB 저장
2. WebSocket 알림 발송
3. 클라이언트가 통화 정보 조회
4. ❌ 아직 DB에 커밋 안 됨!
</code></pre></div></div>

<p>알림은 보냈는데 DB에는 아직 데이터가 없는 상황.</p>

<p>클라이언트에서 에러가 났다. “통화를 찾을 수 없습니다.”</p>

<p><strong>해결:</strong> 트랜잭션 커밋 후에 알림 보내기</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// DB 커밋 성공 후에만 알림</span>
<span class="nc">TransactionSynchronizationManager</span><span class="o">.</span><span class="na">registerSynchronization</span><span class="o">(</span>
    <span class="k">new</span> <span class="nf">TransactionSynchronization</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterCommit</span><span class="o">()</span> <span class="o">{</span>
            <span class="c1">// 이제야 알림 발송</span>
            <span class="n">sendNotification</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">);</span>
</code></pre></div></div>

<p>이 부분은 Spring 문서를 뒤져가며 찾았다. “트랜잭션 동기화”라는 개념을 처음 알았다.</p>

<hr />

<h2 id="5-동시성의-늪">5. 동시성의 늪</h2>

<p>로컬에서는 잘 되던 게, 배포하니까 문제가 생겼다.</p>

<h3 id="저-두-명이랑-동시에-매칭됐어요">“저 두 명이랑 동시에 매칭됐어요”</h3>

<p>한 사용자가 두 개의 통화에 동시에 매칭되는 버그였다.</p>

<p>원인을 찾아보니… 여러 스레드가 동시에 매칭 로직을 실행하면서 생긴 문제였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[스레드 A] 사용자 101, 102 매칭 시작
[스레드 B] 사용자 101, 103 매칭 시작
     ↓
사용자 101이 두 번 매칭됨!
</code></pre></div></div>

<p><strong>해결:</strong> 사용자 상태 체크</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// "나 지금 매칭 중이야" 표시</span>
<span class="nc">String</span> <span class="n">lockKey</span> <span class="o">=</span> <span class="s">"user:queued:"</span> <span class="o">+</span> <span class="n">userId</span><span class="o">;</span>

<span class="nc">Boolean</span> <span class="n">acquired</span> <span class="o">=</span> <span class="n">redisTemplate</span><span class="o">.</span><span class="na">opsForValue</span><span class="o">()</span>
    <span class="o">.</span><span class="na">setIfAbsent</span><span class="o">(</span><span class="n">lockKey</span><span class="o">,</span> <span class="s">"1"</span><span class="o">,</span> <span class="nc">Duration</span><span class="o">.</span><span class="na">ofMinutes</span><span class="o">(</span><span class="mi">10</span><span class="o">));</span>

<span class="k">if</span> <span class="o">(!</span><span class="n">acquired</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">AlreadyInQueueException</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Redis의 <code class="language-plaintext highlighter-rouge">SETNX</code> (Set if Not eXists) 명령어를 쓰면 원자적으로 체크하고 설정할 수 있다는 걸 배웠다.</p>

<h3 id="카테고리별-독립-처리">카테고리별 독립 처리</h3>

<p>음악, 영화, 게임… 카테고리가 여러 개인데, 하나의 카테고리에서 에러가 나면 다른 카테고리 매칭도 다 실패했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 문제가 있던 코드</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processMatching</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Category</span> <span class="n">category</span> <span class="o">:</span> <span class="n">categories</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">matchCategory</span><span class="o">(</span><span class="n">category</span><span class="o">);</span>  <span class="c1">// 하나 실패하면 전체 롤백!</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>해결:</strong> 각 카테고리마다 독립적인 트랜잭션</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="nc">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">matchCategory</span><span class="o">(</span><span class="nc">Category</span> <span class="n">category</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 이제 하나 실패해도 다른 카테고리는 계속 진행</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">REQUIRES_NEW</code>라는 옵션이 있다는 걸 이때 알았다. Spring은 정말 배울 게 많다.</p>

<hr />

<h2 id="6-db와-redis-사이에서">6. DB와 Redis 사이에서</h2>

<h3 id="어디에-뭘-저장할까">어디에 뭘 저장할까?</h3>

<p>처음엔 Redis에만 대기열을 관리했다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Redis만 사용:
✅ 빠름
❌ 서버 재시작하면 대기열 사라짐
❌ 누가 언제 들어왔는지 기록 없음
</code></pre></div></div>

<p>그래서 DB에도 저장하기로 했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. DB에 저장</span>
<span class="nc">MatchingQueue</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">matchingQueueRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span>
    <span class="k">new</span> <span class="nf">MatchingQueue</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">categoryId</span><span class="o">)</span>
<span class="o">);</span>

<span class="c1">// 2. Redis에도 추가</span>
<span class="n">redisService</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">categoryId</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="그런데-redis-추가가-실패하면">그런데 Redis 추가가 실패하면?</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. DB 저장 성공 ✅
2. Redis 추가 실패 ❌
   ↓
대기열에는 없는데 DB엔 있는 상태
</code></pre></div></div>

<p>이게 생각보다 골치 아팠다.</p>

<p>처음엔 “둘 다 성공하게 만들어야지!” 라고 생각했다. 그런데 현실은 그렇지 않았다.</p>

<p>DB와 Redis는 완전히 다른 시스템이다. 하나의 트랜잭션으로 묶을 수 없다.</p>

<p><strong>결론:</strong> 완벽한 일치는 불가능하다.</p>

<p>대신 이렇게 접근했다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. DB는 "기록용"
   - 누가 언제 매칭을 시도했는지
   - 통계와 분석용

2. Redis는 "실시간 처리용"
   - 지금 대기 중인 사람들
   - 빠른 매칭용

3. 불일치가 생기면?
   - Redis 실패하면 로그 남기고
   - 서버 시작할 때 DB에서 복구
</code></pre></div></div>

<p>“최선”을 “완벽” 대신 선택했다.</p>

<hr />

<h2 id="7-배운-것들">7. 배운 것들</h2>

<h3 id="간단해-보이는-기능도-간단하지-않다">“간단해 보이는 기능도 간단하지 않다”</h3>

<p>“매칭 버튼 하나면 되는 거 아니야?”</p>

<p>아니었다. 정말 아니었다.</p>

<ul>
  <li>타임아웃 처리</li>
  <li>중복 방지</li>
  <li>알림 발송</li>
  <li>동시성 제어</li>
  <li>데이터 일관성</li>
  <li>서버 재시작 대응</li>
  <li>…</li>
</ul>

<p>하나하나 다 신경 써야 할 게 있었다.</p>

<h3 id="완벽은-없다">“완벽은 없다”</h3>

<p>처음엔 “완벽하게 만들어야지!” 라고 생각했다.</p>

<p>DB와 Redis가 항상 일치해야 하고, 알림이 절대 빠지면 안 되고, 매칭이 1초 만에 되어야 하고…</p>

<p>그런데 현실은:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Redis는 가끔 연결이 끊긴다
- 알림은 가끔 실패한다
- 네트워크는 언제나 불안정하다
</code></pre></div></div>

<p>완벽을 추구하다가 영원히 못 끝낼 뻔했다.</p>

<p><strong>대신 이렇게 접근했다:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ 대부분의 경우 잘 작동하면 OK
✅ 실패해도 복구할 수 있으면 OK
✅ 사용자가 크게 불편하지 않으면 OK
</code></pre></div></div>

<h3 id="문제는-운영하면서-발견된다">“문제는 운영하면서 발견된다”</h3>

<p>로컬에서는 몰랐던 문제들:</p>

<ul>
  <li>동시성 이슈</li>
  <li>타임아웃 처리</li>
  <li>메모리 관리</li>
  <li>네트워크 지연</li>
</ul>

<p>다 운영하면서 만났다.</p>

<p>그리고 하나씩 해결했다.</p>

<h3 id="설계보다-중요한-건-개선">“설계보다 중요한 건 개선”</h3>

<p>처음 설계가 완벽할 순 없다.</p>

<p>중요한 건:</p>

<ul>
  <li>문제를 빨리 발견하고</li>
  <li>빨리 고치고</li>
  <li>다시 배포하는 것</li>
</ul>

<p>이 사이클을 빠르게 돌리는 게 핵심이었다.</p>

<h3 id="검색과-시도의-힘">“검색과 시도의 힘”</h3>

<p>이 과정에서 새로 배운 것들:</p>

<ul>
  <li>Redis ZSET</li>
  <li>WebSocket과 STOMP</li>
  <li>트랜잭션 동기화</li>
  <li>SETNX (원자적 연산)</li>
  <li>REQUIRES_NEW 전파 속성</li>
</ul>

<p>하나도 몰랐다. 다 검색하고, 블로그 읽고, 시도하고, 실패하고, 다시 해보면서 배웠다.</p>

<p>“모르는 게 부끄러운 게 아니라, 배우지 않는 게 부끄러운 것”이라는 걸 다시 한번 느꼈다.</p>

<hr />

<h2 id="마치며">마치며</h2>

<p>6개월 전 “매칭 기능 만들어야지!” 라고 생각했을 때는 몰랐다.</p>

<p>이렇게 많은 고민과 삽질이 필요할 줄.</p>

<p>하지만 돌아보니, 이 과정에서 정말 많이 배웠다.</p>

<ul>
  <li>Redis의 다양한 자료구조</li>
  <li>WebSocket 실시간 통신</li>
  <li>동시성 제어</li>
  <li>분산 시스템의 어려움</li>
  <li>완벽함보다 실용성</li>
</ul>

<p>그리고 가장 중요한 것:</p>

<p><strong>“모르는 건 부끄러운 게 아니다. 배우면 된다.”</strong></p>

<p>하나씩 검색하고, 블로그 읽고, 시도해보고, 실패하고, 다시 해보고.</p>

<p>그렇게 만들어졌다.</p>

<p>완벽하진 않지만, 작동한다.</p>

<p>그리고 계속 개선하고 있다.</p>

<hr />

<p>다음 편에서는 이 시스템을 운영하면서 만난 <strong>진짜 문제들</strong>을 이야기해보려고 한다.</p>

<ul>
  <li>Redis 메모리가 터졌던 날</li>
  <li>WebSocket이 다 끊어졌던 날</li>
  <li>매칭이 안 되는 버그를 3일 동안 찾았던 이야기</li>
</ul>

<p>기대해주시길!</p>

<hr />

<p><strong>시리즈:</strong></p>

<ol>
  <li><a href="https://nan0silver.github.io/projectdiary/2025-12-20-diary/">왜 이 기술들을 선택했나</a></li>
  <li><strong>실시간 매칭 시스템, 생각보다 어려웠던 이야기</strong> ← 현재 글</li>
</ol>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA["버튼 하나면 되는 거 아냐?" 라고 생각했던 나에게 현실이 알려준 것들]]></summary></entry><entry><title type="html">[친구하자 2025 회고] 실시간 음성 매칭 서비스, 왜 이 기술들을 선택했나</title><link href="https://nan0silver.github.io/projectdiary/2025-12-20-diary/" rel="alternate" type="text/html" title="[친구하자 2025 회고] 실시간 음성 매칭 서비스, 왜 이 기술들을 선택했나" /><published>2025-12-20T00:00:00+00:00</published><updated>2026-02-18T07:00:01+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-12-20-diary/"><![CDATA[<ul>
  <li><a href="#들어가며">들어가며</a></li>
  <li><a href="#1-전체-그림-우리-서비스가-필요한-것">1. 전체 그림: 우리 서비스가 필요한 것</a></li>
  <li><a href="#2-backend-spring-boot--webflux를-선택한-이유">2. Backend: Spring Boot + WebFlux를 선택한 이유</a></li>
  <li><a href="#3-database-mysql을-선택한-이유">3. Database: MySQL을 선택한 이유</a></li>
  <li><a href="#4-cache--queue-redis를-선택한-이유">4. Cache &amp; Queue: Redis를 선택한 이유</a></li>
  <li><a href="#5-webrtc-agora를-선택한-이유">5. WebRTC: Agora를 선택한 이유</a></li>
  <li><a href="#6-file-storage-firebase-storage를-선택한-이유">6. File Storage: Firebase Storage를 선택한 이유</a></li>
  <li><a href="#7-frontend-react--capacitor를-선택한-이유">7. Frontend: React + Capacitor를 선택한 이유</a></li>
  <li><a href="#8-배포-환경-aws--vercel">8. 배포 환경: AWS + Vercel</a></li>
  <li><a href="#9-기술-선택의-원칙">9. 기술 선택의 원칙</a></li>
  <li><a href="#10-마치며">10. 마치며</a></li>
</ul>

<hr />

<h2 id="들어가며">들어가며</h2>

<p>“관심사 기반 1:1 랜덤 음성 통화”라는 아이디어를 떠올렸을 때, 가장 먼저 든 생각은 “어떻게 구현하지?”였다. 학부와 석사 과정에서 배운 이론과 토이 프로젝트 경험은 있었지만, 실제 사용자가 쓸 서비스를 만드는 것은 처음이었다.</p>

<p>기술 스택을 선택하는 과정에서 수많은 블로그 글을 읽었고, 여러 서비스를 비교했다. 하지만 결국 깨달은 건 <strong>“정답은 없다”</strong>는 것이었다. 각 기술은 장단점이 있고, 중요한 건 우리 서비스의 맥락에서 어떤 게 적합한가였다.</p>

<p>이 글에서는 내가 왜 이런 선택을 했는지, 어떤 고민을 했는지를 솔직하게 공유해보려 한다.</p>

<hr />

<h2 id="1-전체-그림-우리-서비스가-필요한-것">1. 전체 그림: 우리 서비스가 필요한 것</h2>

<p>기술을 선택하기 전에, 먼저 우리 서비스의 특성을 정리했다.</p>

<h3 id="핵심-요구사항">핵심 요구사항</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 실시간성
   - 매칭 대기 시간을 최소화 (목표: 1분 이내)
   - 매칭 완료 즉시 알림
   - 끊김 없는 음성 통화

2. 확장성
   - 초기엔 소규모지만, 사용자 증가에 대응 가능해야 함
   - 트래픽 급증 시나리오 고려

3. 운영 편의성
   - 문제 발생 시 빠른 파악과 대응
   - 모니터링과 로깅
   - 배포 자동화

4. 비용 효율성
   - MVP 단계에서 과도한 인프라 비용 지양
   - 사용량에 따른 탄력적 비용 구조
</code></pre></div></div>

<p>이 네 가지 축을 기준으로 모든 기술 선택을 평가했다.</p>

<hr />

<h2 id="2-backend-spring-boot--webflux를-선택한-이유">2. Backend: Spring Boot + WebFlux를 선택한 이유</h2>

<h3 id="왜-비동기가-필요했나">왜 비동기가 필요했나?</h3>

<p>처음에는 익숙한 Spring MVC를 쓸까 고민했다. 하지만 우리 서비스의 특성을 생각해보니 WebFlux가 더 적합해 보였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 시나리오: 통화 종료 후 녹음 저장</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">endCall</span><span class="o">(</span><span class="nc">Long</span> <span class="n">callId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 1. 통화 종료 처리</span>
    <span class="n">callService</span><span class="o">.</span><span class="na">endCall</span><span class="o">(</span><span class="n">callId</span><span class="o">);</span>

    <span class="c1">// 2. Agora API 호출 (외부 API, 2-3초 소요)</span>
    <span class="n">agoraService</span><span class="o">.</span><span class="na">stopRecording</span><span class="o">(</span><span class="n">callId</span><span class="o">);</span>  <span class="c1">// ← 여기서 블로킹!</span>

    <span class="c1">// 3. 평가 페이지로 리다이렉트</span>
    <span class="k">return</span> <span class="s">"redirect:/evaluation"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>동기 방식의 문제는 Agora API 응답을 기다리는 2-3초 동안 스레드가 블로킹된다는 거였다. 200개 스레드로 동시 200명만 처리 가능하고, 대기 시간이 증가하면 사용자 경험이 저하된다.</p>

<p>비동기 방식을 쓰면:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">endCall</span><span class="o">(</span><span class="nc">Long</span> <span class="n">callId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">callService</span><span class="o">.</span><span class="na">endCall</span><span class="o">(</span><span class="n">callId</span><span class="o">)</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">agoraService</span><span class="o">.</span><span class="na">stopRecording</span><span class="o">(</span><span class="n">callId</span><span class="o">))</span>  <span class="c1">// 논블로킹</span>
        <span class="o">.</span><span class="na">then</span><span class="o">();</span>
    <span class="c1">// 스레드가 즉시 다른 요청 처리 가능</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="실제-경험-webflux의-학습-곡선">실제 경험: WebFlux의 학습 곡선</h3>

<p>솔직히 말하면, WebFlux는 쉽지 않았다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ 이렇게 하면 안 됨</span>
<span class="kd">public</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="nf">getUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">).</span><span class="na">block</span><span class="o">();</span>  <span class="c1">// 블로킹!</span>
    <span class="k">return</span> <span class="nc">Mono</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ✅ 올바른 방법</span>
<span class="kd">public</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="nf">getUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>  <span class="c1">// 논블로킹 체인</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">block()</code>을 쓰는 순간 비동기의 의미가 사라진다. “Reactive하게 생각하기”까지 시간이 필요했지만, 익숙해지니 외부 API 호출이 많은 우리 서비스에 딱 맞았다.</p>

<h3 id="언제-webflux를-쓰면-좋을까">언제 WebFlux를 쓰면 좋을까?</h3>

<p>내 경험상 이런 경우 WebFlux가 적합하다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ WebFlux 추천:
- 외부 API 호출이 많은 서비스
- WebSocket 등 실시간 통신 필요
- I/O 대기 시간이 긴 작업
- 동시 접속자가 많은 서비스

❌ WebFlux 비추천:
- CPU 집약적 작업 (이미지 처리, 암호화 등)
- 간단한 CRUD 중심 서비스
- 팀이 Spring MVC에 익숙하고, 학습 시간이 부족한 경우
</code></pre></div></div>

<hr />

<h2 id="3-database-mysql을-선택한-이유">3. Database: MySQL을 선택한 이유</h2>

<h3 id="mysql-vs-nosql-고민">MySQL vs NoSQL 고민</h3>

<p>“요즘 트렌드는 NoSQL 아닌가?”라는 생각도 했다. MongoDB를 쓸까 진지하게 고민했다.</p>

<p>우리 데이터의 특성을 분석해봤다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User ←→ Friendships ←→ User
  ↓
Calls ←→ CallRecordings
  ↓
CallEvaluations
</code></pre></div></div>

<p>친구 관계는 양방향이고 상태 관리가 필요하다 (요청중/수락/차단). 통화 이력은 두 사용자 간의 연결이고, 평가는 통화와 1:1 관계다.</p>

<p>이런 구조를 보니 관계형 데이터베이스가 더 자연스러웠다.</p>

<h3 id="데이터-일관성의-중요성">데이터 일관성의 중요성</h3>

<p>특히 친구 관계에서 일관성이 중요했다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 친구 요청은 반드시 양쪽 모두 저장되어야 함</span>
<span class="k">BEGIN</span> <span class="n">TRANSACTION</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">friendships</span> <span class="p">(</span><span class="n">user_a_id</span><span class="p">,</span> <span class="n">user_b_id</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'PENDING'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">friendships</span> <span class="p">(</span><span class="n">user_b_id</span><span class="p">,</span> <span class="n">user_a_id</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'REQUESTED'</span><span class="p">);</span>
<span class="k">COMMIT</span><span class="p">;</span>

<span class="c1">-- 하나라도 실패하면 전체 롤백</span>
</code></pre></div></div>

<p>NoSQL에서는 이런 트랜잭션 보장이 상대적으로 약하다.</p>

<h3 id="쿼리-복잡도">쿼리 복잡도</h3>

<p>통화 이력 조회 같은 경우, JOIN이 필요했다:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 내 통화 이력 + 상대방 정보 + 친구 상태</span>
<span class="k">SELECT</span>
    <span class="k">c</span><span class="p">.</span><span class="o">*</span><span class="p">,</span>
    <span class="n">u</span><span class="p">.</span><span class="n">nickname</span> <span class="k">as</span> <span class="n">partner_name</span><span class="p">,</span>
    <span class="n">f</span><span class="p">.</span><span class="n">status</span> <span class="k">as</span> <span class="n">friend_status</span>
<span class="k">FROM</span> <span class="n">calls</span> <span class="k">c</span>
<span class="k">JOIN</span> <span class="n">users</span> <span class="n">u</span> <span class="k">ON</span> <span class="p">(</span><span class="k">c</span><span class="p">.</span><span class="n">user_a_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span> <span class="k">OR</span> <span class="k">c</span><span class="p">.</span><span class="n">user_b_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">AND</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span> <span class="o">!=</span> <span class="p">:</span><span class="n">myId</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">friendships</span> <span class="n">f</span> <span class="k">ON</span> <span class="n">f</span><span class="p">.</span><span class="n">friend_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">f</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="p">:</span><span class="n">myId</span>
<span class="k">WHERE</span> <span class="k">c</span><span class="p">.</span><span class="n">user_a_id</span> <span class="o">=</span> <span class="p">:</span><span class="n">myId</span> <span class="k">OR</span> <span class="k">c</span><span class="p">.</span><span class="n">user_b_id</span> <span class="o">=</span> <span class="p">:</span><span class="n">myId</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="k">c</span><span class="p">.</span><span class="n">created_at</span> <span class="k">DESC</span><span class="p">;</span>
</code></pre></div></div>

<p>NoSQL에서 이런 쿼리는 애플리케이션 레벨에서 여러 번 조회해야 한다.</p>

<h3 id="그럼-nosql은-언제">그럼 NoSQL은 언제?</h3>

<p>내가 생각하는 NoSQL 적합 케이스:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ NoSQL 추천:
- 스키마가 자주 변하는 경우
- 단순 Key-Value 조회가 대부분
- 대용량 로그/이벤트 데이터
- 수평 확장이 필수적인 경우

❌ NoSQL 비추천:
- 복잡한 관계와 트랜잭션 필요
- JOIN 쿼리가 많은 경우
- 데이터 일관성이 중요한 비즈니스 로직
</code></pre></div></div>

<p>결론은 MySQL로 시작하고, 필요시 캐시(Redis)와 조합하기로 했다.</p>

<hr />

<h2 id="4-cache--queue-redis를-선택한-이유">4. Cache &amp; Queue: Redis를 선택한 이유</h2>

<h3 id="redis의-세-가지-역할">Redis의 세 가지 역할</h3>

<p>우리 서비스에서 Redis는 단순 캐시를 넘어 세 가지 역할을 한다:</p>

<ol>
  <li><strong>매칭 대기열</strong> - 카테고리별로 대기 중인 사용자 관리</li>
  <li><strong>실시간 세션 관리</strong> - WebSocket 연결 정보</li>
  <li><strong>캐시</strong> - 자주 조회되는 카테고리 정보</li>
</ol>

<h3 id="자료구조-선택-zset-vs-set-vs-list">자료구조 선택: ZSET vs SET vs List</h3>

<p>매칭 대기열을 어떤 자료구조로 구현할지 고민이 많았다.</p>

<h4 id="시도-1-list-lpushrpop">시도 1: List (LPUSH/RPOP)</h4>

<pre><code class="language-redis"># 입장
LPUSH wait:music userId_101

# 매칭 (2명 추출)
RPOP wait:music  # userId_101
RPOP wait:music  # userId_205
</code></pre>

<p>문제점은 대기 순서는 보장되지만, 타임아웃 처리가 어렵고 랜덤 매칭이 불가능했다.</p>

<h4 id="시도-2-set-saddspop">시도 2: Set (SADD/SPOP)</h4>

<pre><code class="language-redis"># 입장
SADD wait:music userId_101

# 매칭 (랜덤 2명)
SPOP wait:music 2
</code></pre>

<p>랜덤은 쉽지만 대기 순서를 알 수 없어서 공정성이 없었다.</p>

<h4 id="최종-선택-zset-sorted-set">최종 선택: ZSET (Sorted Set)</h4>

<pre><code class="language-redis"># 입장 (점수 = 대기 시작 시각)
ZADD wait:music 1725430000456 userId_101
ZADD wait:music 1725430001234 userId_205

# 대기순 매칭
ZPOPMIN wait:music 2

# 랜덤 매칭
ZRANDMEMBER wait:music 2
</code></pre>

<p>장점이 명확했다:</p>

<ul>
  <li>대기 시간 기준 정렬 ✅</li>
  <li>대기순/랜덤 모두 가능 ✅</li>
  <li>타임아웃 쉬움 (점수 기준 삭제) ✅</li>
</ul>

<h3 id="왜-별도의-메시지-큐를-안-썼나">왜 별도의 메시지 큐를 안 썼나?</h3>

<p>RabbitMQ, Kafka 같은 전문 메시지 큐도 고려했다.</p>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Redis</th>
      <th>RabbitMQ</th>
      <th>Kafka</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>학습 곡선</td>
      <td>낮음</td>
      <td>중간</td>
      <td>높음</td>
    </tr>
    <tr>
      <td>운영 복잡도</td>
      <td>낮음</td>
      <td>중간</td>
      <td>높음</td>
    </tr>
    <tr>
      <td>성능 (우리 규모)</td>
      <td>충분</td>
      <td>충분</td>
      <td>과함</td>
    </tr>
    <tr>
      <td>비용</td>
      <td>낮음</td>
      <td>중간</td>
      <td>높음</td>
    </tr>
  </tbody>
</table>

<p>초기 단계에서는 Redis로 충분하다고 판단했다. 트래픽이 늘면 그때 전환을 고려하기로 했다. “과도한 엔지니어링”을 경계해야 한다고 생각했다.</p>

<hr />

<h2 id="5-webrtc-agora를-선택한-이유">5. WebRTC: Agora를 선택한 이유</h2>

<h3 id="직접-구현-vs-saas">직접 구현 vs SaaS</h3>

<p>WebRTC를 직접 구현할지, SaaS를 쓸지 고민했다.</p>

<p>직접 구현 시나리오를 생각해보니:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>필요한 것:
- STUN/TURN 서버 구축 및 운영
- Signaling 서버 개발
- NAT Traversal 처리
- 통화 품질 모니터링
- 녹음 기능 구현

예상 개발 시간: 2-3개월
예상 운영 부담: 높음
</code></pre></div></div>

<p>SaaS 사용 시나리오:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>필요한 것:
- SDK 통합 (1-2주)
- 설정 및 테스트

예상 개발 시간: 2주
예상 운영 부담: 낮음
</code></pre></div></div>

<p>MVP는 빠르게 검증하는 게 중요하다고 생각해서 SaaS를 선택했다.</p>

<h3 id="agora-vs-twilio-vs-daily">Agora vs Twilio vs Daily</h3>

<p>WebRTC SaaS를 비교 분석했다.</p>

<p>비교 기준:</p>

<ol>
  <li><strong>통화 품질</strong> - 모두 우수한 수준, 한국 리전 지원 여부가 중요</li>
  <li><strong>Cloud Recording</strong> - 우리 서비스에 필수 기능</li>
  <li><strong>가격</strong> - 초기 단계라 비용 민감</li>
  <li><strong>문서 및 커뮤니티</strong> - 문제 해결이 쉬운가</li>
</ol>

<p>최종적으로 Agora를 선택한 이유:</p>

<ul>
  <li>Cloud Recording 기능이 강력 (Individual Mode 지원)</li>
  <li>Firebase Storage 직접 연동 가능</li>
  <li>가격 경쟁력</li>
  <li>한국어 문서와 한국 리전 지원</li>
</ul>

<p>다만 Twilio보다 커뮤니티가 작고, 일부 고급 기능은 Twilio가 우세하다는 점은 고려사항이었다.</p>

<h3 id="실제-사용-후기">실제 사용 후기</h3>

<p>Agora를 6개월간 사용한 경험을 정리하면:</p>

<p>만족스러운 점:</p>

<ul>
  <li>SDK 통합이 생각보다 쉬움</li>
  <li>녹음 기능이 안정적</li>
  <li>통화 품질 좋음</li>
</ul>

<p>아쉬운 점:</p>

<ul>
  <li>일부 에러 메시지가 불친절</li>
  <li>고급 설정 시 영어 문서 의존도 높음</li>
</ul>

<hr />

<h2 id="6-file-storage-firebase-storage를-선택한-이유">6. File Storage: Firebase Storage를 선택한 이유</h2>

<h3 id="왜-aws-s3가-아닌가">왜 AWS S3가 아닌가?</h3>

<p>통화 녹음 파일을 저장할 곳이 필요했다. 가장 먼저 떠오른 건 AWS S3였다.</p>

<p>고민한 점:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AWS S3:
✅ 업계 표준
✅ 많은 레퍼런스
✅ 강력한 기능

Firebase Storage:
✅ 이미 프로필 이미지에 사용 중
✅ GCS 기반 (Agora와 호환성 좋음)
✅ Firebase 생태계 활용 가능
</code></pre></div></div>

<h3 id="실용적-판단">실용적 판단</h3>

<p>결정적이었던 건 <strong>이미 사용하고 있다</strong>는 점이었다.</p>

<p>새로운 기술을 도입하면:</p>

<ul>
  <li>학습 시간</li>
  <li>설정 및 테스트</li>
  <li>운영 노하우 축적</li>
  <li>문제 해결 경험</li>
</ul>

<p>이 모든 비용이 든다.</p>

<p>기존 기술을 활용하면:</p>

<ul>
  <li>즉시 사용 가능</li>
  <li>이미 익숙함</li>
  <li>통합 관리 편함</li>
</ul>

<p>“최신/유명 != 우리에게 최선”이라는 걸 다시 한번 깨달았다.</p>

<h3 id="agora와의-통합">Agora와의 통합</h3>

<p>특히 Agora Cloud Recording이 GCS(Google Cloud Storage)와 직접 연동된다는 점이 좋았다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Agora → Firebase Storage (GCS 기반)
- HMAC 인증으로 직접 업로드
- 별도의 파일 전송 서버 불필요
- 자동 업로드 (15초마다 segment)
</code></pre></div></div>

<hr />

<h2 id="7-frontend-react--capacitor를-선택한-이유">7. Frontend: React + Capacitor를 선택한 이유</h2>

<h3 id="웹인가-앱인가">웹인가, 앱인가?</h3>

<p>처음부터 모바일 앱을 목표로 했다. 음성 통화 특성상 앱이 더 자연스럽다고 판단했다.</p>

<p>선택지를 정리하면:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 웹 (React)만 개발
   → 빠르지만 접근성 낮음

2. React Native
   → 네이티브 성능, 웹 코드 재사용 불가

3. Flutter
   → 성능 좋음, Dart 새로 학습 필요

4. Capacitor (선택!)
   → 웹 코드 100% 재사용, WebView 기반
</code></pre></div></div>

<h3 id="capacitor의-장점">Capacitor의 장점</h3>

<p>가장 큰 장점은 빠른 개발이었다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기존 React 웹 코드</span>
<span class="kd">const</span> <span class="nx">CallPage</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">setChannel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="dl">''</span><span class="p">);</span>
  <span class="c1">// Agora WebRTC 로직</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// Capacitor 추가 후</span>
<span class="nx">npm</span> <span class="nx">install</span> <span class="p">@</span><span class="nd">capacitor</span><span class="sr">/cor</span><span class="err">e
</span><span class="nx">npx</span> <span class="nx">cap</span> <span class="nx">add</span> <span class="nx">android</span> <span class="nx">ios</span>

<span class="c1">// 앱 빌드 완료!</span>
</code></pre></div></div>

<p>단일 코드베이스로 관리할 수 있다는 것도 큰 장점이었다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/
  components/
    CallPage.tsx      ← 웹, Android, iOS 모두 사용
    MatchingButton.tsx
  lib/
    agora.ts          ← 한 번만 작성
    websocket.ts
</code></pre></div></div>

<h3 id="네이티브-기능-접근">네이티브 기능 접근</h3>

<p>Capacitor 플러그인으로 네이티브 기능도 사용 가능했다:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 카카오 네이티브 로그인</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">KakaoLoginPlugin</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">capacitor-kakao-login-plugin</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">KakaoLoginPlugin</span><span class="p">.</span><span class="nx">goLogin</span><span class="p">();</span>

<span class="c1">// 구글 네이티브 로그인</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">GoogleAuth</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@codetrix-studio/capacitor-google-auth</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">GoogleAuth</span><span class="p">.</span><span class="nx">signIn</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="한계와-트레이드오프">한계와 트레이드오프</h3>

<p>WebView 제약이 있다:</p>

<ul>
  <li>네이티브 앱보다 성능 떨어짐</li>
  <li>일부 브라우저 제약 (CORS, Cookie 등)</li>
  <li>플랫폼별 차이 (iOS vs Android)</li>
</ul>

<p>그럼에도 선택한 이유는:</p>

<ul>
  <li><strong>속도:</strong> 2-3개월 단축</li>
  <li><strong>유지보수:</strong> 하나의 코드베이스</li>
  <li><strong>검증:</strong> MVP 빠르게 출시</li>
</ul>

<p>초기에는 Capacitor로 시작하고, 성장하면 부분적으로 네이티브 전환을 고려하기로 했다.</p>

<hr />

<h2 id="8-배포-환경-aws--vercel">8. 배포 환경: AWS + Vercel</h2>

<h3 id="backend-aws-ec2">Backend: AWS EC2</h3>

<p>“왜 컨테이너(ECS, EKS)가 아닌가?”라는 질문을 받을 수 있는데:</p>

<p>우리 상황:</p>

<ul>
  <li>단일 서버로 충분</li>
  <li>오토 스케일링 아직 불필요</li>
  <li>운영 복잡도 최소화</li>
</ul>

<p>선택:</p>

<ul>
  <li>EC2 단일 인스턴스</li>
  <li>Nginx 리버스 프록시</li>
  <li>Let’s Encrypt SSL</li>
</ul>

<p>비용도 고려했다. ECS/EKS는 추가 비용이 들고, Elastic Load Balancer도 고정 비용이 든다. EC2 단독이 가장 경제적이었다.</p>

<h3 id="frontend-vercel">Frontend: Vercel</h3>

<p>왜 Vercel인가?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ 장점:
- Git push → 자동 배포
- HTTPS 기본 제공
- CDN 자동 설정
- 무료 플랜으로 충분

vs

AWS S3 + CloudFront:
- 직접 설정 필요
- 비용 발생
- CI/CD 직접 구축
</code></pre></div></div>

<p>프론트엔드는 정적 파일이므로 Vercel이 훨씬 편했다.</p>

<hr />

<h2 id="9-기술-선택의-원칙">9. 기술 선택의 원칙</h2>

<p>6개월간의 경험을 돌아보니, 내게는 몇 가지 원칙이 생겼다.</p>

<h3 id="원칙-1-맥락이-가장-중요하다">원칙 1: “맥락”이 가장 중요하다</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❌ "요즘 A가 대세니까 A를 써야지"
✅ "우리 상황에서는 B가 더 적합해"
</code></pre></div></div>

<p>예시:</p>

<ul>
  <li>Kafka는 강력하지만 우리 규모에는 과함 → Redis 선택</li>
  <li>React Native는 좋지만 웹 코드 재사용 중요 → Capacitor 선택</li>
</ul>

<h3 id="원칙-2-mvp는-빠르게-확장은-점진적으로">원칙 2: MVP는 빠르게, 확장은 점진적으로</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>처음부터 완벽한 설계 (X)
빠른 검증 → 점진적 개선 (O)
</code></pre></div></div>

<p>실제 적용:</p>

<ul>
  <li>단일 EC2로 시작 → 트래픽 증가 시 확장 고려</li>
  <li>Redis 대기열 → 필요시 Kafka 전환</li>
  <li>Capacitor → 성장하면 부분 네이티브</li>
</ul>

<h3 id="원칙-3-익숙함도-중요한-가치">원칙 3: “익숙함”도 중요한 가치</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>새로운 기술 학습 비용 vs 익숙한 기술 활용

학부/석사에서 Spring 사용 경험
→ Spring Boot 선택이 자연스러움
</code></pre></div></div>

<h3 id="원칙-4-비용은-현실적-제약">원칙 4: 비용은 현실적 제약</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기 단계의 인프라 비용:
- EC2, RDS, Redis, Agora, Firebase
→ 월 수십 달러 수준으로 통제

vs

이상적 아키텍처:
- ECS, ELB, CloudFront, Kafka...
→ 월 수백 달러
</code></pre></div></div>

<p>서비스 검증이 우선이고, 인프라는 필요 시 확장하기로 했다.</p>

<hr />

<h2 id="10-마치며">10. 마치며</h2>

<p>기술 선택은 트레이드오프의 연속이었다.</p>

<ul>
  <li>성능 vs 개발 속도</li>
  <li>이상 vs 현실</li>
  <li>최신 기술 vs 익숙한 기술</li>
  <li>비용 vs 확장성</li>
</ul>

<p>중요한 건 “정답”을 찾는 게 아니라, “우리에게 맞는 답”을 찾는 것이었다.</p>

<p>6개월간 이 기술들로 서비스를 만들고 운영하며 정말 많이 배웠다.
선택이 완벽하진 않았지만, 후회는 없다.
각 선택의 이유를 명확히 알고 있고, 필요하면 언제든 바꿀 수 있다는 확신이 있기 때문이다!</p>

<p><strong>“왜?”라는 질문을 끊임없이 던지자. 그 답이 쌓이면, 그게 바로 우리의 기술 철학이 된다.</strong></p>

<hr />

<p><strong>시리즈:</strong></p>

<ol>
  <li><strong>왜 이 기술들을 선택했나</strong> ← 현재 글</li>
  <li><a href="https://nan0silver.github.io/projectdiary/2025-12-25-diary/">실시간 매칭 시스템 설계</a></li>
</ol>

<hr />

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://docs.spring.io/spring-framework/reference/web/webflux.html">Spring WebFlux 공식 문서</a></li>
  <li><a href="https://redis.io/docs/data-types/">Redis 자료구조 가이드</a></li>
  <li><a href="https://docs.agora.io/en/cloud-recording">Agora Cloud Recording</a></li>
  <li><a href="https://capacitorjs.com/docs">Capacitor 공식 문서</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[컴퓨터공학 석사 출신 개발자가 첫 실전 프로젝트에서 마주한 기술 선택의 기록]]></summary></entry><entry><title type="html">[친구하자] Agora Cloud Recording과 Firebase Storage로 음성 통화 녹음 구현하기</title><link href="https://nan0silver.github.io/projectdiary/2025-11-24-diary/" rel="alternate" type="text/html" title="[친구하자] Agora Cloud Recording과 Firebase Storage로 음성 통화 녹음 구현하기" /><published>2025-11-24T00:00:00+00:00</published><updated>2026-02-18T07:00:01+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-24-diary/"><![CDATA[<p>‘친구하자’를 개발하며 통화 녹음 기능을 구현해야 했다. AI 개발과 통화 분석 등 추후 기능들을 위해 통화를 녹음하는 것을 전제로 구현을 시작했다.</p>

<p>처음에는 단순할 줄 알았는데, 생각보다 에러도 많이 나고 시행착오가 많아서 MVP에서 제외하고 개발했다. 이 글에서는 어떤 문제들을 겪었고, 어떻게 해결했는지를 정리하려고 한다.</p>

<h2 id="목차">목차</h2>

<ul>
  <li><a href="#1-기술-스택-선택">1. 기술 스택 선택</a></li>
  <li><a href="#2-구현-과정에서-만난-문제들">2. 구현 과정에서 만난 문제들</a></li>
  <li><a href="#3-최종-구조">3. 최종 구조</a></li>
  <li><a href="#4-배운-점">4. 배운 점</a></li>
  <li><a href="#5-운영-지표">5. 운영 지표</a></li>
  <li><a href="#6-마치며">6. 마치며</a></li>
  <li><a href="#참고-자료">참고 자료</a></li>
</ul>

<hr />

<h2 id="1-기술-스택-선택">1. 기술 스택 선택</h2>

<h3 id="11-왜-agora-cloud-recording을-선택했나">1.1. 왜 Agora Cloud Recording을 선택했나?</h3>

<p>처음에 WebRTC 서비스를 선택하기에 앞서 Recording 구현을 고려했다. WebRTC 중에는 recording을 지원하는 서비스가 있고, 아닌 서비스가 있었다. 그중 Agora는 Recording 지원이 가장 다양했고, 가격도 저렴했다.</p>

<p>Recording을 저장하는 것에도 많은 선택지가 있었다:</p>

<ol>
  <li><strong>Agora 백업 저장소</strong>
    <ul>
      <li>제3자 스토리지 설정이 실패하면 백업 서버에 <strong>24시간 동안만</strong> 임시 저장</li>
      <li>운영용이 아니므로 반드시 외부 저장소 연동 필요</li>
    </ul>
  </li>
  <li><strong>AWS S3 직접 연동</strong>
    <ul>
      <li>가장 일반적이고 안정적인 방법</li>
    </ul>
  </li>
  <li><strong>Firebase Storage (GCS 기반)</strong>
    <ul>
      <li>이미 프로젝트에서 사용 중 (프로필 이미지 등)</li>
    </ul>
  </li>
</ol>

<p>고민 끝에 <strong>Firebase Storage</strong>를 선택했다:</p>

<ul>
  <li>이미 프로젝트에서 사용 중이어서 익숙함</li>
  <li>GCS(Google Cloud Storage) 기반이라 Agora와 호환성이 좋음</li>
  <li>Firebase의 다른 기능들과도 잘 통합됨</li>
  <li>AWS S3와 비용이 비슷한 수준 (월 1,000분 통화 기준 약 80원 차이)</li>
</ul>

<h3 id="12-individual-recording-mode-선택">1.2. Individual Recording Mode 선택</h3>

<p>Agora Cloud Recording에는 여러 모드가 있다:</p>

<ul>
  <li><strong>Composite Mode</strong>: 모든 사람의 음성을 하나로 합침</li>
  <li><strong>Individual Mode</strong>: 각 사용자별로 별도 녹음</li>
</ul>

<p>나는 <strong>Individual Mode</strong>를 선택했다. 추후 각 사용자의 음성을 따로 분석할 수도 있고, 더 유연하기 때문이다.</p>

<h2 id="2-구현-과정에서-만난-문제들">2. 구현 과정에서 만난 문제들</h2>

<h3 id="21-비동기-처리-설정-문제">2.1. 비동기 처리 설정 문제</h3>

<p>녹음 시작/중지는 시간이 걸리는 작업이기 때문에 비동기로 처리해야 했다. 그런데 Spring에서 이런 경고가 떴다:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>More than one TaskExecutor bean found within the context,
and none is named <span class="s1">'taskExecutor'</span>
</code></pre></div></div>

<p><strong>문제:</strong></p>

<p><code class="language-plaintext highlighter-rouge">@Async</code>만 쓰면 Spring이 <code class="language-plaintext highlighter-rouge">SimpleAsyncTaskExecutor</code>를 사용한다. 이는 매번 새 스레드를 생성하기 때문에 매우 비효율적이다.</p>

<p>내 경우, 애플리케이션 컨텍스트에 이미 여러 개의 <code class="language-plaintext highlighter-rouge">TaskExecutor</code> 빈이 존재했는데 (<code class="language-plaintext highlighter-rouge">recordingTaskExecutor</code>, <code class="language-plaintext highlighter-rouge">matchingTaskExecutor</code> 등), 어느 것도 <code class="language-plaintext highlighter-rouge">taskExecutor</code>라는 이름을 가지고 있지 않았다. Executor를 지정하지 않고 <code class="language-plaintext highlighter-rouge">@Async</code>만 작성하니 Spring에서 경고를 보냈다.</p>

<p><strong>해결:</strong></p>

<p>용도별로 Executor를 분리하고, 기본 <code class="language-plaintext highlighter-rouge">taskExecutor</code>를 명시적으로 지정했다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableAsync</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsyncConfig</span> <span class="kd">implements</span> <span class="nc">AsyncConfigurer</span> <span class="o">{</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"taskExecutor"</span><span class="o">)</span>
    <span class="nd">@Primary</span>
    <span class="kd">public</span> <span class="nc">Executor</span> <span class="nf">taskExecutor</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ThreadPoolTaskExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolTaskExecutor</span><span class="o">();</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setCorePoolSize</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setMaxPoolSize</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setQueueCapacity</span><span class="o">(</span><span class="mi">25</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setThreadNamePrefix</span><span class="o">(</span><span class="s">"Async-"</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">executor</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"recordingTaskExecutor"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Executor</span> <span class="nf">recordingTaskExecutor</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ThreadPoolTaskExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolTaskExecutor</span><span class="o">();</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setCorePoolSize</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setMaxPoolSize</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setQueueCapacity</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setThreadNamePrefix</span><span class="o">(</span><span class="s">"Recording-"</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">executor</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 하면 스레드 풀을 재사용해서 성능이 훨씬 좋아진다:</p>

<ul>
  <li>스레드 생성 비용: ~1-2ms → ~0.01ms</li>
  <li>리소스 제한: 무제한 → 최대 5개로 제어</li>
</ul>

<h3 id="22-firebase-storage-저장-실패">2.2. Firebase Storage 저장 실패</h3>

<p>드디어 녹음이 시작되었다! 로그에도 성공 메시지가 떴다. 그런데 Firebase Storage를 확인해보니… 파일이 없었다. 😱</p>

<p><strong>문제의 핵심: <code class="language-plaintext highlighter-rouge">uploadingStatus=backuped</code></strong></p>

<p><code class="language-plaintext highlighter-rouge">uploadingStatus</code>에는 두 가지 값이 있다:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">uploaded</code></strong>: 제3자 스토리지(Firebase)에 업로드 성공</li>
  <li><strong><code class="language-plaintext highlighter-rouge">backuped</code></strong>: Agora 자체 백업 서버에 저장 (24시간 후 삭제)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">backuped</code>가 나왔다는 건 Firebase에 업로드가 실패했다는 의미였다.</p>

<p><strong>원인: HMAC 키가 없었다!</strong></p>

<p>Agora가 GCS(Google Cloud Storage)에 파일을 올리려면 <strong>HMAC 인증 키</strong>가 필요하다. Firebase Console → Storage → Settings → Interoperability를 확인해보니 아무것도 없었다.</p>

<p><strong>해결 과정:</strong></p>

<ol>
  <li>
    <p><strong>Google Cloud Console 접속</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cloud Console → Storage → Settings → Interoperability
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>HMAC 키 생성</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Service account HMAC 섹션
→ Create a key for a service account
→ firebase-adminsdk-xxxxx@프로젝트명.iam.gserviceaccount.com 선택
→ CREATE KEY
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Access Key와 Secret 복사</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Access Key: GOOG1E...로 시작하는 긴 문자열
Secret: 한 번만 보여주니 즉시 복사!
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>application.yml 설정</strong></p>
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">app</span><span class="pi">:</span>
  <span class="na">agora</span><span class="pi">:</span>
    <span class="na">recording-region</span><span class="pi">:</span> <span class="m">0</span> <span class="c1"># GCS Multi-region US</span>
    <span class="na">recording-storage-vendor</span><span class="pi">:</span> <span class="s2">"</span><span class="s">6"</span> <span class="c1"># 6 = GCS</span>
    <span class="na">recording-storage-bucket</span><span class="pi">:</span> <span class="s">프로젝트명.appspot.com</span>
    <span class="na">recording-storage-access-key</span><span class="pi">:</span> <span class="s">${AGORA_STORAGE_ACCESS_KEY}</span>
    <span class="na">recording-storage-secret-key</span><span class="pi">:</span> <span class="s">${AGORA_STORAGE_SECRET_KEY}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>이렇게 설정하고 다시 녹음을 시작했더니… 드디어 성공! 🎉</p>

<h2 id="3-최종-구조">3. 최종 구조</h2>

<p>모든 삽질을 마치고 완성된 구조는 다음과 같다:</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-24-pic1.png?raw=true" alt="이미지1" /></p>

<h3 id="31-주요-특징">3.1. 주요 특징</h3>

<ol>
  <li><strong>Individual Recording Mode</strong>: 각 사용자별로 별도 녹음</li>
  <li><strong>Audio Only</strong>: 비용 절감 (비디오 없음)</li>
  <li><strong>자동 업로드</strong>: Agora → Firebase Storage 직접 저장</li>
  <li><strong>파일 구조화</strong>: 날짜/Call ID별 폴더 정리</li>
  <li><strong>비동기 처리</strong>: 녹음 시작/중지가 메인 스레드를 블로킹하지 않음</li>
</ol>

<h2 id="4-배운-점">4. 배운 점</h2>

<h3 id="41-공식-문서를-꼼꼼히-읽자">4.1. 공식 문서를 꼼꼼히 읽자</h3>

<p>Agora 공식 문서에 Individual Mode와 Composite Mode의 차이가 명확하게 나와 있었다. 처음부터 제대로 읽었으면 불필요한 시행착오를 줄일 수 있었을 것이다.</p>

<h3 id="42-클라우드-서비스는-인증이-핵심">4.2. 클라우드 서비스는 인증이 핵심</h3>

<p>Firebase Storage에 파일이 안 올라가는 이유가 HMAC 키 때문이었다. 클라우드 간 연동에서는 항상 <strong>인증 설정을 먼저 확인</strong>해야 한다.</p>

<h3 id="43-비동기-처리는-제대로-설정하자">4.3. 비동기 처리는 제대로 설정하자</h3>

<p><code class="language-plaintext highlighter-rouge">@Async</code>만 쓰고 넘어가면 안 된다. 제대로 된 <code class="language-plaintext highlighter-rouge">ThreadPoolTaskExecutor</code>를 설정해야 운영에서 안정적이다.</p>

<h2 id="5-운영-지표">5. 운영 지표</h2>

<p>현재 운영 중인 시스템의 주요 지표:</p>

<ul>
  <li><strong>녹음 시작 시간</strong>: 평균 2-3초</li>
  <li><strong>파일 업로드</strong>: Agora가 자동 처리 (15초마다)</li>
  <li><strong>DB 저장</strong>: 비동기 처리로 메인 로직에 영향 없음</li>
  <li><strong>스레드 풀</strong>: 최대 5개 스레드로 제한되어 안정적</li>
</ul>

<p><strong>비용 최적화:</strong></p>

<ul>
  <li>Audio Only로 비디오 대비 비용 1/5 수준</li>
  <li>maxIdleTime 설정으로 30초 무음 시 자동 종료</li>
  <li>streamMode: standard (Agora 권장)</li>
</ul>

<h2 id="6-마치며">6. 마치며</h2>

<p>처음엔 “그냥 녹음만 하면 되는 거 아니야?”라고 쉽게 생각했는데, 실제로는 정말 많은 함정이 있었다:</p>

<ul>
  <li>Individual vs Composite Mode 이해</li>
  <li>HMAC 키 설정</li>
  <li>비동기 처리 구성</li>
  <li>에러 핸들링</li>
</ul>

<p>하나하나 해결하면서 많이 배웠다. 특히 클라우드 서비스 간 연동에서 <strong>인증과 권한 설정</strong>이 얼마나 중요한지 깨달았다.</p>

<p>이 글이 Agora Cloud Recording과 Firebase Storage를 연동하려는 누군가에게 도움이 되었으면 좋겠다. 😅</p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://docs.agora.io/en/cloud-recording/develop/individual-mode">Agora Individual Recording 공식 문서</a></li>
  <li><a href="https://docs.agora.io/en/cloud-recording/reference/region-vendor">Agora Cloud Storage 설정</a></li>
  <li><a href="https://cloud.google.com/storage/docs/authentication/hmackeys">Google Cloud HMAC 키 생성</a></li>
  <li><a href="https://spring.io/guides/gs/async-method">Spring Async 설정</a></li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Agora Cloud Recording을 통한 통화 녹음과 이를 Firebase Storage에 저장하는 기능을 구현하면서 경험한 것과 느낀 점을 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor 앱 Custom Splash Screen 구현하기</title><link href="https://nan0silver.github.io/projectdiary/2025-11-20-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor 앱 Custom Splash Screen 구현하기" /><published>2025-11-20T00:00:00+00:00</published><updated>2026-02-18T07:00:01+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-20-diary/"><![CDATA[<ul>
  <li>이번 포스팅에선 Capacitor로 빌드한 앱에서 여러 아이콘이 순차적으로 표시되는 커스텀 스플래시 스크린을 구현하는 방법을 정리했다.</li>
  <li>왜 Custom splash screen이 필요했나?
    <ul>
      <li>Capacitor의 기본 splash screen은 단일 정적 이미지만 지원한다.<a href="https://capacitorjs.com/docs/apis/splash-screen">🔗링크</a></li>
      <li>나는 여러 아이콘을 순차적으로 보여주는 애니메이션을 구현하고 싶어 React 컴포넌트로 직접 구현하였다!</li>
    </ul>
  </li>
</ul>

<h2 id="목차">목차</h2>

<ul>
  <li><a href="#1-필요한-패키지-설치">1. 필요한 패키지 설치</a></li>
  <li><a href="#2-capacitor-설정">2. Capacitor 설정</a></li>
  <li><a href="#3-커스텀-스플래시-스크린-컴포넌트-생성">3. 커스텀 스플래시 스크린 컴포넌트 생성</a></li>
  <li><a href="#4-apptsx에-통합">4. App.tsx에 통합</a></li>
  <li><a href="#핵심-구현-포인트">핵심 구현 포인트</a></li>
  <li><a href="#주의사항">주의사항</a></li>
  <li><a href="#참고-문헌">참고 문헌</a></li>
</ul>

<hr />

<h2 id="1-필요한-패키지-설치">1. 필요한 패키지 설치</h2>

<p>먼저 스플래시 스크린 관련 패키지를 설치하자.</p>

<blockquote>
  <p>나는 pnpm을 사용하고 있었으므로 pnpm으로 설치했다.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pnpm add @capacitor/splash-screen
pnpm add <span class="nt">-D</span> @capacitor/assets
</code></pre></div></div>

<h2 id="2-capacitor-설정">2. Capacitor 설정</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">capacitor.config.ts</code> 파일에 스플래시 스크린 설정을 추가하자.</li>
  <li>‼️ 커스텀 스플래시를 사용하므로 네이티브 스플래시는 최소화!</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// &lt;reference types="@capacitor/splash-screen" /&gt;</span>

<span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">CapacitorConfig</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@capacitor/cli</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">config</span><span class="p">:</span> <span class="nx">CapacitorConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ... 기타 설정</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">SplashScreen</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">launchShowDuration</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// 커스텀 스플래시를 사용하므로 0으로 설정</span>
      <span class="na">launchAutoHide</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 자동으로 숨길지 여부</span>
      <span class="na">launchFadeOutDuration</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// 페이드 아웃 애니메이션 시간 (커스텀 스플래시에서 처리)</span>
      <span class="na">backgroundColor</span><span class="p">:</span> <span class="dl">"</span><span class="s2">#ffffff</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 배경색 (hex 형식) - 커스텀 스플래시와 동일하게 설정</span>
      <span class="c1">// ... 기타 설정</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">config</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="3-커스텀-스플래시-스크린-컴포넌트-생성">3. 커스텀 스플래시 스크린 컴포넌트 생성</h2>

<p><code class="language-plaintext highlighter-rouge">client/components/CustomSplashScreen.tsx</code> 파일을 생성한다.</p>

<h3 id="props-정의">Props 정의</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">CustomSplashScreenProps</span> <span class="p">{</span>
  <span class="nl">onComplete</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span> <span class="c1">// 스플래시 완료 시 콜백</span>
  <span class="nl">icons</span><span class="p">?:</span> <span class="kr">string</span><span class="p">[];</span> <span class="c1">// 표시할 아이콘 배열</span>
  <span class="nl">iconDuration</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// 각 아이콘 표시 시간(ms)</span>
  <span class="nl">minDisplayDuration</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// 최소 표시 시간(ms)</span>
  <span class="nl">animationType</span><span class="p">?:</span> <span class="dl">"</span><span class="s2">slide-up</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">fade</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">none</span><span class="dl">"</span><span class="p">;</span>
  <span class="nl">backgroundColor</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="핵심-로직">핵심 로직</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">CustomSplashScreen</span> <span class="o">=</span> <span class="p">({</span>
  <span class="nx">onComplete</span><span class="p">,</span>
  <span class="nx">icons</span> <span class="o">=</span> <span class="p">[],</span>
  <span class="nx">iconDuration</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
  <span class="nx">minDisplayDuration</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
  <span class="nx">animationType</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">slide-up</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">backgroundColor</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">#ffffff</span><span class="dl">"</span><span class="p">,</span>
<span class="p">}:</span> <span class="nx">CustomSplashScreenProps</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">currentIconIndex</span><span class="p">,</span> <span class="nx">setCurrentIconIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">isVisible</span><span class="p">,</span> <span class="nx">setIsVisible</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

  <span class="c1">// 1. 네이티브 스플래시 스크린 즉시 숨기기</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">hideNativeSplash</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="k">await</span> <span class="nx">SplashScreen</span><span class="p">.</span><span class="nx">hide</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 웹 환경에서는 에러가 발생할 수 있으므로 무시</span>
      <span class="p">}</span>
    <span class="p">};</span>
    <span class="nx">hideNativeSplash</span><span class="p">();</span>
  <span class="p">},</span> <span class="p">[]);</span>

  <span class="c1">// 2. 아이콘 순차 표시 로직</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">icons</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">setIsVisible</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">onComplete</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
      <span class="p">},</span> <span class="nx">minDisplayDuration</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 아이콘 전환 인터벌</span>
    <span class="kd">const</span> <span class="nx">iconInterval</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setCurrentIconIndex</span><span class="p">((</span><span class="nx">prev</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">prev</span> <span class="o">&lt;</span> <span class="nx">icons</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">prev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">prev</span><span class="p">;</span>
      <span class="p">});</span>
    <span class="p">},</span> <span class="nx">iconDuration</span><span class="p">);</span>

    <span class="c1">// 총 표시 시간 계산</span>
    <span class="kd">const</span> <span class="nx">totalAnimationDuration</span> <span class="o">=</span> <span class="nx">icons</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="nx">iconDuration</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">actualDuration</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">totalAnimationDuration</span><span class="p">,</span> <span class="nx">minDisplayDuration</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">completeTimer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setIsVisible</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
      <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">onComplete</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
    <span class="p">},</span> <span class="nx">actualDuration</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">iconInterval</span><span class="p">);</span>
      <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">completeTimer</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">},</span> <span class="p">[</span><span class="nx">icons</span><span class="p">,</span> <span class="nx">iconDuration</span><span class="p">,</span> <span class="nx">minDisplayDuration</span><span class="p">,</span> <span class="nx">onComplete</span><span class="p">]);</span>

  <span class="c1">// ... 렌더링 로직</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li>아이콘 슬라이드 애니메이션과 텍스트 추가 등 개인의 디자인에 맞게 React 코드를 수정해서 꾸며주면 된다!!</li>
</ul>

<h2 id="4-apptsx에-통합">4. App.tsx에 통합</h2>

<p>메인 앱 컴포넌트에 커스텀 스플래시 스크린을 통합합니다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">CustomSplashScreen</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./components/CustomSplashScreen</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">AppRoutes</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">showSplash</span><span class="p">,</span> <span class="nx">setShowSplash</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

  <span class="c1">// 스플래시 스크린에 표시할 아이콘들</span>
  <span class="kd">const</span> <span class="nx">splashIcons</span> <span class="o">=</span> <span class="p">[</span>
    <span class="dl">"</span><span class="s2">/splash-icons/icon1.png</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">/splash-icons/icon2.png</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">/splash-icons/icon3.png</span><span class="dl">"</span><span class="p">,</span>
    <span class="c1">// ... 더 많은 아이콘</span>
  <span class="p">];</span>

  <span class="kd">const</span> <span class="nx">handleSplashComplete</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setShowSplash</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">showSplash</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">CustomSplashScreen</span>
        <span class="nx">onComplete</span><span class="o">=</span><span class="p">{</span><span class="nx">handleSplashComplete</span><span class="p">}</span>
        <span class="nx">icons</span><span class="o">=</span><span class="p">{</span><span class="nx">splashIcons</span><span class="p">}</span>
        <span class="nx">iconDuration</span><span class="o">=</span><span class="p">{</span><span class="mi">400</span><span class="p">}</span>
        <span class="nx">minDisplayDuration</span><span class="o">=</span><span class="p">{</span><span class="mi">2000</span><span class="p">}</span>
        <span class="nx">animationType</span><span class="o">=</span><span class="dl">"</span><span class="s2">slide-up</span><span class="dl">"</span>
      <span class="o">/&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ... 나머지 앱 로직</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="-핵심-구현-포인트-">🍎 핵심 구현 포인트 🍎</h2>

<h3 id="1-네이티브-스플래시와-커스텀-스플래시-분리">1. 네이티브 스플래시와 커스텀 스플래시 분리</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">launchShowDuration: 0</code>으로 설정하여 네이티브 스플래시를 즉시 숨김</li>
  <li><code class="language-plaintext highlighter-rouge">SplashScreen.hide()</code>를 컴포넌트 마운트 시 호출</li>
</ul>

<h3 id="2-텍스트-깜빡임-방지">2. 텍스트 깜빡임 방지</h3>

<p>아이콘과 텍스트를 별도의 <code class="language-plaintext highlighter-rouge">div</code>로 렌더링하여 아이콘이 변경될 때 텍스트가 깜빡이지 않도록 구현</p>

<h3 id="3-부드러운-애니메이션">3. 부드러운 애니메이션</h3>

<p>CSS <code class="language-plaintext highlighter-rouge">transition</code>과 <code class="language-plaintext highlighter-rouge">cubic-bezier</code> 타이밍 함수를 사용하여 자연스러운 전환 효과 구현</p>

<h3 id="4-최소-표시-시간-보장">4. 최소 표시 시간 보장</h3>

<p><code class="language-plaintext highlighter-rouge">minDisplayDuration</code>을 설정하여 애니메이션이 너무 빨리 끝나도 최소 시간은 보장</p>

<h3 id="5-이미지-준비">5. 이미지 준비</h3>

<p>아이콘 이미지는 <code class="language-plaintext highlighter-rouge">public/splash-icons/</code> 디렉토리에 저장합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public/
  splash-icons/
    icon1.png
    icon2.png
    icon3.png
</code></pre></div></div>

<h2 id="️-주의사항">‼️ 주의사항</h2>

<ul>
  <li>이미지는 반드시 <code class="language-plaintext highlighter-rouge">public</code> 폴더에 저장 (빌드 시 자동 포함)</li>
  <li>웹 환경에서는 <code class="language-plaintext highlighter-rouge">SplashScreen.hide()</code>가 에러를 발생시킬 수 있으므로 try-catch 처리 필요</li>
  <li>Android 12 이상에서는 네이티브 스플래시 API가 강제 적용되므로 초기 0.5초는 네이티브 스플래시가 보일 수 있음</li>
</ul>

<h2 id="-참고-문헌">🍀 참고 문헌</h2>

<ul>
  <li><a href="https://github.com/ionic-team/capacitor-assets">Capacitor assets github page</a></li>
  <li><a href="https://capacitorjs.com/docs/apis/splash-screen">@capacitor/splash-screen DOCS</a></li>
  <li><a href="https://capacitorjs.com/docs/guides/splash-screens-and-icons">Splash Screens and Icons DOCS</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 앱에서 Splash Screen을 React로 직접 구현한 내용에 대해 다룹니다.]]></summary></entry></feed>