<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-04-04T02:21:48+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[Spring] DTO vs VO vs Entity</title><link href="https://nan0silver.github.io/spring/2025-04-02-dto-vo/" rel="alternate" type="text/html" title="[Spring] DTO vs VO vs Entity" /><published>2025-04-02T00:00:00+00:00</published><updated>2025-04-04T02:21:08+00:00</updated><id>https://nan0silver.github.io/spring/dto-vo</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-02-dto-vo/"><![CDATA[<ul>
  <li><a href="#-resttemplate이란">RestTemplate이란?</a></li>
</ul>

<hr />

<h2 id="dto-vs-vo-vs-entity">DTO vs VO vs Entity</h2>

<blockquote>
  <p>Entity는 DB와 매핑되는 핵심 객체, DTO는 데이터 전달용 객체, VO는 값 자체에 의미가 있는 불변 객체
Entity는 저장용, DTO는 전달용, VO는 표현용 객체</p>
</blockquote>

<ul>
  <li>
    <p>DTO : Data Transfer Object ➡️ 데이터 전달용 객체 (계층 간, 네트워크 등)</p>

    <ul>
      <li>🚐 손님에게 배달될 포장된 도시락
        <ul>
          <li>음식점 → 배달기사 → 고객까지 전달하는 용도
            <ul>
              <li>💡 클라이언트와 데이터 주고받는 운반용 객체! 💡</li>
            </ul>
          </li>
          <li>메뉴명, 수량, 요청사항 등 담겨 있고, 전달 중에 수정될 수도 있음 (상황에 따라 포장을 다르게 담을 수 있다.)</li>
        </ul>
      </li>
      <li>외부에 노출되는 API요청이나 응답은 Entity가 아닌 DTO를 통해 전달함으로써 보안성과 유연성을 확보</li>
    </ul>

    <blockquote>
      <p>🔴 DTO는 데이터를 <strong>“옮기는 상자”</strong></p>
    </blockquote>
  </li>
  <li>
    <p>VO : Value Object ➡️ 값을 표현하는 객체 (의미 있는 불변 값)</p>

    <ul>
      <li>🍱 도시락 자체
        <ul>
          <li>만들어지면 바꿀 수 없음 (불변)</li>
          <li>메뉴가 같으면 같은 도시락 취급</li>
          <li>값 자체가 의미 있음 - 예: 좌표, 돈, 날짜, 주소 등</li>
        </ul>
      </li>
    </ul>

    <blockquote>
      <p>🔴 VO는 의미 있는 값을 담은 <strong>“정체성 있는 객체”</strong></p>

      <blockquote>
        <p>“무엇을 나타내는 값인지”가 중요한 객체</p>
      </blockquote>
    </blockquote>
  </li>
  <li>
    <p>Entity ➡️ 실제 DB 테이블과 연결된 핵심 객체</p>

    <ul>
      <li>🍱 도시락 안의 구성 요소 (밥, 반찬, 소스 등)
        <ul>
          <li>소중하기 때문에 주방 안에서만 써야 함</li>
        </ul>
      </li>
      <li>Entity는 VO를 포함할 수 있음</li>
      <li>DB와 직접 연결된 객체이기 때문에 식별자가 존재하며 상태가 바뀔 수 있음</li>
    </ul>

    <blockquote>
      <p>🔴 Entity는 “누구인지”를 <strong>식별할 수 있는 객체</strong></p>
    </blockquote>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/nan0silver/nan0silver.github.io/7ddb58f4af0e22814e7e85a4f7111495d9cd25eb/assets/img/blog/2025-04-02-dto-vo.png" alter="DTOvsVOvsEntity" /></p>

<h2 id="-dto-vs-vo">📦 DTO vs VO</h2>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>DTO</th>
      <th>VO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>목적</td>
      <td><strong>데이터 전달</strong></td>
      <td><strong>값 표현</strong></td>
    </tr>
    <tr>
      <td>가변성</td>
      <td><strong>가변(mutable)</strong></td>
      <td><strong>불변(immutable)</strong></td>
    </tr>
    <tr>
      <td>equals/hashCode 기준</td>
      <td>주소 (기본)</td>
      <td><strong>값 기준으로 재정의</strong></td>
    </tr>
    <tr>
      <td>주 사용 위치</td>
      <td>Controller ↔ Service ↔ API</td>
      <td>도메인 내부, 로직 내 값 처리</td>
    </tr>
    <tr>
      <td>예시</td>
      <td>회원 요청 객체, 응답 DTO 등</td>
      <td>Money, Address, Coordinate 등</td>
    </tr>
    <tr>
      <td>생성 시</td>
      <td>언제든 생성 가능</td>
      <td>생성 후에는 값 변경 ❌</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-entity-vs-vo">📦 Entity vs VO</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Entity</th>
      <th>VO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>의미</td>
      <td><strong>DB 테이블과 1:1 매핑되는 객체</strong></td>
      <td><strong>의미 있는 작은 값 단위 객체</strong></td>
    </tr>
    <tr>
      <td>식별자 (ID)</td>
      <td><strong>있음 (PK, 고유값)</strong></td>
      <td><strong>없음 (값 자체로 구별)</strong></td>
    </tr>
    <tr>
      <td>불변성</td>
      <td>보통 가변</td>
      <td><strong>보통 불변 (<code class="language-plaintext highlighter-rouge">final</code>)</strong></td>
    </tr>
    <tr>
      <td>관리 위치</td>
      <td>DB와 연결되는 핵심 모델</td>
      <td>Entity 안의 필드나 계산용 값</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="entity와-dto로-분리해야하는-이유">Entity와 DTO로 분리해야하는 이유</h2>

<blockquote>
  <p>굳이 클래스를 2개로 나누지 않고 그냥 Entity 하나로 다 처리하면 안 되는 이유!</p>
</blockquote>

<ul>
  <li>구체적인 이유 5가지
    <ol>
      <li>보안
        <ul>
          <li>Entity에는 민감한 필드(비밀번호 등)가 있을 수 있음 ➡️ 그대로 외부에 노출하면 위험</li>
        </ul>
      </li>
      <li>유연성
        <ul>
          <li>API 요청/응답마다 필요한 필드가 다름 ➡️ DTO로 맞춤 설계 가능</li>
        </ul>
      </li>
      <li>엔티티 보호
        <ul>
          <li>DTO로 외부와 통신 ➡️ Entity는 내부에서만 안전하게 관리</li>
        </ul>
      </li>
      <li>유효성 검사 분리
        <ul>
          <li><code class="language-plaintext highlighter-rouge">@Valid</code>, <code class="language-plaintext highlighter-rouge">@NotNull</code>등 검증 로직은 DTO에만 적용
            <blockquote>
              <p>Entity는 DB와 연결된 순수한 모델이여야 함으로 비즈니스 룰, 요청 유효성 검증 같은 책임이 없어야 한다.</p>

              <blockquote>
                <p>JPA의 역할은 저장, 조회인데 검증 로직이 섞이면 책임이 뒤엉킴 (SRP(Single Responsibility Principle) 위반)</p>
              </blockquote>
            </blockquote>
          </li>
        </ul>
      </li>
      <li>레이어 분리 원칙
        <ul>
          <li>Controller ↔ Service ↔ Repository 역할 구분이 명확해짐
            <blockquote>
              <p>“Controller” : 클라이언트와 통신 (DTO 입출력)
“Service” : 비즈니스 로직 (DTO 🔁 Entity 변환, 로직 처리)
“Repository” : DB 접근 (Entity 전용)</p>

              <blockquote>
                <p>DTO와 Entity를 나누지 않고 Controller, Service에서 Entity를 직접 다루면</p>

                <ul>
                  <li>한 객체가 너무 많은 계층을 넘나듬 (의존성 얽힘)</li>
                  <li>책임이 명확하지 않음 (수정 시 어디를 고쳐야 할지 모름)</li>
                  <li>보안 이슈 발생 가능 (불필요한 필드 노출)</li>
                </ul>
              </blockquote>
            </blockquote>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<hr />

<h2 id="코드-예제">코드 예제</h2>

<h3 id="-dto-값-전달용-가변-객체">✅ DTO (값 전달용, 가변 객체)</h3>

<ul>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberDTO</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
      <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

      <span class="c1">// 생성자</span>
      <span class="kd">public</span> <span class="nf">MemberDTO</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
          <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="c1">// getter &amp; setter (값 변경 가능!)</span>
      <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>

      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>setName(), setAge()처럼 값은 변경 가능</li>
  <li>주로 Controller 🔁 Service 🔁 Client 간 데이터 전달용</li>
</ul>

<h3 id="-vo-값-표현용-불변-객체">✅ VO (값 표현용, 불변 객체)</h3>

<ul>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Money</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">;</span>

      <span class="kd">public</span> <span class="nf">Money</span><span class="o">(</span><span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">amount</span> <span class="o">=</span> <span class="n">amount</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAmount</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">amount</span><span class="o">;</span> <span class="o">}</span>

      <span class="c1">// 값 기반 equals, hashCode</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
          <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Money</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
          <span class="nc">Money</span> <span class="n">money</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Money</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
          <span class="k">return</span> <span class="n">amount</span> <span class="o">==</span> <span class="n">money</span><span class="o">.</span><span class="na">amount</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">amount</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>필드가 <code class="language-plaintext highlighter-rouge">final</code>, setter없음 → 불변 객체</li>
  <li>equals() 재정의 → 값이 같으면 같은 객체로 간주</li>
  <li>주로 비즈니스 로직 내부에서 의미 있는 값 표현용</li>
</ul>

<h3 id="-entity">✅ Entity</h3>

<ul>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>  <span class="c1">// 노출되면 안 되는 정보</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="-면접-시-설명-예시">💬 면접 시 설명 예시</h2>

<blockquote>
  <p>“DTO는 계층 간 데이터를 전달할 때 사용하는 객체로, 보통 가변이고 네트워크나 컨트롤러에 노출됩니다. 반면 VO는 불변 객체로, 값 자체가 의미를 가지며 equals와 hashCode를 통해 같은 값을 같다고 간주해 도메인 모델 내에서 활용됩니다. Entity는 DB와 직접 연결된 객체로 식별자가 존재하며 상태가 바뀔 수 있습니다. 외부에 노출되는 API 요청이나 응답은 Entity가 아닌 DTO를 통해 전달함으로써 보안성과 유연성을 확보할 수 있습니다.”</p>
</blockquote>

<hr />

<h2 id="-java-17부터는-record로-vo를-만들기-더-쉬워짐">🚀 Java 17부터는 <code class="language-plaintext highlighter-rouge">record</code>로 VO를 만들기 더 쉬워짐!</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">Coordinate</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">final</code>, 불변성, equals/hashCode 자동 구현!</li>
  <li><strong>값 객체(VO)</strong>를 표현할 때 <strong>record는 아주 강력한 도구</strong></li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[Spring에서 데이터를 다루는 객체인 DTO, VO, Entity의 차이점에 대해 알아보자.]]></summary></entry><entry><title type="html">[Spring] RestTemplate</title><link href="https://nan0silver.github.io/spring/2025-04-01-resttemplate/" rel="alternate" type="text/html" title="[Spring] RestTemplate" /><published>2025-04-01T00:00:00+00:00</published><updated>2025-04-04T02:21:08+00:00</updated><id>https://nan0silver.github.io/spring/resttemplate</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-01-resttemplate/"><![CDATA[<ul>
  <li><a href="#-resttemplate이란">RestTemplate이란?</a></li>
  <li><a href="#-필요한-이유">필요한 이유</a></li>
  <li><a href="#️-예시-코드-get-요청">예시 코드 (Get)</a></li>
  <li><a href="#-주요-메서드들">주요 메서드들</a></li>
  <li><a href="#-응답을-객체로-받기-json--java-객체">응답을 객체로 받기 (JSON → Java 객체)</a></li>
  <li><a href="#-resttemplate-vs-webclient-핵심-비교"><code class="language-plaintext highlighter-rouge">RestTemplate</code> vs <code class="language-plaintext highlighter-rouge">WebClient</code> 핵심 비교</a></li>
  <li><a href="#-코드로-비교">코드로 비교</a></li>
  <li><a href="#-결론-언제-뭘-쓰면-좋을까">결론: 언제 뭘 쓰면 좋을까?</a></li>
</ul>

<hr />

<h2 id="-resttemplate이란">✅ RestTemplate이란?</h2>

<p><code class="language-plaintext highlighter-rouge">RestTemplate</code>은 <strong>Spring에서 다른 서버의 REST API와 통신할 수 있도록 도와주는 HTTP 클라이언트</strong>.</p>

<p>즉, 서버끼리 통신할 때:</p>

<ul>
  <li>다른 서버에 요청을 보내고(<code class="language-plaintext highlighter-rouge">GET</code>, <code class="language-plaintext highlighter-rouge">POST</code>, <code class="language-plaintext highlighter-rouge">PUT</code>, <code class="language-plaintext highlighter-rouge">DELETE</code> 등),</li>
  <li>그 응답을 받아서 처리할 수 있도록 도와주는 <strong>도구</strong></li>
</ul>

<hr />

<h2 id="-필요한-이유">🧠 필요한 이유</h2>

<p>웹 애플리케이션을 만들다 보면,</p>

<ul>
  <li>다른 서버에 있는 데이터를 가져오거나 (예: Kakao Map API, 날씨 API)</li>
  <li>다른 서버에 정보를 보내야 할 때</li>
</ul>

<p>이때 <code class="language-plaintext highlighter-rouge">RestTemplate</code>이 <strong>HTTP 요청/응답을 대신 처리</strong>해주는 역할을 함.</p>

<hr />

<h2 id="️-예시-코드-get-요청">⚙️ 예시 코드 (GET 요청)</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.web.client.RestTemplate</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Example</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">RestTemplate</span> <span class="n">restTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RestTemplate</span><span class="o">();</span>

        <span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"https://api.agify.io/?name=seongwoo"</span><span class="o">;</span>  <span class="c1">// 이름을 넣으면 예상 나이를 알려주는 무료 API</span>
        <span class="nc">String</span> <span class="n">response</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">response</span><span class="o">);</span>
        <span class="c1">// 출력 예: {"name":"seongwoo","age":27,"count":1123}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">getForObject()</code>는 <code class="language-plaintext highlighter-rouge">GET</code> 요청을 보내고, 결과를 <code class="language-plaintext highlighter-rouge">String</code> 타입으로 받아오는 함수.</p>

<hr />

<h2 id="-주요-메서드들">🔧 주요 메서드들</h2>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">getForObject()</code></td>
      <td>GET 요청 후, 결과를 객체로 받음</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">getForEntity()</code></td>
      <td>GET 요청 후, 전체 응답(ResponseEntity) 받음</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">postForObject()</code></td>
      <td>POST 요청 후, 결과를 객체로 받음</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">postForEntity()</code></td>
      <td>POST 요청 후, 전체 응답 받음</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">put()</code></td>
      <td>PUT 요청 (응답 없음)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">delete()</code></td>
      <td>DELETE 요청</td>
    </tr>
  </tbody>
</table>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-04-01-spring-resttemplate.png?raw=true" /></p>

<hr />

<h2 id="-응답을-객체로-받기-json--java-객체">📦 응답을 객체로 받기 (JSON → Java 객체)</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AgifyResponse</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>

    <span class="c1">// 꼭! Getter/Setter 만들어줘야 함 (Lombok 써도 됨)</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RestTemplate</span> <span class="n">restTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RestTemplate</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"https://api.agify.io/?name=seongwoo"</span><span class="o">;</span>

<span class="nc">AgifyResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="nc">AgifyResponse</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">getAge</span><span class="o">());</span>  <span class="c1">// 예: 27</span>
</code></pre></div></div>

<p>→ JSON 데이터를 Java 객체로 자동으로 바꿔줌! (<code class="language-plaintext highlighter-rouge">Jackson</code> 같은 라이브러리를 내부에서 사용함)</p>

<hr />

<h2 id="-resttemplate-특징-요약">💡 RestTemplate 특징 요약</h2>

<ul>
  <li>동기 방식이다 (요청을 보내고 응답 올 때까지 기다림)</li>
  <li>간단한 API 호출엔 유용하지만, <strong>요즘은 WebClient 사용이 증가</strong> (비동기 처리, reactive 프로그래밍에 적합)</li>
  <li>Spring 5 이후로는 <code class="language-plaintext highlighter-rouge">RestTemplate</code>은 <strong>점점 deprecated 방향</strong>이지만, 여전히 많이 사용됨</li>
</ul>

<hr />

<h2 id="-resttemplate-vs-webclient-핵심-비교">🆚 <code class="language-plaintext highlighter-rouge">RestTemplate</code> vs <code class="language-plaintext highlighter-rouge">WebClient</code> 핵심 비교</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>RestTemplate</th>
      <th>WebClient</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>방식</td>
      <td><strong>동기(Synchronous)</strong></td>
      <td><strong>비동기(Asynchronous)</strong> (동기도 가능)</td>
    </tr>
    <tr>
      <td>등장 시기</td>
      <td>오래됨 (Spring 3.x부터)</td>
      <td>최신 (Spring 5, WebFlux부터 등장)</td>
    </tr>
    <tr>
      <td>쓰레드 처리</td>
      <td>요청 → 응답 올 때까지 <strong>쓰레드 점유</strong></td>
      <td>응답 기다리는 동안 <strong>쓰레드 반환</strong>, 더 효율적</td>
    </tr>
    <tr>
      <td>성능</td>
      <td>단순 요청에는 충분</td>
      <td>고성능 시스템, MSA에서 더 좋음</td>
    </tr>
    <tr>
      <td>사용성</td>
      <td>코드가 간단하고 직관적</td>
      <td>비동기라 처음엔 약간 복잡할 수 있음</td>
    </tr>
    <tr>
      <td>미래 방향</td>
      <td><strong>Deprecated 예정</strong> (Spring 6에서는 제거될 수 있음)</td>
      <td>Spring이 권장하는 <strong>표준 방식</strong></td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-코드로-비교">🔧 코드로 비교</h2>

<h3 id="1️⃣-resttemplate-예시-동기">1️⃣ RestTemplate 예시 (동기)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RestTemplate</span> <span class="n">restTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RestTemplate</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"https://api.agify.io/?name=seongwoo"</span><span class="o">;</span>

<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</code></pre></div></div>

<p>→ 응답이 올 때까지 <strong>기다림</strong>. 동기 처리.</p>

<hr />

<h3 id="2️⃣-webclient-예시-비동기--동기화-처리-가능">2️⃣ WebClient 예시 (비동기 + 동기화 처리 가능)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.web.reactive.function.client.WebClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">reactor.core.publisher.Mono</span><span class="o">;</span>

<span class="nc">WebClient</span> <span class="n">webClient</span> <span class="o">=</span> <span class="nc">WebClient</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"https://api.agify.io/?name=seongwoo"</span><span class="o">;</span>

<span class="c1">// 비동기 방식 → block()을 붙이면 동기처럼 동작</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">webClient</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
        <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">url</span><span class="o">)</span>
        <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
        <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
        <span class="o">.</span><span class="na">block</span><span class="o">();</span>  <span class="c1">// 이게 바로 응답 받을 때까지 기다리는 코드 (동기화)</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</code></pre></div></div>

<p>→ WebClient는 원래 비동기지만, <code class="language-plaintext highlighter-rouge">.block()</code>을 붙이면 동기처럼 사용할 수도 있음.</p>

<hr />

<h2 id="-비동기-방식으로-진짜-쓰고-싶다면">💬 비동기 방식으로 진짜 쓰고 싶다면?</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">webClient</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">url</span><span class="o">)</span>
    <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
    <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">result</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"결과: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">});</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"여긴 먼저 실행됨!"</span><span class="o">);</span>  <span class="c1">// 비동기니까 이게 먼저 출력될 수도 있음</span>
</code></pre></div></div>

<hr />

<h2 id="-결론-언제-뭘-쓰면-좋을까">✅ 결론: 언제 뭘 쓰면 좋을까?</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>추천</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>간단한 테스트, 외부 API 한두 번 호출할 때</td>
      <td>RestTemplate (빠르게 개발 가능)</td>
    </tr>
    <tr>
      <td>마이크로서비스 간 통신, 대용량 처리, reactive 시스템</td>
      <td>WebClient (성능과 확장성 좋음)</td>
    </tr>
    <tr>
      <td>Spring 5 이상 + 새로운 프로젝트</td>
      <td>WebClient를 사용하는 게 <strong>미래지향적</strong></td>
    </tr>
  </tbody>
</table>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[Spring에서 다른 서버의 REST API와 통신할 수 있도록 도와주는 HTTP 클라이언트인 RestTemplate에 대해 알아보자.]]></summary></entry><entry><title type="html">[Etc] 💣 SQL Injection</title><link href="https://nan0silver.github.io/miscellaneous/2025-03-31-sql-injection/" rel="alternate" type="text/html" title="[Etc] 💣 SQL Injection" /><published>2025-03-31T00:00:00+00:00</published><updated>2025-04-04T02:21:08+00:00</updated><id>https://nan0silver.github.io/miscellaneous/sql-injection</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-03-31-sql-injection/"><![CDATA[<ul>
  <li><a href="#sql-injection이란">SQL Injection이란?</a></li>
  <li><a href="#-spring-관점에서-sql-injection-방지법">Spring 관점에서 SQL Injection 방지법</a></li>
  <li><a href="#-spring-배우는-입장에서-조심할-포인트-요약">요약</a></li>
</ul>

<hr />

<h2 id="sql-injection이란">SQL Injection이란?</h2>

<blockquote>
  <p><strong>SQL Injection</strong>이란, 사용자가 입력한 값을 통해 <strong>원래 의도하지 않은 SQL문을 실행하게 만들어</strong><br />
<strong>데이터베이스의 데이터를 탈취하거나 조작하는 공격</strong></p>
</blockquote>

<h3 id="-예시-spring-쓰기-전-일반-jdbc-코드-기준">🔍 예시 (Spring 쓰기 전 일반 JDBC 코드 기준):</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"SELECT * FROM users WHERE username = '"</span> <span class="o">+</span> <span class="n">username</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">;</span>
</code></pre></div></div>

<p>만약 <code class="language-plaintext highlighter-rouge">username</code>에 아래와 같은 값을 입력하면?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>' OR '1'='1
</code></pre></div></div>

<p>그러면 쿼리가 이렇게 바뀜:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users</span> <span class="k">WHERE</span> <span class="n">username</span> <span class="o">=</span> <span class="s1">''</span> <span class="k">OR</span> <span class="s1">'1'</span><span class="o">=</span><span class="s1">'1'</span>
</code></pre></div></div>

<p>→ 모든 유저 정보가 다 조회됨 😱<br />
→ 비밀번호 없이 로그인도 가능해짐</p>

<hr />

<h2 id="-spring-관점에서-sql-injection-방지법">🔐 Spring 관점에서 SQL Injection 방지법</h2>

<h3 id="-1-jdbc-직접-사용-시-preparedstatement-필수">✅ 1. <strong>JDBC 직접 사용 시: PreparedStatement 필수!</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"SELECT * FROM users WHERE username = ?"</span><span class="o">;</span>
<span class="nc">PreparedStatement</span> <span class="n">pstmt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
<span class="n">pstmt</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">username</span><span class="o">);</span>  <span class="c1">// 자동으로 문자열 escape 처리</span>
</code></pre></div></div>

<p>이렇게 하면 <code class="language-plaintext highlighter-rouge">' OR '1'='1</code> 같은 입력도 그냥 문자열로 인식되므로 안전하다.</p>

<hr />

<h3 id="-2-spring-jdbc-template-사용-시">✅ 2. <strong>Spring JDBC Template 사용 시</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"SELECT * FROM users WHERE username = ?"</span><span class="o">;</span>
<span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">queryForObject</span><span class="o">(</span><span class="n">sql</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="n">username</span><span class="o">},</span> <span class="n">userRowMapper</span><span class="o">);</span>
</code></pre></div></div>

<p>여기서도 <code class="language-plaintext highlighter-rouge">?</code>를 사용해서 바인딩하면 PreparedStatement가 적용되므로 안전하다.</p>

<hr />

<h3 id="-3-jpa--spring-data-jpa-사용-시">✅ 3. <strong>JPA / Spring Data JPA 사용 시</strong></h3>

<p>JPA는 SQL을 직접 작성하지 않고 엔티티 중심으로 데이터를 다루기 때문에 <strong>기본적으로 SQL Injection에 강함</strong>!</p>

<h4 id="-예시">🔸 예시:</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findByUsername</span><span class="o">(</span><span class="n">username</span><span class="o">);</span>
</code></pre></div></div>

<p>이런 방식은 내부적으로 PreparedStatement를 사용하기 때문에 안전함.</p>

<h4 id="-커스텀-jpql-사용-시에도-파라미터-바인딩-필수">🔸 커스텀 JPQL 사용 시에도 파라미터 바인딩 필수!</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Query</span><span class="o">(</span><span class="s">"SELECT u FROM User u WHERE u.username = :username"</span><span class="o">)</span>
<span class="nc">User</span> <span class="nf">findByUsername</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">"username"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">username</span><span class="o">);</span>
</code></pre></div></div>

<p>✅ <code class="language-plaintext highlighter-rouge">:username</code> 형태로 파라미터 바인딩하면 OK<br />
❌ 아래처럼 문자열 직접 연결하면 위험:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Query</span><span class="o">(</span><span class="s">"SELECT u FROM User u WHERE u.username = '"</span> <span class="o">+</span> <span class="n">username</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">)</span>
</code></pre></div></div>

<hr />

<h2 id="-spring-배우는-입장에서-조심할-포인트-요약">🚨 Spring 배우는 입장에서 조심할 포인트 요약</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>안전한 방법</th>
      <th>주의할 점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>JDBC 직접 사용</td>
      <td><code class="language-plaintext highlighter-rouge">PreparedStatement</code></td>
      <td>문자열 직접 연결 ❌</td>
    </tr>
    <tr>
      <td>JdbcTemplate</td>
      <td><code class="language-plaintext highlighter-rouge">?</code> 자리 바인딩 사용</td>
      <td>쿼리 조합 ❌</td>
    </tr>
    <tr>
      <td>JPA / Spring Data JPA</td>
      <td>파라미터 바인딩 (<code class="language-plaintext highlighter-rouge">:param</code>)</td>
      <td>JPQL 문자열 직접 붙이기 ❌</td>
    </tr>
    <tr>
      <td>QueryDSL</td>
      <td>완전 안전 (타입 기반 쿼리)</td>
      <td>-</td>
    </tr>
    <tr>
      <td>사용자 입력값 처리</td>
      <td>입력 검증, 길이 제한</td>
      <td>필터 없이 바로 사용 ❌</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-마무리-요약">🎯 마무리 요약</h2>

<ul>
  <li>SQL Injection = <strong>사용자가 입력한 값을 통해 악성 SQL 실행</strong></li>
  <li>Spring에서는 기본적으로 <strong>PreparedStatement</strong> 방식이므로 잘 쓰면 안전함</li>
  <li>하지만 <strong>직접 쿼리 짜거나, 문자열로 SQL을 조합</strong>하는 경우 주의!</li>
  <li><strong>ORM(JPA) + 파라미터 바인딩</strong> 방식으로 작성하면 거의 대부분 안전하게 막을 수 있음</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[악의적인 사용자가 SQL 쿼리에 코드를 삽입해 DB정보를 탈취하거나 조작하는 것을 뜻하는 SQL Injection에 대해 알아보자.]]></summary></entry><entry><title type="html">[Algorithm] 소수 빠르게 찾는 법</title><link href="https://nan0silver.github.io/algorithm/2025-03-20-is-prime/" rel="alternate" type="text/html" title="[Algorithm] 소수 빠르게 찾는 법" /><published>2025-03-20T00:00:00+00:00</published><updated>2025-04-04T02:21:08+00:00</updated><id>https://nan0silver.github.io/algorithm/is-prime</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2025-03-20-is-prime/"><![CDATA[<ol>
  <li><a href="#1️⃣-기본-소수-판별-on">기본 소수 판별</a></li>
  <li><a href="#2️⃣-에라토스테네스의-체-on-log-log-n">에라토스테네스의 체</a></li>
  <li><a href="#3️⃣-miller-rabin-소수판별법-olog-n">Miller-Rabin 소수 판별법</a></li>
</ol>

<hr />

<h2 id="1️⃣-기본-소수-판별-on">1️⃣ 기본 소수 판별 (O(√N))</h2>

<ul>
  <li>어떤 숫자 N이 소수인지 판별하는 가장 기본적인 방법은 1과 자기 자신을 제외한 다른 수로 나누어떨어지는지 확인하는 것</li>
  <li>🔥 2부터 √N까지 나누어보자!
    <ul>
      <li>소수가 아니라면 작은 약수를 가지고 있기 때문</li>
    </ul>
  </li>
  <li>코드 예제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrimeCheck</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">n</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">29</span><span class="o">));</span> <span class="c1">//true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span> <span class="c1">//false</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="2️⃣-에라토스테네스의-체-on-log-log-n">2️⃣ 에라토스테네스의 체 (O(N log log N))</h2>

<blockquote>
  <p>여러 개의 소수를 빠르게 찾는 방법</p>
</blockquote>

<ul>
  <li>1부터 N까지의 수 중에서 소수를 모두 찾아야 하는 경우</li>
  <li>🔥 방법
    <ol>
      <li>2부터 시작해서 배수들을 모두 제거</li>
      <li>남은 수들만 소수로 판별</li>
    </ol>
  </li>
  <li>장점
    <ul>
      <li>한 번 계산해 두면 특정 범위 내에서 빠르게 소수 여부를 판별할 수 있음.</li>
    </ul>
  </li>
  <li>코드 예제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SieveOfEratosthenes</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">sieveOfEratosthenes</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">isPrime</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">isPrime</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="n">isPrime</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">isPrime</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isPrime</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">isPrime</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">//소수 리스트 생성</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="3️⃣-miller-rabin-소수판별법-olog-n">3️⃣ Miller-Rabin 소수판별법 (O(log N))</h2>

<blockquote>
  <p>소수 판별이 자주 필요할 때</p>
</blockquote>

<ul>
  <li>N이 엄청 크면 밀러-라빈 소수판별법을 사용해야함
    <ul>
      <li>10^18이상의 큰 수가 소수인지 판별할 때</li>
      <li>암후학, 해시 관련 문제에서 사용</li>
    </ul>
  </li>
  <li>🔥 확률적 알고리즘</li>
  <li>코드 예제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MillerRabin</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// k는 테스트 횟수</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="c1">// n - 1 = 2^r * d 형태로 변환</span>
        <span class="kt">long</span> <span class="n">d</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">d</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">r</span><span class="o">++;</span>
            <span class="n">d</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>

        <span class="c1">// Miller-Rabin 테스트 실행</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextLong</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">3</span><span class="o">);</span> <span class="c1">// 2 ≤ a ≤ n-2</span>
            <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="n">powerMod</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// x = a^d % n</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>

            <span class="kt">boolean</span> <span class="n">isComposite</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">powerMod</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// x = x^2 % n</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">isComposite</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">isComposite</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 합성수 판별</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// 소수 판별</span>
    <span class="o">}</span>

    <span class="c1">// (base^exp) % mod 연산 (빠른 거듭제곱)</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">powerMod</span><span class="o">(</span><span class="kt">long</span> <span class="n">base</span><span class="o">,</span> <span class="kt">long</span> <span class="n">exp</span><span class="o">,</span> <span class="kt">long</span> <span class="n">mod</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">base</span> <span class="o">%=</span> <span class="n">mod</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">exp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">exp</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 홀수 지수 처리</span>
                <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">result</span> <span class="o">*</span> <span class="n">base</span><span class="o">)</span> <span class="o">%</span> <span class="n">mod</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">base</span> <span class="o">=</span> <span class="o">(</span><span class="n">base</span> <span class="o">*</span> <span class="n">base</span><span class="o">)</span> <span class="o">%</span> <span class="n">mod</span><span class="o">;</span> <span class="c1">// 제곱</span>
            <span class="n">exp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 지수 나누기 2</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">15485863</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>  <span class="c1">// true (소수)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">1000000007</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span> <span class="c1">// true (소수)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">1000000008</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span> <span class="c1">// false (합성수)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[소수를 빠르게 효율적으로 찾는 방법 3가지를 알아보자]]></summary></entry><entry><title type="html">[Etc] 🤖 Layered Architecture &amp;amp; MVC pattern</title><link href="https://nan0silver.github.io/miscellaneous/2025-03-17-layered-architecture/" rel="alternate" type="text/html" title="[Etc] 🤖 Layered Architecture &amp;amp; MVC pattern" /><published>2025-03-17T00:00:00+00:00</published><updated>2025-04-04T02:21:08+00:00</updated><id>https://nan0silver.github.io/miscellaneous/layered-architecture</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-03-17-layered-architecture/"><![CDATA[<ul>
  <li><a href="#레이어드-아키텍쳐layered-architecture란">레이어드 아키텍쳐(Layered Architecture)란?</a></li>
  <li><a href="#mvc란">MVC란?</a></li>
  <li><a href="#레이어드-아키텍쳐와-mvc를-함께-사용">레이어드 아키텍쳐와 MVC를 함께 사용</a></li>
</ul>

<hr />

<h2 id="레이어드-아키텍쳐layered-architecture란">레이어드 아키텍쳐(Layered Architecture)란?</h2>

<ul>
  <li>여러 수평 레이어가 수직적으로 쌓인 구조 (상위 레이어에서 하위 레이어로 단방향 의존성)
    <ul>
      <li>프레젠테이션 레이어 : 1층로비, 방문객 맞이하고 안내</li>
      <li>비즈니스 레이어 : 실제 회사 업무 설계 및 규칙 수립</li>
      <li>서비스 레이어 : 비즈니스 레이어의 명령 실행</li>
      <li>데이터 접근 레이어 : 필요한 정보 저장 및 검색</li>
      <li>각 층은 자신의 역할만 수행, 보통 아래층에만 의존</li>
    </ul>
  </li>
  <li>데이터 흐름
    <ul>
      <li>요청 → 컨트롤러 → 서비스 → 레포지토리</li>
    </ul>
  </li>
  <li>사용 이유
    <ul>
      <li><strong>모듈화:</strong> 각 레이어가 독립적이라 변경 사항이 영향을 최소화</li>
      <li><strong>유지보수성:</strong> 비즈니스 로직(Service)과 DB 접근(Repository)을 분리</li>
      <li><strong>테스트 용이:</strong> 단위 테스트 작성이 쉬움 (ex: Service 레이어만 Mock 테스트 가능)</li>
    </ul>
  </li>
</ul>

<h2 id="mvc란">MVC란?</h2>

<ul>
  <li>Model-View-Controller
    <ul>
      <li>Model : 요리사가 실제 음식을 준비하고 만드는 작업</li>
      <li>View : 음식의 플레이팅</li>
      <li>Controller : 고객의 주문을 받고, 요리사에게 전달하여 완성된 요리를 테이블에 서빙 (백엔드)</li>
      <li>3개의 요소가 유기적으로 협력</li>
    </ul>
  </li>
  <li>사용자 인터페이스와 비즈니스 로직 분리</li>
  <li>데이터 흐름
    <ul>
      <li>요청 → 컨트롤러 → 모델 → 뷰</li>
    </ul>
  </li>
  <li>사용 이유
    <ul>
      <li><strong>역할 분리:</strong> View, Model, Controller가 독립적으로 동작하여 유지보수 용이</li>
      <li><strong>유연한 확장:</strong> UI 변경(View)이나 비즈니스 로직(Model)을 따로 수정 가능</li>
      <li><strong>재사용성 증가:</strong> 같은 Model을 여러 View에서 사용 가능</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-03-17-image.png?raw=true" alt="Layered Architecture &amp; MVC pattern" /></p>

<h2 id="레이어드-아키텍쳐와-mvc를-함께-사용">레이어드 아키텍쳐와 MVC를 함께 사용</h2>

<ul>
  <li><strong>둘을 함께 사용하면 유지보수성과 확장성이 좋아진다.</strong>
    <ul>
      <li><strong>Controller는 최대한 가볍게 (Thin Controller, Fat Service)</strong></li>
      <li><strong>비즈니스 로직은 Service Layer에서 처리 (SRP 원칙 준수)</strong></li>
    </ul>
  </li>
</ul>

<h3 id="둘을-함께-사용했을-때-관계-흐름-요청--응답">둘을 함께 사용했을 때 관계 흐름 (요청 → 응답)</h3>

<ol>
  <li>사용자 (Client) 가 요청을 보냄</li>
  <li>Controller (입력 처리, 요청 매핑)</li>
  <li>Service (비즈니스 로직 처리)</li>
  <li>Repository (데이터베이스 접근)</li>
  <li>Service → Controller 로 응답 반환</li>
  <li>Controller → View (또는 JSON)</li>
</ol>

<ul>
  <li>MVC는 역할을 분리하고, 레이어드 아키텍처는 각 계층을 더 체계적으로 조직화하여 유지보수성과 확장성을 높인다</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[레이어드 아키텍쳐와 MVC 패턴에 대해 알아보자.]]></summary></entry><entry><title type="html">[JAVA] 동시성 처리 (Concurrency)</title><link href="https://nan0silver.github.io/java/2025-03-09-concurrency/" rel="alternate" type="text/html" title="[JAVA] 동시성 처리 (Concurrency)" /><published>2025-03-09T00:00:00+00:00</published><updated>2025-04-04T02:21:08+00:00</updated><id>https://nan0silver.github.io/java/concurrency</id><content type="html" xml:base="https://nan0silver.github.io/java/2025-03-09-concurrency/"><![CDATA[<ul>
  <li><a href="#java에서-동시성">JAVA에서 동시성</a></li>
  <li><a href="#스레드-thread">스레드 (Thread)</a></li>
  <li><a href="#비동기-처리-async">비동기 처리 (Aysnc)</a></li>
  <li><a href="#분산-처리-distributed">분산 처리 (Distribute)</a></li>
  <li><a href="#핵심-키워드-및-정리">핵심 키워드 및 정리</a></li>
</ul>

<hr />

<h2 id="java에서-동시성">JAVA에서 동시성</h2>

<ul>
  <li>여러 작업을 동시에 겹쳐서 처리하는 것</li>
  <li>한 번에 여러 일을 수행하며 일의 효율성을 높임</li>
  <li>크게 3가지 관점에서 접근 가능하다.
    <ol>
      <li>스레드 (Thread)</li>
      <li>비동기 (Async)</li>
      <li>분산 (Distributed)</li>
    </ol>
  </li>
</ul>

<h2 id="스레드-thread">스레드 (Thread)</h2>

<ul>
  <li>스레드는 프로세스 내에서 실제 작업을 수행하는 작업 단위</li>
  <li>한 개의 프로그램(프로세스)은 여러 개의 스레드를 가질 수 있음</li>
  <li>멀티 스레드 (Multi-thread)
    <ul>
      <li>하나의 프로세스에서 여러 스레드를 동시에 실행하는 방식</li>
      <li>자바에서는 주로 JVM(Java Virtual Machine)이 여러 스레드를 관리해줌
        <ul>
          <li>ex) 웹 서버(Servlet, Spring)에서는 사용자 요청마다 별도의 스레드를 생성해서 동시에 많은 요청을 처리할 수 있게 함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>🔥 중요한 이유
    <ul>
      <li>효율성 향상
        <ul>
          <li>CPU 자원을 최대한 활용할 수 있음</li>
        </ul>
      </li>
      <li>응답성 향상
        <ul>
          <li>동시에 여러 요청을 처리할 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>하지만 최근 자바 프레임워크(Spring)는 스레드를 자동으로 관리해주기 때문에 개발자가 직접 스레드를 관리할 일이 많지 않음
    <ul>
      <li>JVM과 프레임워크가 이미 효율적으로 관리해줌</li>
    </ul>
  </li>
</ul>

<h2 id="비동기-처리-async">비동기 처리 (Async)</h2>

<ul>
  <li>비동기란 “요청을 보낸 뒤 결과를 기다리지 않고 다음 작업을 진행”하는 방식
    <ul>
      <li>동기 (Synchronous)
        <ul>
          <li>하나의 요청이 끝날 때까지 기다림</li>
        </ul>
      </li>
      <li>비동기 (Asynchronous)
        <ul>
          <li>요청이 처리되는 동안 다른 작업 수행</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>자바에서 비동기 처리를 지원하는 방법
    <ul>
      <li><code class="language-plaintext highlighter-rouge">CompletableFuture</code> : 자바 비동기 처리 클래스</li>
      <li>자바스크립트의 async/await와 비슷한 방식</li>
    </ul>
  </li>
  <li>🔥 중요한 이유
    <ul>
      <li>빠른 응답성
        <ul>
          <li>요청 처리 중에도 사용자가 대기하지 않고, 시스템의 다른 작업 수행 가능</li>
        </ul>
      </li>
      <li>높은 확장성
        <ul>
          <li>비동기 처리를 하면 서버가 많은 요청을 효율적으로 관리 가능</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="분산-처리-distributed">분산 처리 (Distributed)</h2>

<ul>
  <li>분산처리는 “하나의 서버가 아닌, 여러 대의 서버가 나누어서 작업을 처리하는 방식”
    <ul>
      <li>서버 하나만 운영하는 것부다 작은 여러 서버(클러스터)를 운영하면 비용이 줄어듬</li>
      <li>대규모 서비스나 성장한 서비스에서 자주 사용됨</li>
    </ul>
  </li>
  <li>분산 환경에서 자주 사용되는 기술
    <ul>
      <li>Redis
        <ul>
          <li>메모리 기반 데이터 저장소로, 분산락(Distributed Lock)울 구현할 때 사용</li>
          <li>예를 들어, 여러 서버가 하나의 데이터를 동시에 수정하지 못하게 관리하는 방식</li>
        </ul>
      </li>
      <li>Kafka
        <ul>
          <li>메시지 큐(Message Queue)로, 서버간 메시지를 주고받고, 작업을 순차적으로 처리할 때 사용됨</li>
        </ul>
      </li>
      <li>클러스터(Cluster)
        <ul>
          <li>여러 대의 서버가 협력하여 요청을 나누어 처리 (MSA와 비슷한 개념)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>🔥 중요한 이유
    <ul>
      <li>비용 효율성
        <ul>
          <li>큰 서버 하나보다 여러 작은 서버가 경제적</li>
        </ul>
      </li>
      <li>안정성 및 확장성
        <ul>
          <li>한 서버가 문제가 생기더라도 서비스는 계속 운영됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="핵심-키워드-및-정리">핵심 키워드 및 정리</h2>

<ol>
  <li>스레스 (Thread)</li>
</ol>

<ul>
  <li>멀티 스레드 -&gt; JVM, Servlet, Spring</li>
  <li>스레드는 직원이다. 회사(JVM, Servlet, Spring)가 직원(스레드)을 잘 관리하면, 일(요청 처리)이 효율적이다.</li>
</ul>

<ol>
  <li>비동기 (Async)</li>
</ol>

<ul>
  <li>CompletableFuture, async/await</li>
  <li>비동기는 배달앱이다. 주문을 넣고 기다리지 않고, 다음 일을 진행한다.</li>
</ul>

<ol>
  <li>분산처리 (Distributed)</li>
</ol>

<ul>
  <li>Redis, Kafka, 클러스터</li>
  <li>분산처리는 프랜차이즈이다. 큰 가게 하나보다 작은 여러 가게가 효율적이고 비용도 절감된다.</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="java" /><summary type="html"><![CDATA[동시성 처리에 관한 3가지 관점에 대해 이야기해보자.]]></summary></entry><entry><title type="html">[Etc] 🎞️ Boilerplate</title><link href="https://nan0silver.github.io/miscellaneous/2025-03-06-boiler-plate/" rel="alternate" type="text/html" title="[Etc] 🎞️ Boilerplate" /><published>2025-03-06T00:00:00+00:00</published><updated>2025-04-04T02:21:08+00:00</updated><id>https://nan0silver.github.io/miscellaneous/boiler-plate</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-03-06-boiler-plate/"><![CDATA[<ul>
  <li><a href="#보일러플레이트boilerplate란">보일러플레이트(Boilerplate)란?</a></li>
  <li><a href="#보일러플레이트의-특징">보일러플레이트의 특징</a></li>
  <li><a href="#예제-코드">예제 코드</a></li>
</ul>

<hr />

<h2 id="보일러플레이트boilerplate란">보일러플레이트(Boilerplate)란?</h2>

<ul>
  <li>소프트웨어 개발에서 반복적으로 사용되는 사용되는 <strong>기본 코드 템플릿</strong></li>
  <li>🔥 즉, “매번 새로 작성해야하는 기본 코드세트”를 보일러플레이트라고 함</li>
  <li>의미
    <ul>
      <li>원래는 인쇄 산업에서 반복적으로 사용되는 금속판을 의미</li>
      <li>이후 소프트웨어 개발에서도 “반복적으로 작성해야하는 코드 덩어리”를 의미하게 되었다.</li>
    </ul>
  </li>
</ul>

<h2 id="보일러플레이트의-특징">보일러플레이트의 특징</h2>

<ol>
  <li>반복적인 코드</li>
</ol>

<ul>
  <li>프로젝트를 시작할 때 매번 작성해야하는 코드들이 포함됨</li>
  <li>예를 들어, 웹 애플리케이션을 만들 때 기본적인 프로젝트 구조, 설정 파일, 인증 로직 등이 해당</li>
</ul>

<ol>
  <li>템플릿 역할</li>
</ol>

<ul>
  <li>코드 재사용성을 높이고, 개발 시간을 줄여줌</li>
  <li>예를 들어, React, Express, Spring Boot같은 프레임워크에서는 보일러플레이트 코드가 포함된 템플릿이 제공됨</li>
</ul>

<ol>
  <li>프레임워크 및 라이브러리에서 자주 사용됨</li>
</ol>

<ul>
  <li>React : <code class="language-plaintext highlighter-rouge">create-react-app</code>이 기본적인 프로젝트 구조와 설정을 자동으로 생성</li>
  <li>Express : <code class="language-plaintext highlighter-rouge">express-generator</code>를 사용하면 기본적인 Express 프로젝트 생성</li>
  <li>Spring Boot : <code class="language-plaintext highlighter-rouge">Spring Initializr</code>를 사용사면 기본적인 설정이 포함된 프로젝트 생성</li>
</ul>

<h2 id="예제-코드">예제 코드</h2>

<ul>
  <li>Spring Boot 보일러플레이트</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.boot.SpringApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.SpringBootApplication</span><span class="o">;</span>

<span class="nd">@SpringBootApplication</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyApplication</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">MyApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[반복적으로 사용되는 기본 코드 템플릿인 Boilerplate에 대해 알아보자.]]></summary></entry><entry><title type="html">[JAVA] 🚀 ArrayList vs 배열(int[]) 성능 비교</title><link href="https://nan0silver.github.io/java/2025-02-25-arraylist-array/" rel="alternate" type="text/html" title="[JAVA] 🚀 ArrayList vs 배열(int[]) 성능 비교" /><published>2025-02-25T00:00:00+00:00</published><updated>2025-04-04T02:21:08+00:00</updated><id>https://nan0silver.github.io/java/arraylist-array</id><content type="html" xml:base="https://nan0silver.github.io/java/2025-02-25-arraylist-array/"><![CDATA[<ul>
  <li><a href="#-arraylistinteger는-언제-더-유리할까"><code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>는 언제 더 유리할까?</a></li>
  <li><a href="#-int-배열이-더-유리한-경우"><code class="language-plaintext highlighter-rouge">int[] 배열</code>이 더 유리한 경우</a></li>
  <li><a href="#-성능-비교-실험-java">성능 비교 실험 (Java)</a></li>
  <li><a href="#-결론-언제-arraylist를-쓰고-언제-배열int을-써야-할까">결론: 언제 <code class="language-plaintext highlighter-rouge">ArrayList</code>를 쓰고, 언제 <code class="language-plaintext highlighter-rouge">배열(int[])</code>을 써야 할까?</a></li>
  <li><a href="#추가--hashmapinteger-integer와의-성능-비교">추가 : HashMap&lt;Integer, Integer&gt;와의 성능 비교</a></li>
</ul>

<hr />

<h2 id="-arraylist-vs-배열int-성능-비교"><strong>🚀 <code class="language-plaintext highlighter-rouge">ArrayList</code> vs <code class="language-plaintext highlighter-rouge">배열(int[])</code> 성능 비교</strong></h2>

<table>
  <thead>
    <tr>
      <th> </th>
      <th><code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code></th>
      <th><code class="language-plaintext highlighter-rouge">int[] 배열</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>저장 방식</strong></td>
      <td>내부적으로 동적 배열(<code class="language-plaintext highlighter-rouge">Object[]</code>) 사용</td>
      <td>고정 크기의 <code class="language-plaintext highlighter-rouge">int[]</code> 배열 사용</td>
    </tr>
    <tr>
      <td><strong>메모리 사용량</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Integer</code> 객체를 사용하여 오버헤드가 큼</td>
      <td><code class="language-plaintext highlighter-rouge">int</code> 원시 타입 사용 (메모리 효율적)</td>
    </tr>
    <tr>
      <td><strong>속도 (읽기/쓰기)</strong></td>
      <td>일반적으로 <code class="language-plaintext highlighter-rouge">int[]</code>보다 느림</td>
      <td><strong>빠름 (메모리 직접 접근)</strong></td>
    </tr>
    <tr>
      <td><strong>크기 변경 가능 여부</strong></td>
      <td>가능 (<code class="language-plaintext highlighter-rouge">add()</code>, <code class="language-plaintext highlighter-rouge">remove()</code> 등 제공)</td>
      <td>불가능 (고정 크기)</td>
    </tr>
    <tr>
      <td><strong>사용 편의성</strong></td>
      <td>유동적인 크기 조절이 가능</td>
      <td>크기 변경이 불가능하여 유연성이 떨어짐</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-arraylistinteger는-언제-더-유리할까"><strong>📌 <code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>는 언제 더 유리할까?</strong></h2>

<ul>
  <li><strong>크기가 가변적인 데이터를 다룰 때</strong> (<code class="language-plaintext highlighter-rouge">add()</code>로 쉽게 추가 가능)</li>
  <li><strong>삭제, 삽입이 자주 발생할 때</strong> (<code class="language-plaintext highlighter-rouge">remove()</code> 메서드 활용 가능)</li>
  <li><strong>제네릭(<code class="language-plaintext highlighter-rouge">List&lt;T&gt;</code>)을 활용해야 할 때</strong></li>
</ul>

<h4 id="-예제-arraylist-사용-시"><strong>🚀 예제: <code class="language-plaintext highlighter-rouge">ArrayList</code> 사용 시</strong></h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>  <span class="c1">// 값 추가</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>  <span class="c1">// 첫 번째 요소 삭제</span>
</code></pre></div></div>

<ul>
  <li>크기가 유동적으로 변할 수 있음 (<code class="language-plaintext highlighter-rouge">add()</code>, <code class="language-plaintext highlighter-rouge">remove()</code> 사용 가능)</li>
  <li>그러나 <strong>내부적으로 <code class="language-plaintext highlighter-rouge">Integer</code> 객체를 사용하므로 메모리 사용량이 큼</strong> (<code class="language-plaintext highlighter-rouge">int</code>보다 많은 메모리 차지)</li>
</ul>

<hr />

<h2 id="-int-배열이-더-유리한-경우"><strong>📌 <code class="language-plaintext highlighter-rouge">int[] 배열</code>이 더 유리한 경우</strong></h2>

<ul>
  <li><strong>고정된 크기의 데이터를 다룰 때</strong> (메모리 절약 가능)</li>
  <li><strong>빠른 접근 속도가 필요할 때</strong>
    <ul>
      <li>메모리에 <strong>직접 접근 (O(1))</strong> 가능</li>
    </ul>
  </li>
  <li><strong>성능 최적화가 필요한 경우</strong> (특히 대량 데이터)</li>
</ul>

<h4 id="-예제-int-사용-시"><strong>🚀 예제: <code class="language-plaintext highlighter-rouge">int[]</code> 사용 시</strong></h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="mi">30</span><span class="o">;</span>
</code></pre></div></div>

<ul>
  <li>메모리를 <strong><code class="language-plaintext highlighter-rouge">int</code> 타입 크기만큼만 사용</strong>(불필요한 <code class="language-plaintext highlighter-rouge">Integer</code> 객체 생성 없음)</li>
  <li><strong>읽기/쓰기 속도가 빠름</strong></li>
</ul>

<hr />

<h2 id="-성능-비교-실험-java"><strong>⏳ 성능 비교 실험 (Java)</strong></h2>

<p>내가 직접 <code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>와 <code class="language-plaintext highlighter-rouge">int[]</code>의 속도를 비교하는 코드를 실행해볼게!<br />
아래 코드로 <strong>같은 데이터를 저장하고 조회하는데 걸리는 시간</strong>을 비교해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PerformanceTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="no">SIZE</span> <span class="o">=</span> <span class="mi">10_000_000</span><span class="o">;</span> <span class="c1">// 1천만 개의 데이터 테스트</span>

        <span class="c1">// 1️⃣ 배열 테스트</span>
        <span class="kt">long</span> <span class="n">startTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">SIZE</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">SIZE</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">long</span> <span class="n">endTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"배열(int[]) 실행 시간: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="o">)</span> <span class="o">/</span> <span class="mi">1_000_000</span> <span class="o">+</span> <span class="s">" ms"</span><span class="o">);</span>

        <span class="c1">// 2️⃣ ArrayList 테스트</span>
        <span class="n">startTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="no">SIZE</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">SIZE</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">endTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ArrayList 실행 시간: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="o">)</span> <span class="o">/</span> <span class="mi">1_000_000</span> <span class="o">+</span> <span class="s">" ms"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="-성능-테스트-결과-대략적인-차이"><strong>⏳ 성능 테스트 결과 (대략적인 차이)</strong></h2>

<p><strong>테스트 환경:</strong> <code class="language-plaintext highlighter-rouge">10,000,000</code>개의 데이터를 저장하는 경우<br />
(결과는 실행 환경에 따라 다를 수 있음)</p>

<table>
  <thead>
    <tr>
      <th>데이터 크기</th>
      <th><code class="language-plaintext highlighter-rouge">int[] 배열</code> (배열)</th>
      <th><code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code> (리스트)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10,000,000개 데이터 저장</td>
      <td><strong>30~50ms</strong></td>
      <td><strong>100~200ms</strong></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong>✅ 배열(<code class="language-plaintext highlighter-rouge">int[]</code>)이 <code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>보다 약 3~5배 빠름!</strong></p>
</blockquote>

<hr />

<h2 id="-결론-언제-arraylist를-쓰고-언제-배열int을-써야-할까"><strong>📌 결론: 언제 <code class="language-plaintext highlighter-rouge">ArrayList</code>를 쓰고, 언제 <code class="language-plaintext highlighter-rouge">배열(int[])</code>을 써야 할까?</strong></h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th><code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code></th>
      <th><code class="language-plaintext highlighter-rouge">int[] 배열</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>데이터 크기가 가변적일 때</strong></td>
      <td>✅ 추천 (자동 크기 증가)</td>
      <td>❌ 비효율적 (고정 크기)</td>
    </tr>
    <tr>
      <td><strong>빠른 읽기/쓰기 성능이 필요할 때</strong></td>
      <td>❌ 상대적으로 느림</td>
      <td>✅ 빠름 (메모리 직접 접근)</td>
    </tr>
    <tr>
      <td><strong>메모리 사용량 최적화가 필요할 때</strong></td>
      <td>❌ <code class="language-plaintext highlighter-rouge">Integer</code> 객체로 인해 메모리 낭비</td>
      <td>✅ <code class="language-plaintext highlighter-rouge">int</code> 원시 타입이므로 메모리 절약</td>
    </tr>
    <tr>
      <td><strong>삭제/삽입이 자주 발생할 때</strong></td>
      <td>✅ <code class="language-plaintext highlighter-rouge">remove()</code> 지원</td>
      <td>❌ 배열 크기 고정이라 비효율적</td>
    </tr>
  </tbody>
</table>

<ol>
  <li><strong>성능이 중요하다면 <code class="language-plaintext highlighter-rouge">int[]</code> 배열이 훨씬 빠르고 메모리도 절약된다!</strong> 🚀</li>
  <li><strong>크기가 변하는 데이터를 다룰 때는 <code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>가 편리하다.</strong> ✅</li>
  <li><strong>데이터 개수가 많고, 읽기/쓰기 성능이 중요하다면 <code class="language-plaintext highlighter-rouge">int[]</code>을 사용하는 것이 좋다.</strong> ⚡</li>
  <li><strong>일반적인 상황에서는 <code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>를 쓰는 게 개발 편의성 면에서 좋다.</strong></li>
</ol>

<p>즉, <strong>고정된 크기라면 배열을 쓰고, 크기가 유동적이면 <code class="language-plaintext highlighter-rouge">ArrayList</code>를 쓰는 게 정답!</strong> 😃</p>

<hr />

<h2 id="추가--hashmapinteger-integer와의-성능-비교">추가 : HashMap&lt;Integer, Integer&gt;와의 성능 비교</h2>

<table>
  <thead>
    <tr>
      <th>데이터 구조</th>
      <th>실행 속도 (초)</th>
      <th>특징</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>배열 (<code class="language-plaintext highlighter-rouge">int[]</code>)</strong></td>
      <td><strong>가장 빠름</strong> (0.03~0.05초)</td>
      <td>메모리 직접 접근 (고정 크기)</td>
    </tr>
    <tr>
      <td><strong>ArrayList (<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>)</strong></td>
      <td><strong>중간 (0.1~0.2초)</strong></td>
      <td>동적 크기 조정 가능</td>
    </tr>
    <tr>
      <td><strong>HashMap (<code class="language-plaintext highlighter-rouge">HashMap&lt;Integer, Integer&gt;</code>)</strong></td>
      <td><strong>가장 느림 (0.3~0.5초)</strong></td>
      <td>키-값 매핑 (빠른 탐색)</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="3️⃣-hashmap-hashmapinteger-integer"><strong>3️⃣ HashMap (<code class="language-plaintext highlighter-rouge">HashMap&lt;Integer, Integer&gt;</code>)</strong></h3>

<ul>
  <li><strong>속도:</strong> <strong>가장 느림 (배열보다 약 5~10배 느림)</strong></li>
  <li><strong>이유:</strong>
    <ul>
      <li>내부적으로 <strong>해시 함수(Hashing)</strong> 사용 → 빠른 탐색(O(1)) 가능</li>
      <li>하지만 키-값 저장 방식이라 <strong>메모리 오버헤드가 큼</strong></li>
    </ul>
  </li>
  <li><strong>장점:</strong>
    <ul>
      <li>데이터 검색이 <strong>O(1) (거의 즉각적)</strong></li>
      <li>키 기반으로 <strong>빠르게 값에 접근 가능</strong></li>
    </ul>
  </li>
  <li><strong>언제 사용하면 좋을까?</strong>
    <ul>
      <li><strong>Key-Value 형태의 데이터 저장이 필요할 때</strong></li>
      <li><strong>데이터 조회 속도가 중요한 경우</strong> (탐색이 많을 때)</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="-결론"><strong>💡 결론</strong></h3>

<table>
  <thead>
    <tr>
      <th>사용 목적</th>
      <th>추천 자료 구조</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>고정된 크기의 데이터</strong></td>
      <td><code class="language-plaintext highlighter-rouge">int[]</code> (배열)</td>
    </tr>
    <tr>
      <td><strong>크기가 유동적인 리스트</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code></td>
    </tr>
    <tr>
      <td><strong>빠른 탐색이 필요한 경우</strong></td>
      <td><code class="language-plaintext highlighter-rouge">HashMap&lt;Integer, Integer&gt;</code></td>
    </tr>
  </tbody>
</table>

<p>즉,<br />
✔ <strong>빠른 연산이 필요하면 <code class="language-plaintext highlighter-rouge">int[] 배열</code></strong><br />
✔ <strong>동적 크기가 필요하면 <code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code></strong><br />
✔ <strong>키-값 조회가 많다면 <code class="language-plaintext highlighter-rouge">HashMap&lt;Integer, Integer&gt;</code></strong></p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="java" /><summary type="html"><![CDATA[ArrayList와 배열(int[])의 성능을 비교해보자.]]></summary></entry><entry><title type="html">[JAVA] SOLID 원칙</title><link href="https://nan0silver.github.io/java/2025-02-23-solid/" rel="alternate" type="text/html" title="[JAVA] SOLID 원칙" /><published>2025-02-23T00:00:00+00:00</published><updated>2025-04-04T02:21:08+00:00</updated><id>https://nan0silver.github.io/java/solid</id><content type="html" xml:base="https://nan0silver.github.io/java/2025-02-23-solid/"><![CDATA[<ul>
  <li><a href="#1-srp-single-responsibility-principle">1. 단일 책임 원칙</a></li>
  <li><a href="#2-ocp-openclosed-principle">2. 개방-폐쇄 원칙</a></li>
  <li><a href="#3-lsp-liskov-substitution-principle">3. 리스코프 치환 원칙</a></li>
  <li><a href="#4-isp-interface-segregation-principle">4. 인터페이스 분리 원칙</a></li>
  <li><a href="#5-dip-dependency-inversion-principle">5. 의존성 역전 원칙</a></li>
</ul>

<hr />

<h2 id="solid-원칙">SOLID 원칙</h2>

<ul>
  <li>객체지향 프로그래밍(OOP)에서 SOLID 원칙이란, 유지보수와 확장이 쉬운 소프트웨어를 만들기 위한 5가지 설계 원칙</li>
  <li>각각의 원칙의 첫글자를 따서 만든 약자.</li>
  <li><img src="https://raw.githubusercontent.com/nan0silver/nan0silver.github.io/3820f9cfa16c85c0487a9fd198d804a6f957a658/assets/img/blog/2025-02-23-solid.svg" alt="solid 원칙" /></li>
</ul>

<h2 id="1-srp-single-responsibility-principle"><strong>1. SRP (Single Responsibility Principle)</strong></h2>

<blockquote>
  <p>🔴 단일 책임 원칙</p>
</blockquote>

<ul>
  <li>정의
    <ul>
      <li>하나의 클래스는 단 하나의 책임(기능)만 가져야 한다.</li>
      <li>즉, 클래스가 변경될 이유는 오직 하나여야 한다/</li>
    </ul>
  </li>
  <li>의미
    <ul>
      <li>클래스가 너무 많은 역할을 담당하게 되면, 유지보수나 확장 시 하나의 변경 사항이 다른 기능까지 의도치 않게 영향을 줄 수 있음</li>
      <li>하나의 클래스가 단 하나의 목적만 수행하도록 하면, 코드 관리가 쉬워지고 명확해짐</li>
    </ul>
  </li>
  <li>예시
    <ul>
      <li>❌ 나쁜 예시 : 회원 관리 클래스가 로그인, 회원정보 관리, 이메일 발송까지 전부 담당</li>
      <li>✅ 좋은 예시 : 로그인 클래스, 회원정보 관리 클래스, 이메일 발송 클래스를 각각 따로 분리</li>
    </ul>
  </li>
</ul>

<h2 id="2-ocp-openclosed-principle"><strong>2. OCP (Open/Closed Principle)</strong></h2>

<blockquote>
  <p>🟠 개방-폐쇄 원칙</p>
</blockquote>

<ul>
  <li>정의
    <ul>
      <li>소프트웨어의 구성 요소(클래스, 모듈, 함수 등)는 확장에는 열려있고, 변경에는 닫혀있어야 한다.</li>
    </ul>
  </li>
  <li>의미
    <ul>
      <li>새로운 기능을 추가할 때 기존 코드를 수정하지 않고도 기능을 확장할 수 있어야 함.</li>
    </ul>
  </li>
  <li>예시
    <ul>
      <li>❌ 나쁜 예시 : 새로운 결제 방식을 추가할 때마다 기존의 결제 클래스를 직접 수정</li>
      <li>✅ 좋은 예시 : 결제 방식 인터페이스를 정의하고, 이를 구현한 클래스(신용카드 결제, 페이팔 결제 등)를 추가함으로써 기존 코드 수정 없이 확장 가능</li>
    </ul>
  </li>
</ul>

<h2 id="3-lsp-liskov-substitution-principle"><strong>3. LSP (Liskov Substitution Principle)</strong></h2>

<blockquote>
  <p>🟡 리스코프 치환 원칙</p>
</blockquote>

<ul>
  <li>정의
    <ul>
      <li>자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 함.</li>
      <li>부모 클래스가 사용되는 곳에 자식 클래스를 넣었을 때도 프로그램이 정확히 동작해야 함</li>
    </ul>
  </li>
  <li>의미
    <ul>
      <li>상속 관계를 올바르게 설계해 자식 클래스가 부모 클래스의 본질적인 특성을 바꾸지 않아야 한다.</li>
      <li>자식 클래스는 부모 클래스가 가진 모든 속성과 메서드를 위반 없이 사용할 수 있어야함</li>
    </ul>
  </li>
  <li>예시
    <ul>
      <li>❌ 나쁜 예시 : ‘정사각형’ 클래스를 ‘직사각형’의 자식 클래스로 만들었지만, 가로세로를 독립적으로 조정할 수 없어서 예상한 동작이 깨지는 경우</li>
      <li>✅ 좋은 예시 : ‘도형’이라는 부모 클래스를 상속하여 ‘직사각형’, ‘정사각형’, ‘삼각형’ 등으로 각자 독립적으로 확장하여 서로 간섭 없이 동작</li>
    </ul>
  </li>
</ul>

<h2 id="4-isp-interface-segregation-principle"><strong>4. ISP (Interface Segregation Principle)</strong></h2>

<blockquote>
  <p>🟢 인터페이스 분리 원칙</p>
</blockquote>

<ul>
  <li>정의
    <ul>
      <li>클라이언트는 자신이 사용하지 않은 메서드에 의존하지 않아야 함.</li>
      <li>하나의 일반적인 인터페이스보다 여러 개의 구체적이고 세분화된 인터페이스를 사용하는 것이 좋음</li>
    </ul>
  </li>
  <li>의미
    <ul>
      <li>하나의 크고 범용적인 인터페이스보다, 용도에 따라 작고 명확하게 구분된 인터페이스를 제공하는 것이 좋음</li>
      <li>클라이언트가 필요로 하는 최소한의 메서드만 포함한 인터페이스를 만들어야함</li>
    </ul>
  </li>
  <li>예시
    <ul>
      <li>❌ 나쁜 예시 : 하나의 인터페이스에 “프린트, 팩스, 복사, 스캔” 기능을 모두 넣어서 일부만 사용하는 프린터 기기같이 모든 메서드를 구현해야하는 경우</li>
      <li>✅ 좋은 예시 : “프린트 인터페이스”, “팩스 인터페이스”, “복사 인터페이스”, “스캔 인터페이스”로 나눠서 필요한 기능만 구현하도록 제공</li>
    </ul>
  </li>
</ul>

<h2 id="5-dip-dependency-inversion-principle"><strong>5. DIP (Dependency Inversion Principle)</strong></h2>

<blockquote>
  <p>🔵 의존성 역전 원칙</p>
</blockquote>

<ul>
  <li>정의
    <ul>
      <li>고수준 모듈은 저수준 모듈의 구현에 의존해서는 안되며 둘 다 추상화에 의존해야함</li>
      <li>또한, 추상화(인터페이스나 추상 클래스)는 세부 사항에 의존해서는 안되고, 세부 사항이 추상화에 의존해야함</li>
    </ul>
  </li>
  <li>의미
    <ul>
      <li>클래스가 특정 구현(구체적 클래스)이 아닌, 추상화된 인터페이스에 의존하도록 설계해야 함.</li>
      <li>이는 의존 관계룰 유연하게 만들어 유지보수 및 확장이 편리해지게 횜</li>
    </ul>
  </li>
  <li>
    <p>예시</p>

    <ul>
      <li>❌ 나쁜 예시 : 데이터베이스 클래스가 특정 DB(에: MySQL)에 직접 의존하는 코드 설계</li>
      <li>✅ 좋은 예시 : 데이터베이스 인터페이스를 정의하고, 이를 구현하는 다양한 DB클래스(MySQL, PostgreSQL 등)를 만들어 상위 모듈이 인터페이스에만 의존하도록 설계</li>
    </ul>

    <h2 id="solid-원칙을-지켰을-때의-장점">SOLID 원칙을 지켰을 때의 장점</h2>

    <ul>
      <li>유지보수 용이성</li>
      <li>코드 확장 용이성</li>
      <li>가독성 및 코드 품질 향상</li>
      <li>테스트 용이성</li>
    </ul>
  </li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="java" /><summary type="html"><![CDATA[유지보수와 확장이 쉬운 소프트웨어를 만들기 위한 5가지 설계 원칙인 SOLID 원칙에 대해 알아보자.]]></summary></entry><entry><title type="html">[Etc] 🔑 Access Token과 Refresh Token 완벽 정리</title><link href="https://nan0silver.github.io/miscellaneous/2025-02-22-token/" rel="alternate" type="text/html" title="[Etc] 🔑 Access Token과 Refresh Token 완벽 정리" /><published>2025-02-22T00:00:00+00:00</published><updated>2025-04-04T02:21:08+00:00</updated><id>https://nan0silver.github.io/miscellaneous/token</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-02-22-token/"><![CDATA[<ul>
  <li><a href="#1-access-token과-refresh-token이란">Access Token과 Refresh Token이란?</a></li>
  <li><a href="#2-access-token">Access Token</a></li>
  <li><a href="#3-refresh-token">Refresh Token</a></li>
  <li><a href="#4-access-token-vs-refresh-token-비교">Access Token vs. Refresh Token 비교</a></li>
  <li><a href="#5-access-token과-refresh-token을-사용하는-이유">Access Token과 Refresh Token을 사용하는 이유</a></li>
  <li><a href="#6-access-token과-refresh-token을-활용한-인증-흐름">Access Token과 Refresh Token을 활용한 인증 흐름</a></li>
  <li><a href="#7-access-token--refresh-token-보안-고려-사항">Access Token &amp; Refresh Token 보안 고려 사항</a></li>
  <li><a href="#8-access-token--refresh-token-실제-코드-구현-java-spring-security">실제 코드 구현 (Java, Spring Security)</a></li>
</ul>

<hr />

<h2 id="1-access-token과-refresh-token이란"><strong>1. Access Token과 Refresh Token이란?</strong></h2>

<blockquote>
  <p>OAuth 2.0을 사용할 때 핵심이 되는 토큰</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th>토큰 종류</th>
      <th>역할</th>
      <th>유효 기간</th>
      <th>사용 목적</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Access Token</strong></td>
      <td>API 요청 시 인증을 위한 토큰</td>
      <td>짧음 (몇 분~1시간)</td>
      <td>사용자가 인증된 후 API 접근</td>
    </tr>
    <tr>
      <td><strong>Refresh Token</strong></td>
      <td>Access Token이 만료되었을 때 새 토큰 발급</td>
      <td>김 (며칠~몇 달)</td>
      <td>Access Token을 갱신</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="2-access-token"><strong>2. Access Token</strong></h2>

<h3 id="-access-token이란">✅ <strong>Access Token이란?</strong></h3>

<ul>
  <li>사용자가 OAuth 인증을 마치면 <strong>Authorization Server</strong>가 발급하는 <strong>단기 유효 토큰</strong>.</li>
  <li>이 토큰을 API 요청의 <strong>Authorization 헤더</strong>에 포함하여 사용.</li>
  <li>일반적으로 <strong>Bearer Token 방식</strong>으로 사용됨.</li>
</ul>

<h3 id="-access-token-사용-예시">🎯 <strong>Access Token 사용 예시</strong></h3>

<p>HTTP 요청에서 Access Token을 포함하여 API 호출:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/user/profile</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">api.example.com</span>
<span class="na">Authorization</span><span class="p">:</span> <span class="s">Bearer ACCESS_TOKEN</span>
</code></pre></div></div>

<h3 id="-access-token의-유효-기간">⏳ <strong>Access Token의 유효 기간</strong></h3>

<ul>
  <li>보안상 <strong>짧은 시간(몇 분~1시간 정도)</strong> 만 유지됨.</li>
  <li>Access Token이 만료되면 더 이상 API를 호출할 수 없음.</li>
  <li>해결 방법: <strong>Refresh Token을 사용하여 새로운 Access Token 발급</strong>.</li>
</ul>

<hr />

<h2 id="3-refresh-token"><strong>3. Refresh Token</strong></h2>

<h3 id="-refresh-token이란">✅ <strong>Refresh Token이란?</strong></h3>

<ul>
  <li>Access Token이 만료되었을 때, <strong>새로운 Access Token을 요청할 수 있도록 제공되는 장기 토큰</strong>.</li>
  <li>Access Token과 다르게, Refresh Token 자체로는 API 요청을 보낼 수 없음.</li>
  <li>일반적으로 <strong>다시 로그인하지 않고도 인증을 연장할 때 사용</strong>.</li>
</ul>

<h3 id="-refresh-token-사용-예시">🎯 <strong>Refresh Token 사용 예시</strong></h3>

<p>Access Token이 만료되면, Refresh Token을 이용하여 새 Access Token을 요청:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">POST</span> <span class="nn">/auth/token</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">auth.example.com</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/x-www-form-urlencoded</span>

grant_type=refresh_token&amp;
client_id=YOUR_CLIENT_ID&amp;
client_secret=YOUR_CLIENT_SECRET&amp;
refresh_token=YOUR_REFRESH_TOKEN
</code></pre></div></div>

<h3 id="-refresh-token의-유효-기간">⏳ <strong>Refresh Token의 유효 기간</strong></h3>

<ul>
  <li><strong>며칠~몇 달까지 유지 가능</strong> (보안 정책에 따라 다름).</li>
  <li>일반적으로 <strong>기기 변경, 비밀번호 변경, 보안 위험 감지 시 강제 만료됨</strong>.</li>
</ul>

<hr />

<h2 id="4-access-token-vs-refresh-token-비교"><strong>4. Access Token vs. Refresh Token 비교</strong></h2>

<table>
  <thead>
    <tr>
      <th> </th>
      <th><strong>Access Token</strong></th>
      <th><strong>Refresh Token</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>목적</strong></td>
      <td>API 요청 인증</td>
      <td>새로운 Access Token 발급</td>
    </tr>
    <tr>
      <td><strong>유효 기간</strong></td>
      <td>짧음 (몇 분~1시간)</td>
      <td>김 (며칠~몇 달)</td>
    </tr>
    <tr>
      <td><strong>보관 위치</strong></td>
      <td>클라이언트 저장</td>
      <td>클라이언트 저장 (보안 필요)</td>
    </tr>
    <tr>
      <td><strong>보안 위험</strong></td>
      <td>탈취되면 API 무단 접근 가능</td>
      <td>탈취되면 새로운 Access Token 발급 가능</td>
    </tr>
    <tr>
      <td><strong>사용 가능 횟수</strong></td>
      <td>여러 번 API 요청 가능</td>
      <td>1회 또는 제한적 사용</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="5-access-token과-refresh-token을-사용하는-이유"><strong>5. Access Token과 Refresh Token을 사용하는 이유</strong></h2>

<h3 id="access-token만-사용하면"><strong>Access Token만 사용하면?</strong></h3>

<ul>
  <li>보안상 유효 기간을 길게 설정할 수 없음.</li>
  <li>토큰이 만료될 때마다 사용자가 다시 로그인해야 함 → <strong>불편함</strong>.</li>
</ul>

<h3 id="refresh-token을-추가하면"><strong>Refresh Token을 추가하면?</strong></h3>

<ul>
  <li><strong>Access Token을 자주 갱신할 수 있음</strong> → 보안 강화.</li>
  <li>사용자가 다시 로그인할 필요 없이 <strong>자동으로 인증 연장 가능</strong>.</li>
</ul>

<p>👉 <strong>Refresh Token을 사용하면 보안과 사용자 편의성 모두 향상됨</strong>.</p>

<hr />

<h2 id="6-access-token과-refresh-token을-활용한-인증-흐름"><strong>6. Access Token과 Refresh Token을 활용한 인증 흐름</strong></h2>

<p>1️⃣ <strong>사용자가 로그인 &amp; 권한 부여</strong><br />
 → OAuth 서버가 <strong>Access Token과 Refresh Token 발급</strong><br />
2️⃣ <strong>클라이언트가 API 요청</strong><br />
 → <code class="language-plaintext highlighter-rouge">Authorization: Bearer Access_Token</code> 포함하여 요청<br />
3️⃣ <strong>Access Token이 만료됨</strong><br />
 → API 서버가 <strong>401 Unauthorized</strong> 응답 반환<br />
4️⃣ <strong>Refresh Token을 사용해 새 Access Token 요청</strong><br />
 → 새 Access Token 발급 후 다시 API 요청 가능<br />
5️⃣ <strong>Refresh Token도 만료됨</strong><br />
 → 사용자는 <strong>다시 로그인 필요</strong></p>

<p>👉 <strong>Access Token은 API 요청을 인증하는 용도, Refresh Token은 새로운 Access Token을 발급하는 용도!</strong><br />
👉 <strong>보안이 중요한 만큼 저장 방식과 유효 기간을 잘 관리해야 함!</strong> 🚀</p>

<hr />

<h2 id="7-access-token--refresh-token-보안-고려-사항"><strong>7. Access Token &amp; Refresh Token 보안 고려 사항</strong></h2>

<h3 id="-access-token-보안">✅ <strong>Access Token 보안</strong></h3>

<ul>
  <li><strong>유효 기간을 짧게 설정</strong> (몇 분~1시간)</li>
  <li><strong>HTTPS 사용 필수</strong> (네트워크 스니핑 방지)</li>
  <li><strong>탈취되면 API 접근 가능 → 짧은 유효 기간이 보안성을 보장</strong></li>
</ul>

<h3 id="-refresh-token-보안">✅ <strong>Refresh Token 보안</strong></h3>

<ul>
  <li><strong>보안 저장소 사용</strong> (예: 모바일 앱에서는 <strong>Secure Storage</strong>)</li>
  <li><strong>HTTP 요청 시 노출되지 않도록 주의</strong> (쿠키 또는 안전한 저장소에 보관)</li>
  <li><strong>유출 시 즉시 무효화 필요</strong> (서버에서 토큰 무효화 기능 추가)</li>
</ul>

<h3 id="-탈취-방지-방법">🚨 <strong>탈취 방지 방법</strong></h3>

<ol>
  <li><strong>Refresh Token을 클라이언트에서 안전하게 저장</strong>
    <ul>
      <li>브라우저: <strong>HttpOnly Secure Cookie</strong> 사용</li>
      <li>모바일 앱: <strong>Secure Storage / Keychain</strong> 사용</li>
    </ul>
  </li>
  <li><strong>Refresh Token 재사용 방지 (One-Time Refresh Token)</strong>
    <ul>
      <li>Refresh Token을 사용할 때마다 새 Refresh Token을 발급하고 이전 것은 무효화</li>
    </ul>
  </li>
  <li><strong>IP &amp; 디바이스 검증</strong>
    <ul>
      <li>Refresh Token 사용 시 <strong>IP 주소와 디바이스 정보를 확인하여 이상 감지 시 무효화</strong></li>
    </ul>
  </li>
  <li><strong>토큰 암호화 및 서명</strong>
    <ul>
      <li>JWT 기반 Access Token은 <strong>서명(Signature)</strong> 을 포함하여 위변조 방지</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="8-access-token--refresh-token-실제-코드-구현-java-spring-security"><strong>8. Access Token &amp; Refresh Token 실제 코드 구현 (Java, Spring Security)</strong></h2>

<h3 id="-access-token--refresh-token-발급-api-예제-spring-boot"><strong>🔹 Access Token &amp; Refresh Token 발급 API 예제 (Spring Boot)</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/auth"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthController</span> <span class="o">{</span>

    <span class="nd">@PostMapping</span><span class="o">(</span><span class="s">"/token"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;?&gt;</span> <span class="n">getToken</span><span class="o">(</span><span class="nd">@RequestParam</span> <span class="nc">String</span> <span class="n">refreshToken</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isValidRefreshToken</span><span class="o">(</span><span class="n">refreshToken</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">newAccessToken</span> <span class="o">=</span> <span class="n">generateNewAccessToken</span><span class="o">();</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">ok</span><span class="o">(</span><span class="n">newAccessToken</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">UNAUTHORIZED</span><span class="o">).</span><span class="na">body</span><span class="o">(</span><span class="s">"Invalid Refresh Token"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isValidRefreshToken</span><span class="o">(</span><span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Refresh Token 검증 로직</span>
        <span class="k">return</span> <span class="n">token</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"valid-refresh-token"</span><span class="o">);</span> <span class="c1">// 예제 코드</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">generateNewAccessToken</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 새로운 Access Token 생성 (JWT 사용 가능)</span>
        <span class="k">return</span> <span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[OAuth 2.0을 사용할때 핵심인 Access Token과 Refresh Token에 대해 알아보자.]]></summary></entry></feed>