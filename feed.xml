<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-04-09T07:34:24+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[Spring] 논블로킹(Non-blocking) vs 비동기 (Asynchronous)</title><link href="https://nan0silver.github.io/spring/2025-04-09-non-blocking/" rel="alternate" type="text/html" title="[Spring] 논블로킹(Non-blocking) vs 비동기 (Asynchronous)" /><published>2025-04-09T00:00:00+00:00</published><updated>2025-04-09T07:33:42+00:00</updated><id>https://nan0silver.github.io/spring/non-blocking</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-09-non-blocking/"><![CDATA[<ul>
  <li><a href="#-논블로킹non-blocking이란">논블로킹이란?</a></li>
  <li><a href="#-실생활-비유로-논블로킹-이해하기">실생활 비유로 논블로킹 이해하기</a></li>
  <li><a href="#-블로킹-vs-논블로킹-기술적-요점-정리">블로킹 vs 논블로킹 기술적 요점 정리</a></li>
  <li><a href="#-논블로킹이-중요한-이유">논블로킹이 중요한 이유</a></li>
  <li><a href="#️-어디서-논블로킹이-쓰이냐">어디서 논블로킹이 쓰이냐?</a></li>
  <li><a href="#논블로킹non-blocking이랑-비동기asynchronous-비교">논블로킹(Non-blocking) 비동기(Asynchronous) 비교</a></li>
  <li><a href="#completablefuture-webclient-코드-예시">CompletableFuture, WebClient 코드 예시</a></li>
</ul>

<hr />

<h2 id="-논블로킹non-blocking이란">✅ 논블로킹(Non-blocking)이란?</h2>

<h3 id="먼저-블로킹blocking이-뭔지부터-알아보자">먼저, 블로킹(Blocking)이 뭔지부터 알아보자</h3>

<ul>
  <li><strong>블로킹 방식</strong>은 어떤 작업이 끝날 때까지 프로그램이 <strong>멈춰서 기다리는 것</strong></li>
  <li>웹 서버라면, DB 응답이나 외부 API 요청이 끝날 때까지 <strong>쓰레드가 잡혀서 못 움직임.</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 블로킹 방식 (예: RestTemplate)</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="s">"http://api.example.com"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// → 이 줄에서 응답이 올 때까지 멈춤</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"응답 받음!"</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<h3 id="-논블로킹-방식은">🚀 논블로킹 방식은?</h3>

<ul>
  <li><strong>기다리지 않는다.</strong> 요청을 보내고, 바로 다음 작업을 처리한다.</li>
  <li>응답이 나중에 오면, 그때 콜백(또는 리액티브 스트림)을 통해 처리</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 논블로킹 방식 (예: WebClient)</span>
<span class="n">webClient</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">"http://api.example.com"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
    <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">result</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"응답 받음! → "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">});</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"바로 다음 코드 실행됨!"</span><span class="o">);</span>
</code></pre></div></div>

<p>👆 여기서 중요한 건:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">subscribe()</code> 안에 있는 코드만 나중에 실행되고</li>
  <li>서버 쓰레드는 그동안 다른 요청을 처리할 수 있다는 것</li>
</ul>

<hr />

<h2 id="-실생활-비유로-논블로킹-이해하기">🍜 실생활 비유로 논블로킹 이해하기</h2>

<h3 id="-블로킹-방식-짜장면집-주방장-1명">✅ 블로킹 방식: 짜장면집 주방장 1명</h3>

<blockquote>
  <p>손님이 주문 → 짜장면 끓이는 동안 주방장이 다음 주문을 못 받음<br />
5명 동시에 오면? 4명은 그냥 기다림 (쓰레드 낭비, 느림)</p>
</blockquote>

<h3 id="-논블로킹-방식-주방장--자동면로봇">✅ 논블로킹 방식: 주방장 + 자동면로봇</h3>

<blockquote>
  <p>손님이 주문 → 기계에 넣고 대기표 발급 → 주방장은 다른 주문 처리<br />
→ 주문 100개가 와도 효율적으로 동시에 처리 가능! (고성능, 확장성)</p>
</blockquote>

<hr />

<h2 id="-블로킹-vs-논블로킹-기술적-요점-정리">🧠 블로킹 vs 논블로킹 기술적 요점 정리</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>블로킹 방식</th>
      <th>논블로킹 방식</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>처리 방식</td>
      <td>요청 → 대기 → 응답</td>
      <td>요청 → 바로 다음 처리 → 응답 오면 콜백</td>
    </tr>
    <tr>
      <td>쓰레드 사용</td>
      <td><strong>요청 1건당 쓰레드 1개</strong></td>
      <td><strong>요청 수백건도 쓰레드 몇 개</strong>로 처리 가능</td>
    </tr>
    <tr>
      <td>성능</td>
      <td>낮은 동시성 처리</td>
      <td>높은 동시성, 고성능</td>
    </tr>
    <tr>
      <td>코드</td>
      <td>간단하고 직관적</td>
      <td>콜백이나 리액티브 스트림 필요</td>
    </tr>
    <tr>
      <td>예시</td>
      <td>RestTemplate, JDBC</td>
      <td>WebClient, R2DBC, Netty 등</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-논블로킹이-중요한-이유">💡 논블로킹이 중요한 이유</h2>

<h3 id="️-1-고성능-서버-만들기">✔️ 1. 고성능 서버 만들기</h3>

<ul>
  <li>수천~수만 명이 동시에 요청을 보내도 효율적으로 처리 가능</li>
</ul>

<h3 id="️-2-외부-api-많이-쓰는-서비스에서-유리">✔️ 2. 외부 API 많이 쓰는 서비스에서 유리</h3>

<ul>
  <li>다른 서비스의 응답을 기다리는 동안, 서버 리소스를 낭비하지 않음</li>
</ul>

<h3 id="️-3-msa-마이크로서비스-아키텍처에서-필수">✔️ 3. MSA (마이크로서비스 아키텍처)에서 필수</h3>

<ul>
  <li>서로 요청 주고받는 일이 많기 때문에 <strong>논블로킹 API가 매우 효율적</strong></li>
</ul>

<hr />

<h2 id="️-어디서-논블로킹이-쓰이냐">🛠️ 어디서 논블로킹이 쓰이냐?</h2>

<table>
  <thead>
    <tr>
      <th>기술</th>
      <th>논블로킹 여부</th>
      <th>비고</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">WebClient</code></td>
      <td>✅</td>
      <td>REST API 호출</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Reactor Netty</code></td>
      <td>✅</td>
      <td>웹서버 / 클라이언트 엔진</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">R2DBC</code></td>
      <td>✅</td>
      <td>논블로킹 DB 클라이언트 (JDBC는 블로킹)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Spring WebFlux</code></td>
      <td>✅</td>
      <td>전체 논블로킹 웹 프레임워크</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="논블로킹non-blocking이랑-비동기asynchronous-비교">“논블로킹(Non-blocking)”이랑 “비동기(Asynchronous)” 비교</h2>

<blockquote>
  <p>❌ <strong>같은 말 아님</strong>.<br />
✅ <strong>서로 관련 있지만, 개념적으로 다르다.</strong></p>
</blockquote>

<h3 id="-핵심-차이-요약">🔍 핵심 차이 요약</h3>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>비동기 (Asynchronous)</th>
      <th>논블로킹 (Non-blocking)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>개념</td>
      <td><strong>작업을 요청하고 바로 다음 코드 실행</strong> (응답 기다리지 않음)</td>
      <td><strong>리소스(쓰레드 등)를 점유하지 않음</strong></td>
    </tr>
    <tr>
      <td>초점</td>
      <td><strong>시간(언제 실행될지 모름)</strong></td>
      <td><strong>리소스 사용 여부</strong></td>
    </tr>
    <tr>
      <td>예시</td>
      <td>콜백, Future, Promise, Mono</td>
      <td><code class="language-plaintext highlighter-rouge">read()</code> 호출 시 즉시 리턴</td>
    </tr>
    <tr>
      <td>관련성</td>
      <td>비동기 처리는 대부분 논블로킹 방식으로 구현됨</td>
      <td>논블로킹이 항상 비동기인 건 아님</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-비유로-설명">🎯 비유로 설명</h3>

<h4 id="-비동기란">🍜 비동기란?</h4>

<blockquote>
  <p>“너 짜장면 하나, 그리고 바로 다음 손님 주세요~”</p>
</blockquote>

<ul>
  <li>주문 받고 <strong>즉시 다음 손님 주문을 받는</strong> 방식</li>
  <li>짜장면이 나올 때까지 <strong>기다리지 않음</strong></li>
  <li>나중에 “주문하신 짜장면 나왔습니다~” 하고 <strong>알림이 옴 (콜백)</strong></li>
</ul>

<p>✅ 즉, “작업이 완료될 때까지 기다리지 않고 <strong>나중에 처리</strong>“가 핵심</p>

<hr />

<h4 id="-논블로킹이란">🥡 논블로킹이란?</h4>

<blockquote>
  <p>“면 삶는 동안 <strong>주방 공간을 계속 점유하지 않음</strong>”</p>
</blockquote>

<ul>
  <li>요리를 맡긴 뒤 주방 공간을 <strong>즉시 다른 요리사에게 넘겨줌</strong></li>
  <li>결과가 나올 때까지 그 <strong>리소스를 점유하지 않음</strong></li>
</ul>

<p>✅ 즉, <strong>요청을 처리 중인 동안에도 시스템 리소스를 점유하지 않음</strong>이 핵심</p>

<hr />

<h2 id="-코드-예시-비교">🧠 코드 예시 비교</h2>

<h3 id="-블로킹--동기-가장-기본">🧱 블로킹 + 동기 (가장 기본)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 이 줄에서 서버 응답이 올 때까지 기다림 (쓰레드 점유 O, 시간도 대기 O)</span>
</code></pre></div></div>

<hr />

<h3 id="-논블로킹--동기">🧱 논블로킹 + 동기</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">readNonBlocking</span><span class="o">();</span>  <span class="c1">// 지금 읽을 수 있는 데이터만 읽고 즉시 리턴</span>
</code></pre></div></div>

<ul>
  <li>당장 읽을 게 없으면 빈 값만 주고 <strong>쓰레드는 곧바로 다음 작업 가능</strong></li>
  <li>하지만 <strong>이 결과로 바로 처리함</strong> → <strong>동기적</strong></li>
</ul>

<hr />

<h3 id="-논블로킹--비동기-진짜-고성능-시스템-핵심">🧱 논블로킹 + 비동기 (진짜 고성능 시스템 핵심!)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">webClient</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">"/data"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
    <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"데이터 도착: "</span> <span class="o">+</span> <span class="n">data</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>

<ul>
  <li>요청 후 <strong>바로 다음 코드 실행됨</strong> (비동기)</li>
  <li><strong>쓰레드를 점유하지 않음</strong> (논블로킹)</li>
  <li>응답이 왔을 때만 콜백으로 실행됨</li>
</ul>

<hr />

<h3 id="-정리하자면">💡 정리하자면</h3>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>설명</th>
      <th>예</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>비동기</td>
      <td>요청 → 응답 기다리지 않고 다른 작업함</td>
      <td>콜백, <code class="language-plaintext highlighter-rouge">subscribe</code>, <code class="language-plaintext highlighter-rouge">Future</code>, <code class="language-plaintext highlighter-rouge">CompletableFuture</code></td>
    </tr>
    <tr>
      <td>논블로킹</td>
      <td>시스템 리소스를 점유하지 않음</td>
      <td>WebClient, R2DBC, Netty</td>
    </tr>
    <tr>
      <td>블로킹</td>
      <td>결과 나올 때까지 멈춤</td>
      <td>RestTemplate, JDBC</td>
    </tr>
    <tr>
      <td>비동기 + 논블로킹</td>
      <td>성능 최상 조합</td>
      <td>WebFlux + Netty + R2DBC</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="completablefuture-webclient-코드-예시">CompletableFuture, WebClient 코드 예시</h2>

<h3 id="-1-completablefuture로-비동기-스레드는-점유함--논블로킹-아님">✅ 1. <code class="language-plaintext highlighter-rouge">CompletableFuture</code>로 비동기 (스레드는 점유함 = 논블로킹 아님)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.CompletableFuture</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutionException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsyncWithCompletableFuture</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ExecutionException</span><span class="o">,</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"비동기 시작"</span><span class="o">);</span>

        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="c1">// 시간이 오래 걸리는 작업 (예: API 호출 시뮬레이션)</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span> <span class="c1">// 2초 대기 (스레드 점유)</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="s">"API 결과값"</span><span class="o">;</span>
        <span class="o">});</span>

        <span class="c1">// 다른 작업 수행</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"다른 작업 수행 중..."</span><span class="o">);</span>

        <span class="c1">// 결과 기다리기</span>
        <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="c1">// 여기서 block됨</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"결과: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="-포인트">📌 포인트:</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture</code>는 비동기처럼 보이지만 <strong>실제로는 별도 스레드를 점유</strong>함.</li>
  <li><code class="language-plaintext highlighter-rouge">.get()</code>을 호출하면 <strong>결과를 기다리는 동안 block</strong>됨.</li>
</ul>

<hr />

<h2 id="-2-webclient로-진짜-논블로킹--비동기">🛸 2. <code class="language-plaintext highlighter-rouge">WebClient</code>로 진짜 논블로킹 + 비동기</h2>

<blockquote>
  <p>의존성 필요:</p>
</blockquote>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- build.gradle 혹은 pom.xml --&gt;</span>
implementation 'org.springframework.boot:spring-boot-starter-webflux'
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.web.reactive.function.client.WebClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">reactor.core.publisher.Mono</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsyncWithWebClient</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">WebClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">WebClient</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"WebClient 비동기 호출 시작"</span><span class="o">);</span>

        <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
                <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">"https://jsonplaceholder.typicode.com/todos/1"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
                <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

        <span class="n">response</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">body</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"응답 도착: "</span> <span class="o">+</span> <span class="n">body</span><span class="o">));</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"다른 작업 수행 중..."</span><span class="o">);</span>

        <span class="c1">// 실제로 메인 스레드가 먼저 종료될 수 있어서 약간 대기</span>
        <span class="k">try</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">3000</span><span class="o">);</span> <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="-포인트-1">📌 포인트:</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">WebClient</code>는 진짜 논블로킹 (스레드 점유 X)</li>
  <li><code class="language-plaintext highlighter-rouge">.subscribe()</code>로 <strong>콜백 기반 응답 처리</strong></li>
  <li><strong>메인 스레드는 응답 기다리지 않음</strong>, 논블로킹 체험 가능</li>
</ul>

<hr />

<h2 id="️-비교-요약">⚖️ 비교 요약</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th><code class="language-plaintext highlighter-rouge">CompletableFuture</code></th>
      <th><code class="language-plaintext highlighter-rouge">WebClient</code> (WebFlux)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>스레드 점유</td>
      <td>O (다른 스레드가 일 함)</td>
      <td>X (논블로킹 방식)</td>
    </tr>
    <tr>
      <td>비동기 처리 방식</td>
      <td>Future 기반</td>
      <td>리액티브 스트림 (Mono/Flux)</td>
    </tr>
    <tr>
      <td>논블로킹 체험 가능 여부</td>
      <td>부분적으로 (Thread 풀에 의존)</td>
      <td>O (진짜 논블로킹)</td>
    </tr>
    <tr>
      <td>사용 목적</td>
      <td>간단한 비동기 로직</td>
      <td>고성능, 동시성 높은 네트워크 호출</td>
    </tr>
  </tbody>
</table>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[논블로킹과 비동기에 대해 알아보자.]]></summary></entry><entry><title type="html">[Spring] Thymeleaf</title><link href="https://nan0silver.github.io/spring/2025-04-09-thymeleaf/" rel="alternate" type="text/html" title="[Spring] Thymeleaf" /><published>2025-04-09T00:00:00+00:00</published><updated>2025-04-09T07:33:42+00:00</updated><id>https://nan0silver.github.io/spring/thymeleaf</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-09-thymeleaf/"><![CDATA[<ul>
  <li><a href="#-1-thymeleaf는-왜-쓰는-걸까">Thymeleaf는 왜 쓰는 걸까?</a></li>
  <li><a href="#-2-기본-문법-정리">기본 문법 정리</a></li>
  <li><a href="#-3-전체-흐름-예시">전체 흐름 예시</a></li>
  <li><a href="#-4-어디에-파일을-넣어야-할까">어디에 파일을 넣어야 할까?</a></li>
  <li><a href="#-요약">요약</a></li>
</ul>

<hr />

<h2 id="-1-thymeleaf는-왜-쓰는-걸까">🌱 1. Thymeleaf는 왜 쓰는 걸까?</h2>

<blockquote>
  <p>Spring Boot에서 매우 자주 사용되는 <strong>서버 사이드 템플릿 엔진</strong></p>
</blockquote>

<ul>
  <li>HTML을 그저 정적인 파일로만 쓰는 게 아니라,<br />
<strong>Spring Controller에서 전달한 데이터를 HTML에서 동적으로 표현하고 싶을 때</strong> Thymeleaf를 사용 - HTML에서 Java 객체나 데이터들을 <strong>동적으로 바인딩</strong>해서 화면에 보여줌.</li>
</ul>

<p>예를 들어,<br />
사용자 이름을 동적으로 보여주려면 이런 식으로:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">th:text=</span><span class="s">"${user.name}"</span><span class="nt">&gt;</span>홍길동<span class="nt">&lt;/p&gt;</span>
</code></pre></div></div>

<p>Spring Controller에서 <code class="language-plaintext highlighter-rouge">user</code>라는 객체를 넘기면, <code class="language-plaintext highlighter-rouge">user.name</code>이 자동으로 대체돼서 HTML에 출력된다.</p>

<hr />

<h2 id="-2-기본-문법-정리">🧩 2. 기본 문법 정리</h2>

<h3 id="-thtext--텍스트-출력">① <code class="language-plaintext highlighter-rouge">th:text</code> — 텍스트 출력</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">th:text=</span><span class="s">"${message}"</span><span class="nt">&gt;&lt;/p&gt;</span>
</code></pre></div></div>

<p>→ <code class="language-plaintext highlighter-rouge">${message}</code>의 값을 이 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 태그 안에 출력해줌.</p>

<hr />

<h3 id="-theach--반복문">② <code class="language-plaintext highlighter-rouge">th:each</code> — 반복문</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;li</span> <span class="na">th:each=</span><span class="s">"item : ${items}"</span> <span class="na">th:text=</span><span class="s">"${item}"</span><span class="nt">&gt;&lt;/li&gt;</span>
</code></pre></div></div>

<p>→ <code class="language-plaintext highlighter-rouge">items</code> 리스트를 하나씩 꺼내서 <code class="language-plaintext highlighter-rouge">item</code>으로 반복해 <code class="language-plaintext highlighter-rouge">&lt;li&gt;</code>들을 만든다.</p>

<hr />

<h3 id="-thif-thunless--조건문">③ <code class="language-plaintext highlighter-rouge">th:if</code>, <code class="language-plaintext highlighter-rouge">th:unless</code> — 조건문</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">th:if=</span><span class="s">"${user != null}"</span><span class="nt">&gt;</span>로그인 성공<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;p</span> <span class="na">th:unless=</span><span class="s">"${user != null}"</span><span class="nt">&gt;</span>로그인 해주세요<span class="nt">&lt;/p&gt;</span>
</code></pre></div></div>

<hr />

<h3 id="-thhref-thsrc--링크나-이미지-경로-바인딩">④ <code class="language-plaintext highlighter-rouge">th:href</code>, <code class="language-plaintext highlighter-rouge">th:src</code> — 링크나 이미지 경로 바인딩</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">th:href=</span><span class="s">"@{/home}"</span><span class="nt">&gt;</span>홈으로<span class="nt">&lt;/a&gt;</span> <span class="nt">&lt;img</span> <span class="na">th:src=</span><span class="s">"@{/images/logo.png}"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@{/home}</code>은 <code class="language-plaintext highlighter-rouge">/home</code> 경로를 의미해. 상대경로, 쿼리스트링도 가능하다.</li>
</ul>

<hr />

<h3 id="-thaction--form-전송-주소">⑤ <code class="language-plaintext highlighter-rouge">th:action</code> — form 전송 주소</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;form</span> <span class="na">th:action=</span><span class="s">"@{/submit}"</span> <span class="na">method=</span><span class="s">"post"</span><span class="nt">&gt;&lt;/form&gt;</span>
</code></pre></div></div>

<p>→ <code class="language-plaintext highlighter-rouge">/submit</code>로 POST 요청을 보냄.</p>

<hr />

<h3 id="-thobject--thfield--폼-객체-바인딩">⑥ <code class="language-plaintext highlighter-rouge">th:object</code> + <code class="language-plaintext highlighter-rouge">th:field</code> — 폼 객체 바인딩</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;form</span> <span class="na">th:object=</span><span class="s">"${userForm}"</span> <span class="na">method=</span><span class="s">"post"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">th:field=</span><span class="s">"*{name}"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</code></pre></div></div>

<p>→ <code class="language-plaintext highlighter-rouge">userForm.getName()</code>과 연결돼서, 입력하면 자동으로 매핑됨.</p>

<hr />

<h2 id="-3-전체-흐름-예시">🧠 3. 전체 흐름 예시</h2>

<h3 id="-controller">✅ Controller</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/hello"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">hello</span><span class="o">(</span><span class="nc">Model</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"message"</span><span class="o">,</span> <span class="s">"안녕하세요!"</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"hello"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="-html-hellohtml">✅ HTML (hello.html)</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">xmlns:th=</span><span class="s">"http://www.thymeleaf.org"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>Hello<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;p</span> <span class="na">th:text=</span><span class="s">"${message}"</span><span class="nt">&gt;</span>기본 메시지<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>결과적으로는 <code class="language-plaintext highlighter-rouge">&lt;p&gt;안녕하세요!&lt;/p&gt;</code>가 출력된다.</p>

<hr />

<h2 id="-4-어디에-파일을-넣어야-할까">🧪 4. 어디에 파일을 넣어야 할까?</h2>

<p>Thymeleaf 템플릿 파일들은 이곳에 넣는다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/main/resources/templates/
</code></pre></div></div>

<p>여기 안에 <code class="language-plaintext highlighter-rouge">hello.html</code>, <code class="language-plaintext highlighter-rouge">index.html</code> 같은 HTML 파일들을 넣으면 됨.<br />
이 파일들은 Spring MVC의 Controller에서 return으로 연결할 수 있음</p>

<hr />

<h2 id="-요약">✨ 요약</h2>

<table>
  <thead>
    <tr>
      <th>기능</th>
      <th>문법 예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>텍스트 출력</td>
      <td><code class="language-plaintext highlighter-rouge">th:text="${data}"</code></td>
    </tr>
    <tr>
      <td>반복</td>
      <td><code class="language-plaintext highlighter-rouge">th:each="item : ${items}"</code></td>
    </tr>
    <tr>
      <td>조건문</td>
      <td><code class="language-plaintext highlighter-rouge">th:if</code>, <code class="language-plaintext highlighter-rouge">th:unless</code></td>
    </tr>
    <tr>
      <td>링크 경로</td>
      <td><code class="language-plaintext highlighter-rouge">th:href="@{/path}"</code></td>
    </tr>
    <tr>
      <td>이미지 경로</td>
      <td><code class="language-plaintext highlighter-rouge">th:src="@{/img/logo.png}"</code></td>
    </tr>
    <tr>
      <td>폼 전송 경로</td>
      <td><code class="language-plaintext highlighter-rouge">th:action="@{/submit}"</code></td>
    </tr>
    <tr>
      <td>폼 객체 바인딩</td>
      <td><code class="language-plaintext highlighter-rouge">th:object</code>, <code class="language-plaintext highlighter-rouge">th:field</code></td>
    </tr>
  </tbody>
</table>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[서버 사이드 템플릿 엔진인 Thymeleaf에 대해 알아보자.]]></summary></entry><entry><title type="html">[Spring] JPA vs MyBatis</title><link href="https://nan0silver.github.io/spring/2025-04-05-jpa-mybatis/" rel="alternate" type="text/html" title="[Spring] JPA vs MyBatis" /><published>2025-04-05T00:00:00+00:00</published><updated>2025-04-09T07:33:42+00:00</updated><id>https://nan0silver.github.io/spring/jpa-mybatis</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-05-jpa-mybatis/"><![CDATA[<ul>
  <li><a href="#-jpa란-java-persistence-api">JPA란?</a></li>
  <li><a href="#-mybatis란">MyBatis란?</a></li>
  <li><a href="#-jpa-vs-mybatis">🔍 JPA vs MyBatis</a></li>
  <li><a href="#jpa-vs-mybatis-비유로-이해하기">JPA vs MyBatis 비유로 이해하기</a></li>
  <li><a href="#-jpa-vs-mybatis-코드로-비교하기">JPA vs MyBatis 코드로 비교하기</a></li>
  <li><a href="#-사용-방식-차이-요약">사용 방식 차이 요약</a></li>
  <li><a href="#-장단점-비교">장단점 비교</a></li>
  <li><a href="#-실무에-쓰는-방법">실무에 쓰는 방법</a></li>
  <li><a href="#-한줄-정리">한줄 정리</a></li>
</ul>

<hr />

<h2 id="-jpa란-java-persistence-api">📌 JPA란? (Java Persistence API)</h2>

<ul>
  <li><strong>자바에서 관계형 데이터베이스(RDB)를 객체로 다룰 수 있게 해주는 표준 API</strong>.</li>
  <li>SQL을 직접 작성하지 않아도 객체처럼 DB 데이터를 저장/조회/수정/삭제 가능.</li>
  <li>구현체 중 가장 유명한 것은 <strong>Hibernate</strong>고, Spring에서 주로 이걸 씀.</li>
</ul>

<hr />

<h2 id="jpa-핵심-용어">JPA 핵심 용어</h2>

<table>
  <thead>
    <tr>
      <th>용어</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Entity</strong></td>
      <td>DB 테이블과 매핑되는 자바 클래스</td>
    </tr>
    <tr>
      <td><strong>EntityManager</strong></td>
      <td>JPA의 핵심! DB와 객체 사이의 작업을 처리하는 도구</td>
    </tr>
    <tr>
      <td><strong>Persistence Context (영속성 컨텍스트)</strong></td>
      <td>엔티티를 관리하는 JPA 내부 메모리 공간</td>
    </tr>
    <tr>
      <td><strong>JPQL (Java Persistence Query Language)</strong></td>
      <td>객체 지향 쿼리 언어. SQL과 유사하지만, 테이블이 아닌 클래스/필드 단위로 작동</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-mybatis란">📌 MyBatis란?</h2>

<ul>
  <li><strong>자바에서 SQL을 직접 작성해서 데이터베이스와 통신할 수 있게 해주는 프레임워크.</strong></li>
  <li>SQL 중심의 프로그래밍이 가능하고, <strong>복잡하고 세밀한 쿼리 제어</strong>에 유리함.</li>
  <li>XML 또는 어노테이션 기반으로 SQL을 작성하고, <strong>쿼리 결과를 자바 객체와 매핑</strong>해줌.</li>
  <li><strong>Spring과도 쉽게 통합 가능</strong>하며, 실무에서는 여전히 널리 사용됨.</li>
</ul>

<hr />

<h2 id="mybatis-핵심-용어">MyBatis 핵심 용어</h2>

<table>
  <thead>
    <tr>
      <th>용어</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Mapper 인터페이스</strong></td>
      <td>SQL 문장을 호출하는 자바 인터페이스. XML과 1:1 매칭되어 동작함</td>
    </tr>
    <tr>
      <td><strong>Mapper XML</strong></td>
      <td>실제 SQL이 작성되는 파일. <code class="language-plaintext highlighter-rouge">&lt;select&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;insert&gt;</code> 등 태그로 구성됨</td>
    </tr>
    <tr>
      <td><strong>SqlSession</strong></td>
      <td>DB 연결과 SQL 실행을 담당하는 핵심 객체 (JDBC의 Connection 역할)</td>
    </tr>
    <tr>
      <td><strong>ResultMap</strong></td>
      <td>쿼리 결과를 자바 객체에 <strong>정밀하게 매핑</strong>할 때 사용하는 설정</td>
    </tr>
    <tr>
      <td><strong>#{} / ${}</strong></td>
      <td>SQL 파라미터 바인딩 방식. <code class="language-plaintext highlighter-rouge">#{}</code>는 안전한 바인딩, <code class="language-plaintext highlighter-rouge">${}</code>는 SQL 인젝션 주의</td>
    </tr>
    <tr>
      <td><strong>TypeAlias</strong></td>
      <td>자바 클래스의 이름을 짧게 별칭으로 사용할 수 있도록 하는 기능</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-jpa-vs-mybatis">🔍 JPA vs MyBatis</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>JPA</th>
      <th>MyBatis</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>개발 방식</td>
      <td><strong>자동 매핑</strong> (객체 중심)</td>
      <td><strong>수동 매핑</strong> (SQL 중심)</td>
    </tr>
    <tr>
      <td>핵심 개념</td>
      <td>객체를 DB에 자동 매핑</td>
      <td>직접 SQL 작성 + 매핑</td>
    </tr>
    <tr>
      <td>학습 곡선</td>
      <td>좀 더 높음 (추상화 많음)</td>
      <td>비교적 쉬움 (SQL 그대로 작성)</td>
    </tr>
    <tr>
      <td>유연성</td>
      <td>추상화 많아 덜 유연함</td>
      <td>SQL 작성 자유로움</td>
    </tr>
    <tr>
      <td>성능 제어</td>
      <td>ORM에 맡김 (튜닝 어려움)</td>
      <td>직접 SQL 작성으로 제어 쉬움</td>
    </tr>
    <tr>
      <td>대표 도구</td>
      <td>Hibernate (JPA 구현체)</td>
      <td>MyBatis 프레임워크</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="jpa-vs-mybatis-비유로-이해하기">JPA vs MyBatis 비유로 이해하기</h2>

<h3 id="️-jpa--자동세탁기-">☝️ JPA = 자동세탁기 👕</h3>

<ul>
  <li><strong>세탁기 안에 옷(객체)</strong>을 넣으면<br />
→ 알아서 물(쿼리) 넣고, 빨고, 말리고<br />
→ 깨끗한 결과(조회된 객체)를 자동으로 꺼내줌!</li>
</ul>

<blockquote>
  <p>→ 개발자는 <strong>“옷만 넣고 결과만 받으면 됨”</strong><br />
→ 단, 세탁 방식은 기계가 알아서 함 (튜닝 어려움)</p>
</blockquote>

<hr />

<h3 id="️-mybatis--손빨래-">✌️ MyBatis = 손빨래 🧼</h3>

<ul>
  <li><strong>개발자가 직접</strong> 물 붓고, 비비고, 헹구고</li>
  <li>어떤 SQL 쿼리를 쓰고, 어떤 칼럼을 어떤 필드에 넣을지도 <strong>직접 지정</strong></li>
</ul>

<blockquote>
  <p>→ 개발자는 <strong>“컨트롤을 많이 할 수 있음”</strong><br />
→ 다만 <strong>귀찮고 실수할 가능성 있음</strong></p>
</blockquote>

<hr />

<h2 id="-jpa-vs-mybatis-코드로-비교하기">🧩 JPA vs MyBatis 코드로 비교하기</h2>

<h3 id="-jpa-예제-hibernate-기반">✅ JPA 예제 (Hibernate 기반)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 저장</span>
<span class="nc">Member</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"Sungwoo"</span><span class="o">);</span>
<span class="n">entityManager</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>

<span class="c1">// 조회</span>
<span class="nc">Member</span> <span class="n">result</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
</code></pre></div></div>

<p>👉 SQL 없이 객체만 조작하면 됨!<br />
→ <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">SELECT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, <code class="language-plaintext highlighter-rouge">DELETE</code>를 <strong>자동으로 처리</strong></p>

<hr />

<h3 id="-mybatis-예제">✅ MyBatis 예제</h3>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- mapper.xml --&gt;</span>
<span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"findMemberById"</span> <span class="na">parameterType=</span><span class="s">"long"</span> <span class="na">resultType=</span><span class="s">"Member"</span><span class="nt">&gt;</span>
  SELECT id, name FROM members WHERE id = #{id}
<span class="nt">&lt;/select&gt;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 자바 코드</span>
<span class="nc">Member</span> <span class="n">m</span> <span class="o">=</span> <span class="n">memberMapper</span><span class="o">.</span><span class="na">findMemberById</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
</code></pre></div></div>

<p>👉 SQL을 내가 직접 작성함<br />
→ DB 구조가 복잡하거나 튜닝이 필요할 땐 <strong>더 유리</strong></p>

<hr />

<h2 id="-사용-방식-차이-요약">✅ 사용 방식 차이 요약</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>JPA</th>
      <th>MyBatis</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SQL 작성</td>
      <td>❌ 안 함 (자동)</td>
      <td>✅ 직접 함</td>
    </tr>
    <tr>
      <td>객체 ↔ DB 매핑</td>
      <td>자동 처리</td>
      <td>명시적 지정</td>
    </tr>
    <tr>
      <td>코드 양</td>
      <td>적음</td>
      <td>많음</td>
    </tr>
    <tr>
      <td>유지보수</td>
      <td>테이블 구조 바뀌면 자동 적용</td>
      <td>SQL 전부 수정해야 함</td>
    </tr>
    <tr>
      <td>복잡한 쿼리</td>
      <td>어려움 (JPQL, QueryDSL)</td>
      <td>자유롭고 세밀하게 가능</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-장단점-비교">✅ 장단점 비교</h2>

<h3 id="-jpa의-장점">🟢 JPA의 장점</h3>

<ul>
  <li>생산성 높음 (코드 적게 작성)</li>
  <li>객체 지향적으로 설계 가능</li>
  <li>유지보수 편함 (쿼리 덜 바꿈)</li>
  <li>캐싱, 지연 로딩, 영속성 컨텍스트 등 부가기능 풍부</li>
</ul>

<hr />

<h3 id="-jpa의-단점">🔴 JPA의 단점</h3>

<ul>
  <li>처음 배울 때 어렵고 추상화가 깊음</li>
  <li>성능 튜닝 어려움</li>
  <li>복잡한 쿼리 작성이 불편함 (<code class="language-plaintext highlighter-rouge">JOIN</code>, <code class="language-plaintext highlighter-rouge">GROUP BY</code> 등)</li>
</ul>

<hr />

<h3 id="-mybatis의-장점">🟢 MyBatis의 장점</h3>

<ul>
  <li>SQL을 자유롭게 짤 수 있어 → DB 성능 튜닝 유리</li>
  <li>복잡한 쿼리나 데이터 조작에 강함</li>
  <li>개발자 컨트롤이 높음</li>
</ul>

<hr />

<h3 id="-mybatis의-단점">🔴 MyBatis의 단점</h3>

<ul>
  <li>반복 코드 많음 (SQL + 매핑 따로)</li>
  <li>유지보수 힘듦 (테이블 구조 바뀌면 SQL 전부 바꿔야 함)</li>
  <li>객체 지향 구조 만들기 어렵고, 연결이 느슨함</li>
</ul>

<hr />

<h2 id="-실무에-쓰는-방법">✅ 실무에 쓰는 방법</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>실무 선택</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>단순한 CRUD 위주의 서비스</td>
      <td>JPA (빠르고 코드 간결)</td>
    </tr>
    <tr>
      <td>복잡한 SQL 다루는 시스템</td>
      <td>MyBatis</td>
    </tr>
    <tr>
      <td>대기업/공공 시스템</td>
      <td>아직도 MyBatis 많음</td>
    </tr>
    <tr>
      <td>스타트업/신규 프로젝트</td>
      <td>JPA + QueryDSL 조합 인기</td>
    </tr>
    <tr>
      <td>둘 다 필요</td>
      <td>일부는 JPA, 일부는 MyBatis 혼용 (실제로 많음)</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-한줄-정리">📌 한줄 정리</h2>

<blockquote>
  <p>“JPA는 객체 중심의 ORM 프레임워크로, DB와의 데이터 처리를 추상화해 코드 생산성을 높여줍니다. 반면 MyBatis는 SQL 중심의 프레임워크로, 복잡한 쿼리나 성능 튜닝이 필요한 경우에 유리합니다. 프로젝트 성격에 따라 두 기술을 선택하거나 병행할 수 있습니다.”</p>
</blockquote>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[JPA vs MyBatis에 대 알아보자.]]></summary></entry><entry><title type="html">[Spring] DTO vs VO vs Entity</title><link href="https://nan0silver.github.io/spring/2025-04-02-dto-vo/" rel="alternate" type="text/html" title="[Spring] DTO vs VO vs Entity" /><published>2025-04-02T00:00:00+00:00</published><updated>2025-04-09T07:33:42+00:00</updated><id>https://nan0silver.github.io/spring/dto-vo</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-02-dto-vo/"><![CDATA[<ul>
  <li><a href="#dto-vs-vo-vs-entity">DTO vs VO vs Entity</a></li>
  <li><a href="#-dto-vs-vo">📦 DTO vs VO</a></li>
  <li><a href="#-entity-vs-vo">📦 Entity vs VO</a></li>
  <li><a href="#-entity와-dto로-분리해야하는-이유">📦 Entity와 DTO로 분리해야하는 이유</a></li>
  <li><a href="#코드-예제">코드 예제</a></li>
  <li><a href="#-면접-시-설명-예시">💬 면접 시 설명 예시</a></li>
  <li><a href="#-java-17부터는-record로-vo를-만들기-더-쉬워짐">🚀 Java 17부터는 <code class="language-plaintext highlighter-rouge">record</code>로 VO를 만들기 더 쉬워짐!</a></li>
</ul>

<hr />

<h2 id="dto-vs-vo-vs-entity">DTO vs VO vs Entity</h2>

<blockquote>
  <p>Entity는 DB와 매핑되는 핵심 객체, DTO는 데이터 전달용 객체, VO는 값 자체에 의미가 있는 불변 객체
Entity는 저장용, DTO는 전달용, VO는 표현용 객체</p>
</blockquote>

<ul>
  <li>
    <p>DTO : Data Transfer Object ➡️ 데이터 전달용 객체 (계층 간, 네트워크 등)</p>

    <ul>
      <li>🚐 손님에게 배달될 포장된 도시락
        <ul>
          <li>음식점 → 배달기사 → 고객까지 전달하는 용도
            <ul>
              <li>💡 클라이언트와 데이터 주고받는 운반용 객체! 💡</li>
            </ul>
          </li>
          <li>메뉴명, 수량, 요청사항 등 담겨 있고, 전달 중에 수정될 수도 있음 (상황에 따라 포장을 다르게 담을 수 있다.)</li>
        </ul>
      </li>
      <li>외부에 노출되는 API요청이나 응답은 Entity가 아닌 DTO를 통해 전달함으로써 보안성과 유연성을 확보</li>
    </ul>

    <blockquote>
      <p>🔴 DTO는 데이터를 <strong>“옮기는 상자”</strong></p>
    </blockquote>
  </li>
  <li>
    <p>VO : Value Object ➡️ 값을 표현하는 객체 (의미 있는 불변 값)</p>

    <ul>
      <li>🍱 도시락 자체
        <ul>
          <li>만들어지면 바꿀 수 없음 (불변)</li>
          <li>메뉴가 같으면 같은 도시락 취급</li>
          <li>값 자체가 의미 있음 - 예: 좌표, 돈, 날짜, 주소 등</li>
        </ul>
      </li>
    </ul>

    <blockquote>
      <p>🔴 VO는 의미 있는 값을 담은 <strong>“정체성 있는 객체”</strong></p>

      <blockquote>
        <p>“무엇을 나타내는 값인지”가 중요한 객체</p>
      </blockquote>
    </blockquote>
  </li>
  <li>
    <p>Entity ➡️ 실제 DB 테이블과 연결된 핵심 객체</p>

    <ul>
      <li>🍱 도시락 안의 구성 요소 (밥, 반찬, 소스 등)
        <ul>
          <li>소중하기 때문에 주방 안에서만 써야 함</li>
        </ul>
      </li>
      <li>Entity는 VO를 포함할 수 있음</li>
      <li>DB와 직접 연결된 객체이기 때문에 식별자가 존재하며 상태가 바뀔 수 있음</li>
    </ul>

    <blockquote>
      <p>🔴 Entity는 “누구인지”를 <strong>식별할 수 있는 객체</strong></p>
    </blockquote>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/nan0silver/nan0silver.github.io/7ddb58f4af0e22814e7e85a4f7111495d9cd25eb/assets/img/blog/2025-04-02-dto-vo.png" alter="DTOvsVOvsEntity" /></p>

<h2 id="-dto-vs-vo">📦 DTO vs VO</h2>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>DTO</th>
      <th>VO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>목적</td>
      <td><strong>데이터 전달</strong></td>
      <td><strong>값 표현</strong></td>
    </tr>
    <tr>
      <td>가변성</td>
      <td><strong>가변(mutable)</strong></td>
      <td><strong>불변(immutable)</strong></td>
    </tr>
    <tr>
      <td>equals/hashCode 기준</td>
      <td>주소 (기본)</td>
      <td><strong>값 기준으로 재정의</strong></td>
    </tr>
    <tr>
      <td>주 사용 위치</td>
      <td>Controller ↔ Service ↔ API</td>
      <td>도메인 내부, 로직 내 값 처리</td>
    </tr>
    <tr>
      <td>예시</td>
      <td>회원 요청 객체, 응답 DTO 등</td>
      <td>Money, Address, Coordinate 등</td>
    </tr>
    <tr>
      <td>생성 시</td>
      <td>언제든 생성 가능</td>
      <td>생성 후에는 값 변경 ❌</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-entity-vs-vo">📦 Entity vs VO</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Entity</th>
      <th>VO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>의미</td>
      <td><strong>DB 테이블과 1:1 매핑되는 객체</strong></td>
      <td><strong>의미 있는 작은 값 단위 객체</strong></td>
    </tr>
    <tr>
      <td>식별자 (ID)</td>
      <td><strong>있음 (PK, 고유값)</strong></td>
      <td><strong>없음 (값 자체로 구별)</strong></td>
    </tr>
    <tr>
      <td>불변성</td>
      <td>보통 가변</td>
      <td><strong>보통 불변 (<code class="language-plaintext highlighter-rouge">final</code>)</strong></td>
    </tr>
    <tr>
      <td>관리 위치</td>
      <td>DB와 연결되는 핵심 모델</td>
      <td>Entity 안의 필드나 계산용 값</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-entity와-dto로-분리해야하는-이유">📦 Entity와 DTO로 분리해야하는 이유</h2>

<blockquote>
  <p>굳이 클래스를 2개로 나누지 않고 그냥 Entity 하나로 다 처리하면 안 되는 이유!</p>
</blockquote>

<ul>
  <li>구체적인 이유 5가지
    <ol>
      <li>보안
        <ul>
          <li>Entity에는 민감한 필드(비밀번호 등)가 있을 수 있음 ➡️ 그대로 외부에 노출하면 위험</li>
        </ul>
      </li>
      <li>유연성
        <ul>
          <li>API 요청/응답마다 필요한 필드가 다름 ➡️ DTO로 맞춤 설계 가능</li>
        </ul>
      </li>
      <li>엔티티 보호
        <ul>
          <li>DTO로 외부와 통신 ➡️ Entity는 내부에서만 안전하게 관리</li>
        </ul>
      </li>
      <li>유효성 검사 분리
        <ul>
          <li><code class="language-plaintext highlighter-rouge">@Valid</code>, <code class="language-plaintext highlighter-rouge">@NotNull</code>등 검증 로직은 DTO에만 적용
            <blockquote>
              <p>Entity는 DB와 연결된 순수한 모델이여야 함으로 비즈니스 룰, 요청 유효성 검증 같은 책임이 없어야 한다.</p>

              <blockquote>
                <p>JPA의 역할은 저장, 조회인데 검증 로직이 섞이면 책임이 뒤엉킴 (SRP(Single Responsibility Principle) 위반)</p>
              </blockquote>
            </blockquote>
          </li>
        </ul>
      </li>
      <li>레이어 분리 원칙
        <ul>
          <li>Controller ↔ Service ↔ Repository 역할 구분이 명확해짐
            <blockquote>
              <p>“Controller” : 클라이언트와 통신 (DTO 입출력)
“Service” : 비즈니스 로직 (DTO 🔁 Entity 변환, 로직 처리)
“Repository” : DB 접근 (Entity 전용)</p>

              <blockquote>
                <p>DTO와 Entity를 나누지 않고 Controller, Service에서 Entity를 직접 다루면</p>

                <ul>
                  <li>한 객체가 너무 많은 계층을 넘나듬 (의존성 얽힘)</li>
                  <li>책임이 명확하지 않음 (수정 시 어디를 고쳐야 할지 모름)</li>
                  <li>보안 이슈 발생 가능 (불필요한 필드 노출)</li>
                </ul>
              </blockquote>
            </blockquote>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<hr />

<h2 id="코드-예제">코드 예제</h2>

<h3 id="-dto-값-전달용-가변-객체">✅ DTO (값 전달용, 가변 객체)</h3>

<ul>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberDTO</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
      <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

      <span class="c1">// 생성자</span>
      <span class="kd">public</span> <span class="nf">MemberDTO</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
          <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="c1">// getter &amp; setter (값 변경 가능!)</span>
      <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>

      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>setName(), setAge()처럼 값은 변경 가능</li>
  <li>주로 Controller 🔁 Service 🔁 Client 간 데이터 전달용</li>
</ul>

<h3 id="-vo-값-표현용-불변-객체">✅ VO (값 표현용, 불변 객체)</h3>

<ul>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Money</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">;</span>

      <span class="kd">public</span> <span class="nf">Money</span><span class="o">(</span><span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">amount</span> <span class="o">=</span> <span class="n">amount</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAmount</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">amount</span><span class="o">;</span> <span class="o">}</span>

      <span class="c1">// 값 기반 equals, hashCode</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
          <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Money</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
          <span class="nc">Money</span> <span class="n">money</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Money</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
          <span class="k">return</span> <span class="n">amount</span> <span class="o">==</span> <span class="n">money</span><span class="o">.</span><span class="na">amount</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">amount</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>필드가 <code class="language-plaintext highlighter-rouge">final</code>, setter없음 → 불변 객체</li>
  <li>equals() 재정의 → 값이 같으면 같은 객체로 간주</li>
  <li>주로 비즈니스 로직 내부에서 의미 있는 값 표현용</li>
</ul>

<h3 id="-entity">✅ Entity</h3>

<ul>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>  <span class="c1">// 노출되면 안 되는 정보</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="-면접-시-설명-예시">💬 면접 시 설명 예시</h2>

<blockquote>
  <p>“DTO는 계층 간 데이터를 전달할 때 사용하는 객체로, 보통 가변이고 네트워크나 컨트롤러에 노출됩니다. 반면 VO는 불변 객체로, 값 자체가 의미를 가지며 equals와 hashCode를 통해 같은 값을 같다고 간주해 도메인 모델 내에서 활용됩니다. Entity는 DB와 직접 연결된 객체로 식별자가 존재하며 상태가 바뀔 수 있습니다. 외부에 노출되는 API 요청이나 응답은 Entity가 아닌 DTO를 통해 전달함으로써 보안성과 유연성을 확보할 수 있습니다.”</p>
</blockquote>

<hr />

<h2 id="-java-17부터는-record로-vo를-만들기-더-쉬워짐">🚀 Java 17부터는 <code class="language-plaintext highlighter-rouge">record</code>로 VO를 만들기 더 쉬워짐!</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">Coordinate</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">final</code>, 불변성, equals/hashCode 자동 구현!</li>
  <li><strong>값 객체(VO)</strong>를 표현할 때 <strong>record는 아주 강력한 도구</strong></li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[Spring에서 데이터를 다루는 객체인 DTO, VO, Entity의 차이점에 대해 알아보자.]]></summary></entry><entry><title type="html">[Spring] HttpURLConnection, RestTemplate, WebClient</title><link href="https://nan0silver.github.io/spring/2025-04-01-resttemplate/" rel="alternate" type="text/html" title="[Spring] HttpURLConnection, RestTemplate, WebClient" /><published>2025-04-01T00:00:00+00:00</published><updated>2025-04-09T07:33:42+00:00</updated><id>https://nan0silver.github.io/spring/resttemplate</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-01-resttemplate/"><![CDATA[<ul>
  <li><a href="#-먼저-한눈에-보는-비교표">한눈에 보는 비교표</a></li>
  <li><a href="#-1-httpurlconnection--java-기본-클래스">1. HttpURLConnection</a></li>
  <li><a href="#-2-resttemplate--동기--블로킹-방식의-spring-http-클라이언트">2. RestTemplate</a></li>
  <li><a href="#-3-webclient--비동기--논블로킹-방식의-최신-http-클라이언트">3. WebClient</a></li>
  <li><a href="#-현업-개발자들은-어떻게-생각할까">현업 개발자들은 어떻게 생각할까?</a></li>
  <li><a href="#-간단-정리-">간단 정리</a></li>
  <li><a href="#-선택-가이드">선택 가이드</a></li>
</ul>

<hr />

<h2 id="java-환경에서-사용되는-http-클라이언트인-httpurlconnection-resttemplate-webclient-비교">Java 환경에서 사용되는 HTTP 클라이언트인 <code class="language-plaintext highlighter-rouge">HttpURLConnection</code>, <code class="language-plaintext highlighter-rouge">RestTemplate</code>, <code class="language-plaintext highlighter-rouge">WebClient</code> 비교</h2>

<h3 id="-1-httpurlconnection-자바-기본-제공">🧱 1. <code class="language-plaintext highlighter-rouge">HttpURLConnection</code> (자바 기본 제공)</h3>

<h3 id="-2-resttemplate-spring-제공-동기">🚗 2. <code class="language-plaintext highlighter-rouge">RestTemplate</code> (Spring 제공, 동기)</h3>

<h3 id="-3-webclient-spring-webflux-제공-비동기--논블로킹">🛸 3. <code class="language-plaintext highlighter-rouge">WebClient</code> (Spring WebFlux 제공, 비동기 &amp; 논블로킹)</h3>

<hr />

<h2 id="-먼저-한눈에-보는-비교표">📌 먼저, 한눈에 보는 비교표</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th><code class="language-plaintext highlighter-rouge">HttpURLConnection</code></th>
      <th><code class="language-plaintext highlighter-rouge">RestTemplate</code></th>
      <th><code class="language-plaintext highlighter-rouge">WebClient</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>제공</td>
      <td>Java SE 표준</td>
      <td>Spring Web (3.x~)</td>
      <td>Spring WebFlux (5.x~)</td>
    </tr>
    <tr>
      <td>방식</td>
      <td>동기 + 블로킹</td>
      <td>동기 + 블로킹</td>
      <td><strong>비동기 + 논블로킹</strong></td>
    </tr>
    <tr>
      <td>쓰기 쉬움</td>
      <td>❌ 불편하고 코드 길다</td>
      <td>✅ 간결함</td>
      <td>✅ (조금 복잡하지만 유연함)</td>
    </tr>
    <tr>
      <td>권장도</td>
      <td>❌ 현업에서 거의 안 씀</td>
      <td>⚠️ Spring 5부터 비권장</td>
      <td>✅ 최신 표준</td>
    </tr>
    <tr>
      <td>성능</td>
      <td>느림, 커넥션 재활용 어려움</td>
      <td>괜찮음, 단순 요청에는 충분 (블로킹)</td>
      <td>고성능 (Netty 기반), MSA에서 더 좋음</td>
    </tr>
    <tr>
      <td>활용</td>
      <td>Java 기본 네트워크 통신</td>
      <td>간단한 API 호출</td>
      <td>MSA, API Gateway, 대규모 호출 등</td>
    </tr>
    <tr>
      <td>미래 방향</td>
      <td>-</td>
      <td><strong>Deprecated 예정</strong> (Spring 6에서는 제거될 수 있음)</td>
      <td>Spring이 권장하는 <strong>표준 방식</strong></td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-1-httpurlconnection--java-기본-클래스">✅ 1. <code class="language-plaintext highlighter-rouge">HttpURLConnection</code> — Java 기본 클래스</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">URL</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"https://api.example.com/data"</span><span class="o">);</span>
<span class="nc">HttpURLConnection</span> <span class="n">conn</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HttpURLConnection</span><span class="o">)</span> <span class="n">url</span><span class="o">.</span><span class="na">openConnection</span><span class="o">();</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setRequestMethod</span><span class="o">(</span><span class="s">"GET"</span><span class="o">);</span>

<span class="nc">BufferedReader</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">conn</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">()));</span>
<span class="nc">String</span> <span class="n">inputLine</span><span class="o">;</span>
<span class="nc">StringBuilder</span> <span class="n">content</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

<span class="k">while</span> <span class="o">((</span><span class="n">inputLine</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">content</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">inputLine</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">in</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">conn</span><span class="o">.</span><span class="na">disconnect</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="-단점">❌ 단점</h3>

<ul>
  <li>코드가 <strong>너무 장황</strong>하고 귀찮음</li>
  <li>커넥션 풀도 없음 (직접 관리해야 함)</li>
  <li>에러 핸들링이 불편함</li>
</ul>

<h3 id="-장점">✅ 장점</h3>

<ul>
  <li><strong>Spring 없이도 동작</strong> (가벼운 프로젝트, 시험용 앱에 쓸 수 있음)</li>
</ul>

<blockquote>
  <p>🚨 <strong>실무에선 거의 안 씀. RestTemplate/WebClient로 대체.</strong></p>
</blockquote>

<hr />

<h2 id="-2-resttemplate--동기--블로킹-방식의-spring-http-클라이언트">✅ 2. <code class="language-plaintext highlighter-rouge">RestTemplate</code> — 동기 &amp; 블로킹 방식의 Spring HTTP 클라이언트</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RestTemplate</span> <span class="n">restTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RestTemplate</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">response</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="s">"https://api.example.com/data"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>

<p>→ 응답이 올 때까지 <strong>기다림</strong>. 동기 처리.</p>

<h3 id="-장점-1">✅ 장점</h3>

<ul>
  <li>코드가 아주 <strong>간단함</strong></li>
  <li>Spring 기반이라 다양한 옵션 (converter, interceptor 등) 연동 쉬움</li>
</ul>

<h3 id="️-단점">⚠️ 단점</h3>

<ul>
  <li><strong>동기 + 블로킹</strong>이라, 요청 수가 많으면 쓰레드 고갈 위험</li>
  <li>Spring 5 이후로 <strong>점점 사용 비권장됨</strong>
    <blockquote>
      <p>📢 Spring 공식 문서: <em>“RestTemplate은 더 이상 발전하지 않으며, WebClient 사용을 권장함.”</em></p>
    </blockquote>
  </li>
</ul>

<h2 id="-주요-메서드들">🔧 주요 메서드들</h2>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">getForObject()</code></td>
      <td>GET 요청 후, 결과를 객체로 받음</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">getForEntity()</code></td>
      <td>GET 요청 후, 전체 응답(ResponseEntity) 받음</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">postForObject()</code></td>
      <td>POST 요청 후, 결과를 객체로 받음</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">postForEntity()</code></td>
      <td>POST 요청 후, 전체 응답 받음</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">put()</code></td>
      <td>PUT 요청 (응답 없음)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">delete()</code></td>
      <td>DELETE 요청</td>
    </tr>
  </tbody>
</table>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-04-01-spring-resttemplate.png?raw=true" /></p>

<hr />

<h2 id="-3-webclient--비동기--논블로킹-방식의-최신-http-클라이언트">✅ 3. <code class="language-plaintext highlighter-rouge">WebClient</code> — 비동기 &amp; 논블로킹 방식의 최신 HTTP 클라이언트</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">WebClient</span> <span class="n">webClient</span> <span class="o">=</span> <span class="nc">WebClient</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
<span class="n">webClient</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">"https://api.example.com/data"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
    <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">result</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"결과: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">));</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"여긴 먼저 실행됨!"</span><span class="o">);</span>  <span class="c1">// 비동기니까 이게 먼저 출력될 수도 있음</span>
</code></pre></div></div>

<h3 id="-장점-2">✅ 장점</h3>

<ul>
  <li><strong>논블로킹 + 비동기</strong> 처리</li>
  <li>대규모 트래픽 처리에 유리</li>
  <li>기능 확장도 쉬움 (OAuth2, Retry, Timeout 등)</li>
</ul>

<h3 id="-단점-1">❗ 단점</h3>

<ul>
  <li>처음 배울 땐 리액티브 스트림(Mono/Flux)이 좀 낯설 수 있음</li>
</ul>

<blockquote>
  <p>🌐 <strong>현업에서는 WebClient가 기본</strong>이 되고 있어! 특히 MSA(마이크로서비스) 환경에서는 거의 필수!</p>
</blockquote>

<hr />

<h2 id="-현업-개발자들은-어떻게-생각할까">🔍 현업 개발자들은 어떻게 생각할까?</h2>

<ul>
  <li>“<code class="language-plaintext highlighter-rouge">HttpURLConnection</code>은 진짜로 아무것도 없을 때 테스트용으로만 씀”</li>
  <li>“<code class="language-plaintext highlighter-rouge">RestTemplate</code>은 작고 단순한 서비스에서는 아직도 많이 씀”</li>
  <li>“<code class="language-plaintext highlighter-rouge">WebClient</code>는 대규모 시스템이나 MSA, API Gateway에서 표준처럼 쓰이고 있음”</li>
</ul>

<hr />

<h2 id="-간단-정리-">🧑‍💻 간단 정리 :</h2>

<blockquote>
  <p>“HttpURLConnection은 Java에서 기본 제공하는 HTTP 클라이언트지만, 코드가 장황하고 관리가 어렵기 때문에 Spring에서는 RestTemplate이나 WebClient를 사용합니다. RestTemplate은 동기 방식으로 간단한 API 호출에는 적합하지만, Spring 5부터는 WebClient처럼 비동기 + 논블로킹 방식을 사용하는 것이 대세입니다.”</p>
</blockquote>

<hr />

<h2 id="-선택-가이드">🎁 선택 가이드</h2>

<table>
  <thead>
    <tr>
      <th>사용 상황</th>
      <th>추천 방식</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>가볍게 테스트용 API 호출</td>
      <td><code class="language-plaintext highlighter-rouge">RestTemplate</code> or <code class="language-plaintext highlighter-rouge">WebClient.block()</code></td>
    </tr>
    <tr>
      <td>복잡한 서비스 간 통신, 고성능 서버</td>
      <td><code class="language-plaintext highlighter-rouge">WebClient</code></td>
    </tr>
    <tr>
      <td>Java만 사용하는 초간단 도구 개발</td>
      <td><code class="language-plaintext highlighter-rouge">HttpURLConnection</code> (단, 실무에는 비권장)</td>
    </tr>
    <tr>
      <td>Spring 5 이상 + 새로운 프로젝트</td>
      <td>WebClient를 사용하는 게 <strong>미래지향적</strong></td>
    </tr>
  </tbody>
</table>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[Java 환경에서 사용되는 HTTP 클라이언트인 `HttpURLConnection`, `RestTemplate`, `WebClient`를 비교해보자.]]></summary></entry><entry><title type="html">[Etc] 💣 SQL Injection</title><link href="https://nan0silver.github.io/miscellaneous/2025-03-31-sql-injection/" rel="alternate" type="text/html" title="[Etc] 💣 SQL Injection" /><published>2025-03-31T00:00:00+00:00</published><updated>2025-04-09T07:33:42+00:00</updated><id>https://nan0silver.github.io/miscellaneous/sql-injection</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-03-31-sql-injection/"><![CDATA[<ul>
  <li><a href="#sql-injection이란">SQL Injection이란?</a></li>
  <li><a href="#-spring-관점에서-sql-injection-방지법">Spring 관점에서 SQL Injection 방지법</a></li>
  <li><a href="#-spring-배우는-입장에서-조심할-포인트-요약">요약</a></li>
</ul>

<hr />

<h2 id="sql-injection이란">SQL Injection이란?</h2>

<blockquote>
  <p><strong>SQL Injection</strong>이란, 사용자가 입력한 값을 통해 <strong>원래 의도하지 않은 SQL문을 실행하게 만들어</strong><br />
<strong>데이터베이스의 데이터를 탈취하거나 조작하는 공격</strong></p>
</blockquote>

<h3 id="-예시-spring-쓰기-전-일반-jdbc-코드-기준">🔍 예시 (Spring 쓰기 전 일반 JDBC 코드 기준):</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"SELECT * FROM users WHERE username = '"</span> <span class="o">+</span> <span class="n">username</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">;</span>
</code></pre></div></div>

<p>만약 <code class="language-plaintext highlighter-rouge">username</code>에 아래와 같은 값을 입력하면?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>' OR '1'='1
</code></pre></div></div>

<p>그러면 쿼리가 이렇게 바뀜:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users</span> <span class="k">WHERE</span> <span class="n">username</span> <span class="o">=</span> <span class="s1">''</span> <span class="k">OR</span> <span class="s1">'1'</span><span class="o">=</span><span class="s1">'1'</span>
</code></pre></div></div>

<p>→ 모든 유저 정보가 다 조회됨 😱<br />
→ 비밀번호 없이 로그인도 가능해짐</p>

<hr />

<h2 id="-spring-관점에서-sql-injection-방지법">🔐 Spring 관점에서 SQL Injection 방지법</h2>

<h3 id="-1-jdbc-직접-사용-시-preparedstatement-필수">✅ 1. <strong>JDBC 직접 사용 시: PreparedStatement 필수!</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"SELECT * FROM users WHERE username = ?"</span><span class="o">;</span>
<span class="nc">PreparedStatement</span> <span class="n">pstmt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
<span class="n">pstmt</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">username</span><span class="o">);</span>  <span class="c1">// 자동으로 문자열 escape 처리</span>
</code></pre></div></div>

<p>이렇게 하면 <code class="language-plaintext highlighter-rouge">' OR '1'='1</code> 같은 입력도 그냥 문자열로 인식되므로 안전하다.</p>

<hr />

<h3 id="-2-spring-jdbc-template-사용-시">✅ 2. <strong>Spring JDBC Template 사용 시</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"SELECT * FROM users WHERE username = ?"</span><span class="o">;</span>
<span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">queryForObject</span><span class="o">(</span><span class="n">sql</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="n">username</span><span class="o">},</span> <span class="n">userRowMapper</span><span class="o">);</span>
</code></pre></div></div>

<p>여기서도 <code class="language-plaintext highlighter-rouge">?</code>를 사용해서 바인딩하면 PreparedStatement가 적용되므로 안전하다.</p>

<hr />

<h3 id="-3-jpa--spring-data-jpa-사용-시">✅ 3. <strong>JPA / Spring Data JPA 사용 시</strong></h3>

<p>JPA는 SQL을 직접 작성하지 않고 엔티티 중심으로 데이터를 다루기 때문에 <strong>기본적으로 SQL Injection에 강함</strong>!</p>

<h4 id="-예시">🔸 예시:</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findByUsername</span><span class="o">(</span><span class="n">username</span><span class="o">);</span>
</code></pre></div></div>

<p>이런 방식은 내부적으로 PreparedStatement를 사용하기 때문에 안전함.</p>

<h4 id="-커스텀-jpql-사용-시에도-파라미터-바인딩-필수">🔸 커스텀 JPQL 사용 시에도 파라미터 바인딩 필수!</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Query</span><span class="o">(</span><span class="s">"SELECT u FROM User u WHERE u.username = :username"</span><span class="o">)</span>
<span class="nc">User</span> <span class="nf">findByUsername</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">"username"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">username</span><span class="o">);</span>
</code></pre></div></div>

<p>✅ <code class="language-plaintext highlighter-rouge">:username</code> 형태로 파라미터 바인딩하면 OK<br />
❌ 아래처럼 문자열 직접 연결하면 위험:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Query</span><span class="o">(</span><span class="s">"SELECT u FROM User u WHERE u.username = '"</span> <span class="o">+</span> <span class="n">username</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">)</span>
</code></pre></div></div>

<hr />

<h2 id="-spring-배우는-입장에서-조심할-포인트-요약">🚨 Spring 배우는 입장에서 조심할 포인트 요약</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>안전한 방법</th>
      <th>주의할 점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>JDBC 직접 사용</td>
      <td><code class="language-plaintext highlighter-rouge">PreparedStatement</code></td>
      <td>문자열 직접 연결 ❌</td>
    </tr>
    <tr>
      <td>JdbcTemplate</td>
      <td><code class="language-plaintext highlighter-rouge">?</code> 자리 바인딩 사용</td>
      <td>쿼리 조합 ❌</td>
    </tr>
    <tr>
      <td>JPA / Spring Data JPA</td>
      <td>파라미터 바인딩 (<code class="language-plaintext highlighter-rouge">:param</code>)</td>
      <td>JPQL 문자열 직접 붙이기 ❌</td>
    </tr>
    <tr>
      <td>QueryDSL</td>
      <td>완전 안전 (타입 기반 쿼리)</td>
      <td>-</td>
    </tr>
    <tr>
      <td>사용자 입력값 처리</td>
      <td>입력 검증, 길이 제한</td>
      <td>필터 없이 바로 사용 ❌</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-마무리-요약">🎯 마무리 요약</h2>

<ul>
  <li>SQL Injection = <strong>사용자가 입력한 값을 통해 악성 SQL 실행</strong></li>
  <li>Spring에서는 기본적으로 <strong>PreparedStatement</strong> 방식이므로 잘 쓰면 안전함</li>
  <li>하지만 <strong>직접 쿼리 짜거나, 문자열로 SQL을 조합</strong>하는 경우 주의!</li>
  <li><strong>ORM(JPA) + 파라미터 바인딩</strong> 방식으로 작성하면 거의 대부분 안전하게 막을 수 있음</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[악의적인 사용자가 SQL 쿼리에 코드를 삽입해 DB정보를 탈취하거나 조작하는 것을 뜻하는 SQL Injection에 대해 알아보자.]]></summary></entry><entry><title type="html">[Algorithm] 소수 빠르게 찾는 법</title><link href="https://nan0silver.github.io/algorithm/2025-03-20-is-prime/" rel="alternate" type="text/html" title="[Algorithm] 소수 빠르게 찾는 법" /><published>2025-03-20T00:00:00+00:00</published><updated>2025-04-09T07:33:42+00:00</updated><id>https://nan0silver.github.io/algorithm/is-prime</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2025-03-20-is-prime/"><![CDATA[<ol>
  <li><a href="#1️⃣-기본-소수-판별-on">기본 소수 판별</a></li>
  <li><a href="#2️⃣-에라토스테네스의-체-on-log-log-n">에라토스테네스의 체</a></li>
  <li><a href="#3️⃣-miller-rabin-소수판별법-olog-n">Miller-Rabin 소수 판별법</a></li>
</ol>

<hr />

<h2 id="1️⃣-기본-소수-판별-on">1️⃣ 기본 소수 판별 (O(√N))</h2>

<ul>
  <li>어떤 숫자 N이 소수인지 판별하는 가장 기본적인 방법은 1과 자기 자신을 제외한 다른 수로 나누어떨어지는지 확인하는 것</li>
  <li>🔥 2부터 √N까지 나누어보자!
    <ul>
      <li>소수가 아니라면 작은 약수를 가지고 있기 때문</li>
    </ul>
  </li>
  <li>코드 예제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrimeCheck</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">n</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">29</span><span class="o">));</span> <span class="c1">//true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span> <span class="c1">//false</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="2️⃣-에라토스테네스의-체-on-log-log-n">2️⃣ 에라토스테네스의 체 (O(N log log N))</h2>

<blockquote>
  <p>여러 개의 소수를 빠르게 찾는 방법</p>
</blockquote>

<ul>
  <li>1부터 N까지의 수 중에서 소수를 모두 찾아야 하는 경우</li>
  <li>🔥 방법
    <ol>
      <li>2부터 시작해서 배수들을 모두 제거</li>
      <li>남은 수들만 소수로 판별</li>
    </ol>
  </li>
  <li>장점
    <ul>
      <li>한 번 계산해 두면 특정 범위 내에서 빠르게 소수 여부를 판별할 수 있음.</li>
    </ul>
  </li>
  <li>코드 예제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SieveOfEratosthenes</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">sieveOfEratosthenes</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">isPrime</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">isPrime</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="n">isPrime</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">isPrime</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isPrime</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">isPrime</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">//소수 리스트 생성</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="3️⃣-miller-rabin-소수판별법-olog-n">3️⃣ Miller-Rabin 소수판별법 (O(log N))</h2>

<blockquote>
  <p>소수 판별이 자주 필요할 때</p>
</blockquote>

<ul>
  <li>N이 엄청 크면 밀러-라빈 소수판별법을 사용해야함
    <ul>
      <li>10^18이상의 큰 수가 소수인지 판별할 때</li>
      <li>암후학, 해시 관련 문제에서 사용</li>
    </ul>
  </li>
  <li>🔥 확률적 알고리즘</li>
  <li>코드 예제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MillerRabin</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// k는 테스트 횟수</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="c1">// n - 1 = 2^r * d 형태로 변환</span>
        <span class="kt">long</span> <span class="n">d</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">d</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">r</span><span class="o">++;</span>
            <span class="n">d</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>

        <span class="c1">// Miller-Rabin 테스트 실행</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextLong</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">3</span><span class="o">);</span> <span class="c1">// 2 ≤ a ≤ n-2</span>
            <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="n">powerMod</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// x = a^d % n</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>

            <span class="kt">boolean</span> <span class="n">isComposite</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">powerMod</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// x = x^2 % n</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">isComposite</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">isComposite</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 합성수 판별</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// 소수 판별</span>
    <span class="o">}</span>

    <span class="c1">// (base^exp) % mod 연산 (빠른 거듭제곱)</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">powerMod</span><span class="o">(</span><span class="kt">long</span> <span class="n">base</span><span class="o">,</span> <span class="kt">long</span> <span class="n">exp</span><span class="o">,</span> <span class="kt">long</span> <span class="n">mod</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">base</span> <span class="o">%=</span> <span class="n">mod</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">exp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">exp</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 홀수 지수 처리</span>
                <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">result</span> <span class="o">*</span> <span class="n">base</span><span class="o">)</span> <span class="o">%</span> <span class="n">mod</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">base</span> <span class="o">=</span> <span class="o">(</span><span class="n">base</span> <span class="o">*</span> <span class="n">base</span><span class="o">)</span> <span class="o">%</span> <span class="n">mod</span><span class="o">;</span> <span class="c1">// 제곱</span>
            <span class="n">exp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 지수 나누기 2</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">15485863</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>  <span class="c1">// true (소수)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">1000000007</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span> <span class="c1">// true (소수)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">1000000008</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span> <span class="c1">// false (합성수)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[소수를 빠르게 효율적으로 찾는 방법 3가지를 알아보자]]></summary></entry><entry><title type="html">[Etc] 🤖 Layered Architecture &amp;amp; MVC pattern</title><link href="https://nan0silver.github.io/miscellaneous/2025-03-17-layered-architecture/" rel="alternate" type="text/html" title="[Etc] 🤖 Layered Architecture &amp;amp; MVC pattern" /><published>2025-03-17T00:00:00+00:00</published><updated>2025-04-09T07:33:42+00:00</updated><id>https://nan0silver.github.io/miscellaneous/layered-architecture</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-03-17-layered-architecture/"><![CDATA[<ul>
  <li><a href="#레이어드-아키텍쳐layered-architecture란">레이어드 아키텍쳐(Layered Architecture)란?</a></li>
  <li><a href="#mvc란">MVC란?</a></li>
  <li><a href="#레이어드-아키텍쳐와-mvc를-함께-사용">레이어드 아키텍쳐와 MVC를 함께 사용</a></li>
</ul>

<hr />

<h2 id="레이어드-아키텍쳐layered-architecture란">레이어드 아키텍쳐(Layered Architecture)란?</h2>

<ul>
  <li>여러 수평 레이어가 수직적으로 쌓인 구조 (상위 레이어에서 하위 레이어로 단방향 의존성)</li>
  <li>
    <p>각 계층이 명확한 역할을 가지며, 하위 계층만 접근할 수 있도록 설계하여 유지보수성과 확장성을 높이는 것이 목적</p>

    <ol>
      <li>
        <p>Presentation Layer (프레젠테이션 계층) : 1층로비, 방문객 맞이하고 안내</p>

        <blockquote>
          <p>예시: Spring Boot의 <code class="language-plaintext highlighter-rouge">Controller</code></p>
        </blockquote>

        <ul>
          <li><strong>사용자와 직접 상호작용</strong>하는 계층 (예: 웹 UI, API 컨트롤러)</li>
          <li>사용자의 입력을 받아 <strong>비즈니스 로직을 호출</strong>하고, 응답을 반환</li>
        </ul>
      </li>
      <li>Business Logic Layer (비즈니스 로직 계층) : 실제 회사 업무 설계 및 규칙 수립
        <blockquote>
          <p>예시: Spring Boot의 <code class="language-plaintext highlighter-rouge">Service</code></p>
        </blockquote>
        <ul>
          <li>핵심 비즈니스 로직을 처리하는 계층</li>
          <li>도메인 규칙을 적용하여 데이터 검증 및 가공 수행</li>
        </ul>
      </li>
      <li>Data Access Layer (데이터 접근 계층) : 비즈니스 레이어의 명령 실행
        <blockquote>
          <p>예시: Spring Boot의 <code class="language-plaintext highlighter-rouge">Repository</code></p>
        </blockquote>
        <ul>
          <li>데이터베이스와 직접 상호작용하는 계층</li>
          <li>DAO(Repository)를 통해 데이터를 저장하고 조회하는 역할</li>
        </ul>
      </li>
      <li>Database Layer (데이터베이스 계층) : 필요한 정보 저장 및 검색
        <ul>
          <li>실제 데이터를 저장하는 <strong>물리적 데이터베이스</strong> (MySQL, PostgreSQL 등)</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>데이터 흐름
    <ul>
      <li>요청 → 컨트롤러 → 서비스 → 레포지토리</li>
    </ul>
  </li>
  <li>사용 이유
    <ul>
      <li><strong>모듈화:</strong> 각 레이어가 독립적이라 변경 사항이 영향을 최소화</li>
      <li><strong>유지보수성:</strong> 비즈니스 로직(Service)과 DB 접근(Repository)을 분리</li>
      <li><strong>테스트 용이:</strong> 단위 테스트 작성이 쉬움 (ex: Service 레이어만 Mock 테스트 가능)</li>
    </ul>
  </li>
</ul>

<h3 id="레이어-간-관계">레이어 간 관계</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[클라이언트]
    ↓
[Presentation Layer]  →  Controller
    ↓
[Business Logic Layer]  →  Service
    ↓
[Data Access Layer]  →  Repository (DAO)
    ↓
[Database Layer]  →  DB (MySQL, PostgreSQL)
</code></pre></div></div>

<ul>
  <li>상위 계층(Presentation)은 <strong>하위 계층(Business Logic)만 호출</strong>할 수 있음.</li>
  <li>데이터베이스 관련 로직이 <strong>비즈니스 로직과 분리</strong>되어 유지보수가 쉬움.</li>
</ul>

<hr />

<h2 id="mvc란">MVC란?</h2>

<ul>
  <li>Model-View-Controller
    <ul>
      <li>Model : 요리사가 실제 음식을 준비하고 만드는 작업</li>
      <li>View : 음식의 플레이팅</li>
      <li>Controller : 고객의 주문을 받고, 요리사에게 전달하여 완성된 요리를 테이블에 서빙 (백엔드)</li>
      <li>3개의 요소가 유기적으로 협력</li>
    </ul>
  </li>
  <li>사용자 인터페이스와 비즈니스 로직 분리</li>
  <li>데이터 흐름
    <ul>
      <li>요청 → 컨트롤러 → 모델 → 뷰</li>
    </ul>
  </li>
  <li>사용 이유
    <ul>
      <li><strong>역할 분리:</strong> View, Model, Controller가 독립적으로 동작하여 유지보수 용이</li>
      <li><strong>유연한 확장:</strong> UI 변경(View)이나 비즈니스 로직(Model)을 따로 수정 가능</li>
      <li><strong>재사용성 증가:</strong> 같은 Model을 여러 View에서 사용 가능</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-03-17-image.png?raw=true" alt="Layered Architecture &amp; MVC pattern" /></p>

<h2 id="레이어드-아키텍쳐와-mvc를-함께-사용">레이어드 아키텍쳐와 MVC를 함께 사용</h2>

<ul>
  <li><strong>둘을 함께 사용하면 유지보수성과 확장성이 좋아진다.</strong>
    <ul>
      <li><strong>Controller는 최대한 가볍게 (Thin Controller, Fat Service)</strong></li>
      <li><strong>비즈니스 로직은 Service Layer에서 처리 (SRP 원칙 준수)</strong></li>
    </ul>
  </li>
</ul>

<h3 id="둘을-함께-사용했을-때-관계-흐름-요청--응답">둘을 함께 사용했을 때 관계 흐름 (요청 → 응답)</h3>

<ol>
  <li>사용자 (Client) 가 요청을 보냄</li>
  <li>Controller (입력 처리, 요청 매핑)</li>
  <li>Service (비즈니스 로직 처리)</li>
  <li>Repository (데이터베이스 접근)</li>
  <li>Service → Controller 로 응답 반환</li>
  <li>Controller → View (또는 JSON)</li>
</ol>

<ul>
  <li>MVC는 역할을 분리하고, 레이어드 아키텍처는 각 계층을 더 체계적으로 조직화하여 유지보수성과 확장성을 높인다</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[레이어드 아키텍쳐와 MVC 패턴에 대해 알아보자.]]></summary></entry><entry><title type="html">[Spring] Spring VS Servlet</title><link href="https://nan0silver.github.io/spring/2025-03-17-servlet-vs-spring/" rel="alternate" type="text/html" title="[Spring] Spring VS Servlet" /><published>2025-03-17T00:00:00+00:00</published><updated>2025-04-09T07:33:42+00:00</updated><id>https://nan0silver.github.io/spring/servlet-vs-spring</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-03-17-servlet-vs-spring/"><![CDATA[<ul>
  <li><a href="#-servlet과-spring의-차이-쉽게-이해하기">Servlet과 Spring의 차이</a></li>
  <li><a href="#servlet-직접-요청을-처리하는-원시적인-방식">Servlet</a></li>
  <li><a href="#spring-웹-개발을-쉽게-만들어주는-프레임워크">Spring</a></li>
  <li><a href="#servlet-vs-spring-비교-정리">Servlet vs Spring 비교 정리 표</a></li>
  <li><a href="#-결론-spring이-servlet보다-훨씬-편리하다">결론</a></li>
</ul>

<hr />

<h2 id="-servlet과-spring의-차이-쉽게-이해하기">🌐 <strong>Servlet과 Spring의 차이: 쉽게 이해하기</strong></h2>

<ul>
  <li>Servlet과 Spring은 <strong>Java로 웹 애플리케이션을 개발할 때 사용하는 기술</strong></li>
  <li>하지만 <strong>Servlet은 아주 기본적인 웹 기술</strong>이고, <strong>Spring은 이를 확장한 강력한 프레임워크</strong></li>
</ul>

<hr />

<h3 id="️-비유-레스토랑-운영-방식으로-이해하기">🍽️ <strong>비유: 레스토랑 운영 방식으로 이해하기</strong></h3>

<blockquote>
  <p><strong>Servlet</strong> = “직접 주문받고 요리하고 서빙하는 작은 식당”<br />
<strong>Spring</strong> = “자동 주문 시스템과 직원이 있는 대형 레스토랑”</p>
</blockquote>

<hr />

<h2 id="servlet-직접-요청을-처리하는-원시적인-방식">Servlet: 직접 요청을 처리하는 원시적인 방식</h2>

<ul>
  <li>Servlet은 <strong>웹 요청을 처리하는 가장 기본적인 방법</strong></li>
  <li>
    <p>개발자가 <strong>요청을 받고, 응답을 만들고, HTML을 직접 작성해야 함</strong>.</p>
  </li>
  <li>
    <p><strong>Servlet의 특징</strong></p>

    <ul>
      <li>✅ 웹 요청을 직접 받아서 응답을 생성함.</li>
      <li>✅ 하지만 HTML 응답을 직접 만들어야 해서 코드가 길어짐.</li>
      <li>✅ 데이터베이스 연결, 보안 등 추가 기능을 직접 구현해야 함.</li>
    </ul>
  </li>
  <li><strong>Servlet 예제 (Java 코드로 HTML 만들기)</strong></li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@WebServlet</span><span class="o">(</span><span class="s">"/hello"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloServlet</span> <span class="kd">extends</span> <span class="nc">HttpServlet</span> <span class="o">{</span>
      <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span>
              <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
          <span class="n">response</span><span class="o">.</span><span class="na">setContentType</span><span class="o">(</span><span class="s">"text/html"</span><span class="o">);</span>
          <span class="nc">PrintWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getWriter</span><span class="o">();</span>
          <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"&lt;html&gt;&lt;body&gt;"</span><span class="o">);</span>
          <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"&lt;h1&gt;Hello, Servlet!&lt;/h1&gt;"</span><span class="o">);</span>
          <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"&lt;/body&gt;&lt;/html&gt;"</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>문제점</strong>:
    <ul>
      <li>HTML을 직접 만들고 응답을 구성해야 해서 코드가 길고 불편함</li>
      <li>데이터베이스 연결이나 보안 기능을 추가하려면 개발자가 직접 구현해야 함.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="spring-웹-개발을-쉽게-만들어주는-프레임워크">Spring: 웹 개발을 쉽게 만들어주는 프레임워크</h2>

<ul>
  <li>Spring은 <strong>Servlet을 더 쉽게 사용할 수 있도록</strong> 만든 프레임워크</li>
  <li>
    <p>기본적인 요청 처리는 Servlet과 비슷하지만, Spring을 사용하면 <strong>자동화된 기능이 많아서 개발이 편리</strong>.</p>
  </li>
  <li>
    <p><strong>Spring의 특징</strong></p>

    <ul>
      <li>✅ 요청을 쉽게 처리할 수 있도록 <code class="language-plaintext highlighter-rouge">@Controller</code>와 <code class="language-plaintext highlighter-rouge">@RestController</code> 제공.</li>
      <li>✅ HTML을 직접 만들지 않고, JSON이나 템플릿을 사용해서 응답을 쉽게 생성할 수 있음.</li>
      <li>✅ 데이터베이스 연결, 보안 기능, API 호출 등을 자동으로 지원함.</li>
    </ul>
  </li>
  <li><strong>Spring 예제 (더 간단한 코드)</strong></li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@RestController</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloController</span> <span class="o">{</span>
        <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/hello"</span><span class="o">)</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">sayHello</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">"Hello, Spring!"</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="err">```</span>
<span class="err">🚀</span> <span class="o">**</span><span class="nc">Spring을</span> <span class="n">사용하면</span> <span class="nc">Servlet보다</span> <span class="n">훨씬</span> <span class="n">간결하고</span> <span class="n">직관적이다</span><span class="o">.**</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h2 id="servlet-vs-spring-비교-정리"><strong>Servlet vs Spring 비교 정리</strong></h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Servlet</th>
      <th>Spring</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>요청 처리 방식</td>
      <td>직접 요청을 받고 응답을 작성</td>
      <td><code class="language-plaintext highlighter-rouge">@Controller</code>와 <code class="language-plaintext highlighter-rouge">@RestController</code>로 간단하게 처리</td>
    </tr>
    <tr>
      <td>코드 복잡도</td>
      <td>HTML을 직접 만들어야 해서 복잡</td>
      <td>JSON이나 템플릿 사용 가능 (코드가 간결)</td>
    </tr>
    <tr>
      <td>데이터베이스 연결</td>
      <td>직접 구현해야 함</td>
      <td>JPA, MyBatis 등의 지원</td>
    </tr>
    <tr>
      <td>보안 및 인증</td>
      <td>직접 구현해야 함</td>
      <td>Spring Security 제공</td>
    </tr>
    <tr>
      <td>개발 속도</td>
      <td>설정이 많고 코드가 길다</td>
      <td>자동 설정 덕분에 개발이 빠름</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-결론-spring이-servlet보다-훨씬-편리하다">🚀 <strong>결론: Spring이 Servlet보다 훨씬 편리하다!</strong></h2>

<p>Servlet은 기본적인 웹 요청 처리를 할 수 있지만, 직접 HTML을 만들고 보안, 데이터베이스 연결 등을 다 처리해야 함.<br />
Spring은 이런 것들을 <strong>자동화</strong>해주기 때문에 개발이 훨씬 쉬워지고, 유지보수도 편하다.</p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[Spring과 Servlet의 차이 대해 알아보자.]]></summary></entry><entry><title type="html">[JAVA] 동시성 처리 (Concurrency)</title><link href="https://nan0silver.github.io/java/2025-03-09-concurrency/" rel="alternate" type="text/html" title="[JAVA] 동시성 처리 (Concurrency)" /><published>2025-03-09T00:00:00+00:00</published><updated>2025-04-09T07:33:42+00:00</updated><id>https://nan0silver.github.io/java/concurrency</id><content type="html" xml:base="https://nan0silver.github.io/java/2025-03-09-concurrency/"><![CDATA[<ul>
  <li><a href="#java에서-동시성">JAVA에서 동시성</a></li>
  <li><a href="#스레드-thread">스레드 (Thread)</a></li>
  <li><a href="#비동기-처리-async">비동기 처리 (Aysnc)</a></li>
  <li><a href="#분산-처리-distributed">분산 처리 (Distribute)</a></li>
  <li><a href="#핵심-키워드-및-정리">핵심 키워드 및 정리</a></li>
</ul>

<hr />

<h2 id="java에서-동시성">JAVA에서 동시성</h2>

<ul>
  <li>여러 작업을 동시에 겹쳐서 처리하는 것</li>
  <li>한 번에 여러 일을 수행하며 일의 효율성을 높임</li>
  <li>크게 3가지 관점에서 접근 가능하다.
    <ol>
      <li>스레드 (Thread)</li>
      <li>비동기 (Async)</li>
      <li>분산 (Distributed)</li>
    </ol>
  </li>
</ul>

<h2 id="스레드-thread">스레드 (Thread)</h2>

<ul>
  <li>스레드는 프로세스 내에서 실제 작업을 수행하는 작업 단위</li>
  <li>한 개의 프로그램(프로세스)은 여러 개의 스레드를 가질 수 있음</li>
  <li>멀티 스레드 (Multi-thread)
    <ul>
      <li>하나의 프로세스에서 여러 스레드를 동시에 실행하는 방식</li>
      <li>자바에서는 주로 JVM(Java Virtual Machine)이 여러 스레드를 관리해줌
        <ul>
          <li>ex) 웹 서버(Servlet, Spring)에서는 사용자 요청마다 별도의 스레드를 생성해서 동시에 많은 요청을 처리할 수 있게 함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>🔥 중요한 이유
    <ul>
      <li>효율성 향상
        <ul>
          <li>CPU 자원을 최대한 활용할 수 있음</li>
        </ul>
      </li>
      <li>응답성 향상
        <ul>
          <li>동시에 여러 요청을 처리할 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>하지만 최근 자바 프레임워크(Spring)는 스레드를 자동으로 관리해주기 때문에 개발자가 직접 스레드를 관리할 일이 많지 않음
    <ul>
      <li>JVM과 프레임워크가 이미 효율적으로 관리해줌</li>
    </ul>
  </li>
</ul>

<h2 id="비동기-처리-async">비동기 처리 (Async)</h2>

<ul>
  <li>비동기란 “요청을 보낸 뒤 결과를 기다리지 않고 다음 작업을 진행”하는 방식
    <ul>
      <li>동기 (Synchronous)
        <ul>
          <li>하나의 요청이 끝날 때까지 기다림</li>
        </ul>
      </li>
      <li>비동기 (Asynchronous)
        <ul>
          <li>요청이 처리되는 동안 다른 작업 수행</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>자바에서 비동기 처리를 지원하는 방법
    <ul>
      <li><code class="language-plaintext highlighter-rouge">CompletableFuture</code> : 자바 비동기 처리 클래스</li>
      <li>자바스크립트의 async/await와 비슷한 방식</li>
    </ul>
  </li>
  <li>🔥 중요한 이유
    <ul>
      <li>빠른 응답성
        <ul>
          <li>요청 처리 중에도 사용자가 대기하지 않고, 시스템의 다른 작업 수행 가능</li>
        </ul>
      </li>
      <li>높은 확장성
        <ul>
          <li>비동기 처리를 하면 서버가 많은 요청을 효율적으로 관리 가능</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="분산-처리-distributed">분산 처리 (Distributed)</h2>

<ul>
  <li>분산처리는 “하나의 서버가 아닌, 여러 대의 서버가 나누어서 작업을 처리하는 방식”
    <ul>
      <li>서버 하나만 운영하는 것부다 작은 여러 서버(클러스터)를 운영하면 비용이 줄어듬</li>
      <li>대규모 서비스나 성장한 서비스에서 자주 사용됨</li>
    </ul>
  </li>
  <li>분산 환경에서 자주 사용되는 기술
    <ul>
      <li>Redis
        <ul>
          <li>메모리 기반 데이터 저장소로, 분산락(Distributed Lock)울 구현할 때 사용</li>
          <li>예를 들어, 여러 서버가 하나의 데이터를 동시에 수정하지 못하게 관리하는 방식</li>
        </ul>
      </li>
      <li>Kafka
        <ul>
          <li>메시지 큐(Message Queue)로, 서버간 메시지를 주고받고, 작업을 순차적으로 처리할 때 사용됨</li>
        </ul>
      </li>
      <li>클러스터(Cluster)
        <ul>
          <li>여러 대의 서버가 협력하여 요청을 나누어 처리 (MSA와 비슷한 개념)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>🔥 중요한 이유
    <ul>
      <li>비용 효율성
        <ul>
          <li>큰 서버 하나보다 여러 작은 서버가 경제적</li>
        </ul>
      </li>
      <li>안정성 및 확장성
        <ul>
          <li>한 서버가 문제가 생기더라도 서비스는 계속 운영됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="핵심-키워드-및-정리">핵심 키워드 및 정리</h2>

<ol>
  <li>스레스 (Thread)</li>
</ol>

<ul>
  <li>멀티 스레드 -&gt; JVM, Servlet, Spring</li>
  <li>스레드는 직원이다. 회사(JVM, Servlet, Spring)가 직원(스레드)을 잘 관리하면, 일(요청 처리)이 효율적이다.</li>
</ul>

<ol>
  <li>비동기 (Async)</li>
</ol>

<ul>
  <li>CompletableFuture, async/await</li>
  <li>비동기는 배달앱이다. 주문을 넣고 기다리지 않고, 다음 일을 진행한다.</li>
</ul>

<ol>
  <li>분산처리 (Distributed)</li>
</ol>

<ul>
  <li>Redis, Kafka, 클러스터</li>
  <li>분산처리는 프랜차이즈이다. 큰 가게 하나보다 작은 여러 가게가 효율적이고 비용도 절감된다.</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="java" /><summary type="html"><![CDATA[동시성 처리에 관한 3가지 관점에 대해 이야기해보자.]]></summary></entry></feed>