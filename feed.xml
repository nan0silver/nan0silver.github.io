<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-06-02T08:17:18+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[TIL] first til</title><link href="https://nan0silver.github.io/til/2025-05-30-til/" rel="alternate" type="text/html" title="[TIL] first til" /><published>2025-05-30T00:00:00+00:00</published><updated>2025-06-02T08:16:34+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-30-til/"><![CDATA[]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><summary type="html"><![CDATA[2025.05.30 TIL]]></summary></entry><entry><title type="html">Jenkins vs GitHub Actions, IaaS vs PaaS vs SaaS</title><link href="https://nan0silver.github.io/git/2025-05-27-jenkins-vs-github-actions-iaas-vs-paas-vs-saas-issue-62/" rel="alternate" type="text/html" title="Jenkins vs GitHub Actions, IaaS vs PaaS vs SaaS" /><published>2025-05-27T00:00:00+00:00</published><updated>2025-05-28T00:36:49+00:00</updated><id>https://nan0silver.github.io/git/jenkins-vs-github-actions-iaas-vs-paas-vs-saas-issue-62</id><content type="html" xml:base="https://nan0silver.github.io/git/2025-05-27-jenkins-vs-github-actions-iaas-vs-paas-vs-saas-issue-62/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/62">#62</a><br />
📅 <strong>작성일</strong>: 2025-05-27<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 28일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<ul>
  <li>AI Tech 2025 : AI 융합 비즈니스 개발 컨퍼런스 후기 작성 완료!
    <ul>
      <li><a href="https://silvernh.tistory.com/3">Tistory</a></li>
    </ul>
  </li>
</ul>

<h3 id="1️⃣-jenkins-vs-github-actions">1️⃣ <strong>Jenkins vs GitHub Actions</strong></h3>

<p>둘 다 **CI/CD(지속적 통합/지속적 배포)**를 자동화하는 도구다.
개발자가 코드를 push하면 <strong>자동으로 빌드하고, 테스트하고, 배포</strong>까지 해주는 파이프라인 역할.</p>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Jenkins</th>
      <th>GitHub Actions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>배포 방식</td>
      <td>직접 서버에 설치 (온프레미스, 클라우드)</td>
      <td>GitHub 내장 서비스 (클라우드 기반)</td>
    </tr>
    <tr>
      <td>파이프라인 구성</td>
      <td>Groovy 기반 DSL (Jenkinsfile)</td>
      <td>YAML 기반 설정 (.github/workflows/)</td>
    </tr>
    <tr>
      <td>UI/플러그인</td>
      <td>수많은 플러그인과 커스터마이징 가능</td>
      <td>GitHub 생태계에 최적화된 워크플로우</td>
    </tr>
    <tr>
      <td>설정 난이도</td>
      <td>다소 복잡 (서버 관리 필요)</td>
      <td>상대적으로 간단하고 빠른 적용 가능</td>
    </tr>
    <tr>
      <td>장점</td>
      <td>유연한 환경 설정, 다양한 툴 연동 가능</td>
      <td>GitHub와 완벽하게 통합, 설정이 간단</td>
    </tr>
    <tr>
      <td>단점</td>
      <td>서버 유지보수 필요, 러닝커브 있음</td>
      <td>GitHub 내에서만 동작 (GitLab, Bitbucket X)</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>✅ GitHub Actions는 빠르게 CI/CD를 도입하고 싶은 팀에 좋고,
✅ Jenkins는 복잡한 환경이나 내부망에서의 CI/CD가 필요할 때 적합하다.</p>
</blockquote>

<p>—å</p>

<h3 id="-간단-예시--github-actions">🧪 간단 예시 – GitHub Actions</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># .github/workflows/deploy.yml</span>
<span class="na">name</span><span class="pi">:</span> <span class="s">Build and Deploy</span>

<span class="na">on</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">push</span><span class="pi">]</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>
      <span class="pi">-</span> <span class="na">run</span><span class="pi">:</span> <span class="s">./gradlew build</span>
</code></pre></div></div>

<hr />

<h3 id="2️⃣-iaas-vs-paas-vs-saas">2️⃣ <strong>IaaS vs PaaS vs SaaS</strong></h3>

<p>클라우드 서비스 모델을 구분할 때 자주 등장하는 세 가지 개념.
“내가 어디까지 책임지고, 어디서부터는 제공자가 해주는가?”가 핵심.</p>

<h4 id="-개념-요약">✅ 개념 요약</h4>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>설명</th>
      <th>예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>IaaS (Infrastructure as a Service)</td>
      <td>인프라만 제공받고, OS부터 직접 설치</td>
      <td>AWS EC2, Google Compute Engine</td>
    </tr>
    <tr>
      <td>PaaS (Platform as a Service)</td>
      <td>실행 환경까지 제공, 앱 코드만 올리면 됨</td>
      <td>Heroku, Google App Engine, Render</td>
    </tr>
    <tr>
      <td>SaaS (Software as a Service)</td>
      <td>소프트웨어 완제품 사용</td>
      <td>Gmail, Notion, Slack</td>
    </tr>
  </tbody>
</table>

<h4 id="-비교-예시">✅ 비교 예시</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>IaaS</th>
      <th>PaaS</th>
      <th>SaaS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>서버 관리</td>
      <td>내가 함</td>
      <td>클라우드가 함</td>
      <td>필요 없음</td>
    </tr>
    <tr>
      <td>개발 유연성</td>
      <td>높음</td>
      <td>중간</td>
      <td>거의 없음</td>
    </tr>
    <tr>
      <td>배포 편의성</td>
      <td>낮음 (직접 설정)</td>
      <td>높음 (코드만 배포)</td>
      <td>매우 높음 (사용만 하면 됨)</td>
    </tr>
    <tr>
      <td>대상 사용자</td>
      <td>인프라 엔지니어, DevOps</td>
      <td>백엔드 개발자</td>
      <td>일반 사용자, 마케터 등</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-요약-정리">🧠 요약 정리</h3>

<table>
  <thead>
    <tr>
      <th>질문</th>
      <th>답변</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Jenkins랑 GitHub Actions 중 뭐가 더 쉽지?</td>
      <td>GitHub Actions! 설정이 YAML이고 GitHub랑 연동이 편함</td>
    </tr>
    <tr>
      <td>IaaS는 언제 써야 해?</td>
      <td>서버에 대해 완전히 커스터마이징이 필요할 때</td>
    </tr>
    <tr>
      <td>SaaS는 어떤 거야?</td>
      <td>구글 드라이브, 노션, 슬랙처럼 바로 쓰는 서비스</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>오늘의 핵심:
✅ CI/CD 도구는 “내가 코드를 어떻게 자동화할지”에 따라 고르고,
✅ 클라우드 서비스 모델은 “어디까지 직접 관리할지”에 따라 고른다.</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="git" /><category term="TIL" /><category term="Git" /><category term="DevOps" /><summary type="html"><![CDATA[Jenkins vs GitHub Actions, IaaS vs PaaS vs SaaS에 대한 TIL 기록]]></summary></entry><entry><title type="html">Jenkins vs GitHub Actions, IaaS vs PaaS vs SaaS</title><link href="https://nan0silver.github.io/git/2025-05-27-jenkins-vs-github-actions-iaas-vs-paas-vs-saas-issue-62/" rel="alternate" type="text/html" title="Jenkins vs GitHub Actions, IaaS vs PaaS vs SaaS" /><published>2025-05-27T00:00:00+00:00</published><updated>2025-05-28T00:36:49+00:00</updated><id>https://nan0silver.github.io/git/jenkins-vs-github-actions-iaas-vs-paas-vs-saas-issue-62</id><content type="html" xml:base="https://nan0silver.github.io/git/2025-05-27-jenkins-vs-github-actions-iaas-vs-paas-vs-saas-issue-62/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/62">#62</a><br />
📅 <strong>작성일</strong>: 2025-05-27<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 28일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<ul>
  <li>AI Tech 2025 : AI 융합 비즈니스 개발 컨퍼런스 후기 작성 완료!
    <ul>
      <li><a href="https://silvernh.tistory.com/3">Tistory</a></li>
    </ul>
  </li>
</ul>

<h3 id="1️⃣-jenkins-vs-github-actions">1️⃣ <strong>Jenkins vs GitHub Actions</strong></h3>

<p>둘 다 **CI/CD(지속적 통합/지속적 배포)**를 자동화하는 도구다.
개발자가 코드를 push하면 <strong>자동으로 빌드하고, 테스트하고, 배포</strong>까지 해주는 파이프라인 역할.</p>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Jenkins</th>
      <th>GitHub Actions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>배포 방식</td>
      <td>직접 서버에 설치 (온프레미스, 클라우드)</td>
      <td>GitHub 내장 서비스 (클라우드 기반)</td>
    </tr>
    <tr>
      <td>파이프라인 구성</td>
      <td>Groovy 기반 DSL (Jenkinsfile)</td>
      <td>YAML 기반 설정 (.github/workflows/)</td>
    </tr>
    <tr>
      <td>UI/플러그인</td>
      <td>수많은 플러그인과 커스터마이징 가능</td>
      <td>GitHub 생태계에 최적화된 워크플로우</td>
    </tr>
    <tr>
      <td>설정 난이도</td>
      <td>다소 복잡 (서버 관리 필요)</td>
      <td>상대적으로 간단하고 빠른 적용 가능</td>
    </tr>
    <tr>
      <td>장점</td>
      <td>유연한 환경 설정, 다양한 툴 연동 가능</td>
      <td>GitHub와 완벽하게 통합, 설정이 간단</td>
    </tr>
    <tr>
      <td>단점</td>
      <td>서버 유지보수 필요, 러닝커브 있음</td>
      <td>GitHub 내에서만 동작 (GitLab, Bitbucket X)</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>✅ GitHub Actions는 빠르게 CI/CD를 도입하고 싶은 팀에 좋고,
✅ Jenkins는 복잡한 환경이나 내부망에서의 CI/CD가 필요할 때 적합하다.</p>
</blockquote>

<p>—å</p>

<h3 id="-간단-예시--github-actions">🧪 간단 예시 – GitHub Actions</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># .github/workflows/deploy.yml</span>
<span class="na">name</span><span class="pi">:</span> <span class="s">Build and Deploy</span>

<span class="na">on</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">push</span><span class="pi">]</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>
      <span class="pi">-</span> <span class="na">run</span><span class="pi">:</span> <span class="s">./gradlew build</span>
</code></pre></div></div>

<hr />

<h3 id="2️⃣-iaas-vs-paas-vs-saas">2️⃣ <strong>IaaS vs PaaS vs SaaS</strong></h3>

<p>클라우드 서비스 모델을 구분할 때 자주 등장하는 세 가지 개념.
“내가 어디까지 책임지고, 어디서부터는 제공자가 해주는가?”가 핵심.</p>

<h4 id="-개념-요약">✅ 개념 요약</h4>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>설명</th>
      <th>예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>IaaS (Infrastructure as a Service)</td>
      <td>인프라만 제공받고, OS부터 직접 설치</td>
      <td>AWS EC2, Google Compute Engine</td>
    </tr>
    <tr>
      <td>PaaS (Platform as a Service)</td>
      <td>실행 환경까지 제공, 앱 코드만 올리면 됨</td>
      <td>Heroku, Google App Engine, Render</td>
    </tr>
    <tr>
      <td>SaaS (Software as a Service)</td>
      <td>소프트웨어 완제품 사용</td>
      <td>Gmail, Notion, Slack</td>
    </tr>
  </tbody>
</table>

<h4 id="-비교-예시">✅ 비교 예시</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>IaaS</th>
      <th>PaaS</th>
      <th>SaaS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>서버 관리</td>
      <td>내가 함</td>
      <td>클라우드가 함</td>
      <td>필요 없음</td>
    </tr>
    <tr>
      <td>개발 유연성</td>
      <td>높음</td>
      <td>중간</td>
      <td>거의 없음</td>
    </tr>
    <tr>
      <td>배포 편의성</td>
      <td>낮음 (직접 설정)</td>
      <td>높음 (코드만 배포)</td>
      <td>매우 높음 (사용만 하면 됨)</td>
    </tr>
    <tr>
      <td>대상 사용자</td>
      <td>인프라 엔지니어, DevOps</td>
      <td>백엔드 개발자</td>
      <td>일반 사용자, 마케터 등</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-요약-정리">🧠 요약 정리</h3>

<table>
  <thead>
    <tr>
      <th>질문</th>
      <th>답변</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Jenkins랑 GitHub Actions 중 뭐가 더 쉽지?</td>
      <td>GitHub Actions! 설정이 YAML이고 GitHub랑 연동이 편함</td>
    </tr>
    <tr>
      <td>IaaS는 언제 써야 해?</td>
      <td>서버에 대해 완전히 커스터마이징이 필요할 때</td>
    </tr>
    <tr>
      <td>SaaS는 어떤 거야?</td>
      <td>구글 드라이브, 노션, 슬랙처럼 바로 쓰는 서비스</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>오늘의 핵심:
✅ CI/CD 도구는 “내가 코드를 어떻게 자동화할지”에 따라 고르고,
✅ 클라우드 서비스 모델은 “어디까지 직접 관리할지”에 따라 고른다.</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="git" /><category term="TIL" /><category term="Git" /><category term="DevOps" /><summary type="html"><![CDATA[Jenkins vs GitHub Actions, IaaS vs PaaS vs SaaS에 대한 TIL 기록]]></summary></entry><entry><title type="html">Nginx, 리버스 프록시, 로드 밸런서</title><link href="https://nan0silver.github.io/miscellaneous/2025-05-24-nginx-%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C-issue-61/" rel="alternate" type="text/html" title="Nginx, 리버스 프록시, 로드 밸런서" /><published>2025-05-24T00:00:00+00:00</published><updated>2025-05-27T05:35:43+00:00</updated><id>https://nan0silver.github.io/miscellaneous/nginx-%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C-issue-61</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-05-24-nginx-%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C-issue-61/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/61">#61</a><br />
📅 <strong>작성일</strong>: 2025-05-24<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-nginx란">1️⃣ <strong>Nginx란?</strong></h3>

<ul>
  <li>**Nginx(엔진엑스)**는 고성능 웹 서버 소프트웨어다.</li>
  <li>원래는 정적 콘텐츠 제공을 위한 웹 서버였지만, 현재는 <strong>리버스 프록시</strong>, <strong>로드 밸런서</strong>, <strong>API Gateway</strong>, <strong>캐시 서버</strong> 등 다용도로 활용된다.</li>
</ul>

<hr />

<h3 id="-nginx의-주요-기능">✅ Nginx의 주요 기능</h3>

<table>
  <thead>
    <tr>
      <th>기능</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>웹 서버</td>
      <td>HTML, CSS, JS 같은 <strong>정적 파일 제공</strong></td>
    </tr>
    <tr>
      <td>리버스 프록시</td>
      <td>클라이언트 요청을 <strong>내부 서버에 전달</strong></td>
    </tr>
    <tr>
      <td>로드 밸런서</td>
      <td>여러 서버에 트래픽을 <strong>분산</strong>하여 처리</td>
    </tr>
    <tr>
      <td>캐시 서버</td>
      <td>응답을 <strong>캐싱</strong>해 성능 향상</td>
    </tr>
    <tr>
      <td>SSL 종단 처리</td>
      <td>HTTPS 인증서 처리 (Let’s Encrypt 등과 연동)</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-리버스-프록시란">🔄 리버스 프록시란?</h3>

<ul>
  <li>클라이언트는 Nginx에 요청을 보내고, Nginx는 **백엔드 서버(Apache, Spring, Node 등)**에 요청을 전달한 후 응답을 다시 클라이언트에 전송한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Client] → [Nginx] → [Spring Server]
</code></pre></div></div>

<ul>
  <li>보안, 로드 밸런싱, 서버 분리 등 다양한 이유로 활용됨</li>
</ul>

<hr />

<h3 id="️-로드-밸런서">⚖️ 로드 밸런서</h3>

<ul>
  <li>요청을 <strong>여러 서버에 고르게 분산</strong>시켜 트래픽 집중을 막고 <strong>가용성</strong>을 높임</li>
</ul>

<h4 id="nginx에서-로드-밸런싱-구성-예시">Nginx에서 로드 밸런싱 구성 예시:</h4>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">upstream</span> <span class="s">backend</span> <span class="p">{</span>
    <span class="kn">server</span> <span class="s">backend1.example.com</span><span class="p">;</span>
    <span class="kn">server</span> <span class="s">backend2.example.com</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://backend</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">upstream</code> 블록을 통해 백엔드 서버를 그룹핑하고, Nginx가 자동으로 라운드로빈 방식으로 분산 처리</p>
</blockquote>

<hr />

<h3 id="-정적-파일-서버로의-활용">📦 정적 파일 서버로의 활용</h3>

<ul>
  <li>HTML/CSS/JS 파일을 빠르게 서빙할 수 있음</li>
  <li>WAS(Spring, Node 등)에서 정적 리소스를 분리하면 서버 부하를 줄일 수 있음</li>
</ul>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">root</span> <span class="n">/usr/share/nginx/html</span><span class="p">;</span>
        <span class="kn">index</span> <span class="s">index.html</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="-https-설정">🔒 HTTPS 설정</h3>

<ul>
  <li>Let’s Encrypt와 Certbot을 이용해 무료 SSL 인증서 발급 가능</li>
  <li>HTTPS로 종단 보안(SSL Termination)을 적용하여 <strong>보안 강화</strong></li>
</ul>

<hr />

<h2 id="-함께-알아두면-좋은-심화-키워드">🧠 함께 알아두면 좋은 심화 키워드</h2>

<table>
  <thead>
    <tr>
      <th>키워드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>리버스 프록시</td>
      <td>Nginx가 중간에 서서 내부 서버 대신 요청 응답 처리</td>
    </tr>
    <tr>
      <td>포워드 프록시</td>
      <td>사용자의 요청을 <strong>외부로 보낼 때</strong> 중개하는 프록시</td>
    </tr>
    <tr>
      <td>CDN (Content Delivery Network)</td>
      <td>정적 리소스를 전 세계에 분산 저장하여 빠르게 전송</td>
    </tr>
    <tr>
      <td>캐싱 정책</td>
      <td><code class="language-plaintext highlighter-rouge">Cache-Control</code>, <code class="language-plaintext highlighter-rouge">ETag</code>를 이용한 정적 자원 캐싱</td>
    </tr>
    <tr>
      <td>Blue-Green Deployment</td>
      <td>Nginx로 배포 서버를 스위칭하여 무중단 배포 실현</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="️-오늘의-요약">✍️ 오늘의 요약</h2>

<ul>
  <li>Nginx는 단순 웹 서버 그 이상으로, <strong>프론트와 백엔드 사이의 허브 역할</strong>을 한다.</li>
  <li>리버스 프록시, 로드 밸런서, 정적 파일 서버, SSL 처리까지 담당할 수 있는 멀티플레이어</li>
  <li>실제 운영 환경에서는 <strong>Spring Boot와 Nginx 연동</strong>, <strong>HTTPS 적용</strong>, <strong>EC2 배포 시 로드밸런싱 구성</strong> 등을 할 수 있도록 익숙해져야 한다</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><category term="TIL" /><summary type="html"><![CDATA[Nginx, 리버스 프록시, 로드 밸런서에 대한 TIL 기록]]></summary></entry><entry><title type="html">Nginx, 리버스 프록시, 로드 밸런서</title><link href="https://nan0silver.github.io/miscellaneous/2025-05-24-nginx-%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C-issue-61/" rel="alternate" type="text/html" title="Nginx, 리버스 프록시, 로드 밸런서" /><published>2025-05-24T00:00:00+00:00</published><updated>2025-05-27T05:35:43+00:00</updated><id>https://nan0silver.github.io/miscellaneous/nginx-%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C-issue-61</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-05-24-nginx-%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C-issue-61/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/61">#61</a><br />
📅 <strong>작성일</strong>: 2025-05-24<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-nginx란">1️⃣ <strong>Nginx란?</strong></h3>

<ul>
  <li>**Nginx(엔진엑스)**는 고성능 웹 서버 소프트웨어다.</li>
  <li>원래는 정적 콘텐츠 제공을 위한 웹 서버였지만, 현재는 <strong>리버스 프록시</strong>, <strong>로드 밸런서</strong>, <strong>API Gateway</strong>, <strong>캐시 서버</strong> 등 다용도로 활용된다.</li>
</ul>

<hr />

<h3 id="-nginx의-주요-기능">✅ Nginx의 주요 기능</h3>

<table>
  <thead>
    <tr>
      <th>기능</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>웹 서버</td>
      <td>HTML, CSS, JS 같은 <strong>정적 파일 제공</strong></td>
    </tr>
    <tr>
      <td>리버스 프록시</td>
      <td>클라이언트 요청을 <strong>내부 서버에 전달</strong></td>
    </tr>
    <tr>
      <td>로드 밸런서</td>
      <td>여러 서버에 트래픽을 <strong>분산</strong>하여 처리</td>
    </tr>
    <tr>
      <td>캐시 서버</td>
      <td>응답을 <strong>캐싱</strong>해 성능 향상</td>
    </tr>
    <tr>
      <td>SSL 종단 처리</td>
      <td>HTTPS 인증서 처리 (Let’s Encrypt 등과 연동)</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-리버스-프록시란">🔄 리버스 프록시란?</h3>

<ul>
  <li>클라이언트는 Nginx에 요청을 보내고, Nginx는 **백엔드 서버(Apache, Spring, Node 등)**에 요청을 전달한 후 응답을 다시 클라이언트에 전송한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Client] → [Nginx] → [Spring Server]
</code></pre></div></div>

<ul>
  <li>보안, 로드 밸런싱, 서버 분리 등 다양한 이유로 활용됨</li>
</ul>

<hr />

<h3 id="️-로드-밸런서">⚖️ 로드 밸런서</h3>

<ul>
  <li>요청을 <strong>여러 서버에 고르게 분산</strong>시켜 트래픽 집중을 막고 <strong>가용성</strong>을 높임</li>
</ul>

<h4 id="nginx에서-로드-밸런싱-구성-예시">Nginx에서 로드 밸런싱 구성 예시:</h4>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">upstream</span> <span class="s">backend</span> <span class="p">{</span>
    <span class="kn">server</span> <span class="s">backend1.example.com</span><span class="p">;</span>
    <span class="kn">server</span> <span class="s">backend2.example.com</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://backend</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">upstream</code> 블록을 통해 백엔드 서버를 그룹핑하고, Nginx가 자동으로 라운드로빈 방식으로 분산 처리</p>
</blockquote>

<hr />

<h3 id="-정적-파일-서버로의-활용">📦 정적 파일 서버로의 활용</h3>

<ul>
  <li>HTML/CSS/JS 파일을 빠르게 서빙할 수 있음</li>
  <li>WAS(Spring, Node 등)에서 정적 리소스를 분리하면 서버 부하를 줄일 수 있음</li>
</ul>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">root</span> <span class="n">/usr/share/nginx/html</span><span class="p">;</span>
        <span class="kn">index</span> <span class="s">index.html</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="-https-설정">🔒 HTTPS 설정</h3>

<ul>
  <li>Let’s Encrypt와 Certbot을 이용해 무료 SSL 인증서 발급 가능</li>
  <li>HTTPS로 종단 보안(SSL Termination)을 적용하여 <strong>보안 강화</strong></li>
</ul>

<hr />

<h2 id="-함께-알아두면-좋은-심화-키워드">🧠 함께 알아두면 좋은 심화 키워드</h2>

<table>
  <thead>
    <tr>
      <th>키워드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>리버스 프록시</td>
      <td>Nginx가 중간에 서서 내부 서버 대신 요청 응답 처리</td>
    </tr>
    <tr>
      <td>포워드 프록시</td>
      <td>사용자의 요청을 <strong>외부로 보낼 때</strong> 중개하는 프록시</td>
    </tr>
    <tr>
      <td>CDN (Content Delivery Network)</td>
      <td>정적 리소스를 전 세계에 분산 저장하여 빠르게 전송</td>
    </tr>
    <tr>
      <td>캐싱 정책</td>
      <td><code class="language-plaintext highlighter-rouge">Cache-Control</code>, <code class="language-plaintext highlighter-rouge">ETag</code>를 이용한 정적 자원 캐싱</td>
    </tr>
    <tr>
      <td>Blue-Green Deployment</td>
      <td>Nginx로 배포 서버를 스위칭하여 무중단 배포 실현</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="️-오늘의-요약">✍️ 오늘의 요약</h2>

<ul>
  <li>Nginx는 단순 웹 서버 그 이상으로, <strong>프론트와 백엔드 사이의 허브 역할</strong>을 한다.</li>
  <li>리버스 프록시, 로드 밸런서, 정적 파일 서버, SSL 처리까지 담당할 수 있는 멀티플레이어</li>
  <li>실제 운영 환경에서는 <strong>Spring Boot와 Nginx 연동</strong>, <strong>HTTPS 적용</strong>, <strong>EC2 배포 시 로드밸런싱 구성</strong> 등을 할 수 있도록 익숙해져야 한다</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><category term="TIL" /><summary type="html"><![CDATA[Nginx, 리버스 프록시, 로드 밸런서에 대한 TIL 기록]]></summary></entry><entry><title type="html">Grafana &amp;amp; Prometheus, Rolling Policy, 시계열 메트릭</title><link href="https://nan0silver.github.io/miscellaneous/2025-05-23-grafana-prometheus-rolling-policy-%EC%8B%9C%EA%B3%84%EC%97%B4-%EB%A9%94%ED%8A%B8%EB%A6%AD-issue-60/" rel="alternate" type="text/html" title="Grafana &amp;amp; Prometheus, Rolling Policy, 시계열 메트릭" /><published>2025-05-23T00:00:00+00:00</published><updated>2025-05-27T05:34:31+00:00</updated><id>https://nan0silver.github.io/miscellaneous/grafana-prometheus-rolling-policy-%EC%8B%9C%EA%B3%84%EC%97%B4-%EB%A9%94%ED%8A%B8%EB%A6%AD-issue-60</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-05-23-grafana-prometheus-rolling-policy-%EC%8B%9C%EA%B3%84%EC%97%B4-%EB%A9%94%ED%8A%B8%EB%A6%AD-issue-60/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/60">#60</a><br />
📅 <strong>작성일</strong>: 2025-05-23<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-grafana--prometheus--시계열-메트릭-시각화-도구">1️⃣ <strong>Grafana &amp; Prometheus – 시계열 메트릭 시각화 도구</strong></h3>

<h4 id="-prometheus">📊 Prometheus</h4>

<ul>
  <li>CNCF(Cloud Native Computing Foundation)에서 관리하는 <strong>시계열 메트릭 수집 도구</strong></li>
  <li>주로 <strong>인프라/애플리케이션 성능 모니터링</strong>에 사용됨</li>
  <li><strong>Pull 방식</strong>으로 타겟 서버의 메트릭을 주기적으로 수집함</li>
  <li>메트릭 쿼리 언어: <strong>PromQL</strong></li>
  <li>내장된 시계열 DB에 메트릭 저장</li>
</ul>

<blockquote>
  <p>예시 메트릭:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http_requests_total{method="GET", status="200"} 1523
cpu_usage_seconds_total{core="1"} 82.3
</code></pre></div></div>

<h4 id="-grafana">📈 Grafana</h4>

<ul>
  <li><strong>Prometheus 등의 시계열 데이터 소스를 시각화하는 대시보드 도구</strong></li>
  <li>사용자가 커스터마이징 가능한 <strong>대시보드/그래프/알람</strong>을 만들 수 있음</li>
  <li>Prometheus 외에도 <strong>Loki(로그), InfluxDB, MySQL, Elasticsearch 등 다양한 소스</strong>와 연동 가능</li>
  <li>
    <p>주요 사용 예:</p>

    <ul>
      <li>CPU/메모리/디스크 사용률 실시간 모니터링</li>
      <li>서비스 요청 응답 시간 추적</li>
      <li>메트릭 기반 알림 설정 (ex. 5분간 에러율이 5% 넘으면 슬랙 알림)</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="-grafana--prometheus--devops-핵심-콤보">🧩 Grafana + Prometheus = DevOps 핵심 콤보</h3>

<table>
  <thead>
    <tr>
      <th>도구</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Prometheus</td>
      <td>메트릭 수집 및 저장</td>
    </tr>
    <tr>
      <td>Grafana</td>
      <td>메트릭 시각화 및 알람</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>두 도구는 함께 사용할 때 진가를 발휘한다.
Prometheus가 메트릭 데이터를 모으고, Grafana가 이를 시각적으로 표현해준다.</p>
</blockquote>

<hr />

<h3 id="2️⃣-rolling-policy-로그-롤링-정책">2️⃣ <strong>Rolling Policy (로그 롤링 정책)</strong></h3>

<h4 id="-개념">🧾 개념</h4>

<ul>
  <li>로그 파일이 커지거나 오래되었을 때, <strong>자동으로 새로운 파일로 교체하거나 백업</strong>하는 정책</li>
  <li>로그 관리를 자동화해서 디스크 과부하를 방지하고, 오래된 로그를 보관하거나 삭제할 수 있게 해줌</li>
</ul>

<h4 id="-적용-예--logback-springxml-예시">📁 적용 예 – <code class="language-plaintext highlighter-rouge">logback-spring.xml</code> 예시:</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;rollingPolicy</span> <span class="na">class=</span><span class="s">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;fileNamePattern&gt;</span>logs/app-%d{yyyy-MM-dd}.log<span class="nt">&lt;/fileNamePattern&gt;</span>
    <span class="nt">&lt;maxHistory&gt;</span>30<span class="nt">&lt;/maxHistory&gt;</span> <span class="c">&lt;!-- 30일간 보관 --&gt;</span>
<span class="nt">&lt;/rollingPolicy&gt;</span>
</code></pre></div></div>

<h4 id="️-주요-타입">🎛️ 주요 타입</h4>

<table>
  <thead>
    <tr>
      <th>정책 유형</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TimeBasedRollingPolicy</td>
      <td>날짜별로 로그 파일 분리 (<code class="language-plaintext highlighter-rouge">app-2025-05-14.log</code>)</td>
    </tr>
    <tr>
      <td>SizeBasedTriggeringPolicy</td>
      <td>특정 크기 초과 시 새로운 파일 생성 (<code class="language-plaintext highlighter-rouge">app.log.1</code>, <code class="language-plaintext highlighter-rouge">.2</code>…)</td>
    </tr>
    <tr>
      <td>FixedWindowRollingPolicy</td>
      <td>번호 기반 순환 롤링 (<code class="language-plaintext highlighter-rouge">app.1.log</code>, <code class="language-plaintext highlighter-rouge">app.2.log</code>)</td>
    </tr>
  </tbody>
</table>

<h4 id="-왜-중요한가">🚧 왜 중요한가?</h4>

<ul>
  <li>로그 파일이 무한히 커지지 않도록 제어</li>
  <li>백업 및 운영에 필요한 로그만 유지 가능</li>
  <li>ELK/EFK 스택과 연동할 때도 파일 기반 로그를 안정적으로 관리</li>
</ul>

<blockquote>
  <p>정리하자면, **“로그를 무한정 쌓지 말고, 잘라서 보관하고, 오래된 건 지우자!”**는 개념이다.</p>
</blockquote>

<hr />

<h3 id="-오늘의-요약">📌 오늘의 요약</h3>

<table>
  <thead>
    <tr>
      <th>개념</th>
      <th>핵심 기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Prometheus</td>
      <td>메트릭 수집 및 저장 (시계열 DB)</td>
    </tr>
    <tr>
      <td>Grafana</td>
      <td>메트릭 시각화 및 알림</td>
    </tr>
    <tr>
      <td>Rolling Policy</td>
      <td>로그 용량/시간 기준 자동 분할 및 관리</td>
    </tr>
  </tbody>
</table>

<h3 id="3️⃣--시계열-메트릭time-series-metrics이란">3️⃣ 🕐 시계열 메트릭(Time Series Metrics)이란?</h3>

<ul>
  <li><strong>시간(Time)</strong> + <strong>값(Value)</strong> 이 쌍으로 구성된 데이터</li>
  <li>특정 지표가 <strong>시간에 따라 어떻게 변하는지</strong>를 보여줌</li>
</ul>

<h4 id="-예시">📊 예시:</h4>

<table>
  <thead>
    <tr>
      <th>시간</th>
      <th>CPU 사용률 (%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2025-05-14 10:00:00</td>
      <td>30</td>
    </tr>
    <tr>
      <td>2025-05-14 10:01:00</td>
      <td>35</td>
    </tr>
    <tr>
      <td>2025-05-14 10:02:00</td>
      <td>70</td>
    </tr>
  </tbody>
</table>

<p>이처럼 “시간에 따른 수치 변화”를 기록한 데이터가 바로 <strong>시계열 메트릭</strong></p>

<hr />

<h4 id="-시계열-메트릭-수집-도구란">📦 시계열 메트릭 수집 도구란?</h4>

<blockquote>
  <p>이런 <strong>시간 기반 데이터</strong>를 <strong>자동으로 수집, 저장, 관리</strong>해주는 도구를 말합니다.</p>
</blockquote>

<ul>
  <li>대표적인 도구:
    <ul>
      <li><strong>Prometheus</strong></li>
      <li>InfluxDB</li>
      <li>Graphite</li>
      <li>OpenTSDB</li>
    </ul>
  </li>
</ul>

<p>이들은 서버나 애플리케이션에서 CPU, 메모리, 요청 수, 에러율 같은 수치를 <strong>주기적으로 수집</strong>해서 시계열 DB에 저장한다.</p>

<h4 id="️-예를-들어-prometheus는">🛠️ 예를 들어 Prometheus는?</h4>

<ul>
  <li>15초마다 모든 서버의 CPU 사용률, HTTP 요청 수 등을 수집</li>
  <li>내부에 <strong>시계열 전용 데이터베이스</strong>를 가지고 있어 시간 순서대로 저장</li>
  <li>나중에 Grafana 같은 도구로 꺾은선 그래프를 그릴 수 있음</li>
</ul>

<h4 id="-정리">📌 정리</h4>

<table>
  <thead>
    <tr>
      <th>용어</th>
      <th>의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>시계열 데이터</td>
      <td>시간에 따라 변화하는 수치 데이터 (예: CPU 70% → 50%)</td>
    </tr>
    <tr>
      <td>시계열 메트릭 도구</td>
      <td>시간 기반 데이터를 주기적으로 수집/저장하는 시스템</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>시계열 메트릭 도구는 결국 **“시간의 흐름에 따라 시스템이 어떻게 작동하고 있는지 보여주는 도구”**</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><category term="TIL" /><summary type="html"><![CDATA[Grafana & Prometheus, Rolling Policy, 시계열 메트릭에 대한 TIL 기록]]></summary></entry><entry><title type="html">Grafana &amp;amp; Prometheus, Rolling Policy, 시계열 메트릭</title><link href="https://nan0silver.github.io/miscellaneous/2025-05-23-grafana-prometheus-rolling-policy-%EC%8B%9C%EA%B3%84%EC%97%B4-%EB%A9%94%ED%8A%B8%EB%A6%AD-issue-60/" rel="alternate" type="text/html" title="Grafana &amp;amp; Prometheus, Rolling Policy, 시계열 메트릭" /><published>2025-05-23T00:00:00+00:00</published><updated>2025-05-27T05:34:31+00:00</updated><id>https://nan0silver.github.io/miscellaneous/grafana-prometheus-rolling-policy-%EC%8B%9C%EA%B3%84%EC%97%B4-%EB%A9%94%ED%8A%B8%EB%A6%AD-issue-60</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-05-23-grafana-prometheus-rolling-policy-%EC%8B%9C%EA%B3%84%EC%97%B4-%EB%A9%94%ED%8A%B8%EB%A6%AD-issue-60/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/60">#60</a><br />
📅 <strong>작성일</strong>: 2025-05-23<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-grafana--prometheus--시계열-메트릭-시각화-도구">1️⃣ <strong>Grafana &amp; Prometheus – 시계열 메트릭 시각화 도구</strong></h3>

<h4 id="-prometheus">📊 Prometheus</h4>

<ul>
  <li>CNCF(Cloud Native Computing Foundation)에서 관리하는 <strong>시계열 메트릭 수집 도구</strong></li>
  <li>주로 <strong>인프라/애플리케이션 성능 모니터링</strong>에 사용됨</li>
  <li><strong>Pull 방식</strong>으로 타겟 서버의 메트릭을 주기적으로 수집함</li>
  <li>메트릭 쿼리 언어: <strong>PromQL</strong></li>
  <li>내장된 시계열 DB에 메트릭 저장</li>
</ul>

<blockquote>
  <p>예시 메트릭:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http_requests_total{method="GET", status="200"} 1523
cpu_usage_seconds_total{core="1"} 82.3
</code></pre></div></div>

<h4 id="-grafana">📈 Grafana</h4>

<ul>
  <li><strong>Prometheus 등의 시계열 데이터 소스를 시각화하는 대시보드 도구</strong></li>
  <li>사용자가 커스터마이징 가능한 <strong>대시보드/그래프/알람</strong>을 만들 수 있음</li>
  <li>Prometheus 외에도 <strong>Loki(로그), InfluxDB, MySQL, Elasticsearch 등 다양한 소스</strong>와 연동 가능</li>
  <li>
    <p>주요 사용 예:</p>

    <ul>
      <li>CPU/메모리/디스크 사용률 실시간 모니터링</li>
      <li>서비스 요청 응답 시간 추적</li>
      <li>메트릭 기반 알림 설정 (ex. 5분간 에러율이 5% 넘으면 슬랙 알림)</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="-grafana--prometheus--devops-핵심-콤보">🧩 Grafana + Prometheus = DevOps 핵심 콤보</h3>

<table>
  <thead>
    <tr>
      <th>도구</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Prometheus</td>
      <td>메트릭 수집 및 저장</td>
    </tr>
    <tr>
      <td>Grafana</td>
      <td>메트릭 시각화 및 알람</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>두 도구는 함께 사용할 때 진가를 발휘한다.
Prometheus가 메트릭 데이터를 모으고, Grafana가 이를 시각적으로 표현해준다.</p>
</blockquote>

<hr />

<h3 id="2️⃣-rolling-policy-로그-롤링-정책">2️⃣ <strong>Rolling Policy (로그 롤링 정책)</strong></h3>

<h4 id="-개념">🧾 개념</h4>

<ul>
  <li>로그 파일이 커지거나 오래되었을 때, <strong>자동으로 새로운 파일로 교체하거나 백업</strong>하는 정책</li>
  <li>로그 관리를 자동화해서 디스크 과부하를 방지하고, 오래된 로그를 보관하거나 삭제할 수 있게 해줌</li>
</ul>

<h4 id="-적용-예--logback-springxml-예시">📁 적용 예 – <code class="language-plaintext highlighter-rouge">logback-spring.xml</code> 예시:</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;rollingPolicy</span> <span class="na">class=</span><span class="s">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;fileNamePattern&gt;</span>logs/app-%d{yyyy-MM-dd}.log<span class="nt">&lt;/fileNamePattern&gt;</span>
    <span class="nt">&lt;maxHistory&gt;</span>30<span class="nt">&lt;/maxHistory&gt;</span> <span class="c">&lt;!-- 30일간 보관 --&gt;</span>
<span class="nt">&lt;/rollingPolicy&gt;</span>
</code></pre></div></div>

<h4 id="️-주요-타입">🎛️ 주요 타입</h4>

<table>
  <thead>
    <tr>
      <th>정책 유형</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TimeBasedRollingPolicy</td>
      <td>날짜별로 로그 파일 분리 (<code class="language-plaintext highlighter-rouge">app-2025-05-14.log</code>)</td>
    </tr>
    <tr>
      <td>SizeBasedTriggeringPolicy</td>
      <td>특정 크기 초과 시 새로운 파일 생성 (<code class="language-plaintext highlighter-rouge">app.log.1</code>, <code class="language-plaintext highlighter-rouge">.2</code>…)</td>
    </tr>
    <tr>
      <td>FixedWindowRollingPolicy</td>
      <td>번호 기반 순환 롤링 (<code class="language-plaintext highlighter-rouge">app.1.log</code>, <code class="language-plaintext highlighter-rouge">app.2.log</code>)</td>
    </tr>
  </tbody>
</table>

<h4 id="-왜-중요한가">🚧 왜 중요한가?</h4>

<ul>
  <li>로그 파일이 무한히 커지지 않도록 제어</li>
  <li>백업 및 운영에 필요한 로그만 유지 가능</li>
  <li>ELK/EFK 스택과 연동할 때도 파일 기반 로그를 안정적으로 관리</li>
</ul>

<blockquote>
  <p>정리하자면, **“로그를 무한정 쌓지 말고, 잘라서 보관하고, 오래된 건 지우자!”**는 개념이다.</p>
</blockquote>

<hr />

<h3 id="-오늘의-요약">📌 오늘의 요약</h3>

<table>
  <thead>
    <tr>
      <th>개념</th>
      <th>핵심 기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Prometheus</td>
      <td>메트릭 수집 및 저장 (시계열 DB)</td>
    </tr>
    <tr>
      <td>Grafana</td>
      <td>메트릭 시각화 및 알림</td>
    </tr>
    <tr>
      <td>Rolling Policy</td>
      <td>로그 용량/시간 기준 자동 분할 및 관리</td>
    </tr>
  </tbody>
</table>

<h3 id="3️⃣--시계열-메트릭time-series-metrics이란">3️⃣ 🕐 시계열 메트릭(Time Series Metrics)이란?</h3>

<ul>
  <li><strong>시간(Time)</strong> + <strong>값(Value)</strong> 이 쌍으로 구성된 데이터</li>
  <li>특정 지표가 <strong>시간에 따라 어떻게 변하는지</strong>를 보여줌</li>
</ul>

<h4 id="-예시">📊 예시:</h4>

<table>
  <thead>
    <tr>
      <th>시간</th>
      <th>CPU 사용률 (%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2025-05-14 10:00:00</td>
      <td>30</td>
    </tr>
    <tr>
      <td>2025-05-14 10:01:00</td>
      <td>35</td>
    </tr>
    <tr>
      <td>2025-05-14 10:02:00</td>
      <td>70</td>
    </tr>
  </tbody>
</table>

<p>이처럼 “시간에 따른 수치 변화”를 기록한 데이터가 바로 <strong>시계열 메트릭</strong></p>

<hr />

<h4 id="-시계열-메트릭-수집-도구란">📦 시계열 메트릭 수집 도구란?</h4>

<blockquote>
  <p>이런 <strong>시간 기반 데이터</strong>를 <strong>자동으로 수집, 저장, 관리</strong>해주는 도구를 말합니다.</p>
</blockquote>

<ul>
  <li>대표적인 도구:
    <ul>
      <li><strong>Prometheus</strong></li>
      <li>InfluxDB</li>
      <li>Graphite</li>
      <li>OpenTSDB</li>
    </ul>
  </li>
</ul>

<p>이들은 서버나 애플리케이션에서 CPU, 메모리, 요청 수, 에러율 같은 수치를 <strong>주기적으로 수집</strong>해서 시계열 DB에 저장한다.</p>

<h4 id="️-예를-들어-prometheus는">🛠️ 예를 들어 Prometheus는?</h4>

<ul>
  <li>15초마다 모든 서버의 CPU 사용률, HTTP 요청 수 등을 수집</li>
  <li>내부에 <strong>시계열 전용 데이터베이스</strong>를 가지고 있어 시간 순서대로 저장</li>
  <li>나중에 Grafana 같은 도구로 꺾은선 그래프를 그릴 수 있음</li>
</ul>

<h4 id="-정리">📌 정리</h4>

<table>
  <thead>
    <tr>
      <th>용어</th>
      <th>의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>시계열 데이터</td>
      <td>시간에 따라 변화하는 수치 데이터 (예: CPU 70% → 50%)</td>
    </tr>
    <tr>
      <td>시계열 메트릭 도구</td>
      <td>시간 기반 데이터를 주기적으로 수집/저장하는 시스템</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>시계열 메트릭 도구는 결국 **“시간의 흐름에 따라 시스템이 어떻게 작동하고 있는지 보여주는 도구”**</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><category term="TIL" /><summary type="html"><![CDATA[Grafana & Prometheus, Rolling Policy, 시계열 메트릭에 대한 TIL 기록]]></summary></entry><entry><title type="html">메테리얼 디자인 vs 쿠퍼티노 디자인, Log vs Metrics, Structured Logging, ELK vs EFK 스택</title><link href="https://nan0silver.github.io/miscellaneous/2025-05-22-%EB%A9%94%ED%85%8C%EB%A6%AC%EC%96%BC-%EB%94%94%EC%9E%90%EC%9D%B8-vs-%EC%BF%A0%ED%8D%BC%ED%8B%B0%EB%85%B8-%EB%94%94%EC%9E%90%EC%9D%B8-log-vs-metrics-structured-log-issue-59/" rel="alternate" type="text/html" title="메테리얼 디자인 vs 쿠퍼티노 디자인, Log vs Metrics, Structured Logging, ELK vs EFK 스택" /><published>2025-05-22T00:00:00+00:00</published><updated>2025-05-27T03:54:57+00:00</updated><id>https://nan0silver.github.io/miscellaneous/%EB%A9%94%ED%85%8C%EB%A6%AC%EC%96%BC-%EB%94%94%EC%9E%90%EC%9D%B8-vs-%EC%BF%A0%ED%8D%BC%ED%8B%B0%EB%85%B8-%EB%94%94%EC%9E%90%EC%9D%B8-log-vs-metrics-structured-log-issue-59</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-05-22-%EB%A9%94%ED%85%8C%EB%A6%AC%EC%96%BC-%EB%94%94%EC%9E%90%EC%9D%B8-vs-%EC%BF%A0%ED%8D%BC%ED%8B%B0%EB%85%B8-%EB%94%94%EC%9E%90%EC%9D%B8-log-vs-metrics-structured-log-issue-59/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/59">#59</a><br />
📅 <strong>작성일</strong>: 2025-05-22<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-메테리얼-디자인material-design-vs-쿠퍼티노-디자인cupertino-design">1️⃣ <strong>메테리얼 디자인(Material Design) vs 쿠퍼티노 디자인(Cupertino Design)</strong></h3>

<h4 id="-메테리얼-디자인-material-design">🎨 메테리얼 디자인 (Material Design)</h4>

<ul>
  <li>Google에서 만든 디자인 시스템</li>
  <li>Android 앱에서 기본적으로 사용되는 UI 가이드라인</li>
  <li>
    <p>특징:</p>

    <ul>
      <li>실제 종이처럼 동작하는 “표면” 개념 → <strong>레이어, 그림자, 깊이감</strong></li>
      <li><strong>굵은 색상, 명확한 애니메이션, 카드 UI</strong></li>
      <li>일관된 컴포넌트 구조 (Button, Dialog 등)</li>
      <li>다양한 화면 크기 및 접근성 고려가 잘 되어 있음</li>
    </ul>
  </li>
</ul>

<h4 id="-쿠퍼티노-디자인-cupertino-design">🍏 쿠퍼티노 디자인 (Cupertino Design)</h4>

<ul>
  <li>Apple이 만든 iOS용 디자인 철학</li>
  <li>Flutter에서는 <code class="language-plaintext highlighter-rouge">CupertinoWidget</code>으로 구현</li>
  <li>
    <p>특징:</p>

    <ul>
      <li><strong>심플하고 정갈한 UI</strong>, 얇은 폰트, 미니멀한 구성</li>
      <li>iOS의 네이티브한 느낌을 충실히 재현</li>
      <li>스크롤, 네비게이션, 토글 스위치 등에서 iOS 특유의 인터랙션 존재</li>
    </ul>
  </li>
</ul>

<h4 id="비교-요약">비교 요약:</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Material Design</th>
      <th>Cupertino Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>주요 플랫폼</td>
      <td>Android, Web, Desktop</td>
      <td>iOS</td>
    </tr>
    <tr>
      <td>디자인 철학</td>
      <td>종이+레이어+애니메이션</td>
      <td>단순함+미려함+일관성</td>
    </tr>
    <tr>
      <td>주요 사용 예</td>
      <td>Google 앱, Android 앱</td>
      <td>Apple 앱, iOS 앱</td>
    </tr>
    <tr>
      <td>Flutter 적용</td>
      <td><code class="language-plaintext highlighter-rouge">MaterialApp</code></td>
      <td><code class="language-plaintext highlighter-rouge">CupertinoApp</code></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>요약: Android 앱은 Material 위주, iOS는 Cupertino 스타일을 따르며, <strong>Flutter는 둘 다 지원</strong>해 플랫폼에 맞는 UI를 쉽게 만들 수 있다!</p>
</blockquote>

<hr />

<h3 id="2️⃣-log-vs-metrics">2️⃣ <strong>Log vs Metrics</strong></h3>

<p>백엔드/운영 환경에서 시스템 상태를 추적할 때 자주 쓰이는 두 가지 개념을 비교해 보았다.</p>

<h4 id="-로그-log">📄 로그 (Log)</h4>

<ul>
  <li>
    <p><strong>시간 순으로 발생한 이벤트 기록</strong></p>
  </li>
  <li>
    <p>보통 텍스트 기반이며, 문제가 발생했을 때 <strong>무슨 일이 있었는지</strong> 파악하는 데 유용</p>
  </li>
  <li>
    <p>예:</p>

    <ul>
      <li>사용자가 로그인에 실패했습니다.</li>
      <li>서버에서 500 에러가 발생했습니다.</li>
    </ul>
  </li>
  <li>
    <p>특징:</p>

    <ul>
      <li>구조화가 느슨함 (JSON 또는 단순 텍스트)</li>
      <li>디버깅, 감사 추적에 용이</li>
      <li><strong>사후 분석</strong>에 효과적</li>
      <li>저장 공간 많이 차지할 수 있음</li>
    </ul>
  </li>
  <li>
    <p>예시:</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2025-05-13T12:45:00"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"level"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ERROR"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Login failed for user ID 123"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<h4 id="-메트릭-metrics">📊 메트릭 (Metrics)</h4>

<ul>
  <li>
    <p><strong>수치로 측정 가능한 시스템의 상태</strong></p>
  </li>
  <li>
    <p>시간에 따라 변화하는 수치 → CPU 사용량, 요청 수, 응답 시간 등</p>
  </li>
  <li>
    <p>예:</p>

    <ul>
      <li>서버 응답 시간 평균 120ms</li>
      <li>현재 접속 사용자 수 300명</li>
    </ul>
  </li>
  <li>
    <p>특징:</p>

    <ul>
      <li>구조화된 데이터</li>
      <li>시각화 및 대시보드 구성에 유리</li>
      <li>알림(경고) 설정에 적합</li>
      <li>보통 <strong>Prometheus</strong>, <strong>Grafana</strong>와 같이 사용됨</li>
    </ul>
  </li>
  <li>
    <p>예시:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http_requests_total{method="GET", status="200"} 3456
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="비교-요약-1">비교 요약:</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>로그(Log)</th>
      <th>메트릭(Metrics)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>목적</td>
      <td>이벤트 디버깅, 추적</td>
      <td>상태 모니터링, 성능 추적</td>
    </tr>
    <tr>
      <td>형식</td>
      <td>텍스트 기반, 구조 유동적</td>
      <td>수치 기반, 구조화됨</td>
    </tr>
    <tr>
      <td>저장</td>
      <td>로그 파일, ELK Stack</td>
      <td>시계열 DB (Prometheus 등)</td>
    </tr>
    <tr>
      <td>시각화</td>
      <td>Kibana, Logtail 등</td>
      <td>Grafana 등</td>
    </tr>
    <tr>
      <td>실시간성</td>
      <td>낮음 (분석 중심)</td>
      <td>높음 (모니터링, 알림에 적합)</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>로그는 “<strong>무슨 일이 일어났는가</strong>”를 알려주고,
메트릭은 “<strong>현재 시스템이 어떤 상태인가</strong>”를 알려준다.
둘은 보완 관계로 함께 사용하는 것이 가장 효과적이다!</p>
</blockquote>

<h2 id="3️⃣-structured-logging-구조화된-로그">3️⃣ <strong>Structured Logging (구조화된 로그)</strong></h2>

<h3 id="-개념">✅ 개념</h3>

<ul>
  <li>일반 로그는 텍스트 형식으로 사람이 읽기 쉽게 쓰는 반면,
<strong>Structured Logging</strong>은 로그를 <strong>JSON 같은 구조화된 형태로 기록</strong>하는 방식입니다.</li>
</ul>

<h3 id="-예시-비교">🔍 예시 비교</h3>

<p><strong>❌ 일반 로그 (Unstructured)</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User 1234 failed to login due to wrong password
</code></pre></div></div>

<p><strong>✅ 구조화 로그 (Structured)</strong>:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2025-05-13T10:42:00Z"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"level"</span><span class="p">:</span><span class="w"> </span><span class="s2">"WARN"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"event"</span><span class="p">:</span><span class="w"> </span><span class="s2">"login_failed"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"user_id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1234</span><span class="p">,</span><span class="w">
  </span><span class="nl">"reason"</span><span class="p">:</span><span class="w"> </span><span class="s2">"wrong_password"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="-장점">✨ 장점</h3>

<ul>
  <li>기계가 파싱하기 쉽고, <strong>검색/필터링/집계</strong>에 유리</li>
  <li>로그 수집 도구(예: Elasticsearch, Datadog)와 연동할 때 편함</li>
  <li>실시간 모니터링이나 <strong>경고 시스템</strong>과 연계 가능</li>
</ul>

<blockquote>
  <p>구조화 로그는 결국 “<strong>로그도 데이터다</strong>”라는 관점에서 관리하는 것!</p>
</blockquote>

<hr />

<h2 id="4️⃣-elk-vs-efk-스택">4️⃣ <strong>ELK vs EFK 스택</strong></h2>

<h3 id="-공통-목적">✅ 공통 목적</h3>

<ul>
  <li><strong>분산 로그 수집, 저장, 분석, 시각화</strong>를 위한 스택입니다.</li>
  <li>대규모 시스템에서 수많은 서버 로그를 한 곳으로 모아서 검색·분석하기 위해 사용합니다.</li>
</ul>

<hr />

<h3 id="-elk-stack">🧩 <strong>ELK Stack</strong></h3>

<ul>
  <li><strong>E</strong>lasticsearch: 로그를 저장하고 검색 가능한 DB</li>
  <li><strong>L</strong>ogstash: 로그 수집기. 다양한 소스에서 로그를 받아 필터링/변환</li>
  <li><strong>K</strong>ibana: 시각화 도구 (대시보드, 검색 UI 등)</li>
</ul>

<h4 id="장점">장점</h4>

<ul>
  <li>오래된 구성으로 안정적이고 성숙함</li>
  <li>다양한 입력 소스를 지원 (DB, 파일, MQ 등)</li>
</ul>

<h4 id="단점">단점</h4>

<ul>
  <li>Logstash가 무거움 → <strong>리소스 많이 사용</strong></li>
  <li>설정 복잡함</li>
</ul>

<hr />

<h3 id="-efk-stack">🧩 <strong>EFK Stack</strong></h3>

<ul>
  <li><strong>E</strong>lasticsearch</li>
  <li><strong>F</strong>luentd: 경량 로그 수집기 (Logstash 대체)</li>
  <li><strong>K</strong>ibana</li>
</ul>

<h4 id="장점-1">장점</h4>

<ul>
  <li><strong>Kubernetes 환경에 더 적합</strong></li>
  <li>Fluentd는 가볍고 플러그인으로 유연하게 확장 가능</li>
  <li>최근 클라우드 환경에서 더 많이 사용됨</li>
</ul>

<h4 id="단점-1">단점</h4>

<ul>
  <li>복잡한 변환/파이프라인 처리 시엔 Logstash보다 기능 제한 있음</li>
</ul>

<hr />

<h3 id="비교-요약표">비교 요약표:</h3>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>ELK</th>
      <th>EFK</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>로그 수집기</td>
      <td>Logstash (무거움)</td>
      <td>Fluentd (가볍고 유연함)</td>
    </tr>
    <tr>
      <td>시각화</td>
      <td>Kibana</td>
      <td>Kibana</td>
    </tr>
    <tr>
      <td>주 사용 환경</td>
      <td>온프레미스, 레거시 시스템</td>
      <td>클라우드, Kubernetes</td>
    </tr>
    <tr>
      <td>구성 난이도</td>
      <td>다소 복잡</td>
      <td>상대적으로 단순</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-결론">📌 결론</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>추천</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Kubernetes 기반 마이크로서비스</td>
      <td>✅ <strong>EFK Stack</strong></td>
    </tr>
    <tr>
      <td>다양한 로그 소스와 복잡한 처리 필요</td>
      <td>✅ <strong>ELK Stack</strong></td>
    </tr>
    <tr>
      <td>단순한 파일 로그 수집 및 시각화</td>
      <td>✅ 둘 다 가능, 구조화 로그 필수</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>실제로는 <strong>EFK + Structured Logging</strong> 조합이 요즘 가장 트렌디한 방식입니다.
로그를 JSON 형태로 남기고, Fluentd를 통해 Elasticsearch에 넣은 뒤 Kibana로 시각화하면 아주 강력한 로그 분석 시스템이 됩니다.</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><category term="TIL" /><summary type="html"><![CDATA[메테리얼 디자인 vs 쿠퍼티노 디자인, Log vs Metrics, Structured Logging, ELK vs EFK 스택에 대한 TIL 기록]]></summary></entry><entry><title type="html">메테리얼 디자인 vs 쿠퍼티노 디자인, Log vs Metrics, Structured Logging, ELK vs EFK 스택</title><link href="https://nan0silver.github.io/miscellaneous/2025-05-22-%EB%A9%94%ED%85%8C%EB%A6%AC%EC%96%BC-%EB%94%94%EC%9E%90%EC%9D%B8-vs-%EC%BF%A0%ED%8D%BC%ED%8B%B0%EB%85%B8-%EB%94%94%EC%9E%90%EC%9D%B8-log-vs-metrics-structured-log-issue-59/" rel="alternate" type="text/html" title="메테리얼 디자인 vs 쿠퍼티노 디자인, Log vs Metrics, Structured Logging, ELK vs EFK 스택" /><published>2025-05-22T00:00:00+00:00</published><updated>2025-05-27T03:54:57+00:00</updated><id>https://nan0silver.github.io/miscellaneous/%EB%A9%94%ED%85%8C%EB%A6%AC%EC%96%BC-%EB%94%94%EC%9E%90%EC%9D%B8-vs-%EC%BF%A0%ED%8D%BC%ED%8B%B0%EB%85%B8-%EB%94%94%EC%9E%90%EC%9D%B8-log-vs-metrics-structured-log-issue-59</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-05-22-%EB%A9%94%ED%85%8C%EB%A6%AC%EC%96%BC-%EB%94%94%EC%9E%90%EC%9D%B8-vs-%EC%BF%A0%ED%8D%BC%ED%8B%B0%EB%85%B8-%EB%94%94%EC%9E%90%EC%9D%B8-log-vs-metrics-structured-log-issue-59/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/59">#59</a><br />
📅 <strong>작성일</strong>: 2025-05-22<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-메테리얼-디자인material-design-vs-쿠퍼티노-디자인cupertino-design">1️⃣ <strong>메테리얼 디자인(Material Design) vs 쿠퍼티노 디자인(Cupertino Design)</strong></h3>

<h4 id="-메테리얼-디자인-material-design">🎨 메테리얼 디자인 (Material Design)</h4>

<ul>
  <li>Google에서 만든 디자인 시스템</li>
  <li>Android 앱에서 기본적으로 사용되는 UI 가이드라인</li>
  <li>
    <p>특징:</p>

    <ul>
      <li>실제 종이처럼 동작하는 “표면” 개념 → <strong>레이어, 그림자, 깊이감</strong></li>
      <li><strong>굵은 색상, 명확한 애니메이션, 카드 UI</strong></li>
      <li>일관된 컴포넌트 구조 (Button, Dialog 등)</li>
      <li>다양한 화면 크기 및 접근성 고려가 잘 되어 있음</li>
    </ul>
  </li>
</ul>

<h4 id="-쿠퍼티노-디자인-cupertino-design">🍏 쿠퍼티노 디자인 (Cupertino Design)</h4>

<ul>
  <li>Apple이 만든 iOS용 디자인 철학</li>
  <li>Flutter에서는 <code class="language-plaintext highlighter-rouge">CupertinoWidget</code>으로 구현</li>
  <li>
    <p>특징:</p>

    <ul>
      <li><strong>심플하고 정갈한 UI</strong>, 얇은 폰트, 미니멀한 구성</li>
      <li>iOS의 네이티브한 느낌을 충실히 재현</li>
      <li>스크롤, 네비게이션, 토글 스위치 등에서 iOS 특유의 인터랙션 존재</li>
    </ul>
  </li>
</ul>

<h4 id="비교-요약">비교 요약:</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Material Design</th>
      <th>Cupertino Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>주요 플랫폼</td>
      <td>Android, Web, Desktop</td>
      <td>iOS</td>
    </tr>
    <tr>
      <td>디자인 철학</td>
      <td>종이+레이어+애니메이션</td>
      <td>단순함+미려함+일관성</td>
    </tr>
    <tr>
      <td>주요 사용 예</td>
      <td>Google 앱, Android 앱</td>
      <td>Apple 앱, iOS 앱</td>
    </tr>
    <tr>
      <td>Flutter 적용</td>
      <td><code class="language-plaintext highlighter-rouge">MaterialApp</code></td>
      <td><code class="language-plaintext highlighter-rouge">CupertinoApp</code></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>요약: Android 앱은 Material 위주, iOS는 Cupertino 스타일을 따르며, <strong>Flutter는 둘 다 지원</strong>해 플랫폼에 맞는 UI를 쉽게 만들 수 있다!</p>
</blockquote>

<hr />

<h3 id="2️⃣-log-vs-metrics">2️⃣ <strong>Log vs Metrics</strong></h3>

<p>백엔드/운영 환경에서 시스템 상태를 추적할 때 자주 쓰이는 두 가지 개념을 비교해 보았다.</p>

<h4 id="-로그-log">📄 로그 (Log)</h4>

<ul>
  <li>
    <p><strong>시간 순으로 발생한 이벤트 기록</strong></p>
  </li>
  <li>
    <p>보통 텍스트 기반이며, 문제가 발생했을 때 <strong>무슨 일이 있었는지</strong> 파악하는 데 유용</p>
  </li>
  <li>
    <p>예:</p>

    <ul>
      <li>사용자가 로그인에 실패했습니다.</li>
      <li>서버에서 500 에러가 발생했습니다.</li>
    </ul>
  </li>
  <li>
    <p>특징:</p>

    <ul>
      <li>구조화가 느슨함 (JSON 또는 단순 텍스트)</li>
      <li>디버깅, 감사 추적에 용이</li>
      <li><strong>사후 분석</strong>에 효과적</li>
      <li>저장 공간 많이 차지할 수 있음</li>
    </ul>
  </li>
  <li>
    <p>예시:</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2025-05-13T12:45:00"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"level"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ERROR"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Login failed for user ID 123"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<h4 id="-메트릭-metrics">📊 메트릭 (Metrics)</h4>

<ul>
  <li>
    <p><strong>수치로 측정 가능한 시스템의 상태</strong></p>
  </li>
  <li>
    <p>시간에 따라 변화하는 수치 → CPU 사용량, 요청 수, 응답 시간 등</p>
  </li>
  <li>
    <p>예:</p>

    <ul>
      <li>서버 응답 시간 평균 120ms</li>
      <li>현재 접속 사용자 수 300명</li>
    </ul>
  </li>
  <li>
    <p>특징:</p>

    <ul>
      <li>구조화된 데이터</li>
      <li>시각화 및 대시보드 구성에 유리</li>
      <li>알림(경고) 설정에 적합</li>
      <li>보통 <strong>Prometheus</strong>, <strong>Grafana</strong>와 같이 사용됨</li>
    </ul>
  </li>
  <li>
    <p>예시:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http_requests_total{method="GET", status="200"} 3456
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="비교-요약-1">비교 요약:</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>로그(Log)</th>
      <th>메트릭(Metrics)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>목적</td>
      <td>이벤트 디버깅, 추적</td>
      <td>상태 모니터링, 성능 추적</td>
    </tr>
    <tr>
      <td>형식</td>
      <td>텍스트 기반, 구조 유동적</td>
      <td>수치 기반, 구조화됨</td>
    </tr>
    <tr>
      <td>저장</td>
      <td>로그 파일, ELK Stack</td>
      <td>시계열 DB (Prometheus 등)</td>
    </tr>
    <tr>
      <td>시각화</td>
      <td>Kibana, Logtail 등</td>
      <td>Grafana 등</td>
    </tr>
    <tr>
      <td>실시간성</td>
      <td>낮음 (분석 중심)</td>
      <td>높음 (모니터링, 알림에 적합)</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>로그는 “<strong>무슨 일이 일어났는가</strong>”를 알려주고,
메트릭은 “<strong>현재 시스템이 어떤 상태인가</strong>”를 알려준다.
둘은 보완 관계로 함께 사용하는 것이 가장 효과적이다!</p>
</blockquote>

<h2 id="3️⃣-structured-logging-구조화된-로그">3️⃣ <strong>Structured Logging (구조화된 로그)</strong></h2>

<h3 id="-개념">✅ 개념</h3>

<ul>
  <li>일반 로그는 텍스트 형식으로 사람이 읽기 쉽게 쓰는 반면,
<strong>Structured Logging</strong>은 로그를 <strong>JSON 같은 구조화된 형태로 기록</strong>하는 방식입니다.</li>
</ul>

<h3 id="-예시-비교">🔍 예시 비교</h3>

<p><strong>❌ 일반 로그 (Unstructured)</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User 1234 failed to login due to wrong password
</code></pre></div></div>

<p><strong>✅ 구조화 로그 (Structured)</strong>:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2025-05-13T10:42:00Z"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"level"</span><span class="p">:</span><span class="w"> </span><span class="s2">"WARN"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"event"</span><span class="p">:</span><span class="w"> </span><span class="s2">"login_failed"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"user_id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1234</span><span class="p">,</span><span class="w">
  </span><span class="nl">"reason"</span><span class="p">:</span><span class="w"> </span><span class="s2">"wrong_password"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="-장점">✨ 장점</h3>

<ul>
  <li>기계가 파싱하기 쉽고, <strong>검색/필터링/집계</strong>에 유리</li>
  <li>로그 수집 도구(예: Elasticsearch, Datadog)와 연동할 때 편함</li>
  <li>실시간 모니터링이나 <strong>경고 시스템</strong>과 연계 가능</li>
</ul>

<blockquote>
  <p>구조화 로그는 결국 “<strong>로그도 데이터다</strong>”라는 관점에서 관리하는 것!</p>
</blockquote>

<hr />

<h2 id="4️⃣-elk-vs-efk-스택">4️⃣ <strong>ELK vs EFK 스택</strong></h2>

<h3 id="-공통-목적">✅ 공통 목적</h3>

<ul>
  <li><strong>분산 로그 수집, 저장, 분석, 시각화</strong>를 위한 스택입니다.</li>
  <li>대규모 시스템에서 수많은 서버 로그를 한 곳으로 모아서 검색·분석하기 위해 사용합니다.</li>
</ul>

<hr />

<h3 id="-elk-stack">🧩 <strong>ELK Stack</strong></h3>

<ul>
  <li><strong>E</strong>lasticsearch: 로그를 저장하고 검색 가능한 DB</li>
  <li><strong>L</strong>ogstash: 로그 수집기. 다양한 소스에서 로그를 받아 필터링/변환</li>
  <li><strong>K</strong>ibana: 시각화 도구 (대시보드, 검색 UI 등)</li>
</ul>

<h4 id="장점">장점</h4>

<ul>
  <li>오래된 구성으로 안정적이고 성숙함</li>
  <li>다양한 입력 소스를 지원 (DB, 파일, MQ 등)</li>
</ul>

<h4 id="단점">단점</h4>

<ul>
  <li>Logstash가 무거움 → <strong>리소스 많이 사용</strong></li>
  <li>설정 복잡함</li>
</ul>

<hr />

<h3 id="-efk-stack">🧩 <strong>EFK Stack</strong></h3>

<ul>
  <li><strong>E</strong>lasticsearch</li>
  <li><strong>F</strong>luentd: 경량 로그 수집기 (Logstash 대체)</li>
  <li><strong>K</strong>ibana</li>
</ul>

<h4 id="장점-1">장점</h4>

<ul>
  <li><strong>Kubernetes 환경에 더 적합</strong></li>
  <li>Fluentd는 가볍고 플러그인으로 유연하게 확장 가능</li>
  <li>최근 클라우드 환경에서 더 많이 사용됨</li>
</ul>

<h4 id="단점-1">단점</h4>

<ul>
  <li>복잡한 변환/파이프라인 처리 시엔 Logstash보다 기능 제한 있음</li>
</ul>

<hr />

<h3 id="비교-요약표">비교 요약표:</h3>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>ELK</th>
      <th>EFK</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>로그 수집기</td>
      <td>Logstash (무거움)</td>
      <td>Fluentd (가볍고 유연함)</td>
    </tr>
    <tr>
      <td>시각화</td>
      <td>Kibana</td>
      <td>Kibana</td>
    </tr>
    <tr>
      <td>주 사용 환경</td>
      <td>온프레미스, 레거시 시스템</td>
      <td>클라우드, Kubernetes</td>
    </tr>
    <tr>
      <td>구성 난이도</td>
      <td>다소 복잡</td>
      <td>상대적으로 단순</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-결론">📌 결론</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>추천</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Kubernetes 기반 마이크로서비스</td>
      <td>✅ <strong>EFK Stack</strong></td>
    </tr>
    <tr>
      <td>다양한 로그 소스와 복잡한 처리 필요</td>
      <td>✅ <strong>ELK Stack</strong></td>
    </tr>
    <tr>
      <td>단순한 파일 로그 수집 및 시각화</td>
      <td>✅ 둘 다 가능, 구조화 로그 필수</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>실제로는 <strong>EFK + Structured Logging</strong> 조합이 요즘 가장 트렌디한 방식입니다.
로그를 JSON 형태로 남기고, Fluentd를 통해 Elasticsearch에 넣은 뒤 Kibana로 시각화하면 아주 강력한 로그 분석 시스템이 됩니다.</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><category term="TIL" /><summary type="html"><![CDATA[메테리얼 디자인 vs 쿠퍼티노 디자인, Log vs Metrics, Structured Logging, ELK vs EFK 스택에 대한 TIL 기록]]></summary></entry><entry><title type="html">RPM, 앙상블, 비용, WSL, Windows Subsystem for Linux 2, Phoenix vs Snowflake</title><link href="https://nan0silver.github.io/miscellaneous/2025-05-21-rpm-%EC%95%99%EC%83%81%EB%B8%94-%EB%B9%84%EC%9A%A9-wsl-windows-subsystem-for-linux-2-phoen-issue-58/" rel="alternate" type="text/html" title="RPM, 앙상블, 비용, WSL, Windows Subsystem for Linux 2, Phoenix vs Snowflake" /><published>2025-05-21T00:00:00+00:00</published><updated>2025-05-27T03:53:22+00:00</updated><id>https://nan0silver.github.io/miscellaneous/rpm-%EC%95%99%EC%83%81%EB%B8%94-%EB%B9%84%EC%9A%A9-wsl-windows-subsystem-for-linux-2-phoen-issue-58</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-05-21-rpm-%EC%95%99%EC%83%81%EB%B8%94-%EB%B9%84%EC%9A%A9-wsl-windows-subsystem-for-linux-2-phoen-issue-58/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/58">#58</a><br />
📅 <strong>작성일</strong>: 2025-05-21<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-rpm-앙상블-비용">1️⃣ <strong>RPM, 앙상블, 비용</strong></h3>

<ul>
  <li>
    <p><strong>RPM (Revolutions Per Minute)</strong></p>

    <ul>
      <li>원래는 하드디스크나 모터 회전 속도를 나타내는 단위지만, **웹/앱 분석에서는 보통 “Revenue Per Mille(천 회당 수익)”**로 사용된다.</li>
      <li>
        <p>광고 업계에서는 광고가 <strong>1,000번 노출될 때 수익이 얼마인지</strong>를 뜻함.</p>

        <ul>
          <li>예: RPM = 5라면, 1,000번 광고 노출 시 수익이 $5</li>
        </ul>
      </li>
      <li>수익성을 평가하는 지표로 자주 사용됨.</li>
    </ul>
  </li>
  <li>
    <p><strong>앙상블 (Ensemble)</strong></p>

    <ul>
      <li>머신러닝에서 여러 모델을 조합해 <strong>예측 정확도를 향상시키는 기법</strong></li>
      <li>
        <p>주요 기법:</p>

        <ul>
          <li><strong>Bagging</strong> (ex. Random Forest)</li>
          <li><strong>Boosting</strong> (ex. XGBoost, LightGBM)</li>
          <li><strong>Stacking</strong> (모델들의 출력값을 다시 모델에 입력)</li>
        </ul>
      </li>
      <li>하나의 모델보다 성능이 좋을 가능성이 높고, 특히 Kaggle 등 실전 대회에서 필수 전략임.</li>
    </ul>
  </li>
  <li>
    <p><strong>비용 (Cost)</strong></p>

    <ul>
      <li>머신러닝에서의 비용은 보통 <strong>오차(error)를 수치화한 값</strong></li>
      <li>
        <p>목표는 이 비용(Cost)을 <strong>최소화하는 모델 파라미터를 찾는 것</strong></p>

        <ul>
          <li>예: 회귀에서는 <strong>MSE (Mean Squared Error)</strong></li>
          <li>분류에서는 <strong>Cross Entropy</strong> 같은 손실 함수 사용</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="2️⃣-wsl-windows-subsystem-for-linux-2">2️⃣ <strong>WSL, Windows Subsystem for Linux 2</strong></h3>

<ul>
  <li>
    <p><strong>WSL (Windows Subsystem for Linux)</strong></p>

    <ul>
      <li>Windows에서 Linux 환경을 사용할 수 있게 해주는 Microsoft의 호환 계층</li>
      <li>
        <p>WSL2는 WSL1과 달리 <strong>실제 Linux 커널을 가상 머신 위에 구동</strong>시킴</p>

        <ul>
          <li>더 빠르고 호환성이 뛰어남 (ex. Docker 사용 가능)</li>
        </ul>
      </li>
      <li>개발자가 <strong>Mac 없이도 Unix/Linux 개발 환경</strong>을 Windows에서 구성할 수 있어 유용함</li>
    </ul>
  </li>
  <li>
    <p><strong>UNIX vs MacOS vs WSL2 vs Tux</strong></p>

    <ul>
      <li><strong>UNIX</strong>: OS 설계 철학/표준, 안정성과 보안성으로 서버 환경에서 많이 사용됨</li>
      <li><strong>MacOS</strong>: BSD 계열의 UNIX 기반 OS → 터미널 환경이 UNIX 명령어와 유사</li>
      <li><strong>WSL2</strong>: 윈도우 안에서 리눅스 환경을 제공해, 리눅스 개발 도구 사용 가능</li>
      <li><strong>Tux</strong>: 리눅스의 공식 마스코트 펭귄 이름 🐧</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>요약: Mac이나 Linux 서버가 없더라도 WSL2를 쓰면 로컬에서 UNIX 개발 환경을 손쉽게 세팅할 수 있다.</p>
</blockquote>

<hr />

<h3 id="3️⃣-phoenix-vs-snowflake">3️⃣ <strong>Phoenix vs Snowflake</strong></h3>

<ul>
  <li>이 두 용어는 <strong>데이터 웨어하우스 시스템</strong> 및 <strong>클라우드 아키텍처</strong> 문맥에서 자주 사용됨.</li>
</ul>

<h4 id="-phoenix-server-불사조-서버">🔥 Phoenix Server (불사조 서버)</h4>

<ul>
  <li>시스템을 중단하지 않고 <strong>점진적으로 설정, 코드, 인프라를 바꾸는 방식</strong></li>
  <li>“죽지 않는 서버”</li>
  <li>실시간으로 코드를 수정하거나, 배포 중에도 유저에게 영향을 주지 않음</li>
  <li>하지만 시간이 지날수록 <strong>기술 부채</strong>가 쌓일 수 있음</li>
</ul>

<h4 id="️-snowflake-server-눈송이-서버">❄️ Snowflake Server (눈송이 서버)</h4>

<ul>
  <li>수작업 설정이 많고, <strong>특정 환경에서만 작동하는 불안정한 서버</strong></li>
  <li>배포마다 설정이 조금씩 달라서, 한번 망가지면 <strong>복원하기 어려움</strong></li>
  <li>
    <p>반의어로 <strong>Immutable Infrastructure</strong> (변경 불가능한 인프라)가 선호됨</p>

    <ul>
      <li>예: 컨테이너 기반 인프라 (Docker + CI/CD)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>요약:</p>

  <ul>
    <li><strong>Phoenix 서버</strong>는 장기적으로 위험이 쌓이고,</li>
    <li><strong>Snowflake 서버</strong>는 설정 의존도가 높아 불안정하며,</li>
    <li>**이 둘을 피하기 위해 IaC(Infrastructure as Code)**와 컨테이너, 배포 자동화를 쓰는 것이 최신 DevOps 흐름이다.</li>
  </ul>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><category term="TIL" /><summary type="html"><![CDATA[RPM, 앙상블, 비용, WSL, Windows Subsystem for Linux 2, Phoenix vs Snowflake에 대한 TIL 기록]]></summary></entry></feed>