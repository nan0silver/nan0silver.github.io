<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-04-08T12:29:17+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[Spring] JPA vs MyBatis</title><link href="https://nan0silver.github.io/spring/2025-04-05-jpa-mybatis/" rel="alternate" type="text/html" title="[Spring] JPA vs MyBatis" /><published>2025-04-05T00:00:00+00:00</published><updated>2025-04-08T12:28:34+00:00</updated><id>https://nan0silver.github.io/spring/jpa-mybatis</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-05-jpa-mybatis/"><![CDATA[<ul>
  <li><a href="#-jpa란-java-persistence-api">JPA란?</a></li>
  <li><a href="#-mybatis란">MyBatis란?</a></li>
  <li><a href="#-jpa-vs-mybatis">🔍 JPA vs MyBatis</a></li>
  <li><a href="#jpa-vs-mybatis-비유로-이해하기">JPA vs MyBatis 비유로 이해하기</a></li>
  <li><a href="#-jpa-vs-mybatis-코드로-비교하기">JPA vs MyBatis 코드로 비교하기</a></li>
  <li><a href="#-사용-방식-차이-요약">사용 방식 차이 요약</a></li>
  <li><a href="#-장단점-비교">장단점 비교</a></li>
  <li><a href="#-실무에-쓰는-방법">실무에 쓰는 방법</a></li>
  <li><a href="#-한줄-정리">한줄 정리</a></li>
</ul>

<hr />

<h2 id="-jpa란-java-persistence-api">📌 JPA란? (Java Persistence API)</h2>

<ul>
  <li><strong>자바에서 관계형 데이터베이스(RDB)를 객체로 다룰 수 있게 해주는 표준 API</strong>.</li>
  <li>SQL을 직접 작성하지 않아도 객체처럼 DB 데이터를 저장/조회/수정/삭제 가능.</li>
  <li>구현체 중 가장 유명한 것은 <strong>Hibernate</strong>고, Spring에서 주로 이걸 씀.</li>
</ul>

<hr />

<h2 id="jpa-핵심-용어">JPA 핵심 용어</h2>

<table>
  <thead>
    <tr>
      <th>용어</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Entity</strong></td>
      <td>DB 테이블과 매핑되는 자바 클래스</td>
    </tr>
    <tr>
      <td><strong>EntityManager</strong></td>
      <td>JPA의 핵심! DB와 객체 사이의 작업을 처리하는 도구</td>
    </tr>
    <tr>
      <td><strong>Persistence Context (영속성 컨텍스트)</strong></td>
      <td>엔티티를 관리하는 JPA 내부 메모리 공간</td>
    </tr>
    <tr>
      <td><strong>JPQL (Java Persistence Query Language)</strong></td>
      <td>객체 지향 쿼리 언어. SQL과 유사하지만, 테이블이 아닌 클래스/필드 단위로 작동</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-mybatis란">📌 MyBatis란?</h2>

<ul>
  <li><strong>자바에서 SQL을 직접 작성해서 데이터베이스와 통신할 수 있게 해주는 프레임워크.</strong></li>
  <li>SQL 중심의 프로그래밍이 가능하고, <strong>복잡하고 세밀한 쿼리 제어</strong>에 유리함.</li>
  <li>XML 또는 어노테이션 기반으로 SQL을 작성하고, <strong>쿼리 결과를 자바 객체와 매핑</strong>해줌.</li>
  <li><strong>Spring과도 쉽게 통합 가능</strong>하며, 실무에서는 여전히 널리 사용됨.</li>
</ul>

<hr />

<h2 id="mybatis-핵심-용어">MyBatis 핵심 용어</h2>

<table>
  <thead>
    <tr>
      <th>용어</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Mapper 인터페이스</strong></td>
      <td>SQL 문장을 호출하는 자바 인터페이스. XML과 1:1 매칭되어 동작함</td>
    </tr>
    <tr>
      <td><strong>Mapper XML</strong></td>
      <td>실제 SQL이 작성되는 파일. <code class="language-plaintext highlighter-rouge">&lt;select&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;insert&gt;</code> 등 태그로 구성됨</td>
    </tr>
    <tr>
      <td><strong>SqlSession</strong></td>
      <td>DB 연결과 SQL 실행을 담당하는 핵심 객체 (JDBC의 Connection 역할)</td>
    </tr>
    <tr>
      <td><strong>ResultMap</strong></td>
      <td>쿼리 결과를 자바 객체에 <strong>정밀하게 매핑</strong>할 때 사용하는 설정</td>
    </tr>
    <tr>
      <td><strong>#{} / ${}</strong></td>
      <td>SQL 파라미터 바인딩 방식. <code class="language-plaintext highlighter-rouge">#{}</code>는 안전한 바인딩, <code class="language-plaintext highlighter-rouge">${}</code>는 SQL 인젝션 주의</td>
    </tr>
    <tr>
      <td><strong>TypeAlias</strong></td>
      <td>자바 클래스의 이름을 짧게 별칭으로 사용할 수 있도록 하는 기능</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-jpa-vs-mybatis">🔍 JPA vs MyBatis</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>JPA</th>
      <th>MyBatis</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>개발 방식</td>
      <td><strong>자동 매핑</strong> (객체 중심)</td>
      <td><strong>수동 매핑</strong> (SQL 중심)</td>
    </tr>
    <tr>
      <td>핵심 개념</td>
      <td>객체를 DB에 자동 매핑</td>
      <td>직접 SQL 작성 + 매핑</td>
    </tr>
    <tr>
      <td>학습 곡선</td>
      <td>좀 더 높음 (추상화 많음)</td>
      <td>비교적 쉬움 (SQL 그대로 작성)</td>
    </tr>
    <tr>
      <td>유연성</td>
      <td>추상화 많아 덜 유연함</td>
      <td>SQL 작성 자유로움</td>
    </tr>
    <tr>
      <td>성능 제어</td>
      <td>ORM에 맡김 (튜닝 어려움)</td>
      <td>직접 SQL 작성으로 제어 쉬움</td>
    </tr>
    <tr>
      <td>대표 도구</td>
      <td>Hibernate (JPA 구현체)</td>
      <td>MyBatis 프레임워크</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="jpa-vs-mybatis-비유로-이해하기">JPA vs MyBatis 비유로 이해하기</h2>

<h3 id="️-jpa--자동세탁기-">☝️ JPA = 자동세탁기 👕</h3>

<ul>
  <li><strong>세탁기 안에 옷(객체)</strong>을 넣으면<br />
→ 알아서 물(쿼리) 넣고, 빨고, 말리고<br />
→ 깨끗한 결과(조회된 객체)를 자동으로 꺼내줌!</li>
</ul>

<blockquote>
  <p>→ 개발자는 <strong>“옷만 넣고 결과만 받으면 됨”</strong><br />
→ 단, 세탁 방식은 기계가 알아서 함 (튜닝 어려움)</p>
</blockquote>

<hr />

<h3 id="️-mybatis--손빨래-">✌️ MyBatis = 손빨래 🧼</h3>

<ul>
  <li><strong>개발자가 직접</strong> 물 붓고, 비비고, 헹구고</li>
  <li>어떤 SQL 쿼리를 쓰고, 어떤 칼럼을 어떤 필드에 넣을지도 <strong>직접 지정</strong></li>
</ul>

<blockquote>
  <p>→ 개발자는 <strong>“컨트롤을 많이 할 수 있음”</strong><br />
→ 다만 <strong>귀찮고 실수할 가능성 있음</strong></p>
</blockquote>

<hr />

<h2 id="-jpa-vs-mybatis-코드로-비교하기">🧩 JPA vs MyBatis 코드로 비교하기</h2>

<h3 id="-jpa-예제-hibernate-기반">✅ JPA 예제 (Hibernate 기반)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 저장</span>
<span class="nc">Member</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"Sungwoo"</span><span class="o">);</span>
<span class="n">entityManager</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>

<span class="c1">// 조회</span>
<span class="nc">Member</span> <span class="n">result</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
</code></pre></div></div>

<p>👉 SQL 없이 객체만 조작하면 됨!<br />
→ <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">SELECT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, <code class="language-plaintext highlighter-rouge">DELETE</code>를 <strong>자동으로 처리</strong></p>

<hr />

<h3 id="-mybatis-예제">✅ MyBatis 예제</h3>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- mapper.xml --&gt;</span>
<span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"findMemberById"</span> <span class="na">parameterType=</span><span class="s">"long"</span> <span class="na">resultType=</span><span class="s">"Member"</span><span class="nt">&gt;</span>
  SELECT id, name FROM members WHERE id = #{id}
<span class="nt">&lt;/select&gt;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 자바 코드</span>
<span class="nc">Member</span> <span class="n">m</span> <span class="o">=</span> <span class="n">memberMapper</span><span class="o">.</span><span class="na">findMemberById</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
</code></pre></div></div>

<p>👉 SQL을 내가 직접 작성함<br />
→ DB 구조가 복잡하거나 튜닝이 필요할 땐 <strong>더 유리</strong></p>

<hr />

<h2 id="-사용-방식-차이-요약">✅ 사용 방식 차이 요약</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>JPA</th>
      <th>MyBatis</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SQL 작성</td>
      <td>❌ 안 함 (자동)</td>
      <td>✅ 직접 함</td>
    </tr>
    <tr>
      <td>객체 ↔ DB 매핑</td>
      <td>자동 처리</td>
      <td>명시적 지정</td>
    </tr>
    <tr>
      <td>코드 양</td>
      <td>적음</td>
      <td>많음</td>
    </tr>
    <tr>
      <td>유지보수</td>
      <td>테이블 구조 바뀌면 자동 적용</td>
      <td>SQL 전부 수정해야 함</td>
    </tr>
    <tr>
      <td>복잡한 쿼리</td>
      <td>어려움 (JPQL, QueryDSL)</td>
      <td>자유롭고 세밀하게 가능</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-장단점-비교">✅ 장단점 비교</h2>

<h3 id="-jpa의-장점">🟢 JPA의 장점</h3>

<ul>
  <li>생산성 높음 (코드 적게 작성)</li>
  <li>객체 지향적으로 설계 가능</li>
  <li>유지보수 편함 (쿼리 덜 바꿈)</li>
  <li>캐싱, 지연 로딩, 영속성 컨텍스트 등 부가기능 풍부</li>
</ul>

<hr />

<h3 id="-jpa의-단점">🔴 JPA의 단점</h3>

<ul>
  <li>처음 배울 때 어렵고 추상화가 깊음</li>
  <li>성능 튜닝 어려움</li>
  <li>복잡한 쿼리 작성이 불편함 (<code class="language-plaintext highlighter-rouge">JOIN</code>, <code class="language-plaintext highlighter-rouge">GROUP BY</code> 등)</li>
</ul>

<hr />

<h3 id="-mybatis의-장점">🟢 MyBatis의 장점</h3>

<ul>
  <li>SQL을 자유롭게 짤 수 있어 → DB 성능 튜닝 유리</li>
  <li>복잡한 쿼리나 데이터 조작에 강함</li>
  <li>개발자 컨트롤이 높음</li>
</ul>

<hr />

<h3 id="-mybatis의-단점">🔴 MyBatis의 단점</h3>

<ul>
  <li>반복 코드 많음 (SQL + 매핑 따로)</li>
  <li>유지보수 힘듦 (테이블 구조 바뀌면 SQL 전부 바꿔야 함)</li>
  <li>객체 지향 구조 만들기 어렵고, 연결이 느슨함</li>
</ul>

<hr />

<h2 id="-실무에-쓰는-방법">✅ 실무에 쓰는 방법</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>실무 선택</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>단순한 CRUD 위주의 서비스</td>
      <td>JPA (빠르고 코드 간결)</td>
    </tr>
    <tr>
      <td>복잡한 SQL 다루는 시스템</td>
      <td>MyBatis</td>
    </tr>
    <tr>
      <td>대기업/공공 시스템</td>
      <td>아직도 MyBatis 많음</td>
    </tr>
    <tr>
      <td>스타트업/신규 프로젝트</td>
      <td>JPA + QueryDSL 조합 인기</td>
    </tr>
    <tr>
      <td>둘 다 필요</td>
      <td>일부는 JPA, 일부는 MyBatis 혼용 (실제로 많음)</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-한줄-정리">📌 한줄 정리</h2>

<blockquote>
  <p>“JPA는 객체 중심의 ORM 프레임워크로, DB와의 데이터 처리를 추상화해 코드 생산성을 높여줍니다. 반면 MyBatis는 SQL 중심의 프레임워크로, 복잡한 쿼리나 성능 튜닝이 필요한 경우에 유리합니다. 프로젝트 성격에 따라 두 기술을 선택하거나 병행할 수 있습니다.”</p>
</blockquote>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[스프링 프레임워크의 주요 개념(IoC, DI, Bean, AOP, PSA)을 간략히 설명한 포스트입니다.]]></summary></entry><entry><title type="html">[Spring] DTO vs VO vs Entity</title><link href="https://nan0silver.github.io/spring/2025-04-02-dto-vo/" rel="alternate" type="text/html" title="[Spring] DTO vs VO vs Entity" /><published>2025-04-02T00:00:00+00:00</published><updated>2025-04-08T12:28:34+00:00</updated><id>https://nan0silver.github.io/spring/dto-vo</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-02-dto-vo/"><![CDATA[<ul>
  <li><a href="#dto-vs-vo-vs-entity">DTO vs VO vs Entity</a></li>
  <li><a href="#-dto-vs-vo">📦 DTO vs VO</a></li>
  <li><a href="#-entity-vs-vo">📦 Entity vs VO</a></li>
  <li><a href="#-entity와-dto로-분리해야하는-이유">📦 Entity와 DTO로 분리해야하는 이유</a></li>
  <li><a href="#코드-예제">코드 예제</a></li>
  <li><a href="#-면접-시-설명-예시">💬 면접 시 설명 예시</a></li>
  <li><a href="#-java-17부터는-record로-vo를-만들기-더-쉬워짐">🚀 Java 17부터는 <code class="language-plaintext highlighter-rouge">record</code>로 VO를 만들기 더 쉬워짐!</a></li>
</ul>

<hr />

<h2 id="dto-vs-vo-vs-entity">DTO vs VO vs Entity</h2>

<blockquote>
  <p>Entity는 DB와 매핑되는 핵심 객체, DTO는 데이터 전달용 객체, VO는 값 자체에 의미가 있는 불변 객체
Entity는 저장용, DTO는 전달용, VO는 표현용 객체</p>
</blockquote>

<ul>
  <li>
    <p>DTO : Data Transfer Object ➡️ 데이터 전달용 객체 (계층 간, 네트워크 등)</p>

    <ul>
      <li>🚐 손님에게 배달될 포장된 도시락
        <ul>
          <li>음식점 → 배달기사 → 고객까지 전달하는 용도
            <ul>
              <li>💡 클라이언트와 데이터 주고받는 운반용 객체! 💡</li>
            </ul>
          </li>
          <li>메뉴명, 수량, 요청사항 등 담겨 있고, 전달 중에 수정될 수도 있음 (상황에 따라 포장을 다르게 담을 수 있다.)</li>
        </ul>
      </li>
      <li>외부에 노출되는 API요청이나 응답은 Entity가 아닌 DTO를 통해 전달함으로써 보안성과 유연성을 확보</li>
    </ul>

    <blockquote>
      <p>🔴 DTO는 데이터를 <strong>“옮기는 상자”</strong></p>
    </blockquote>
  </li>
  <li>
    <p>VO : Value Object ➡️ 값을 표현하는 객체 (의미 있는 불변 값)</p>

    <ul>
      <li>🍱 도시락 자체
        <ul>
          <li>만들어지면 바꿀 수 없음 (불변)</li>
          <li>메뉴가 같으면 같은 도시락 취급</li>
          <li>값 자체가 의미 있음 - 예: 좌표, 돈, 날짜, 주소 등</li>
        </ul>
      </li>
    </ul>

    <blockquote>
      <p>🔴 VO는 의미 있는 값을 담은 <strong>“정체성 있는 객체”</strong></p>

      <blockquote>
        <p>“무엇을 나타내는 값인지”가 중요한 객체</p>
      </blockquote>
    </blockquote>
  </li>
  <li>
    <p>Entity ➡️ 실제 DB 테이블과 연결된 핵심 객체</p>

    <ul>
      <li>🍱 도시락 안의 구성 요소 (밥, 반찬, 소스 등)
        <ul>
          <li>소중하기 때문에 주방 안에서만 써야 함</li>
        </ul>
      </li>
      <li>Entity는 VO를 포함할 수 있음</li>
      <li>DB와 직접 연결된 객체이기 때문에 식별자가 존재하며 상태가 바뀔 수 있음</li>
    </ul>

    <blockquote>
      <p>🔴 Entity는 “누구인지”를 <strong>식별할 수 있는 객체</strong></p>
    </blockquote>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/nan0silver/nan0silver.github.io/7ddb58f4af0e22814e7e85a4f7111495d9cd25eb/assets/img/blog/2025-04-02-dto-vo.png" alter="DTOvsVOvsEntity" /></p>

<h2 id="-dto-vs-vo">📦 DTO vs VO</h2>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>DTO</th>
      <th>VO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>목적</td>
      <td><strong>데이터 전달</strong></td>
      <td><strong>값 표현</strong></td>
    </tr>
    <tr>
      <td>가변성</td>
      <td><strong>가변(mutable)</strong></td>
      <td><strong>불변(immutable)</strong></td>
    </tr>
    <tr>
      <td>equals/hashCode 기준</td>
      <td>주소 (기본)</td>
      <td><strong>값 기준으로 재정의</strong></td>
    </tr>
    <tr>
      <td>주 사용 위치</td>
      <td>Controller ↔ Service ↔ API</td>
      <td>도메인 내부, 로직 내 값 처리</td>
    </tr>
    <tr>
      <td>예시</td>
      <td>회원 요청 객체, 응답 DTO 등</td>
      <td>Money, Address, Coordinate 등</td>
    </tr>
    <tr>
      <td>생성 시</td>
      <td>언제든 생성 가능</td>
      <td>생성 후에는 값 변경 ❌</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-entity-vs-vo">📦 Entity vs VO</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Entity</th>
      <th>VO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>의미</td>
      <td><strong>DB 테이블과 1:1 매핑되는 객체</strong></td>
      <td><strong>의미 있는 작은 값 단위 객체</strong></td>
    </tr>
    <tr>
      <td>식별자 (ID)</td>
      <td><strong>있음 (PK, 고유값)</strong></td>
      <td><strong>없음 (값 자체로 구별)</strong></td>
    </tr>
    <tr>
      <td>불변성</td>
      <td>보통 가변</td>
      <td><strong>보통 불변 (<code class="language-plaintext highlighter-rouge">final</code>)</strong></td>
    </tr>
    <tr>
      <td>관리 위치</td>
      <td>DB와 연결되는 핵심 모델</td>
      <td>Entity 안의 필드나 계산용 값</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-entity와-dto로-분리해야하는-이유">📦 Entity와 DTO로 분리해야하는 이유</h2>

<blockquote>
  <p>굳이 클래스를 2개로 나누지 않고 그냥 Entity 하나로 다 처리하면 안 되는 이유!</p>
</blockquote>

<ul>
  <li>구체적인 이유 5가지
    <ol>
      <li>보안
        <ul>
          <li>Entity에는 민감한 필드(비밀번호 등)가 있을 수 있음 ➡️ 그대로 외부에 노출하면 위험</li>
        </ul>
      </li>
      <li>유연성
        <ul>
          <li>API 요청/응답마다 필요한 필드가 다름 ➡️ DTO로 맞춤 설계 가능</li>
        </ul>
      </li>
      <li>엔티티 보호
        <ul>
          <li>DTO로 외부와 통신 ➡️ Entity는 내부에서만 안전하게 관리</li>
        </ul>
      </li>
      <li>유효성 검사 분리
        <ul>
          <li><code class="language-plaintext highlighter-rouge">@Valid</code>, <code class="language-plaintext highlighter-rouge">@NotNull</code>등 검증 로직은 DTO에만 적용
            <blockquote>
              <p>Entity는 DB와 연결된 순수한 모델이여야 함으로 비즈니스 룰, 요청 유효성 검증 같은 책임이 없어야 한다.</p>

              <blockquote>
                <p>JPA의 역할은 저장, 조회인데 검증 로직이 섞이면 책임이 뒤엉킴 (SRP(Single Responsibility Principle) 위반)</p>
              </blockquote>
            </blockquote>
          </li>
        </ul>
      </li>
      <li>레이어 분리 원칙
        <ul>
          <li>Controller ↔ Service ↔ Repository 역할 구분이 명확해짐
            <blockquote>
              <p>“Controller” : 클라이언트와 통신 (DTO 입출력)
“Service” : 비즈니스 로직 (DTO 🔁 Entity 변환, 로직 처리)
“Repository” : DB 접근 (Entity 전용)</p>

              <blockquote>
                <p>DTO와 Entity를 나누지 않고 Controller, Service에서 Entity를 직접 다루면</p>

                <ul>
                  <li>한 객체가 너무 많은 계층을 넘나듬 (의존성 얽힘)</li>
                  <li>책임이 명확하지 않음 (수정 시 어디를 고쳐야 할지 모름)</li>
                  <li>보안 이슈 발생 가능 (불필요한 필드 노출)</li>
                </ul>
              </blockquote>
            </blockquote>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<hr />

<h2 id="코드-예제">코드 예제</h2>

<h3 id="-dto-값-전달용-가변-객체">✅ DTO (값 전달용, 가변 객체)</h3>

<ul>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberDTO</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
      <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

      <span class="c1">// 생성자</span>
      <span class="kd">public</span> <span class="nf">MemberDTO</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
          <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="c1">// getter &amp; setter (값 변경 가능!)</span>
      <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>

      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>setName(), setAge()처럼 값은 변경 가능</li>
  <li>주로 Controller 🔁 Service 🔁 Client 간 데이터 전달용</li>
</ul>

<h3 id="-vo-값-표현용-불변-객체">✅ VO (값 표현용, 불변 객체)</h3>

<ul>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Money</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">;</span>

      <span class="kd">public</span> <span class="nf">Money</span><span class="o">(</span><span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">amount</span> <span class="o">=</span> <span class="n">amount</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAmount</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">amount</span><span class="o">;</span> <span class="o">}</span>

      <span class="c1">// 값 기반 equals, hashCode</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
          <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Money</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
          <span class="nc">Money</span> <span class="n">money</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Money</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
          <span class="k">return</span> <span class="n">amount</span> <span class="o">==</span> <span class="n">money</span><span class="o">.</span><span class="na">amount</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">amount</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>필드가 <code class="language-plaintext highlighter-rouge">final</code>, setter없음 → 불변 객체</li>
  <li>equals() 재정의 → 값이 같으면 같은 객체로 간주</li>
  <li>주로 비즈니스 로직 내부에서 의미 있는 값 표현용</li>
</ul>

<h3 id="-entity">✅ Entity</h3>

<ul>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>  <span class="c1">// 노출되면 안 되는 정보</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="-면접-시-설명-예시">💬 면접 시 설명 예시</h2>

<blockquote>
  <p>“DTO는 계층 간 데이터를 전달할 때 사용하는 객체로, 보통 가변이고 네트워크나 컨트롤러에 노출됩니다. 반면 VO는 불변 객체로, 값 자체가 의미를 가지며 equals와 hashCode를 통해 같은 값을 같다고 간주해 도메인 모델 내에서 활용됩니다. Entity는 DB와 직접 연결된 객체로 식별자가 존재하며 상태가 바뀔 수 있습니다. 외부에 노출되는 API 요청이나 응답은 Entity가 아닌 DTO를 통해 전달함으로써 보안성과 유연성을 확보할 수 있습니다.”</p>
</blockquote>

<hr />

<h2 id="-java-17부터는-record로-vo를-만들기-더-쉬워짐">🚀 Java 17부터는 <code class="language-plaintext highlighter-rouge">record</code>로 VO를 만들기 더 쉬워짐!</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">Coordinate</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">final</code>, 불변성, equals/hashCode 자동 구현!</li>
  <li><strong>값 객체(VO)</strong>를 표현할 때 <strong>record는 아주 강력한 도구</strong></li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[Spring에서 데이터를 다루는 객체인 DTO, VO, Entity의 차이점에 대해 알아보자.]]></summary></entry><entry><title type="html">[Spring] RestTemplate</title><link href="https://nan0silver.github.io/spring/2025-04-01-resttemplate/" rel="alternate" type="text/html" title="[Spring] RestTemplate" /><published>2025-04-01T00:00:00+00:00</published><updated>2025-04-08T12:28:34+00:00</updated><id>https://nan0silver.github.io/spring/resttemplate</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-01-resttemplate/"><![CDATA[<ul>
  <li><a href="#-resttemplate이란">RestTemplate이란?</a></li>
  <li><a href="#-필요한-이유">필요한 이유</a></li>
  <li><a href="#️-예시-코드-get-요청">예시 코드 (Get)</a></li>
  <li><a href="#-주요-메서드들">주요 메서드들</a></li>
  <li><a href="#-응답을-객체로-받기-json--java-객체">응답을 객체로 받기 (JSON → Java 객체)</a></li>
  <li><a href="#-resttemplate-vs-webclient-핵심-비교"><code class="language-plaintext highlighter-rouge">RestTemplate</code> vs <code class="language-plaintext highlighter-rouge">WebClient</code> 핵심 비교</a></li>
  <li><a href="#-코드로-비교">코드로 비교</a></li>
  <li><a href="#-결론-언제-뭘-쓰면-좋을까">결론: 언제 뭘 쓰면 좋을까?</a></li>
</ul>

<hr />

<h2 id="-resttemplate이란">✅ RestTemplate이란?</h2>

<p><code class="language-plaintext highlighter-rouge">RestTemplate</code>은 <strong>Spring에서 다른 서버의 REST API와 통신할 수 있도록 도와주는 HTTP 클라이언트</strong>.</p>

<p>즉, 서버끼리 통신할 때:</p>

<ul>
  <li>다른 서버에 요청을 보내고(<code class="language-plaintext highlighter-rouge">GET</code>, <code class="language-plaintext highlighter-rouge">POST</code>, <code class="language-plaintext highlighter-rouge">PUT</code>, <code class="language-plaintext highlighter-rouge">DELETE</code> 등),</li>
  <li>그 응답을 받아서 처리할 수 있도록 도와주는 <strong>도구</strong></li>
</ul>

<hr />

<h2 id="-필요한-이유">🧠 필요한 이유</h2>

<p>웹 애플리케이션을 만들다 보면,</p>

<ul>
  <li>다른 서버에 있는 데이터를 가져오거나 (예: Kakao Map API, 날씨 API)</li>
  <li>다른 서버에 정보를 보내야 할 때</li>
</ul>

<p>이때 <code class="language-plaintext highlighter-rouge">RestTemplate</code>이 <strong>HTTP 요청/응답을 대신 처리</strong>해주는 역할을 함.</p>

<hr />

<h2 id="️-예시-코드-get-요청">⚙️ 예시 코드 (GET 요청)</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.web.client.RestTemplate</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Example</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">RestTemplate</span> <span class="n">restTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RestTemplate</span><span class="o">();</span>

        <span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"https://api.agify.io/?name=seongwoo"</span><span class="o">;</span>  <span class="c1">// 이름을 넣으면 예상 나이를 알려주는 무료 API</span>
        <span class="nc">String</span> <span class="n">response</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">response</span><span class="o">);</span>
        <span class="c1">// 출력 예: {"name":"seongwoo","age":27,"count":1123}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">getForObject()</code>는 <code class="language-plaintext highlighter-rouge">GET</code> 요청을 보내고, 결과를 <code class="language-plaintext highlighter-rouge">String</code> 타입으로 받아오는 함수.</p>

<hr />

<h2 id="-주요-메서드들">🔧 주요 메서드들</h2>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">getForObject()</code></td>
      <td>GET 요청 후, 결과를 객체로 받음</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">getForEntity()</code></td>
      <td>GET 요청 후, 전체 응답(ResponseEntity) 받음</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">postForObject()</code></td>
      <td>POST 요청 후, 결과를 객체로 받음</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">postForEntity()</code></td>
      <td>POST 요청 후, 전체 응답 받음</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">put()</code></td>
      <td>PUT 요청 (응답 없음)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">delete()</code></td>
      <td>DELETE 요청</td>
    </tr>
  </tbody>
</table>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-04-01-spring-resttemplate.png?raw=true" /></p>

<hr />

<h2 id="-응답을-객체로-받기-json--java-객체">📦 응답을 객체로 받기 (JSON → Java 객체)</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AgifyResponse</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>

    <span class="c1">// 꼭! Getter/Setter 만들어줘야 함 (Lombok 써도 됨)</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RestTemplate</span> <span class="n">restTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RestTemplate</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"https://api.agify.io/?name=seongwoo"</span><span class="o">;</span>

<span class="nc">AgifyResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="nc">AgifyResponse</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">getAge</span><span class="o">());</span>  <span class="c1">// 예: 27</span>
</code></pre></div></div>

<p>→ JSON 데이터를 Java 객체로 자동으로 바꿔줌! (<code class="language-plaintext highlighter-rouge">Jackson</code> 같은 라이브러리를 내부에서 사용함)</p>

<hr />

<h2 id="-resttemplate-특징-요약">💡 RestTemplate 특징 요약</h2>

<ul>
  <li>동기 방식이다 (요청을 보내고 응답 올 때까지 기다림)</li>
  <li>간단한 API 호출엔 유용하지만, <strong>요즘은 WebClient 사용이 증가</strong> (비동기 처리, reactive 프로그래밍에 적합)</li>
  <li>Spring 5 이후로는 <code class="language-plaintext highlighter-rouge">RestTemplate</code>은 <strong>점점 deprecated 방향</strong>이지만, 여전히 많이 사용됨</li>
</ul>

<hr />

<h2 id="-resttemplate-vs-webclient-핵심-비교">🆚 <code class="language-plaintext highlighter-rouge">RestTemplate</code> vs <code class="language-plaintext highlighter-rouge">WebClient</code> 핵심 비교</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>RestTemplate</th>
      <th>WebClient</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>방식</td>
      <td><strong>동기(Synchronous)</strong></td>
      <td><strong>비동기(Asynchronous)</strong> (동기도 가능)</td>
    </tr>
    <tr>
      <td>등장 시기</td>
      <td>오래됨 (Spring 3.x부터)</td>
      <td>최신 (Spring 5, WebFlux부터 등장)</td>
    </tr>
    <tr>
      <td>쓰레드 처리</td>
      <td>요청 → 응답 올 때까지 <strong>쓰레드 점유</strong></td>
      <td>응답 기다리는 동안 <strong>쓰레드 반환</strong>, 더 효율적</td>
    </tr>
    <tr>
      <td>성능</td>
      <td>단순 요청에는 충분</td>
      <td>고성능 시스템, MSA에서 더 좋음</td>
    </tr>
    <tr>
      <td>사용성</td>
      <td>코드가 간단하고 직관적</td>
      <td>비동기라 처음엔 약간 복잡할 수 있음</td>
    </tr>
    <tr>
      <td>미래 방향</td>
      <td><strong>Deprecated 예정</strong> (Spring 6에서는 제거될 수 있음)</td>
      <td>Spring이 권장하는 <strong>표준 방식</strong></td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-코드로-비교">🔧 코드로 비교</h2>

<h3 id="1️⃣-resttemplate-예시-동기">1️⃣ RestTemplate 예시 (동기)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RestTemplate</span> <span class="n">restTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RestTemplate</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"https://api.agify.io/?name=seongwoo"</span><span class="o">;</span>

<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</code></pre></div></div>

<p>→ 응답이 올 때까지 <strong>기다림</strong>. 동기 처리.</p>

<hr />

<h3 id="2️⃣-webclient-예시-비동기--동기화-처리-가능">2️⃣ WebClient 예시 (비동기 + 동기화 처리 가능)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.web.reactive.function.client.WebClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">reactor.core.publisher.Mono</span><span class="o">;</span>

<span class="nc">WebClient</span> <span class="n">webClient</span> <span class="o">=</span> <span class="nc">WebClient</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"https://api.agify.io/?name=seongwoo"</span><span class="o">;</span>

<span class="c1">// 비동기 방식 → block()을 붙이면 동기처럼 동작</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">webClient</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
        <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">url</span><span class="o">)</span>
        <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
        <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
        <span class="o">.</span><span class="na">block</span><span class="o">();</span>  <span class="c1">// 이게 바로 응답 받을 때까지 기다리는 코드 (동기화)</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</code></pre></div></div>

<p>→ WebClient는 원래 비동기지만, <code class="language-plaintext highlighter-rouge">.block()</code>을 붙이면 동기처럼 사용할 수도 있음.</p>

<hr />

<h2 id="-비동기-방식으로-진짜-쓰고-싶다면">💬 비동기 방식으로 진짜 쓰고 싶다면?</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">webClient</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">url</span><span class="o">)</span>
    <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
    <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">result</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"결과: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">});</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"여긴 먼저 실행됨!"</span><span class="o">);</span>  <span class="c1">// 비동기니까 이게 먼저 출력될 수도 있음</span>
</code></pre></div></div>

<hr />

<h2 id="-결론-언제-뭘-쓰면-좋을까">✅ 결론: 언제 뭘 쓰면 좋을까?</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>추천</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>간단한 테스트, 외부 API 한두 번 호출할 때</td>
      <td>RestTemplate (빠르게 개발 가능)</td>
    </tr>
    <tr>
      <td>마이크로서비스 간 통신, 대용량 처리, reactive 시스템</td>
      <td>WebClient (성능과 확장성 좋음)</td>
    </tr>
    <tr>
      <td>Spring 5 이상 + 새로운 프로젝트</td>
      <td>WebClient를 사용하는 게 <strong>미래지향적</strong></td>
    </tr>
  </tbody>
</table>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[Spring에서 다른 서버의 REST API와 통신할 수 있도록 도와주는 HTTP 클라이언트인 RestTemplate에 대해 알아보자.]]></summary></entry><entry><title type="html">[Etc] 💣 SQL Injection</title><link href="https://nan0silver.github.io/miscellaneous/2025-03-31-sql-injection/" rel="alternate" type="text/html" title="[Etc] 💣 SQL Injection" /><published>2025-03-31T00:00:00+00:00</published><updated>2025-04-08T12:28:34+00:00</updated><id>https://nan0silver.github.io/miscellaneous/sql-injection</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-03-31-sql-injection/"><![CDATA[<ul>
  <li><a href="#sql-injection이란">SQL Injection이란?</a></li>
  <li><a href="#-spring-관점에서-sql-injection-방지법">Spring 관점에서 SQL Injection 방지법</a></li>
  <li><a href="#-spring-배우는-입장에서-조심할-포인트-요약">요약</a></li>
</ul>

<hr />

<h2 id="sql-injection이란">SQL Injection이란?</h2>

<blockquote>
  <p><strong>SQL Injection</strong>이란, 사용자가 입력한 값을 통해 <strong>원래 의도하지 않은 SQL문을 실행하게 만들어</strong><br />
<strong>데이터베이스의 데이터를 탈취하거나 조작하는 공격</strong></p>
</blockquote>

<h3 id="-예시-spring-쓰기-전-일반-jdbc-코드-기준">🔍 예시 (Spring 쓰기 전 일반 JDBC 코드 기준):</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"SELECT * FROM users WHERE username = '"</span> <span class="o">+</span> <span class="n">username</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">;</span>
</code></pre></div></div>

<p>만약 <code class="language-plaintext highlighter-rouge">username</code>에 아래와 같은 값을 입력하면?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>' OR '1'='1
</code></pre></div></div>

<p>그러면 쿼리가 이렇게 바뀜:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users</span> <span class="k">WHERE</span> <span class="n">username</span> <span class="o">=</span> <span class="s1">''</span> <span class="k">OR</span> <span class="s1">'1'</span><span class="o">=</span><span class="s1">'1'</span>
</code></pre></div></div>

<p>→ 모든 유저 정보가 다 조회됨 😱<br />
→ 비밀번호 없이 로그인도 가능해짐</p>

<hr />

<h2 id="-spring-관점에서-sql-injection-방지법">🔐 Spring 관점에서 SQL Injection 방지법</h2>

<h3 id="-1-jdbc-직접-사용-시-preparedstatement-필수">✅ 1. <strong>JDBC 직접 사용 시: PreparedStatement 필수!</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"SELECT * FROM users WHERE username = ?"</span><span class="o">;</span>
<span class="nc">PreparedStatement</span> <span class="n">pstmt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
<span class="n">pstmt</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">username</span><span class="o">);</span>  <span class="c1">// 자동으로 문자열 escape 처리</span>
</code></pre></div></div>

<p>이렇게 하면 <code class="language-plaintext highlighter-rouge">' OR '1'='1</code> 같은 입력도 그냥 문자열로 인식되므로 안전하다.</p>

<hr />

<h3 id="-2-spring-jdbc-template-사용-시">✅ 2. <strong>Spring JDBC Template 사용 시</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"SELECT * FROM users WHERE username = ?"</span><span class="o">;</span>
<span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">queryForObject</span><span class="o">(</span><span class="n">sql</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="n">username</span><span class="o">},</span> <span class="n">userRowMapper</span><span class="o">);</span>
</code></pre></div></div>

<p>여기서도 <code class="language-plaintext highlighter-rouge">?</code>를 사용해서 바인딩하면 PreparedStatement가 적용되므로 안전하다.</p>

<hr />

<h3 id="-3-jpa--spring-data-jpa-사용-시">✅ 3. <strong>JPA / Spring Data JPA 사용 시</strong></h3>

<p>JPA는 SQL을 직접 작성하지 않고 엔티티 중심으로 데이터를 다루기 때문에 <strong>기본적으로 SQL Injection에 강함</strong>!</p>

<h4 id="-예시">🔸 예시:</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findByUsername</span><span class="o">(</span><span class="n">username</span><span class="o">);</span>
</code></pre></div></div>

<p>이런 방식은 내부적으로 PreparedStatement를 사용하기 때문에 안전함.</p>

<h4 id="-커스텀-jpql-사용-시에도-파라미터-바인딩-필수">🔸 커스텀 JPQL 사용 시에도 파라미터 바인딩 필수!</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Query</span><span class="o">(</span><span class="s">"SELECT u FROM User u WHERE u.username = :username"</span><span class="o">)</span>
<span class="nc">User</span> <span class="nf">findByUsername</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">"username"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">username</span><span class="o">);</span>
</code></pre></div></div>

<p>✅ <code class="language-plaintext highlighter-rouge">:username</code> 형태로 파라미터 바인딩하면 OK<br />
❌ 아래처럼 문자열 직접 연결하면 위험:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Query</span><span class="o">(</span><span class="s">"SELECT u FROM User u WHERE u.username = '"</span> <span class="o">+</span> <span class="n">username</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">)</span>
</code></pre></div></div>

<hr />

<h2 id="-spring-배우는-입장에서-조심할-포인트-요약">🚨 Spring 배우는 입장에서 조심할 포인트 요약</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>안전한 방법</th>
      <th>주의할 점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>JDBC 직접 사용</td>
      <td><code class="language-plaintext highlighter-rouge">PreparedStatement</code></td>
      <td>문자열 직접 연결 ❌</td>
    </tr>
    <tr>
      <td>JdbcTemplate</td>
      <td><code class="language-plaintext highlighter-rouge">?</code> 자리 바인딩 사용</td>
      <td>쿼리 조합 ❌</td>
    </tr>
    <tr>
      <td>JPA / Spring Data JPA</td>
      <td>파라미터 바인딩 (<code class="language-plaintext highlighter-rouge">:param</code>)</td>
      <td>JPQL 문자열 직접 붙이기 ❌</td>
    </tr>
    <tr>
      <td>QueryDSL</td>
      <td>완전 안전 (타입 기반 쿼리)</td>
      <td>-</td>
    </tr>
    <tr>
      <td>사용자 입력값 처리</td>
      <td>입력 검증, 길이 제한</td>
      <td>필터 없이 바로 사용 ❌</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-마무리-요약">🎯 마무리 요약</h2>

<ul>
  <li>SQL Injection = <strong>사용자가 입력한 값을 통해 악성 SQL 실행</strong></li>
  <li>Spring에서는 기본적으로 <strong>PreparedStatement</strong> 방식이므로 잘 쓰면 안전함</li>
  <li>하지만 <strong>직접 쿼리 짜거나, 문자열로 SQL을 조합</strong>하는 경우 주의!</li>
  <li><strong>ORM(JPA) + 파라미터 바인딩</strong> 방식으로 작성하면 거의 대부분 안전하게 막을 수 있음</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[악의적인 사용자가 SQL 쿼리에 코드를 삽입해 DB정보를 탈취하거나 조작하는 것을 뜻하는 SQL Injection에 대해 알아보자.]]></summary></entry><entry><title type="html">[Algorithm] 소수 빠르게 찾는 법</title><link href="https://nan0silver.github.io/algorithm/2025-03-20-is-prime/" rel="alternate" type="text/html" title="[Algorithm] 소수 빠르게 찾는 법" /><published>2025-03-20T00:00:00+00:00</published><updated>2025-04-08T12:28:34+00:00</updated><id>https://nan0silver.github.io/algorithm/is-prime</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2025-03-20-is-prime/"><![CDATA[<ol>
  <li><a href="#1️⃣-기본-소수-판별-on">기본 소수 판별</a></li>
  <li><a href="#2️⃣-에라토스테네스의-체-on-log-log-n">에라토스테네스의 체</a></li>
  <li><a href="#3️⃣-miller-rabin-소수판별법-olog-n">Miller-Rabin 소수 판별법</a></li>
</ol>

<hr />

<h2 id="1️⃣-기본-소수-판별-on">1️⃣ 기본 소수 판별 (O(√N))</h2>

<ul>
  <li>어떤 숫자 N이 소수인지 판별하는 가장 기본적인 방법은 1과 자기 자신을 제외한 다른 수로 나누어떨어지는지 확인하는 것</li>
  <li>🔥 2부터 √N까지 나누어보자!
    <ul>
      <li>소수가 아니라면 작은 약수를 가지고 있기 때문</li>
    </ul>
  </li>
  <li>코드 예제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrimeCheck</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">n</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">29</span><span class="o">));</span> <span class="c1">//true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span> <span class="c1">//false</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="2️⃣-에라토스테네스의-체-on-log-log-n">2️⃣ 에라토스테네스의 체 (O(N log log N))</h2>

<blockquote>
  <p>여러 개의 소수를 빠르게 찾는 방법</p>
</blockquote>

<ul>
  <li>1부터 N까지의 수 중에서 소수를 모두 찾아야 하는 경우</li>
  <li>🔥 방법
    <ol>
      <li>2부터 시작해서 배수들을 모두 제거</li>
      <li>남은 수들만 소수로 판별</li>
    </ol>
  </li>
  <li>장점
    <ul>
      <li>한 번 계산해 두면 특정 범위 내에서 빠르게 소수 여부를 판별할 수 있음.</li>
    </ul>
  </li>
  <li>코드 예제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SieveOfEratosthenes</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">sieveOfEratosthenes</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">isPrime</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">isPrime</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="n">isPrime</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">isPrime</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isPrime</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">isPrime</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">//소수 리스트 생성</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="3️⃣-miller-rabin-소수판별법-olog-n">3️⃣ Miller-Rabin 소수판별법 (O(log N))</h2>

<blockquote>
  <p>소수 판별이 자주 필요할 때</p>
</blockquote>

<ul>
  <li>N이 엄청 크면 밀러-라빈 소수판별법을 사용해야함
    <ul>
      <li>10^18이상의 큰 수가 소수인지 판별할 때</li>
      <li>암후학, 해시 관련 문제에서 사용</li>
    </ul>
  </li>
  <li>🔥 확률적 알고리즘</li>
  <li>코드 예제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MillerRabin</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// k는 테스트 횟수</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="c1">// n - 1 = 2^r * d 형태로 변환</span>
        <span class="kt">long</span> <span class="n">d</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">d</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">r</span><span class="o">++;</span>
            <span class="n">d</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>

        <span class="c1">// Miller-Rabin 테스트 실행</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextLong</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">3</span><span class="o">);</span> <span class="c1">// 2 ≤ a ≤ n-2</span>
            <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="n">powerMod</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// x = a^d % n</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>

            <span class="kt">boolean</span> <span class="n">isComposite</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">powerMod</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// x = x^2 % n</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">isComposite</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">isComposite</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 합성수 판별</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// 소수 판별</span>
    <span class="o">}</span>

    <span class="c1">// (base^exp) % mod 연산 (빠른 거듭제곱)</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">powerMod</span><span class="o">(</span><span class="kt">long</span> <span class="n">base</span><span class="o">,</span> <span class="kt">long</span> <span class="n">exp</span><span class="o">,</span> <span class="kt">long</span> <span class="n">mod</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">base</span> <span class="o">%=</span> <span class="n">mod</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">exp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">exp</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 홀수 지수 처리</span>
                <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">result</span> <span class="o">*</span> <span class="n">base</span><span class="o">)</span> <span class="o">%</span> <span class="n">mod</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">base</span> <span class="o">=</span> <span class="o">(</span><span class="n">base</span> <span class="o">*</span> <span class="n">base</span><span class="o">)</span> <span class="o">%</span> <span class="n">mod</span><span class="o">;</span> <span class="c1">// 제곱</span>
            <span class="n">exp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 지수 나누기 2</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">15485863</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>  <span class="c1">// true (소수)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">1000000007</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span> <span class="c1">// true (소수)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="mi">1000000008</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span> <span class="c1">// false (합성수)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[소수를 빠르게 효율적으로 찾는 방법 3가지를 알아보자]]></summary></entry><entry><title type="html">[Etc] 🤖 Layered Architecture &amp;amp; MVC pattern</title><link href="https://nan0silver.github.io/miscellaneous/2025-03-17-layered-architecture/" rel="alternate" type="text/html" title="[Etc] 🤖 Layered Architecture &amp;amp; MVC pattern" /><published>2025-03-17T00:00:00+00:00</published><updated>2025-04-08T12:28:34+00:00</updated><id>https://nan0silver.github.io/miscellaneous/layered-architecture</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-03-17-layered-architecture/"><![CDATA[<ul>
  <li><a href="#레이어드-아키텍쳐layered-architecture란">레이어드 아키텍쳐(Layered Architecture)란?</a></li>
  <li><a href="#mvc란">MVC란?</a></li>
  <li><a href="#레이어드-아키텍쳐와-mvc를-함께-사용">레이어드 아키텍쳐와 MVC를 함께 사용</a></li>
</ul>

<hr />

<h2 id="레이어드-아키텍쳐layered-architecture란">레이어드 아키텍쳐(Layered Architecture)란?</h2>

<ul>
  <li>여러 수평 레이어가 수직적으로 쌓인 구조 (상위 레이어에서 하위 레이어로 단방향 의존성)</li>
  <li>
    <p>각 계층이 명확한 역할을 가지며, 하위 계층만 접근할 수 있도록 설계하여 유지보수성과 확장성을 높이는 것이 목적</p>

    <ol>
      <li>
        <p>Presentation Layer (프레젠테이션 계층) : 1층로비, 방문객 맞이하고 안내</p>

        <blockquote>
          <p>예시: Spring Boot의 <code class="language-plaintext highlighter-rouge">Controller</code></p>
        </blockquote>

        <ul>
          <li><strong>사용자와 직접 상호작용</strong>하는 계층 (예: 웹 UI, API 컨트롤러)</li>
          <li>사용자의 입력을 받아 <strong>비즈니스 로직을 호출</strong>하고, 응답을 반환</li>
        </ul>
      </li>
      <li>Business Logic Layer (비즈니스 로직 계층) : 실제 회사 업무 설계 및 규칙 수립
        <blockquote>
          <p>예시: Spring Boot의 <code class="language-plaintext highlighter-rouge">Service</code></p>
        </blockquote>
        <ul>
          <li>핵심 비즈니스 로직을 처리하는 계층</li>
          <li>도메인 규칙을 적용하여 데이터 검증 및 가공 수행</li>
        </ul>
      </li>
      <li>Data Access Layer (데이터 접근 계층) : 비즈니스 레이어의 명령 실행
        <blockquote>
          <p>예시: Spring Boot의 <code class="language-plaintext highlighter-rouge">Repository</code></p>
        </blockquote>
        <ul>
          <li>데이터베이스와 직접 상호작용하는 계층</li>
          <li>DAO(Repository)를 통해 데이터를 저장하고 조회하는 역할</li>
        </ul>
      </li>
      <li>Database Layer (데이터베이스 계층) : 필요한 정보 저장 및 검색
        <ul>
          <li>실제 데이터를 저장하는 <strong>물리적 데이터베이스</strong> (MySQL, PostgreSQL 등)</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>데이터 흐름
    <ul>
      <li>요청 → 컨트롤러 → 서비스 → 레포지토리</li>
    </ul>
  </li>
  <li>사용 이유
    <ul>
      <li><strong>모듈화:</strong> 각 레이어가 독립적이라 변경 사항이 영향을 최소화</li>
      <li><strong>유지보수성:</strong> 비즈니스 로직(Service)과 DB 접근(Repository)을 분리</li>
      <li><strong>테스트 용이:</strong> 단위 테스트 작성이 쉬움 (ex: Service 레이어만 Mock 테스트 가능)</li>
    </ul>
  </li>
</ul>

<h3 id="레이어-간-관계">레이어 간 관계</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[클라이언트]
    ↓
[Presentation Layer]  →  Controller
    ↓
[Business Logic Layer]  →  Service
    ↓
[Data Access Layer]  →  Repository (DAO)
    ↓
[Database Layer]  →  DB (MySQL, PostgreSQL)
</code></pre></div></div>

<ul>
  <li>상위 계층(Presentation)은 <strong>하위 계층(Business Logic)만 호출</strong>할 수 있음.</li>
  <li>데이터베이스 관련 로직이 <strong>비즈니스 로직과 분리</strong>되어 유지보수가 쉬움.</li>
</ul>

<hr />

<h2 id="mvc란">MVC란?</h2>

<ul>
  <li>Model-View-Controller
    <ul>
      <li>Model : 요리사가 실제 음식을 준비하고 만드는 작업</li>
      <li>View : 음식의 플레이팅</li>
      <li>Controller : 고객의 주문을 받고, 요리사에게 전달하여 완성된 요리를 테이블에 서빙 (백엔드)</li>
      <li>3개의 요소가 유기적으로 협력</li>
    </ul>
  </li>
  <li>사용자 인터페이스와 비즈니스 로직 분리</li>
  <li>데이터 흐름
    <ul>
      <li>요청 → 컨트롤러 → 모델 → 뷰</li>
    </ul>
  </li>
  <li>사용 이유
    <ul>
      <li><strong>역할 분리:</strong> View, Model, Controller가 독립적으로 동작하여 유지보수 용이</li>
      <li><strong>유연한 확장:</strong> UI 변경(View)이나 비즈니스 로직(Model)을 따로 수정 가능</li>
      <li><strong>재사용성 증가:</strong> 같은 Model을 여러 View에서 사용 가능</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-03-17-image.png?raw=true" alt="Layered Architecture &amp; MVC pattern" /></p>

<h2 id="레이어드-아키텍쳐와-mvc를-함께-사용">레이어드 아키텍쳐와 MVC를 함께 사용</h2>

<ul>
  <li><strong>둘을 함께 사용하면 유지보수성과 확장성이 좋아진다.</strong>
    <ul>
      <li><strong>Controller는 최대한 가볍게 (Thin Controller, Fat Service)</strong></li>
      <li><strong>비즈니스 로직은 Service Layer에서 처리 (SRP 원칙 준수)</strong></li>
    </ul>
  </li>
</ul>

<h3 id="둘을-함께-사용했을-때-관계-흐름-요청--응답">둘을 함께 사용했을 때 관계 흐름 (요청 → 응답)</h3>

<ol>
  <li>사용자 (Client) 가 요청을 보냄</li>
  <li>Controller (입력 처리, 요청 매핑)</li>
  <li>Service (비즈니스 로직 처리)</li>
  <li>Repository (데이터베이스 접근)</li>
  <li>Service → Controller 로 응답 반환</li>
  <li>Controller → View (또는 JSON)</li>
</ol>

<ul>
  <li>MVC는 역할을 분리하고, 레이어드 아키텍처는 각 계층을 더 체계적으로 조직화하여 유지보수성과 확장성을 높인다</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[레이어드 아키텍쳐와 MVC 패턴에 대해 알아보자.]]></summary></entry><entry><title type="html">[JAVA] 동시성 처리 (Concurrency)</title><link href="https://nan0silver.github.io/java/2025-03-09-concurrency/" rel="alternate" type="text/html" title="[JAVA] 동시성 처리 (Concurrency)" /><published>2025-03-09T00:00:00+00:00</published><updated>2025-04-08T12:28:34+00:00</updated><id>https://nan0silver.github.io/java/concurrency</id><content type="html" xml:base="https://nan0silver.github.io/java/2025-03-09-concurrency/"><![CDATA[<ul>
  <li><a href="#java에서-동시성">JAVA에서 동시성</a></li>
  <li><a href="#스레드-thread">스레드 (Thread)</a></li>
  <li><a href="#비동기-처리-async">비동기 처리 (Aysnc)</a></li>
  <li><a href="#분산-처리-distributed">분산 처리 (Distribute)</a></li>
  <li><a href="#핵심-키워드-및-정리">핵심 키워드 및 정리</a></li>
</ul>

<hr />

<h2 id="java에서-동시성">JAVA에서 동시성</h2>

<ul>
  <li>여러 작업을 동시에 겹쳐서 처리하는 것</li>
  <li>한 번에 여러 일을 수행하며 일의 효율성을 높임</li>
  <li>크게 3가지 관점에서 접근 가능하다.
    <ol>
      <li>스레드 (Thread)</li>
      <li>비동기 (Async)</li>
      <li>분산 (Distributed)</li>
    </ol>
  </li>
</ul>

<h2 id="스레드-thread">스레드 (Thread)</h2>

<ul>
  <li>스레드는 프로세스 내에서 실제 작업을 수행하는 작업 단위</li>
  <li>한 개의 프로그램(프로세스)은 여러 개의 스레드를 가질 수 있음</li>
  <li>멀티 스레드 (Multi-thread)
    <ul>
      <li>하나의 프로세스에서 여러 스레드를 동시에 실행하는 방식</li>
      <li>자바에서는 주로 JVM(Java Virtual Machine)이 여러 스레드를 관리해줌
        <ul>
          <li>ex) 웹 서버(Servlet, Spring)에서는 사용자 요청마다 별도의 스레드를 생성해서 동시에 많은 요청을 처리할 수 있게 함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>🔥 중요한 이유
    <ul>
      <li>효율성 향상
        <ul>
          <li>CPU 자원을 최대한 활용할 수 있음</li>
        </ul>
      </li>
      <li>응답성 향상
        <ul>
          <li>동시에 여러 요청을 처리할 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>하지만 최근 자바 프레임워크(Spring)는 스레드를 자동으로 관리해주기 때문에 개발자가 직접 스레드를 관리할 일이 많지 않음
    <ul>
      <li>JVM과 프레임워크가 이미 효율적으로 관리해줌</li>
    </ul>
  </li>
</ul>

<h2 id="비동기-처리-async">비동기 처리 (Async)</h2>

<ul>
  <li>비동기란 “요청을 보낸 뒤 결과를 기다리지 않고 다음 작업을 진행”하는 방식
    <ul>
      <li>동기 (Synchronous)
        <ul>
          <li>하나의 요청이 끝날 때까지 기다림</li>
        </ul>
      </li>
      <li>비동기 (Asynchronous)
        <ul>
          <li>요청이 처리되는 동안 다른 작업 수행</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>자바에서 비동기 처리를 지원하는 방법
    <ul>
      <li><code class="language-plaintext highlighter-rouge">CompletableFuture</code> : 자바 비동기 처리 클래스</li>
      <li>자바스크립트의 async/await와 비슷한 방식</li>
    </ul>
  </li>
  <li>🔥 중요한 이유
    <ul>
      <li>빠른 응답성
        <ul>
          <li>요청 처리 중에도 사용자가 대기하지 않고, 시스템의 다른 작업 수행 가능</li>
        </ul>
      </li>
      <li>높은 확장성
        <ul>
          <li>비동기 처리를 하면 서버가 많은 요청을 효율적으로 관리 가능</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="분산-처리-distributed">분산 처리 (Distributed)</h2>

<ul>
  <li>분산처리는 “하나의 서버가 아닌, 여러 대의 서버가 나누어서 작업을 처리하는 방식”
    <ul>
      <li>서버 하나만 운영하는 것부다 작은 여러 서버(클러스터)를 운영하면 비용이 줄어듬</li>
      <li>대규모 서비스나 성장한 서비스에서 자주 사용됨</li>
    </ul>
  </li>
  <li>분산 환경에서 자주 사용되는 기술
    <ul>
      <li>Redis
        <ul>
          <li>메모리 기반 데이터 저장소로, 분산락(Distributed Lock)울 구현할 때 사용</li>
          <li>예를 들어, 여러 서버가 하나의 데이터를 동시에 수정하지 못하게 관리하는 방식</li>
        </ul>
      </li>
      <li>Kafka
        <ul>
          <li>메시지 큐(Message Queue)로, 서버간 메시지를 주고받고, 작업을 순차적으로 처리할 때 사용됨</li>
        </ul>
      </li>
      <li>클러스터(Cluster)
        <ul>
          <li>여러 대의 서버가 협력하여 요청을 나누어 처리 (MSA와 비슷한 개념)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>🔥 중요한 이유
    <ul>
      <li>비용 효율성
        <ul>
          <li>큰 서버 하나보다 여러 작은 서버가 경제적</li>
        </ul>
      </li>
      <li>안정성 및 확장성
        <ul>
          <li>한 서버가 문제가 생기더라도 서비스는 계속 운영됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="핵심-키워드-및-정리">핵심 키워드 및 정리</h2>

<ol>
  <li>스레스 (Thread)</li>
</ol>

<ul>
  <li>멀티 스레드 -&gt; JVM, Servlet, Spring</li>
  <li>스레드는 직원이다. 회사(JVM, Servlet, Spring)가 직원(스레드)을 잘 관리하면, 일(요청 처리)이 효율적이다.</li>
</ul>

<ol>
  <li>비동기 (Async)</li>
</ol>

<ul>
  <li>CompletableFuture, async/await</li>
  <li>비동기는 배달앱이다. 주문을 넣고 기다리지 않고, 다음 일을 진행한다.</li>
</ul>

<ol>
  <li>분산처리 (Distributed)</li>
</ol>

<ul>
  <li>Redis, Kafka, 클러스터</li>
  <li>분산처리는 프랜차이즈이다. 큰 가게 하나보다 작은 여러 가게가 효율적이고 비용도 절감된다.</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="java" /><summary type="html"><![CDATA[동시성 처리에 관한 3가지 관점에 대해 이야기해보자.]]></summary></entry><entry><title type="html">[JAVA] record</title><link href="https://nan0silver.github.io/java/2025-03-09-record/" rel="alternate" type="text/html" title="[JAVA] record" /><published>2025-03-09T00:00:00+00:00</published><updated>2025-04-08T12:28:34+00:00</updated><id>https://nan0silver.github.io/java/record</id><content type="html" xml:base="https://nan0silver.github.io/java/2025-03-09-record/"><![CDATA[<ul>
  <li><a href="#-record란-java-14">record란?</a></li>
  <li><a href="#1️⃣-record의-특징">record의 특징</a></li>
  <li><a href="#2️⃣-기존-클래스-vs-record-비교">기존 클래스 vs record 비교</a></li>
  <li><a href="#3️⃣-record의-내부-동작">record 내부 동작</a></li>
  <li><a href="#4️⃣-record의-주요-기능">record 주요 기능</a></li>
  <li><a href="#5️⃣-record를-언제-사용할까">record 사용 방법</a></li>
  <li><a href="#6️⃣-정리">정리</a></li>
</ul>

<hr />

<h2 id="-record란-java-14"><strong>✅ <code class="language-plaintext highlighter-rouge">record</code>란? (Java 14+)</strong></h2>

<p><code class="language-plaintext highlighter-rouge">record</code>는 <strong>Java 14부터 도입된 새로운 클래스 유형</strong>으로, <strong>불변(immutable)한 데이터 객체를 간결하게 표현</strong>할 수 있도록 설계되었습니다.</p>

<p>👉 기존의 <strong>DTO(Data Transfer Object)</strong>, <strong>VO(Value Object)</strong> 등을 만들 때 <strong>코드를 대폭 줄여줍니다.</strong></p>

<hr />

<h2 id="1️⃣-record의-특징"><strong>1️⃣ <code class="language-plaintext highlighter-rouge">record</code>의 특징</strong></h2>

<ol>
  <li><strong>자동으로 생성자, <code class="language-plaintext highlighter-rouge">getter</code>, <code class="language-plaintext highlighter-rouge">toString()</code>, <code class="language-plaintext highlighter-rouge">equals()</code>, <code class="language-plaintext highlighter-rouge">hashCode()</code> 제공</strong></li>
  <li><strong>불변 객체 (Immutable)</strong></li>
  <li><strong>Java의 일반적인 클래스처럼 사용 가능</strong></li>
  <li><strong>Compact Constructor(압축된 생성자) 지원</strong></li>
  <li><strong>상속 불가능 (<code class="language-plaintext highlighter-rouge">final</code> 클래스처럼 동작)</strong></li>
</ol>

<hr />

<h2 id="2️⃣-기존-클래스-vs-record-비교"><strong>2️⃣ 기존 클래스 vs <code class="language-plaintext highlighter-rouge">record</code> 비교</strong></h2>

<h3 id="-기존-방식-java-클래스로-dto-만들기"><strong>🔹 기존 방식: Java 클래스로 DTO 만들기</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Person{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"', age="</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span> <span class="s">"}"</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Person</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">age</span> <span class="o">==</span> <span class="n">person</span><span class="o">.</span><span class="na">age</span> <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">person</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">getter</code>, <code class="language-plaintext highlighter-rouge">toString()</code>, <code class="language-plaintext highlighter-rouge">equals()</code>, <code class="language-plaintext highlighter-rouge">hashCode()</code>를 직접 구현해야 해서 <strong>코드가 길어짐</strong>.</li>
</ul>

<hr />

<h3 id="-record를-사용한-간단한-구현"><strong>🔹 <code class="language-plaintext highlighter-rouge">record</code>를 사용한 간단한 구현</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div>

<ul>
  <li>위처럼 <strong>한 줄만 작성하면 동일한 기능을 제공</strong>함!</li>
  <li>자동으로 <code class="language-plaintext highlighter-rouge">getter</code>, <code class="language-plaintext highlighter-rouge">toString()</code>, <code class="language-plaintext highlighter-rouge">equals()</code>, <code class="language-plaintext highlighter-rouge">hashCode()</code>가 생성됨.</li>
</ul>

<hr />

<h2 id="3️⃣-record의-내부-동작"><strong>3️⃣ <code class="language-plaintext highlighter-rouge">record</code>의 내부 동작</strong></h2>

<p>위의 <code class="language-plaintext highlighter-rouge">record Person(String name, int age)</code>는 <strong>자동으로 다음과 같이 동작</strong>합니다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 생성자 자동 생성</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">name</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span> <span class="c1">// getter 자동 생성</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">age</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* 자동 생성 */</span> <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* 자동 생성 */</span> <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Person[name="</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">", age="</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>💡 <strong>이름이 <code class="language-plaintext highlighter-rouge">getName()</code>이 아니라 <code class="language-plaintext highlighter-rouge">name()</code>인 점이 특징!</strong></p>

<hr />

<h2 id="4️⃣-record의-주요-기능"><strong>4️⃣ <code class="language-plaintext highlighter-rouge">record</code>의 주요 기능</strong></h2>

<h3 id="-1-기본-사용"><strong>✅ 1. 기본 사용</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">,</span> <span class="mi">25</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">name</span><span class="o">());</span>  <span class="c1">// Alice (getter)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">age</span><span class="o">());</span>   <span class="c1">// 25 (getter)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>         <span class="c1">// Person[name=Alice, age=25]</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">name()</code>과 <code class="language-plaintext highlighter-rouge">age()</code>가 <strong>getter 역할을 함</strong> (<code class="language-plaintext highlighter-rouge">getName()</code>이 아님)</li>
  <li><code class="language-plaintext highlighter-rouge">toString()</code>이 자동 생성됨 → <code class="language-plaintext highlighter-rouge">Person[name=Alice, age=25]</code></li>
</ul>

<hr />

<h3 id="-2-compact-constructor-압축된-생성자"><strong>✅ 2. Compact Constructor (압축된 생성자)</strong></h3>

<ul>
  <li>기본적으로 <code class="language-plaintext highlighter-rouge">record</code>는 <strong>모든 필드가 자동 초기화</strong>되지만, 추가 검증 로직을 넣을 수도 있음.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Person</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"나이는 0 이상이어야 합니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>위처럼 생성자에서 유효성 검사를 추가 가능.</li>
</ul>

<hr />

<h3 id="-3-메서드-추가-가능"><strong>✅ 3. 메서드 추가 가능</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">record</code>도 일반적인 클래스처럼 <strong>메서드를 추가할 수 있음</strong>.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">Circle</span><span class="o">(</span><span class="kt">double</span> <span class="n">radius</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">area</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">PI</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Circle</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Circle</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"원의 넓이: "</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="na">area</span><span class="o">());</span>  <span class="c1">// 원의 넓이: 78.5398...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">record</code>는 단순히 데이터를 저장하는 역할이지만, <strong>관련 메서드를 추가하는 것도 가능</strong>.</li>
</ul>

<hr />

<h3 id="-4-상속-불가능-final-클래스처럼-동작"><strong>✅ 4. 상속 불가능 (<code class="language-plaintext highlighter-rouge">final</code> 클래스처럼 동작)</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">record</code>는 자동으로 <code class="language-plaintext highlighter-rouge">final</code>로 선언되므로 <strong>상속이 불가능</strong>함.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">Parent</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{}</span>

<span class="c1">// 오류: record는 상속할 수 없음</span>
<span class="kd">class</span> <span class="nc">Child</span> <span class="kd">extends</span> <span class="nc">Parent</span> <span class="o">{}</span>  <span class="c1">// ❌ 컴파일 오류</span>
</code></pre></div></div>

<hr />

<h2 id="5️⃣-record를-언제-사용할까"><strong>5️⃣ <code class="language-plaintext highlighter-rouge">record</code>를 언제 사용할까?</strong></h2>

<p>✅ <strong>불변 객체(Immutable Object)가 필요할 때</strong><br />
✅ <strong>DTO, VO (Data Transfer Object, Value Object)를 만들 때</strong><br />
✅ <strong>간단한 데이터 저장용 클래스가 필요할 때</strong><br />
✅ <strong>불필요한 <code class="language-plaintext highlighter-rouge">getter</code>, <code class="language-plaintext highlighter-rouge">toString()</code>, <code class="language-plaintext highlighter-rouge">equals()</code> 코드 작성을 줄이고 싶을 때</strong></p>

<p>❌ <strong>상속을 해야 하는 경우에는 <code class="language-plaintext highlighter-rouge">record</code>를 사용할 수 없음</strong><br />
❌ <strong>데이터 변경이 필요한 경우 (Mutable Object)는 <code class="language-plaintext highlighter-rouge">record</code>보다 일반 클래스를 사용</strong></p>

<hr />

<h2 id="6️⃣-정리"><strong>6️⃣ 정리</strong></h2>

<table>
  <thead>
    <tr>
      <th>특징</th>
      <th>일반 클래스</th>
      <th><code class="language-plaintext highlighter-rouge">record</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>코드 길이</td>
      <td>길다 (필드, 생성자, <code class="language-plaintext highlighter-rouge">getter</code>, <code class="language-plaintext highlighter-rouge">toString()</code>, <code class="language-plaintext highlighter-rouge">equals()</code>, <code class="language-plaintext highlighter-rouge">hashCode()</code>)</td>
      <td>짧다 (한 줄로 가능)</td>
    </tr>
    <tr>
      <td>불변성(Immutable)</td>
      <td>X (<code class="language-plaintext highlighter-rouge">final</code> 필드 필요)</td>
      <td>✅ 기본적으로 불변</td>
    </tr>
    <tr>
      <td>자동 생성</td>
      <td>X (수동으로 작성해야 함)</td>
      <td>✅ 생성자, <code class="language-plaintext highlighter-rouge">getter</code>, <code class="language-plaintext highlighter-rouge">toString()</code> 자동 생성</td>
    </tr>
    <tr>
      <td>상속 가능 여부</td>
      <td>✅ 가능</td>
      <td>❌ 불가능 (<code class="language-plaintext highlighter-rouge">final</code> 클래스처럼 동작)</td>
    </tr>
    <tr>
      <td>데이터 변경</td>
      <td>가능 (setter 추가 가능)</td>
      <td>❌ 변경 불가능</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-결론-record를-사용하면-불변-객체를-쉽게-만들-수-있으며-dto나-vo-같은-데이터-클래스를-훨씬-간결하게-표현할-수-있다-">🚀 <strong>결론: <code class="language-plaintext highlighter-rouge">record</code>를 사용하면 불변 객체를 쉽게 만들 수 있으며, DTO나 VO 같은 데이터 클래스를 훨씬 간결하게 표현할 수 있다!</strong> 🚀</h3>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="java" /><summary type="html"><![CDATA[Java 14부터 도입된 새로운 클래스 유형인 record에 대해 이야기해보자.]]></summary></entry><entry><title type="html">[Etc] 🎞️ Boilerplate</title><link href="https://nan0silver.github.io/miscellaneous/2025-03-06-boiler-plate/" rel="alternate" type="text/html" title="[Etc] 🎞️ Boilerplate" /><published>2025-03-06T00:00:00+00:00</published><updated>2025-04-08T12:28:34+00:00</updated><id>https://nan0silver.github.io/miscellaneous/boiler-plate</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-03-06-boiler-plate/"><![CDATA[<ul>
  <li><a href="#보일러플레이트boilerplate란">보일러플레이트(Boilerplate)란?</a></li>
  <li><a href="#보일러플레이트의-특징">보일러플레이트의 특징</a></li>
  <li><a href="#예제-코드">예제 코드</a></li>
</ul>

<hr />

<h2 id="보일러플레이트boilerplate란">보일러플레이트(Boilerplate)란?</h2>

<ul>
  <li>소프트웨어 개발에서 반복적으로 사용되는 사용되는 <strong>기본 코드 템플릿</strong></li>
  <li>🔥 즉, “매번 새로 작성해야하는 기본 코드세트”를 보일러플레이트라고 함</li>
  <li>의미
    <ul>
      <li>원래는 인쇄 산업에서 반복적으로 사용되는 금속판을 의미</li>
      <li>이후 소프트웨어 개발에서도 “반복적으로 작성해야하는 코드 덩어리”를 의미하게 되었다.</li>
    </ul>
  </li>
</ul>

<h2 id="보일러플레이트의-특징">보일러플레이트의 특징</h2>

<ol>
  <li>반복적인 코드</li>
</ol>

<ul>
  <li>프로젝트를 시작할 때 매번 작성해야하는 코드들이 포함됨</li>
  <li>예를 들어, 웹 애플리케이션을 만들 때 기본적인 프로젝트 구조, 설정 파일, 인증 로직 등이 해당</li>
</ul>

<ol>
  <li>템플릿 역할</li>
</ol>

<ul>
  <li>코드 재사용성을 높이고, 개발 시간을 줄여줌</li>
  <li>예를 들어, React, Express, Spring Boot같은 프레임워크에서는 보일러플레이트 코드가 포함된 템플릿이 제공됨</li>
</ul>

<ol>
  <li>프레임워크 및 라이브러리에서 자주 사용됨</li>
</ol>

<ul>
  <li>React : <code class="language-plaintext highlighter-rouge">create-react-app</code>이 기본적인 프로젝트 구조와 설정을 자동으로 생성</li>
  <li>Express : <code class="language-plaintext highlighter-rouge">express-generator</code>를 사용하면 기본적인 Express 프로젝트 생성</li>
  <li>Spring Boot : <code class="language-plaintext highlighter-rouge">Spring Initializr</code>를 사용사면 기본적인 설정이 포함된 프로젝트 생성</li>
</ul>

<h2 id="예제-코드">예제 코드</h2>

<ul>
  <li>Spring Boot 보일러플레이트</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.boot.SpringApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.SpringBootApplication</span><span class="o">;</span>

<span class="nd">@SpringBootApplication</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyApplication</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">MyApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[반복적으로 사용되는 기본 코드 템플릿인 Boilerplate에 대해 알아보자.]]></summary></entry><entry><title type="html">[Etc] immutable, final, constant</title><link href="https://nan0silver.github.io/miscellaneous/2025-03-06-immutable/" rel="alternate" type="text/html" title="[Etc] immutable, final, constant" /><published>2025-03-06T00:00:00+00:00</published><updated>2025-04-08T12:28:34+00:00</updated><id>https://nan0silver.github.io/miscellaneous/immutable</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/2025-03-06-immutable/"><![CDATA[<ul>
  <li><a href="#immutable-불변"><code class="language-plaintext highlighter-rouge">Immutable</code></a></li>
  <li><a href="#final-최종-변경-불가"><code class="language-plaintext highlighter-rouge">final</code></a></li>
  <li><a href="#const-상수"><code class="language-plaintext highlighter-rouge">const</code></a></li>
</ul>

<hr />

<h2 id="immutable-불변"><code class="language-plaintext highlighter-rouge">Immutable</code> (불변)</h2>

<blockquote>
  <p>생성 후 객체 자체의 상태를 변경할 수 없음
Java의 키워드는 아님, 다양한 언어에서 사용되는 객체의 속성 개념</p>
</blockquote>

<ul>
  <li>객체와 관련됨</li>
  <li>특징
    <ul>
      <li>모든 필드가 <code class="language-plaintext highlighter-rouge">final</code>이고 <code class="language-plaintext highlighter-rouge">private</code></li>
      <li>setter 메서드가 없음</li>
      <li>모든 가변 참조 필드가 방어적 복사를 통해 보호됨</li>
    </ul>
  </li>
  <li>중요한 점
    <ul>
      <li>불변 객체는 멀티 스레드 환경에서 안전하게 사용 가능</li>
      <li>내부 상태를 변경하는 메서드를 제공하지 않아야 함.</li>
    </ul>
  </li>
  <li>예 : String, Integer, BigDecimal
    <ul>
      <li><code class="language-plaintext highlighter-rouge">String</code> 클래스는 자바에서 대표적인 불변 객체
        <blockquote>
          <p><code class="language-plaintext highlighter-rouge">String</code>객체를 한 번 생성하면 내부 값이 변경되지 않음.
새로운 값을 할당하려면 새로운 객체가 만들어짐.</p>
        </blockquote>
        <ul>
          <li>
            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
  <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">concat</span><span class="o">(</span><span class="s">" World"</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span> <span class="c1">// 여전히 "Hello"</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="final-최종-변경-불가"><code class="language-plaintext highlighter-rouge">Final</code> (최종, 변경 불가)</h2>

<blockquote>
  <p>한 번 할당되면 값을 변경할 수 없는 변수 또는 참조
Java의 키워드</p>
</blockquote>

<ul>
  <li>특징
    <ul>
      <li>변수에 사용 : 초기화 후 재할당 불가</li>
      <li>메서드에 사용 : 오버라이딩 불가</li>
      <li>클래스에 사용 : 상속 불가</li>
    </ul>
  </li>
  <li>중요한 점
    <ul>
      <li><code class="language-plaintext highlighter-rouge">final</code>은 참조의 변경을 막지만, 참조가 가리키는 객체의 내용 변경은 막지 않음</li>
    </ul>
  </li>
  <li>실무에서 활용
    <ol>
      <li>메서드 파라미터
        <ul>
          <li>메서드 내에서 파라미터 값이 변경되지 않도록 보장</li>
          <li>
            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processUser</span><span class="o">(</span><span class="kd">final</span> <span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>람다 표현식
        <ul>
          <li>람다에서 외부 변수를 사용할 때는 반드시 <code class="language-plaintext highlighter-rouge">final</code> 또는 <code class="language-plaintext highlighter-rouge">effectively final</code>이어야 함</li>
          <li>
            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">final</span> <span class="nc">String</span> <span class="n">prefix</span> <span class="o">=</span> <span class="s">"User-"</span><span class="o">;</span>
  <span class="n">userList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
      <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">user</span> <span class="o">-&gt;</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">())</span>
      <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>스레드 안정성
        <ul>
          <li>멀티스레드 환경에서 불변성 보장에 도움</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h2 id="const-상수"><code class="language-plaintext highlighter-rouge">Const</code> (상수)</h2>

<blockquote>
  <p>프로그램 전체에서 변경되지 않는 고정 값
Java의 키워드</p>
</blockquote>

<ul>
  <li>특징
    <ul>
      <li>일반적으로 <code class="language-plaintext highlighter-rouge">static final</code>로 선언</li>
      <li>클래스 로딩 시점에 초기화</li>
      <li>관례적으로 대문자와 언더스코어 사용 (UPPER_SNAKE_CASE)</li>
      <li>예
        <ul>
          <li><code class="language-plaintext highlighter-rouge">public static final int MAX_USERS = 100;</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">static</code>
    <ul>
      <li>상수(<code class="language-plaintext highlighter-rouge">const</code>)와 자주 함께 사용되는 변수</li>
      <li>클래스 수준에서 사용되며, 객체가 아닌 클래스에 종속됨
        <ul>
          <li>클래스 로딩 시 한 번만 초기화되며 모든 객체가 공유</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><summary type="html"><![CDATA[값이나 상태를 변경하지 못하도록 하는데 사용되는 immutable, final, constant에 대해 알아보자.]]></summary></entry></feed>