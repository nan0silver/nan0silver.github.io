<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-04-28T11:12:50+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[버티] 버티 서비스를 위한 Spring Boot MSA 구현 방식 조사</title><link href="https://nan0silver.github.io/projectdiary/2025-04-28-diary/" rel="alternate" type="text/html" title="[버티] 버티 서비스를 위한 Spring Boot MSA 구현 방식 조사" /><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T11:12:06+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-04-28-diary/"><![CDATA[<ul>
  <li><a href="#1-jjwt-라이브러리-버전에-따른-변경-사항">JJWT 라이브러리 버전에 따른 변경 사항</a></li>
  <li><a href="#2-카카오-소셜-로그인-이메일-누락-문제">카카오 소셜 로그인 이메일 누락 문제</a></li>
  <li><a href="#3-oauth2-인증-요청-정보-손실-문제">OAuth2 인증 요청 정보 손실 문제</a></li>
</ul>

<hr />

<blockquote>
  <p>현재 버티 서비스는 백엔드 서버의 도메인이 2개로 되어있다. 프론트와 연동을 하기 직전 과정에서 CORS 문제 해결과 이 과정에서 Render배포의 리소스 제약 문제를 어떤 식으로 해결하는 것이 좋은지 아래 내용과 같이 조사해보았다.</p>
</blockquote>

<h2 id="1-현재-버티-서비스-상황-분석">1. 현재 버티 서비스 상황 분석</h2>

<ul>
  <li><strong>서버 구조</strong>: 서버 도메인 URL이 2개 (회원 정보는 한쪽에만 존재)</li>
  <li><strong>프론트엔드</strong>: 도메인 URL이 1개</li>
  <li><strong>인증 방식</strong>: JWT 기반 인증 구현 중</li>
  <li><strong>문제점</strong>:
    <ul>
      <li>사용자 프로필 업데이트 기능이 있어 JWT에 프로필 정보 포함 어려움</li>
      <li>프론트엔드와 백엔드 간 CORS 이슈 발생 가능</li>
      <li>Render 프리티어 환경으로 리소스 제약 존재</li>
    </ul>
  </li>
</ul>

<h2 id="2-msa-구현-방안">2. MSA 구현 방안</h2>

<h3 id="21-api-gateway-패턴-도입">2.1 API Gateway 패턴 도입</h3>

<ul>
  <li><strong>목적</strong>: 프론트엔드에 단일 진입점 제공, CORS 문제 해결</li>
  <li><strong>구현 방식</strong>: Spring Cloud Gateway 활용</li>
  <li><strong>장점</strong>:
    <ul>
      <li>단일 도메인으로 프론트엔드 요청 처리</li>
      <li>중앙화된 인증/인가 처리</li>
      <li>요청 라우팅 관리 용이</li>
    </ul>
  </li>
</ul>

<h3 id="22-회원-정보-공유-방식">2.2 회원 정보 공유 방식</h3>

<p>현재 버티 서비스는 JWT에 프로필 정보를 포함하기 어려운 상황이므로:
(로그인 후 사용자 프로필을 업데이트 하기 때문)</p>

<h4 id="서비스-간-직접-통신-방식">서비스 간 직접 통신 방식</h4>

<ul>
  <li><strong>기본 개념</strong>: 회원 정보가 필요할 때 회원 서비스의 API를 직접 호출하여 최신 정보를 가져오는 방식</li>
  <li><strong>구현 내용</strong>:
    <ul>
      <li>회원 서비스에 내부용 API 엔드포인트 추가 (예: <code class="language-plaintext highlighter-rouge">/api/internal/users/{userId}</code>)</li>
      <li>이 API는 외부 접근이 아닌 서비스 간 통신용으로만 사용</li>
      <li>기능 서비스에서 특정 사용자 정보가 필요할 때 이 API를 호출하여 최신 정보 획득</li>
      <li>내부 API 키를 사용해 인증 (서비스 간 통신이 안전하게 이루어지도록)</li>
    </ul>
  </li>
</ul>

<h4 id="캐싱-전략-적용">캐싱 전략 적용</h4>

<ul>
  <li><strong>문제점</strong>: 매번 API를 호출하면 Render 프리티어 환경에서 성능 저하 발생</li>
  <li><strong>해결책</strong>:
    <ul>
      <li>자주 조회되는 회원 정보를 메모리에 임시 저장(캐싱)</li>
      <li>첫 번째 조회 시에만 API 호출, 이후에는 캐시에서 빠르게 조회</li>
      <li>정해진 시간(예: 15분) 후 캐시 만료하여 일정 주기로 최신 정보 반영</li>
      <li>사용자가 프로필을 업데이트하면 해당 사용자의 캐시만 즉시 무효화하는 API 호출</li>
    </ul>
  </li>
</ul>

<h4 id="장애-대응-방안">장애 대응 방안</h4>

<ul>
  <li><strong>문제점</strong>: 회원 서비스가 일시적으로 장애가 발생하면 기능 서비스도 영향 받음</li>
  <li><strong>해결책</strong>:
    <ul>
      <li>Circuit Breaker 패턴: 회원 서비스 장애 감지 시 API 호출을 일시 중단하고 기본 정보 반환</li>
      <li>예를 들어, 회원 이름을 조회할 수 없으면 “Guest”와 같은 기본값 사용</li>
      <li>재시도 제한 및 타임아웃 설정으로 불필요한 대기 시간 방지</li>
    </ul>
  </li>
</ul>

<p>이 방식을 통해 JWT에 모든 회원 정보를 담지 않아도 최신 정보를 안전하게 공유하고, 성능과 안정성을 확보할 수 있습니다.</p>

<h2 id="3-render-프리티어-환경-최적화-방안">3. Render 프리티어 환경 최적화 방안</h2>

<p>리소스 제약이 있는 Render 프리티어 환경에 맞춘 최적화 전략:</p>

<ul>
  <li>
    <p><strong>경량화된 MSA 구조</strong>:</p>

    <ul>
      <li>필수적인 도메인만 분리 (회원 서비스 + 기능 서비스)</li>
      <li>최소한의 서비스 디스커버리 구조 사용</li>
    </ul>
  </li>
  <li>
    <p><strong>성능 최적화</strong>:</p>

    <ul>
      <li>데이터베이스 커넥션 풀 크기 제한 (5-10개)</li>
      <li>API 요청 타임아웃 짧게 설정 (3초 내외)</li>
      <li>캐시 크기 제한 (500 항목 이내)</li>
      <li>Lazy Loading 적용하여 필요한 데이터만 로딩</li>
    </ul>
  </li>
  <li>
    <p><strong>에러 처리 강화</strong>:</p>
    <ul>
      <li>서비스 간 통신 실패 시 폴백(fallback) 메커니즘 구현</li>
      <li>재시도 횟수 제한 (최대 3회)</li>
    </ul>
  </li>
</ul>

<h2 id="4-단계적-구현-전략">4. 단계적 구현 전략</h2>

<p>Burty 서비스에 MSA를 점진적으로 도입하기 위한 단계:</p>

<h3 id="41-1단계-api-gateway-구현">4.1 1단계: API Gateway 구현</h3>

<ul>
  <li>Spring Cloud Gateway 기반 게이트웨이 서비스 구축</li>
  <li>라우팅 규칙 설정 (회원/기능 서비스 분리)</li>
  <li>JWT 토큰 검증 필터 구현</li>
  <li>CORS 설정 적용</li>
</ul>

<h3 id="42-2단계-서비스-간-통신-구현">4.2 2단계: 서비스 간 통신 구현</h3>

<ul>
  <li>회원 서비스에 내부 API 엔드포인트 추가</li>
  <li>기능 서비스에 RestTemplate 설정</li>
  <li>서비스 간 인증 메커니즘 적용</li>
</ul>

<h3 id="43-3단계-캐싱-적용">4.3 3단계: 캐싱 적용</h3>

<ul>
  <li>인메모리 캐시 설정</li>
  <li>회원 정보 캐싱 서비스 구현</li>
  <li>캐시 무효화 API 구현</li>
</ul>

<h3 id="44-4단계-장애-대응-패턴-적용">4.4 4단계: 장애 대응 패턴 적용</h3>

<ul>
  <li>Circuit Breaker 패턴 구현</li>
  <li>재시도 메커니즘 추가</li>
  <li>로깅 및 모니터링 강화</li>
</ul>

<h2 id="5-결론">5. 결론</h2>

<p>Burty 서비스의 현재 상황과 Render 프리티어 환경을 고려할 때:</p>

<ol>
  <li>
    <p>JWT만으로는 회원 정보 공유에 한계가 있으므로, 서비스 간 API 통신과 캐싱을 조합하는 것이 적합</p>
  </li>
  <li>
    <p>API Gateway 패턴을 통해 프론트엔드의 CORS 문제 해결 및 단일 진입점 제공</p>
  </li>
  <li>
    <p>리소스 제약을 고려한 경량화된 MSA 구조와 성능 최적화 필요</p>
  </li>
  <li>
    <p>단계적 구현을 통해 점진적으로 MSA 아키텍처로 전환</p>
  </li>
</ol>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[테스트]]></summary></entry><entry><title type="html">[버티] 프로젝트 개발 중 마주한 사소한 이슈들</title><link href="https://nan0silver.github.io/projectdiary/2025-04-17-diary/" rel="alternate" type="text/html" title="[버티] 프로젝트 개발 중 마주한 사소한 이슈들" /><published>2025-04-17T00:00:00+00:00</published><updated>2025-04-28T11:12:06+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-04-17-diary/"><![CDATA[<ul>
  <li><a href="#1-jjwt-라이브러리-버전에-따른-변경-사항">JJWT 라이브러리 버전에 따른 변경 사항</a></li>
  <li><a href="#2-카카오-소셜-로그인-이메일-누락-문제">카카오 소셜 로그인 이메일 누락 문제</a></li>
  <li><a href="#3-oauth2-인증-요청-정보-손실-문제">OAuth2 인증 요청 정보 손실 문제</a></li>
</ul>

<hr />

<p>이 문서는 “버티” 프로젝트를 개발하면서 마주쳤던 비교적 사소하지만, 실제 구현 과정에서는 꽤나 시간을 잡아먹거나 시행착오를 유발했던 문제들을 기록해두는 공간입니다.</p>

<p>단순한 에러라기보다는 “한 번쯤은 헷갈릴 수 있는 포인트들”을 중심으로 정리하여, 나중에 유지보수하거나 다른 프로젝트에서 재사용할 때 참고할 수 있도록 작성합니다.</p>

<hr />

<h2 id="1-jjwt-라이브러리-버전에-따른-변경-사항">1. JJWT 라이브러리 버전에 따른 변경 사항</h2>

<p>JJWT 라이브러리의 업데이트로 인해 토큰 생성 및 파싱 방식이 크게 변경되었습니다. 기존 방식으로 작성된 코드는 더 이상 컴파일되지 않거나 실행 시 에러가 발생할 수 있습니다.</p>

<h3 id="-기존-코드-구버전-jjwt">🔧 기존 코드 (구버전 JJWT)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">secretKey</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">secretKey</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
<span class="nc">Claims</span> <span class="n">claims</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">claims</span><span class="o">().</span><span class="na">setSubject</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getNickname</span><span class="o">());</span>
<span class="nc">String</span> <span class="n">accessToken</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
                <span class="o">.</span><span class="na">setHeaderParam</span><span class="o">(</span><span class="nc">Header</span><span class="o">.</span><span class="na">TYPE</span><span class="o">,</span> <span class="nc">Header</span><span class="o">.</span><span class="na">JWT_TYPE</span><span class="o">)</span>
                <span class="o">.</span><span class="na">setClaims</span><span class="o">(</span><span class="n">claims</span><span class="o">)</span>
                <span class="o">.</span><span class="na">setIssuedAt</span><span class="o">(</span><span class="n">now</span><span class="o">)</span>
                <span class="o">.</span><span class="na">setExpiration</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">getTime</span><span class="o">()</span> <span class="o">+</span> <span class="no">ACCESS_TOKEN_VALID_MILLISECOND</span><span class="o">))</span>
                <span class="o">.</span><span class="na">signWith</span><span class="o">(</span><span class="nc">SignatureAlgorithm</span><span class="o">.</span><span class="na">HS256</span><span class="o">,</span> <span class="n">secretKey</span><span class="o">)</span>
                <span class="o">.</span><span class="na">compact</span><span class="o">();</span>
<span class="nc">Claims</span> <span class="n">parsedClaims</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">parser</span><span class="o">().</span><span class="na">setSigningKey</span><span class="o">(</span><span class="n">secretKey</span><span class="o">).</span><span class="na">parseClaimsJws</span><span class="o">(</span><span class="n">accessToken</span><span class="o">).</span><span class="na">getBody</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="-변경-코드-최신-jjwt">✅ 변경 코드 (최신 JJWT)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SecretKey</span> <span class="n">secretKey</span> <span class="o">=</span> <span class="nc">Keys</span><span class="o">.</span><span class="na">hmacShaKeyFor</span><span class="o">(</span><span class="n">secretKeyStr</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
<span class="nc">Claims</span> <span class="n">claims</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">claims</span><span class="o">().</span><span class="na">subject</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getNickname</span><span class="o">()).</span><span class="na">build</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">accessToken</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
                <span class="o">.</span><span class="na">claims</span><span class="o">(</span><span class="n">claims</span><span class="o">)</span>
                <span class="o">.</span><span class="na">header</span><span class="o">()</span>
                <span class="o">.</span><span class="na">type</span><span class="o">(</span><span class="s">"JWT"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span>
                <span class="o">.</span><span class="na">issuedAt</span><span class="o">(</span><span class="n">now</span><span class="o">)</span>
                <span class="o">.</span><span class="na">expiration</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">getTime</span><span class="o">()</span> <span class="o">+</span> <span class="no">ACCESS_TOKEN_VALID_MILLISECOND</span><span class="o">))</span>
                <span class="o">.</span><span class="na">signWith</span><span class="o">(</span><span class="n">secretKey</span><span class="o">,</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">SIG</span><span class="o">.</span><span class="na">HS256</span><span class="o">)</span>
                <span class="o">.</span><span class="na">compact</span><span class="o">();</span>
<span class="nc">Claims</span> <span class="n">parsedClaims</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">parser</span><span class="o">()</span>
                <span class="o">.</span><span class="na">verifyWith</span><span class="o">(</span><span class="n">secretKey</span><span class="o">)</span>
                <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                <span class="o">.</span><span class="na">parseSignedClaims</span><span class="o">(</span><span class="n">accessToken</span><span class="o">)</span>
                <span class="o">.</span><span class="na">getPayload</span><span class="o">();</span>
</code></pre></div></div>

<p>참고 :</p>

<ul>
  <li><a href="https://myeongju00.tistory.com/112">Jwt.parserBuilder() Deprecated</a></li>
  <li><a href="https://stackoverflow.com/questions/78805779/issue-with-parserbuilder-method-in-jjwt-library-for-jwt-token-validation">stack overflow</a></li>
</ul>

<hr />

<h2 id="2-카카오-소셜-로그인-이메일-누락-문제">2. 카카오 소셜 로그인 이메일 누락 문제</h2>

<h3 id="-문제-상황">🧩 문제 상황</h3>

<p>카카오 로그인 시 사용자 이메일이 제공되지 않아 <code class="language-plaintext highlighter-rouge">InternalAuthenticationServiceException</code> 이 발생하는 문제가 있었습니다.</p>

<h3 id="-해결-방법">✅ 해결 방법</h3>

<p>카카오 계정에 이메일 정보가 없을 경우 자동으로 생성된 이메일을 부여하도록 로직을 보완했습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// KakaoOAuth2UserInfo 클래스</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getEmail</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">attributes</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="s">"kakao_account"</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">kakaoAccount</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;)</span> <span class="n">attributes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"kakao_account"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">kakaoAccount</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">kakaoAccount</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="s">"email"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">kakaoAccount</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"email"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 상위 메소드에서 처리</span>
<span class="o">}</span>

<span class="c1">// OAuth2UserService 클래스</span>
<span class="kd">private</span> <span class="nc">OAuth2User</span> <span class="nf">processOAuth2User</span><span class="o">(...)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">email</span> <span class="o">=</span> <span class="n">oAuth2UserInfo</span><span class="o">.</span><span class="na">getEmail</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">email</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">email</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">email</span> <span class="o">=</span> <span class="n">registrationId</span> <span class="o">+</span> <span class="s">"_"</span> <span class="o">+</span> <span class="n">oAuth2UserInfo</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">+</span> <span class="s">"@example.com"</span><span class="o">;</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"이메일 정보가 없어 생성된 이메일: {}"</span><span class="o">,</span> <span class="n">email</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 나머지 사용자 생성/업데이트 로직</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="3-oauth2-인증-요청-정보-손실-문제">3. OAuth2 인증 요청 정보 손실 문제</h2>

<h3 id="-문제-상황-1">🧩 문제 상황</h3>

<p>로그인 시 다음과 같은 오류가 발생했습니다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>oauth2LoginException: authorization_request_not_found
</code></pre></div></div>

<p>이유는 Security 설정에서 다음과 같이 세션 생성을 완전히 차단했기 때문입니다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">http</span><span class="o">.</span><span class="na">sessionManagement</span><span class="o">().</span><span class="na">sessionCreationPolicy</span><span class="o">(</span><span class="nc">SessionCreationPolicy</span><span class="o">.</span><span class="na">STATELESS</span><span class="o">);</span>
</code></pre></div></div>

<p>OAuth2 로그인 과정은 내부적으로 세션에 인증 요청 정보를 저장하여 인증을 이어가는데, 해당 설정으로 인해 정보가 손실되었습니다.</p>

<h3 id="-해결-방법-1">✅ 해결 방법</h3>

<p>개발 초기에는 단순화를 위해 다음과 같이 설정을 변경했습니다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">http</span><span class="o">.</span><span class="na">sessionManagement</span><span class="o">().</span><span class="na">sessionCreationPolicy</span><span class="o">(</span><span class="nc">SessionCreationPolicy</span><span class="o">.</span><span class="na">IF_REQUIRED</span><span class="o">);</span>
</code></pre></div></div>

<p>이를 통해 OAuth2 인증 플로우 중 세션을 사용할 수 있도록 하여 문제를 해결했습니다.</p>

<h3 id="-추가-구현-리프레시-토큰">💡 추가 구현: 리프레시 토큰</h3>

<p>보안성과 사용자 경험을 위해 리프레시 토큰도 함께 구현했습니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RefreshToken</code> 엔티티 및 리포지토리 생성</li>
  <li>토큰 갱신 서비스 및 API 엔드포인트 구현</li>
  <li>액세스 토큰과 리프레시 토큰을 분리 관리하여 보안성 강화</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[테스트]]></summary></entry><entry><title type="html">[Spring] JPA Query Method</title><link href="https://nan0silver.github.io/spring/2025-04-17-query-method/" rel="alternate" type="text/html" title="[Spring] JPA Query Method" /><published>2025-04-17T00:00:00+00:00</published><updated>2025-04-28T11:12:06+00:00</updated><id>https://nan0silver.github.io/spring/query-method</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-17-query-method/"><![CDATA[<ul>
  <li><a href="#jparepository-상속">JpaRepository 상속</a></li>
  <li><a href="#-그렇다면-커스텀-쿼리는-어떻게-할까">그렇다면 커스텀 쿼리는 어떻게 할까?</a></li>
  <li><a href="#-개발자-관점-팁">개발자 관점 팁</a></li>
</ul>

<hr />

<h2 id="jparepository-상속"><code class="language-plaintext highlighter-rouge">JpaRepository</code> 상속</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">JpaRepository</code>를 상속한 Repository 인터페이스는 여러 기능이 내장된 상태가 된다.
    <ul>
      <li>예시 : <code class="language-plaintext highlighter-rouge">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {}</code></li>
    </ul>
  </li>
  <li>이 경우, <code class="language-plaintext highlighter-rouge">findById()</code> 같은 기능은 이미 내장되어 편리하게 사용할 수 있다.</li>
  <li>
    <p>내장 함수</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">JpaReposiroty</code>가 상속하고 있는 인터페이스 중, <code class="language-plaintext highlighter-rouge">CrudRepository</code>가 아래와 같이 기본 CRUD 메서드를 가지고 있어 직접 구현하지 않아도 사용할 수 있음.</li>
      <li>
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">CrudRepository</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">ID</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Repository</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">ID</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="o">&lt;</span><span class="no">S</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="no">S</span> <span class="nf">save</span><span class="o">(</span><span class="no">S</span> <span class="n">entity</span><span class="o">);</span>

    <span class="o">&lt;</span><span class="no">S</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="nf">saveAll</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="n">entities</span><span class="o">);</span>

    <span class="nc">Optional</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">findById</span><span class="o">(</span><span class="no">ID</span> <span class="n">id</span><span class="o">);</span>

    <span class="kt">boolean</span> <span class="nf">existsById</span><span class="o">(</span><span class="no">ID</span> <span class="n">id</span><span class="o">);</span>

    <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">findAll</span><span class="o">();</span>

    <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">findAllById</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">ID</span><span class="o">&gt;</span> <span class="n">ids</span><span class="o">);</span>

    <span class="kt">long</span> <span class="nf">count</span><span class="o">();</span>

    <span class="kt">void</span> <span class="nf">deleteById</span><span class="o">(</span><span class="no">ID</span> <span class="n">id</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="no">T</span> <span class="n">entity</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">deleteAllById</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">ID</span><span class="o">&gt;</span> <span class="n">ids</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">deleteAll</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">entities</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">deleteAll</span><span class="o">();</span>
   <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="-그렇다면-커스텀-쿼리는-어떻게-할까">🤔 그렇다면 커스텀 쿼리는 어떻게 할까?</h2>

<ul>
  <li>Spring Data JPA는 메서드 이름만으로 쿼리를 만들어줌
    <ul>
      <li><code class="language-plaintext highlighter-rouge">List&lt;User&gt; findByAgeGreaterThan(int n);</code> -&gt; age &gt; n인 유저들</li>
    </ul>
  </li>
</ul>

<h3 id="예시">예시:</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="nf">findByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 메서드를 호출하면 JPA는 이런 SQL을 자동으로 만든다:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<hr />

<h3 id="1-다양한-조건-연산자">1. 다양한 조건 연산자</h3>

<ul>
  <li>사용 가능한 키워드들:</li>
</ul>

<table>
  <thead>
    <tr>
      <th>키워드</th>
      <th>의미</th>
      <th>예시</th>
      <th>SQL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">And</code></td>
      <td>AND 조건</td>
      <td><code class="language-plaintext highlighter-rouge">findByNameAndAge</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE name=? AND age=?</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Or</code></td>
      <td>OR 조건</td>
      <td><code class="language-plaintext highlighter-rouge">findByNameOrEmail</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE name=? OR email=?</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Between</code></td>
      <td>사이 값</td>
      <td><code class="language-plaintext highlighter-rouge">findByAgeBetween(int a, int b)</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE age BETWEEN ? AND ?</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LessThan</code> / <code class="language-plaintext highlighter-rouge">GreaterThan</code></td>
      <td>부등호</td>
      <td><code class="language-plaintext highlighter-rouge">findByAgeGreaterThan(20)</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE age &gt; 20</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">IsNull</code> / <code class="language-plaintext highlighter-rouge">IsNotNull</code></td>
      <td>널 여부</td>
      <td><code class="language-plaintext highlighter-rouge">findByEmailIsNull()</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE email IS NULL</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">In</code></td>
      <td>여러 값</td>
      <td><code class="language-plaintext highlighter-rouge">findByNameIn(List&lt;String&gt; names)</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE name IN (?, ?, ...)</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Like</code></td>
      <td>부분일치</td>
      <td><code class="language-plaintext highlighter-rouge">findByNameLike("%woo%")</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE name LIKE ?</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">StartingWith</code> / <code class="language-plaintext highlighter-rouge">EndingWith</code> / <code class="language-plaintext highlighter-rouge">Containing</code></td>
      <td>문자열 검색</td>
      <td><code class="language-plaintext highlighter-rouge">findByNameStartingWith("s")</code></td>
      <td><code class="language-plaintext highlighter-rouge">WHERE name LIKE 's%'</code></td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="2-정렬과-페이징도-가능">2. 정렬과 페이징도 가능!</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="nf">findByAgeGreaterThanOrderByNameAsc</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>SQL: <code class="language-plaintext highlighter-rouge">SELECT * FROM user WHERE age &gt; ? ORDER BY name ASC</code></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Page</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="nf">findByNameContaining</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>페이징 처리까지 자동으로 해줌!</li>
</ul>

<hr />

<h3 id="3-존재-여부만-알고-싶다면">3. 존재 여부만 알고 싶다면?</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="nf">existsByEmail</span><span class="o">(</span><span class="nc">String</span> <span class="n">email</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>SQL: <code class="language-plaintext highlighter-rouge">SELECT COUNT(*) FROM user WHERE email = ?</code></li>
  <li>결과: 해당 이메일이 존재하면 <code class="language-plaintext highlighter-rouge">true</code>, 없으면 <code class="language-plaintext highlighter-rouge">false</code></li>
</ul>

<hr />

<h3 id="4-리턴-타입도-다양하게-지원한다">4. 리턴 타입도 다양하게 지원한다.</h3>

<table>
  <thead>
    <tr>
      <th>리턴 타입</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">User</code></td>
      <td>단일 객체 (없으면 <code class="language-plaintext highlighter-rouge">null</code>)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Optional&lt;User&gt;</code></td>
      <td>단일 객체 (안전하게 Optional로 감쌈)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">List&lt;User&gt;</code></td>
      <td>여러 개</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Page&lt;User&gt;</code></td>
      <td>페이징 결과</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">boolean</code></td>
      <td>존재 여부 확인</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="5-규칙을-안-지키면-어떻게-될까">5. 규칙을 안 지키면 어떻게 될까?</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">findByWhatIsThis</span><span class="o">()</span> <span class="c1">// ← 엔티티에 없는 필드명이면 컴파일은 되지만 실행 시 에러</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">No property whatIsThis found for type User!</code> 같은 예외 발생</li>
</ul>

<hr />

<h2 id="-개발자-관점-팁">🧠 개발자 관점 팁</h2>

<ul>
  <li>메서드 이름이 너무 길어지면 <strong><code class="language-plaintext highlighter-rouge">@Query</code>를 써서 직접 JPQL 작성</strong>하는 게 낫다.</li>
  <li><strong>자동 생성 쿼리 → 빠르게 CRUD 만들 때 유용</strong></li>
  <li><strong>복잡한 조건</strong> → <code class="language-plaintext highlighter-rouge">@Query</code> 또는 <code class="language-plaintext highlighter-rouge">QueryDSL</code>, <code class="language-plaintext highlighter-rouge">Specification</code> 권장</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[JPA의 Query Method에 대해 알아보자.]]></summary></entry><entry><title type="html">[버티] JWT로 로그인을 구현했을 때 로그아웃 방법을 어떻게 해야할까?</title><link href="https://nan0silver.github.io/projectdiary/2025-04-16-diary/" rel="alternate" type="text/html" title="[버티] JWT로 로그인을 구현했을 때 로그아웃 방법을 어떻게 해야할까?" /><published>2025-04-16T00:00:00+00:00</published><updated>2025-04-28T11:12:06+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-04-16-diary/"><![CDATA[<blockquote>
  <p>저번 프로젝트에서는 로그아웃을 구현하지 않고, 토큰 만료를 사용했는데 로그아웃을 구현해달라는 요청이 있었어서 이번 프로젝트에서는 제대로 알아보고 구현해보기로 하였다.</p>
</blockquote>

<ul>
  <li>JWT는 기본적으로 상태를 저장하지 않아(stateless) 로그아웃 처리에 어려움이 있다.</li>
  <li>
    <p>로그아웃을 구현하는 방법에는 크게 3가지가 있다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 프론트엔트에서 토큰 삭제
   - 가장 구현이 간단하다.
   - 클라이언트 측에서 토큰을 삭제하여 로그아웃을 구현하는 방법
   - 이 방법이 토큰의 `Stateless`한 특징을 최대한 살린 방식
     &gt; 'Stateful` : 데이터베이스에 정보를 저장하고 조회하는 경우
</code></pre></div>    </div>

    <p>‘Stateless`: 데이터베이스를 사용하지 않는 방식</p>

    <blockquote>
      <blockquote>
        <p>JWT는 데이터베이스에 저장 및 조회가 필요없기 때문에<code class="language-plaintext highlighter-rouge">Stateless</code>한 특징을 가지고 있다.</p>
      </blockquote>
    </blockquote>

    <ul>
      <li>단점 : 서버에선 토큰이 유효하기 때문에, 토큰이 노출되면 보안 문제가 생길 수 있음.</li>
    </ul>

    <ol>
      <li>토큰 블랙리스트 관리
        <ul>
          <li>JWT가 만료되지 않은 상태에서 로그아웃 요청이 오는 경우, 서버에서 해당 토큰을 블랙리스트 DB에 넣어 처리</li>
          <li>인증 필터에서 매 요청마다 토큰이 블랙리스트에 해당하는 토큰인지 확인해야한다.</li>
          <li>서버에서 토큰을 효과적으로 관리할 수 있지만, 매 요청마다 블랙리스트를 확인해야하기 때문에 <code class="language-plaintext highlighter-rouge">stateless</code>한 JWT의 장점이 없어진다.</li>
        </ul>
      </li>
      <li>Refresh Token 기간 만료 처리
        <ul>
          <li>사용자가 로그아웃을 요청할 때 리프레시 토큰을 무효화해 해당 사용자가 더 이상 새로운 엑세스 토큰을 발급받지 못하도록 하는 방식</li>
          <li>사용자의 로그아웃 요청에 대해 서버 측에서 적극적으로 대응할 수 있다는 장점이 있다.</li>
          <li>엑세스 토큰 재발급의 연속성을 차단해 보안을 강화할 수도 있다.</li>
          <li>하지만 리프레시 토큰 확인 과정에서 JWT의 <code class="language-plaintext highlighter-rouge">Stateless</code>한 장점이 사라진다.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>2번 VS 3번 비교
    <ul>
      <li>2번의 경우, 블랙리스트 DB 혹은 Redis를 사용해 서버 상태를 관리해야 한다.</li>
      <li>또한 <code class="language-plaintext highlighter-rouge">Stateless</code>성이 완전히 깨지고 (모은 요청 시 DB확인이 필요하기 때문에!) 성능 이슈가 생길 수 있다.</li>
      <li>하지만 3번의 경우, 리프레시 토큰만 관리하면 되기 때문에 상대적으로 가볍다.
        <ul>
          <li>리프레시 토큰만 서버 저장 및 관리하면 된다!</li>
        </ul>
      </li>
      <li>또한 3번은 <code class="language-plaintext highlighter-rouge">Stateless</code>를 부분적으로 유지 가능하다. (액세스 토큰은 여전히 <code class="language-plaintext highlighter-rouge">Stateless</code>)</li>
    </ul>
  </li>
  <li>일단은 3번 방법을 선택해서 로그아웃을 구현해보기로 결정하였다.
    <ul>
      <li>어플리케이션이 그렇게 무거운 프로젝트가 아니기 때문에, 블랙 리스트 방식처럼 서버 자원을 지속적으로 소모하는 설계보다는 토큰 생명주기를 명확히 관리할 수 있는 방식이 더 적합할 것 같다고 판단했다.</li>
      <li>또한 리프레시 토큰 구현으로 토큰의 생명 주기에 대해 이해해볼 수 있을 것 같아 선택하게 되었다.</li>
      <li>이번 프로젝트는 데이터베이스 사용이 많은 구조이기 때문에, 불필요한 토큰 상태 관리를 피하고 전체 시스템의 부하를 줄이기 위한 의도도 있었다.
        <blockquote>
          <p>리프레시 토큰의 발급 및 만료 흐름을 직접 설계함으로써, JWT 기반 인증 시스템의 구조와 보안 설계에 대한 이해도를 높이는 기회로 삼고자 한다.</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<p>참고 :</p>

<ul>
  <li><a href="https://upcurvewave.tistory.com/611">JWT 토큰 기반의 상태 관리시 로그아웃 처리 문제</a></li>
  <li><a href="https://engineerinsight.tistory.com/232#google_vignette">[우테코] JWT 방식에서 로그아웃, Refresh Token 만들기(1)</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[테스트]]></summary></entry><entry><title type="html">[버티] Spring Security와 Swagger 통합 시 발생한 이슈 해결기</title><link href="https://nan0silver.github.io/projectdiary/2025-04-15-diary/" rel="alternate" type="text/html" title="[버티] Spring Security와 Swagger 통합 시 발생한 이슈 해결기" /><published>2025-04-15T00:00:00+00:00</published><updated>2025-04-28T11:12:06+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-04-15-diary/"><![CDATA[<ul>
  <li><a href="#1-swagger-문서-접근-제한-및-인증-설정-이슈">1. Swagger 문서 접근 제한 및 인증 설정 이슈</a></li>
  <li><a href="#2-oauth2-엔드포인트가-swagger에-표시되지-않는-문제">2. OAuth2 엔드포인트가 Swagger에 표시되지 않는 문제</a></li>
  <li><a href="#3-swagger-ui-그룹명-default-표시-이슈">3. Swagger UI 그룹명 ‘default’ 표시 이슈</a></li>
  <li><a href="#4-swagger-ui에-authorization-설정-추가">4. Swagger UI에 Authorization 설정 추가</a></li>
  <li><a href="#5-실무-관점에서의-swagger-접근-관리-전략">5. 실무 관점에서의 Swagger 접근 관리 전략</a></li>
  <li><a href="#6-정리하며">6. 정리하며</a></li>
</ul>

<hr />

<p>Spring Boot와 Spring Security, 그리고 Swagger(OpenAPI)를 함께 사용하기 위해 공부하고 구현하며 여러 이슈가 발생했습니다. 따라서 제가 프로젝트를 수행하며 “소셜 로그인 기능을 구현하면서 Swagger와 관련된 문제들을 어떻게 인지하고 해결했는지”를 기록해 보았습니다.</p>

<hr />

<h2 id="1-swagger-문서-접근-제한-및-인증-설정-이슈">1. Swagger 문서 접근 제한 및 인증 설정 이슈</h2>

<h3 id="11-문제-상황">1.1. 문제 상황</h3>

<p>Spring Security 환경에서 Swagger 문서(<code class="language-plaintext highlighter-rouge">/swagger-ui/index.html</code>, <code class="language-plaintext highlighter-rouge">/v3/api-docs</code>)에 접근하려면 인증이 필요한 상황이 발생하였습니다. 이는 프론트엔드 개발자와 API 명세를 공유하고 협업하는 데 불편을 초래할 것이라 판단했습니다. 로그인 과정을 거치지 않으면 Swagger UI 자체가 열리지 않았기 때문에, 프론트엔드가 API 테스트를 원활히 진행할 수 없었습니다.</p>

<p>그래서 <strong>개발 환경(dev profile)</strong> 에 한해 Swagger 관련 인증을 해제했습니다. 이렇게 하니 Swagger 문서를 보다 자유롭게 접근할 수 있었고, API 확인과 테스트 속도도 한결 빨라졌습니다.</p>

<p>다만 이러한 설정을 그대로 운영 환경에 적용할 경우, 민감한 정보 노출의 위험이 있기 때문에, <strong>배포 시에는 Swagger 접근을 차단하거나 관리자만 접근 가능하도록 제한</strong>할 계획입니다. 이처럼 환경에 따라 적절하게 보안 수준을 조절하는 방식은 실제 현업에서도 자주 사용하는 전략이기도 합니다.</p>

<p>추가적으로, 설정 과정 중 다음과 같은 오류가 발생했습니다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IllegalStateException: Can't configure mvcMatchers after anyRequest.
</code></pre></div></div>

<h3 id="12--원인-분석">1.2. 👀 원인 분석</h3>

<ol>
  <li>Spring Security는 기본적으로 모든 요청에 대해 보안 필터를 적용하여, 인증되지 않은 사용자의 접근을 차단합니다. Swagger 문서 관련 URL 또한 별도의 예외 처리를 하지 않으면 일반적인 보호 대상 경로로 인식되어 접근이 제한됩니다.</li>
  <li>Spring Security에서 <code class="language-plaintext highlighter-rouge">.anyRequest()</code> 호출 이후 <code class="language-plaintext highlighter-rouge">.requestMatchers()</code>를 선언한 것이 문제
    <ul>
      <li>URL 매칭 규칙상 구체적인 경로를 먼저 선언하고, 마지막에 <code class="language-plaintext highlighter-rouge">anyRequest()</code>를 사용해야 합니다</li>
    </ul>
  </li>
</ol>

<h3 id="13-해결-방법">1.3. 해결 방법</h3>

<p><code class="language-plaintext highlighter-rouge">SecurityConfig</code> 클래스에서 Swagger 관련 경로에 대한 접근을 허용하도록 다음과 같이 설정했습니다:</p>

<ul>
  <li>Swagger 관련 경로를 먼저 선언한 후, 마지막에 <code class="language-plaintext highlighter-rouge">anyRequest()</code>를 설정하는 방식으로 해결했습니다:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Bean</span>
<span class="kd">public</span> <span class="nc">SecurityFilterChain</span> <span class="nf">securityFilterChain</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">http</span>
        <span class="o">.</span><span class="na">authorizeHttpRequests</span><span class="o">(</span><span class="n">authorize</span> <span class="o">-&gt;</span> <span class="n">authorize</span>
            <span class="o">.</span><span class="na">requestMatchers</span><span class="o">(</span>
                <span class="s">"/swagger-ui/**"</span><span class="o">,</span>
                <span class="s">"/swagger-resources/**"</span><span class="o">,</span>
                <span class="s">"/v2/api-docs"</span><span class="o">,</span>
                <span class="s">"/v3/api-docs"</span><span class="o">,</span>
                <span class="s">"/webjars/**"</span>
            <span class="o">).</span><span class="na">permitAll</span><span class="o">()</span>
            <span class="o">.</span><span class="na">anyRequest</span><span class="o">().</span><span class="na">authenticated</span><span class="o">()</span>
        <span class="o">);</span>

    <span class="k">return</span> <span class="n">http</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 설정으로 인해 Swagger 문서에 로그인 없이 접근 가능하게 되었으며, 프론트엔드와의 협업도 원활해졌습니다.</p>

<blockquote>
  <p>“개발 생산성과 보안의 균형”이라는 관점에 대해 생각하게 되었습니다.</p>
</blockquote>

<hr />

<h2 id="2-oauth2-엔드포인트가-swagger에-표시되지-않는-문제">2. OAuth2 엔드포인트가 Swagger에 표시되지 않는 문제</h2>

<h3 id="21-문제-상황">2.1. 문제 상황</h3>

<p>Spring Security가 자동으로 생성해주는 OAuth2 엔드포인트(<code class="language-plaintext highlighter-rouge">/oauth2/authorize/{provider}</code>, <code class="language-plaintext highlighter-rouge">/login/oauth2/code/{provider}</code>)는 컨트롤러 기반이 아니기 때문에 Swagger 문서에 자동으로 포함되지 않았습니다.</p>

<h3 id="22--원인">2.2. 👀 원인</h3>

<p>Swagger는 기본적으로 <code class="language-plaintext highlighter-rouge">@RestController</code> 및 <code class="language-plaintext highlighter-rouge">@RequestMapping</code> 애노테이션이 붙은 메서드를 기준으로 API 문서를 생성합니다. 하지만 Spring Security의 OAuth2 로그인 경로는 Security 설정 내부에서 동적으로 구성되기 때문에 Swagger가 자동으로 인식할 수 없습니다.</p>

<h3 id="23-해결-방법">2.3. 해결 방법</h3>

<p>SwaggerConfig에서 수동으로 OpenAPI 객체에 경로를 등록하여 문서화했습니다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SwaggerConfig</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">OpenAPI</span> <span class="nf">customOpenAPI</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">OpenAPI</span> <span class="n">openAPI</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OpenAPI</span><span class="o">()</span>
                <span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="k">new</span> <span class="nc">Info</span><span class="o">()</span>
                        <span class="o">.</span><span class="na">title</span><span class="o">(</span><span class="s">"Burty Server API"</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="s">"1.0.0"</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">description</span><span class="o">(</span><span class="s">"버티 서버 API 문서"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">paths</span><span class="o">(</span><span class="k">new</span> <span class="nc">Paths</span><span class="o">());</span>

        <span class="n">openAPI</span><span class="o">.</span><span class="na">getPaths</span><span class="o">().</span><span class="na">addPathItem</span><span class="o">(</span><span class="s">"/oauth2/authorize/{provider}"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">PathItem</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="k">new</span> <span class="nc">Operation</span><span class="o">().</span><span class="na">summary</span><span class="o">(</span><span class="s">"OAuth2 인증 요청"</span><span class="o">)));</span>
        <span class="n">openAPI</span><span class="o">.</span><span class="na">getPaths</span><span class="o">().</span><span class="na">addPathItem</span><span class="o">(</span><span class="s">"/login/oauth2/code/{provider}"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">PathItem</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="k">new</span> <span class="nc">Operation</span><span class="o">().</span><span class="na">summary</span><span class="o">(</span><span class="s">"OAuth2 로그인 콜백"</span><span class="o">)));</span>

        <span class="k">return</span> <span class="n">openAPI</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="3-swagger-ui-그룹명-default-표시-이슈">3. Swagger UI 그룹명 ‘default’ 표시 이슈</h2>

<h3 id="31-문제-상황">3.1. 문제 상황</h3>

<p>Swagger UI에서 각 API가 <code class="language-plaintext highlighter-rouge">default</code>라는 그룹으로 묶여 가독성이 떨어졌습니다.</p>

<h3 id="32--원인">3.2. 👀 원인</h3>

<p>Swagger는 명시적으로 <code class="language-plaintext highlighter-rouge">@Tag</code> 애노테이션이 부여되지 않은 컨트롤러의 경우, 자동으로 <code class="language-plaintext highlighter-rouge">default</code>라는 태그로 묶어 표시합니다. 이는 다양한 기능의 API가 하나의 그룹으로 합쳐져 구분이 어렵게 됩니다.</p>

<h3 id="33-해결-방법">3.3. 해결 방법</h3>

<p>컨트롤러에 <code class="language-plaintext highlighter-rouge">@Tag</code> 애노테이션을 추가하고, 각 API에 <code class="language-plaintext highlighter-rouge">tags</code>를 명시함으로써 그룹을 명확하게 분리했습니다:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Tag</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"인증"</span><span class="o">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s">"사용자 인증 관련 API"</span><span class="o">)</span>
<span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/auth"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthController</span> <span class="o">{</span>

    <span class="nd">@Operation</span><span class="o">(</span><span class="n">summary</span> <span class="o">=</span> <span class="s">"카카오 로그인 URL 반환"</span><span class="o">,</span> <span class="n">tags</span> <span class="o">=</span> <span class="o">{</span><span class="s">"인증"</span><span class="o">})</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/kakao"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">kakaoLogin</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="4-swagger-ui에-authorization-설정-추가">4. Swagger UI에 Authorization 설정 추가</h2>

<h3 id="41-문제-상황">4.1. 문제 상황</h3>

<p>프론트엔드에서 JWT 인증이 필요한 API를 Swagger UI로 테스트하고자 했으나, Authorization 정보를 입력할 수 있는 UI가 없었습니다.</p>

<h3 id="42--원인-분석">4.2. 👀 원인 분석</h3>

<ul>
  <li>Swagger 기본 설정에는 Authorization 헤더 입력 기능이 포함되어 있지 않습니다.
    <ul>
      <li>JWT 기반 인증이 필요한 API에도 별도의 인증 설정을 명시하지 않으면 Swagger UI에서 테스트가 불가능합니다.</li>
    </ul>
  </li>
  <li>
    <p>따라서 개발 및 테스트 과정에서 프론트엔드가 토큰을 포함한 요청을 손쉽게 재현할 수 있도록 하기 위해 보안 스키마 설정이 필요했습니다.</p>
  </li>
  <li>프론트엔드에서 JWT 인증이 필요한 API를 Swagger UI로 테스트하고자 했으나, Authorization 정보를 입력할 수 있는 UI가 없었습니다.</li>
</ul>

<h3 id="43-해결-방법">4.3. 해결 방법</h3>

<h4 id="1-전역-보안-스키마-정의">1) 전역 보안 스키마 정의</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@SecurityScheme</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"bearerAuth"</span><span class="o">,</span>
        <span class="n">type</span> <span class="o">=</span> <span class="nc">SecuritySchemeType</span><span class="o">.</span><span class="na">HTTP</span><span class="o">,</span>
        <span class="n">scheme</span> <span class="o">=</span> <span class="s">"bearer"</span><span class="o">,</span>
        <span class="n">bearerFormat</span> <span class="o">=</span> <span class="s">"JWT"</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OpenApiConfig</span> <span class="o">{</span>
    <span class="c1">// 어노테이션으로 설정</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="2-개별-api에-적용">2) 개별 API에 적용</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Operation</span><span class="o">(</span><span class="n">security</span> <span class="o">=</span> <span class="o">{</span> <span class="nd">@SecurityRequirement</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"bearerAuth"</span><span class="o">)</span> <span class="o">})</span>
<span class="nd">@PutMapping</span><span class="o">(</span><span class="s">"/profile"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;?&gt;</span> <span class="n">updateUserProfile</span><span class="o">(...)</span> <span class="o">{</span>
    <span class="c1">// 메서드 구현</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 설정을 통해 Swagger UI에서도 인증이 필요한 API를 명확히 구분하고, 테스트 시 토큰을 직접 입력할 수 있도록 구성할 수 있었습니다.</p>

<hr />

<h2 id="5-실무-관점에서의-swagger-접근-관리-전략">5. 실무 관점에서의 Swagger 접근 관리 전략</h2>

<ul>
  <li>개발 환경에서는 Swagger 접근을 자유롭게 열어두고 프론트엔드 테스트를 용이하게 함</li>
  <li>운영 환경에서는 보안을 위해 관리자 인증 또는 방화벽 제한을 적용하는 것이 일반적</li>
  <li>JWT 기반 인증 API는 Swagger UI에서도 Authorization 헤더를 통해 테스트할 수 있도록 설정</li>
</ul>

<hr />

<h2 id="6-정리하며">6. 정리하며</h2>

<p>Swagger와 Spring Security를 함께 사용할 때 마주친 실제적인 문제들을 해결하면서, 보안과 개발 편의성 사이에서 균형을 맞추는 경험을 할 수 있었습니다. 특히 프론트엔드 협업 관점에서 Swagger 인증 해제와 JWT 연동 설정은 협업 효율을 높이는 핵심 포인트였습니다.</p>

<p>이러한 설정 경험은 포트폴리오에 실질적인 문제 해결 능력으로 정리할 수 있었고, 실무에서도 유용하게 활용될 수 있는 기반이 되었습니다.</p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[테스트]]></summary></entry><entry><title type="html">[버티] 프로젝트 구조 설계 고민과 선택</title><link href="https://nan0silver.github.io/projectdiary/2025-04-14-diary/" rel="alternate" type="text/html" title="[버티] 프로젝트 구조 설계 고민과 선택" /><published>2025-04-14T00:00:00+00:00</published><updated>2025-04-28T11:12:06+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-04-14-diary/"><![CDATA[<hr />

<p>프로젝트를 처음 시작할 때 가장 고민했던 부분 중 하나는 <strong>전체 구조를 어떻게 잡을 것인가</strong>였습니다. 단순한 CRUD를 넘어서 소셜 로그인, 커뮤니티, AI 기반 정착 리포트 등 다양한 기능을 포함할 예정이었기 때문에, 기능이 늘어나더라도 유지보수가 쉽고, 각 도메인이 명확하게 분리되도록 설계하고 싶었습니다.</p>

<p>처음엔 기능 중심으로 폴더를 나눌까도 생각했지만, 여러 기능이 얽혀 있을 때 책임이 명확하지 않고 코드가 뒤섞일 우려가 있었습니다. 그래서 고민 끝에 <strong>도메인 주도 설계(Domain-Driven Design, DDD)</strong> 와 <strong>MVC 구조</strong>, 그리고 <strong>레이어드 아키텍처(Layered Architecture)</strong> 를 조합한 형태로 프로젝트 구조를 설계하기로 했습니다.</p>

<h3 id="-도메인-주도-설계란">💡 도메인 주도 설계란?</h3>

<p>DDD는 비즈니스의 복잡한 요구사항을 도메인 중심으로 풀어가는 소프트웨어 설계 방법입니다. 코드 구조가 실제 도메인 모델과 맞닿아 있어 유지보수가 용이하고, 비즈니스 개념을 중심으로 기능을 구현할 수 있도록 도와줍니다. 핵심은 <strong>‘도메인을 기준으로 책임을 분리’</strong>하는 것입니다.</p>

<p>또한 레이어드 아키텍처는 기능을 계층별로 나누어 역할을 분리함으로써 각 계층 간의 결합도를 낮추고 테스트와 유지보수를 용이하게 합니다. 대표적으로는 Controller → Service → Repository 계층 구조를 따릅니다.</p>

<hr />

<p>최종적으로 다음과 같은 구조를 구성했습니다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>org.example.burtyserver/
 ├── domain/                  # 도메인 중심 패키지
 │   ├── auth/                # 인증 관련 기능
 │   │   ├── controller/      # API 컨트롤러 (Presentation Layer)
 │   │   └── dto/             # 데이터 전송 객체
 │   │
 │   └── user/                # 사용자 관련 기능
 │       ├── entity/          # 엔티티 클래스 (Domain Layer)
 │       ├── repository/      # 데이터 접근 계층 (Persistence Layer)
 │       └── service/         # 비즈니스 로직 (Application Layer)
 │
 ├── global/                  # 공통/전역 기능
 │   ├── config/              # 설정 클래스
 │   ├── exception/           # 예외 처리
 │   └── security/            # 보안 관련 클래스
 │       ├── jwt/             # JWT 관련 클래스
 │       ├── oauth2/          # OAuth2 관련 클래스
 │       └── dto/             # 보안 관련 DTO
 │
 └── BurtyServerApplication.java   # 애플리케이션 진입점
</code></pre></div></div>

<p>-&gt; 아직 개발중!</p>

<p>이 구조는 기능별 분리보다 도메인별 분리를 우선시했으며, 각 도메인이 자신의 책임과 역할에 따라 나뉘도록 구성했습니다. 공통 설정이나 보안 로직처럼 여러 도메인에서 공유되는 요소들은 <code class="language-plaintext highlighter-rouge">global</code>이라는 전역 패키지에 따로 관리하여 관심사 분리를 명확히 했습니다.</p>

<p>실제로 프로젝트를 진행하면서 새로운 기능이 추가될 때마다 이 구조 덕분에 확장이 훨씬 수월했습니다. 예를 들어 AI 정착 리포트 기능을 추가할 때도 <code class="language-plaintext highlighter-rouge">settlement</code>라는 도메인을 추가해 기존 구조에 영향을 주지 않고도 자연스럽게 통합할 수 있었습니다.</p>

<p>도메인 주도 설계를 기반으로 구조를 잡는 과정은 단순히 코드를 예쁘게 나누는 것을 넘어서, 기능과 비즈니스 로직의 맥락(Context)을 코드 레벨에서 표현하는 데 큰 도움이 되었습니다. 또한 레이어드 아키텍처를 통해 각 계층의 역할이 명확해져 협업 시 작업 분담이나 코드 리뷰도 훨씬 효율적으로 이루어졌습니다.</p>

<p>이 경험은 제가 프로젝트를 단순히 “만드는 것”을 넘어서, “운영 가능한 구조로 설계한다”는 감각을 키우는 데 결정적인 계기가 되었습니다.</p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[테스트]]></summary></entry><entry><title type="html">[Spring] 논블로킹(Non-blocking) vs 비동기 (Asynchronous)</title><link href="https://nan0silver.github.io/spring/2025-04-09-non-blocking/" rel="alternate" type="text/html" title="[Spring] 논블로킹(Non-blocking) vs 비동기 (Asynchronous)" /><published>2025-04-09T00:00:00+00:00</published><updated>2025-04-28T11:12:06+00:00</updated><id>https://nan0silver.github.io/spring/non-blocking</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-09-non-blocking/"><![CDATA[<ul>
  <li><a href="#-논블로킹non-blocking이란">논블로킹이란?</a></li>
  <li><a href="#-실생활-비유로-논블로킹-이해하기">실생활 비유로 논블로킹 이해하기</a></li>
  <li><a href="#-블로킹-vs-논블로킹-기술적-요점-정리">블로킹 vs 논블로킹 기술적 요점 정리</a></li>
  <li><a href="#-논블로킹이-중요한-이유">논블로킹이 중요한 이유</a></li>
  <li><a href="#️-어디서-논블로킹이-쓰이냐">어디서 논블로킹이 쓰이냐?</a></li>
  <li><a href="#논블로킹non-blocking이랑-비동기asynchronous-비교">논블로킹(Non-blocking) 비동기(Asynchronous) 비교</a></li>
  <li><a href="#completablefuture-webclient-코드-예시">CompletableFuture, WebClient 코드 예시</a></li>
</ul>

<hr />

<h2 id="-논블로킹non-blocking이란">✅ 논블로킹(Non-blocking)이란?</h2>

<h3 id="먼저-블로킹blocking이-뭔지부터-알아보자">먼저, 블로킹(Blocking)이 뭔지부터 알아보자</h3>

<ul>
  <li><strong>블로킹 방식</strong>은 어떤 작업이 끝날 때까지 프로그램이 <strong>멈춰서 기다리는 것</strong></li>
  <li>웹 서버라면, DB 응답이나 외부 API 요청이 끝날 때까지 <strong>쓰레드가 잡혀서 못 움직임.</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 블로킹 방식 (예: RestTemplate)</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="s">"http://api.example.com"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// → 이 줄에서 응답이 올 때까지 멈춤</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"응답 받음!"</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<h3 id="-논블로킹-방식은">🚀 논블로킹 방식은?</h3>

<ul>
  <li><strong>기다리지 않는다.</strong> 요청을 보내고, 바로 다음 작업을 처리한다.</li>
  <li>응답이 나중에 오면, 그때 콜백(또는 리액티브 스트림)을 통해 처리</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 논블로킹 방식 (예: WebClient)</span>
<span class="n">webClient</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">"http://api.example.com"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
    <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">result</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"응답 받음! → "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">});</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"바로 다음 코드 실행됨!"</span><span class="o">);</span>
</code></pre></div></div>

<p>👆 여기서 중요한 건:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">subscribe()</code> 안에 있는 코드만 나중에 실행되고</li>
  <li>서버 쓰레드는 그동안 다른 요청을 처리할 수 있다는 것</li>
</ul>

<hr />

<h2 id="-실생활-비유로-논블로킹-이해하기">🍜 실생활 비유로 논블로킹 이해하기</h2>

<h3 id="-블로킹-방식-짜장면집-주방장-1명">✅ 블로킹 방식: 짜장면집 주방장 1명</h3>

<blockquote>
  <p>손님이 주문 → 짜장면 끓이는 동안 주방장이 다음 주문을 못 받음<br />
5명 동시에 오면? 4명은 그냥 기다림 (쓰레드 낭비, 느림)</p>
</blockquote>

<h3 id="-논블로킹-방식-주방장--자동면로봇">✅ 논블로킹 방식: 주방장 + 자동면로봇</h3>

<blockquote>
  <p>손님이 주문 → 기계에 넣고 대기표 발급 → 주방장은 다른 주문 처리<br />
→ 주문 100개가 와도 효율적으로 동시에 처리 가능! (고성능, 확장성)</p>
</blockquote>

<hr />

<h2 id="-블로킹-vs-논블로킹-기술적-요점-정리">🧠 블로킹 vs 논블로킹 기술적 요점 정리</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>블로킹 방식</th>
      <th>논블로킹 방식</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>처리 방식</td>
      <td>요청 → 대기 → 응답</td>
      <td>요청 → 바로 다음 처리 → 응답 오면 콜백</td>
    </tr>
    <tr>
      <td>쓰레드 사용</td>
      <td><strong>요청 1건당 쓰레드 1개</strong></td>
      <td><strong>요청 수백건도 쓰레드 몇 개</strong>로 처리 가능</td>
    </tr>
    <tr>
      <td>성능</td>
      <td>낮은 동시성 처리</td>
      <td>높은 동시성, 고성능</td>
    </tr>
    <tr>
      <td>코드</td>
      <td>간단하고 직관적</td>
      <td>콜백이나 리액티브 스트림 필요</td>
    </tr>
    <tr>
      <td>예시</td>
      <td>RestTemplate, JDBC</td>
      <td>WebClient, R2DBC, Netty 등</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-논블로킹이-중요한-이유">💡 논블로킹이 중요한 이유</h2>

<h3 id="️-1-고성능-서버-만들기">✔️ 1. 고성능 서버 만들기</h3>

<ul>
  <li>수천~수만 명이 동시에 요청을 보내도 효율적으로 처리 가능</li>
</ul>

<h3 id="️-2-외부-api-많이-쓰는-서비스에서-유리">✔️ 2. 외부 API 많이 쓰는 서비스에서 유리</h3>

<ul>
  <li>다른 서비스의 응답을 기다리는 동안, 서버 리소스를 낭비하지 않음</li>
</ul>

<h3 id="️-3-msa-마이크로서비스-아키텍처에서-필수">✔️ 3. MSA (마이크로서비스 아키텍처)에서 필수</h3>

<ul>
  <li>서로 요청 주고받는 일이 많기 때문에 <strong>논블로킹 API가 매우 효율적</strong></li>
</ul>

<hr />

<h2 id="️-어디서-논블로킹이-쓰이냐">🛠️ 어디서 논블로킹이 쓰이냐?</h2>

<table>
  <thead>
    <tr>
      <th>기술</th>
      <th>논블로킹 여부</th>
      <th>비고</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">WebClient</code></td>
      <td>✅</td>
      <td>REST API 호출</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Reactor Netty</code></td>
      <td>✅</td>
      <td>웹서버 / 클라이언트 엔진</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">R2DBC</code></td>
      <td>✅</td>
      <td>논블로킹 DB 클라이언트 (JDBC는 블로킹)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Spring WebFlux</code></td>
      <td>✅</td>
      <td>전체 논블로킹 웹 프레임워크</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="논블로킹non-blocking이랑-비동기asynchronous-비교">“논블로킹(Non-blocking)”이랑 “비동기(Asynchronous)” 비교</h2>

<blockquote>
  <p>❌ <strong>같은 말 아님</strong>.<br />
✅ <strong>서로 관련 있지만, 개념적으로 다르다.</strong></p>
</blockquote>

<h3 id="-핵심-차이-요약">🔍 핵심 차이 요약</h3>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>비동기 (Asynchronous)</th>
      <th>논블로킹 (Non-blocking)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>개념</td>
      <td><strong>작업을 요청하고 바로 다음 코드 실행</strong> (응답 기다리지 않음)</td>
      <td><strong>리소스(쓰레드 등)를 점유하지 않음</strong></td>
    </tr>
    <tr>
      <td>초점</td>
      <td><strong>시간(언제 실행될지 모름)</strong></td>
      <td><strong>리소스 사용 여부</strong></td>
    </tr>
    <tr>
      <td>예시</td>
      <td>콜백, Future, Promise, Mono</td>
      <td><code class="language-plaintext highlighter-rouge">read()</code> 호출 시 즉시 리턴</td>
    </tr>
    <tr>
      <td>관련성</td>
      <td>비동기 처리는 대부분 논블로킹 방식으로 구현됨</td>
      <td>논블로킹이 항상 비동기인 건 아님</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-비유로-설명">🎯 비유로 설명</h3>

<h4 id="-비동기란">🍜 비동기란?</h4>

<blockquote>
  <p>“너 짜장면 하나, 그리고 바로 다음 손님 주세요~”</p>
</blockquote>

<ul>
  <li>주문 받고 <strong>즉시 다음 손님 주문을 받는</strong> 방식</li>
  <li>짜장면이 나올 때까지 <strong>기다리지 않음</strong></li>
  <li>나중에 “주문하신 짜장면 나왔습니다~” 하고 <strong>알림이 옴 (콜백)</strong></li>
</ul>

<p>✅ 즉, “작업이 완료될 때까지 기다리지 않고 <strong>나중에 처리</strong>“가 핵심</p>

<hr />

<h4 id="-논블로킹이란">🥡 논블로킹이란?</h4>

<blockquote>
  <p>“면 삶는 동안 <strong>주방 공간을 계속 점유하지 않음</strong>”</p>
</blockquote>

<ul>
  <li>요리를 맡긴 뒤 주방 공간을 <strong>즉시 다른 요리사에게 넘겨줌</strong></li>
  <li>결과가 나올 때까지 그 <strong>리소스를 점유하지 않음</strong></li>
</ul>

<p>✅ 즉, <strong>요청을 처리 중인 동안에도 시스템 리소스를 점유하지 않음</strong>이 핵심</p>

<hr />

<h2 id="-코드-예시-비교">🧠 코드 예시 비교</h2>

<h3 id="-블로킹--동기-가장-기본">🧱 블로킹 + 동기 (가장 기본)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 이 줄에서 서버 응답이 올 때까지 기다림 (쓰레드 점유 O, 시간도 대기 O)</span>
</code></pre></div></div>

<hr />

<h3 id="-논블로킹--동기">🧱 논블로킹 + 동기</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">readNonBlocking</span><span class="o">();</span>  <span class="c1">// 지금 읽을 수 있는 데이터만 읽고 즉시 리턴</span>
</code></pre></div></div>

<ul>
  <li>당장 읽을 게 없으면 빈 값만 주고 <strong>쓰레드는 곧바로 다음 작업 가능</strong></li>
  <li>하지만 <strong>이 결과로 바로 처리함</strong> → <strong>동기적</strong></li>
</ul>

<hr />

<h3 id="-논블로킹--비동기-진짜-고성능-시스템-핵심">🧱 논블로킹 + 비동기 (진짜 고성능 시스템 핵심!)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">webClient</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">"/data"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
    <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"데이터 도착: "</span> <span class="o">+</span> <span class="n">data</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>

<ul>
  <li>요청 후 <strong>바로 다음 코드 실행됨</strong> (비동기)</li>
  <li><strong>쓰레드를 점유하지 않음</strong> (논블로킹)</li>
  <li>응답이 왔을 때만 콜백으로 실행됨</li>
</ul>

<hr />

<h3 id="-정리하자면">💡 정리하자면</h3>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>설명</th>
      <th>예</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>비동기</td>
      <td>요청 → 응답 기다리지 않고 다른 작업함</td>
      <td>콜백, <code class="language-plaintext highlighter-rouge">subscribe</code>, <code class="language-plaintext highlighter-rouge">Future</code>, <code class="language-plaintext highlighter-rouge">CompletableFuture</code></td>
    </tr>
    <tr>
      <td>논블로킹</td>
      <td>시스템 리소스를 점유하지 않음</td>
      <td>WebClient, R2DBC, Netty</td>
    </tr>
    <tr>
      <td>블로킹</td>
      <td>결과 나올 때까지 멈춤</td>
      <td>RestTemplate, JDBC</td>
    </tr>
    <tr>
      <td>비동기 + 논블로킹</td>
      <td>성능 최상 조합</td>
      <td>WebFlux + Netty + R2DBC</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="completablefuture-webclient-코드-예시">CompletableFuture, WebClient 코드 예시</h2>

<h3 id="-1-completablefuture로-비동기-스레드는-점유함--논블로킹-아님">✅ 1. <code class="language-plaintext highlighter-rouge">CompletableFuture</code>로 비동기 (스레드는 점유함 = 논블로킹 아님)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.CompletableFuture</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutionException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsyncWithCompletableFuture</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ExecutionException</span><span class="o">,</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"비동기 시작"</span><span class="o">);</span>

        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="c1">// 시간이 오래 걸리는 작업 (예: API 호출 시뮬레이션)</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span> <span class="c1">// 2초 대기 (스레드 점유)</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="s">"API 결과값"</span><span class="o">;</span>
        <span class="o">});</span>

        <span class="c1">// 다른 작업 수행</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"다른 작업 수행 중..."</span><span class="o">);</span>

        <span class="c1">// 결과 기다리기</span>
        <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="c1">// 여기서 block됨</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"결과: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="-포인트">📌 포인트:</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture</code>는 비동기처럼 보이지만 <strong>실제로는 별도 스레드를 점유</strong>함.</li>
  <li><code class="language-plaintext highlighter-rouge">.get()</code>을 호출하면 <strong>결과를 기다리는 동안 block</strong>됨.</li>
</ul>

<hr />

<h2 id="-2-webclient로-진짜-논블로킹--비동기">🛸 2. <code class="language-plaintext highlighter-rouge">WebClient</code>로 진짜 논블로킹 + 비동기</h2>

<blockquote>
  <p>의존성 필요:</p>
</blockquote>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- build.gradle 혹은 pom.xml --&gt;</span>
implementation 'org.springframework.boot:spring-boot-starter-webflux'
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.web.reactive.function.client.WebClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">reactor.core.publisher.Mono</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsyncWithWebClient</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">WebClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">WebClient</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"WebClient 비동기 호출 시작"</span><span class="o">);</span>

        <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
                <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">"https://jsonplaceholder.typicode.com/todos/1"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
                <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

        <span class="n">response</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">body</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"응답 도착: "</span> <span class="o">+</span> <span class="n">body</span><span class="o">));</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"다른 작업 수행 중..."</span><span class="o">);</span>

        <span class="c1">// 실제로 메인 스레드가 먼저 종료될 수 있어서 약간 대기</span>
        <span class="k">try</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">3000</span><span class="o">);</span> <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="-포인트-1">📌 포인트:</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">WebClient</code>는 진짜 논블로킹 (스레드 점유 X)</li>
  <li><code class="language-plaintext highlighter-rouge">.subscribe()</code>로 <strong>콜백 기반 응답 처리</strong></li>
  <li><strong>메인 스레드는 응답 기다리지 않음</strong>, 논블로킹 체험 가능</li>
</ul>

<hr />

<h2 id="️-비교-요약">⚖️ 비교 요약</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th><code class="language-plaintext highlighter-rouge">CompletableFuture</code></th>
      <th><code class="language-plaintext highlighter-rouge">WebClient</code> (WebFlux)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>스레드 점유</td>
      <td>O (다른 스레드가 일 함)</td>
      <td>X (논블로킹 방식)</td>
    </tr>
    <tr>
      <td>비동기 처리 방식</td>
      <td>Future 기반</td>
      <td>리액티브 스트림 (Mono/Flux)</td>
    </tr>
    <tr>
      <td>논블로킹 체험 가능 여부</td>
      <td>부분적으로 (Thread 풀에 의존)</td>
      <td>O (진짜 논블로킹)</td>
    </tr>
    <tr>
      <td>사용 목적</td>
      <td>간단한 비동기 로직</td>
      <td>고성능, 동시성 높은 네트워크 호출</td>
    </tr>
  </tbody>
</table>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[논블로킹과 비동기에 대해 알아보자.]]></summary></entry><entry><title type="html">[Spring] Thymeleaf</title><link href="https://nan0silver.github.io/spring/2025-04-09-thymeleaf/" rel="alternate" type="text/html" title="[Spring] Thymeleaf" /><published>2025-04-09T00:00:00+00:00</published><updated>2025-04-28T11:12:06+00:00</updated><id>https://nan0silver.github.io/spring/thymeleaf</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-09-thymeleaf/"><![CDATA[<ul>
  <li><a href="#-1-thymeleaf는-왜-쓰는-걸까">Thymeleaf는 왜 쓰는 걸까?</a></li>
  <li><a href="#-2-기본-문법-정리">기본 문법 정리</a></li>
  <li><a href="#-3-전체-흐름-예시">전체 흐름 예시</a></li>
  <li><a href="#-4-어디에-파일을-넣어야-할까">어디에 파일을 넣어야 할까?</a></li>
  <li><a href="#-요약">요약</a></li>
</ul>

<hr />

<h2 id="-1-thymeleaf는-왜-쓰는-걸까">🌱 1. Thymeleaf는 왜 쓰는 걸까?</h2>

<blockquote>
  <p>Spring Boot에서 매우 자주 사용되는 <strong>서버 사이드 템플릿 엔진</strong></p>
</blockquote>

<ul>
  <li>HTML을 그저 정적인 파일로만 쓰는 게 아니라,<br />
<strong>Spring Controller에서 전달한 데이터를 HTML에서 동적으로 표현하고 싶을 때</strong> Thymeleaf를 사용 - HTML에서 Java 객체나 데이터들을 <strong>동적으로 바인딩</strong>해서 화면에 보여줌.</li>
</ul>

<p>예를 들어,<br />
사용자 이름을 동적으로 보여주려면 이런 식으로:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">th:text=</span><span class="s">"${user.name}"</span><span class="nt">&gt;</span>홍길동<span class="nt">&lt;/p&gt;</span>
</code></pre></div></div>

<p>Spring Controller에서 <code class="language-plaintext highlighter-rouge">user</code>라는 객체를 넘기면, <code class="language-plaintext highlighter-rouge">user.name</code>이 자동으로 대체돼서 HTML에 출력된다.</p>

<hr />

<h2 id="-2-기본-문법-정리">🧩 2. 기본 문법 정리</h2>

<h3 id="-thtext--텍스트-출력">① <code class="language-plaintext highlighter-rouge">th:text</code> — 텍스트 출력</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">th:text=</span><span class="s">"${message}"</span><span class="nt">&gt;&lt;/p&gt;</span>
</code></pre></div></div>

<p>→ <code class="language-plaintext highlighter-rouge">${message}</code>의 값을 이 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 태그 안에 출력해줌.</p>

<hr />

<h3 id="-theach--반복문">② <code class="language-plaintext highlighter-rouge">th:each</code> — 반복문</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;li</span> <span class="na">th:each=</span><span class="s">"item : ${items}"</span> <span class="na">th:text=</span><span class="s">"${item}"</span><span class="nt">&gt;&lt;/li&gt;</span>
</code></pre></div></div>

<p>→ <code class="language-plaintext highlighter-rouge">items</code> 리스트를 하나씩 꺼내서 <code class="language-plaintext highlighter-rouge">item</code>으로 반복해 <code class="language-plaintext highlighter-rouge">&lt;li&gt;</code>들을 만든다.</p>

<hr />

<h3 id="-thif-thunless--조건문">③ <code class="language-plaintext highlighter-rouge">th:if</code>, <code class="language-plaintext highlighter-rouge">th:unless</code> — 조건문</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">th:if=</span><span class="s">"${user != null}"</span><span class="nt">&gt;</span>로그인 성공<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;p</span> <span class="na">th:unless=</span><span class="s">"${user != null}"</span><span class="nt">&gt;</span>로그인 해주세요<span class="nt">&lt;/p&gt;</span>
</code></pre></div></div>

<hr />

<h3 id="-thhref-thsrc--링크나-이미지-경로-바인딩">④ <code class="language-plaintext highlighter-rouge">th:href</code>, <code class="language-plaintext highlighter-rouge">th:src</code> — 링크나 이미지 경로 바인딩</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">th:href=</span><span class="s">"@{/home}"</span><span class="nt">&gt;</span>홈으로<span class="nt">&lt;/a&gt;</span> <span class="nt">&lt;img</span> <span class="na">th:src=</span><span class="s">"@{/images/logo.png}"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@{/home}</code>은 <code class="language-plaintext highlighter-rouge">/home</code> 경로를 의미해. 상대경로, 쿼리스트링도 가능하다.</li>
</ul>

<hr />

<h3 id="-thaction--form-전송-주소">⑤ <code class="language-plaintext highlighter-rouge">th:action</code> — form 전송 주소</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;form</span> <span class="na">th:action=</span><span class="s">"@{/submit}"</span> <span class="na">method=</span><span class="s">"post"</span><span class="nt">&gt;&lt;/form&gt;</span>
</code></pre></div></div>

<p>→ <code class="language-plaintext highlighter-rouge">/submit</code>로 POST 요청을 보냄.</p>

<hr />

<h3 id="-thobject--thfield--폼-객체-바인딩">⑥ <code class="language-plaintext highlighter-rouge">th:object</code> + <code class="language-plaintext highlighter-rouge">th:field</code> — 폼 객체 바인딩</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;form</span> <span class="na">th:object=</span><span class="s">"${userForm}"</span> <span class="na">method=</span><span class="s">"post"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">th:field=</span><span class="s">"*{name}"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</code></pre></div></div>

<p>→ <code class="language-plaintext highlighter-rouge">userForm.getName()</code>과 연결돼서, 입력하면 자동으로 매핑됨.</p>

<hr />

<h2 id="-3-전체-흐름-예시">🧠 3. 전체 흐름 예시</h2>

<h3 id="-controller">✅ Controller</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/hello"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">hello</span><span class="o">(</span><span class="nc">Model</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"message"</span><span class="o">,</span> <span class="s">"안녕하세요!"</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"hello"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="-html-hellohtml">✅ HTML (hello.html)</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">xmlns:th=</span><span class="s">"http://www.thymeleaf.org"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>Hello<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;p</span> <span class="na">th:text=</span><span class="s">"${message}"</span><span class="nt">&gt;</span>기본 메시지<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>결과적으로는 <code class="language-plaintext highlighter-rouge">&lt;p&gt;안녕하세요!&lt;/p&gt;</code>가 출력된다.</p>

<hr />

<h2 id="-4-어디에-파일을-넣어야-할까">🧪 4. 어디에 파일을 넣어야 할까?</h2>

<p>Thymeleaf 템플릿 파일들은 이곳에 넣는다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/main/resources/templates/
</code></pre></div></div>

<p>여기 안에 <code class="language-plaintext highlighter-rouge">hello.html</code>, <code class="language-plaintext highlighter-rouge">index.html</code> 같은 HTML 파일들을 넣으면 됨.<br />
이 파일들은 Spring MVC의 Controller에서 return으로 연결할 수 있음</p>

<hr />

<h2 id="-요약">✨ 요약</h2>

<table>
  <thead>
    <tr>
      <th>기능</th>
      <th>문법 예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>텍스트 출력</td>
      <td><code class="language-plaintext highlighter-rouge">th:text="${data}"</code></td>
    </tr>
    <tr>
      <td>반복</td>
      <td><code class="language-plaintext highlighter-rouge">th:each="item : ${items}"</code></td>
    </tr>
    <tr>
      <td>조건문</td>
      <td><code class="language-plaintext highlighter-rouge">th:if</code>, <code class="language-plaintext highlighter-rouge">th:unless</code></td>
    </tr>
    <tr>
      <td>링크 경로</td>
      <td><code class="language-plaintext highlighter-rouge">th:href="@{/path}"</code></td>
    </tr>
    <tr>
      <td>이미지 경로</td>
      <td><code class="language-plaintext highlighter-rouge">th:src="@{/img/logo.png}"</code></td>
    </tr>
    <tr>
      <td>폼 전송 경로</td>
      <td><code class="language-plaintext highlighter-rouge">th:action="@{/submit}"</code></td>
    </tr>
    <tr>
      <td>폼 객체 바인딩</td>
      <td><code class="language-plaintext highlighter-rouge">th:object</code>, <code class="language-plaintext highlighter-rouge">th:field</code></td>
    </tr>
  </tbody>
</table>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[서버 사이드 템플릿 엔진인 Thymeleaf에 대해 알아보자.]]></summary></entry><entry><title type="html">[Spring] JPA vs MyBatis</title><link href="https://nan0silver.github.io/spring/2025-04-05-jpa-mybatis/" rel="alternate" type="text/html" title="[Spring] JPA vs MyBatis" /><published>2025-04-05T00:00:00+00:00</published><updated>2025-04-28T11:12:06+00:00</updated><id>https://nan0silver.github.io/spring/jpa-mybatis</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-05-jpa-mybatis/"><![CDATA[<ul>
  <li><a href="#-jpa란-java-persistence-api">JPA란?</a></li>
  <li><a href="#-mybatis란">MyBatis란?</a></li>
  <li><a href="#-jpa-vs-mybatis">🔍 JPA vs MyBatis</a></li>
  <li><a href="#jpa-vs-mybatis-비유로-이해하기">JPA vs MyBatis 비유로 이해하기</a></li>
  <li><a href="#-jpa-vs-mybatis-코드로-비교하기">JPA vs MyBatis 코드로 비교하기</a></li>
  <li><a href="#-사용-방식-차이-요약">사용 방식 차이 요약</a></li>
  <li><a href="#-장단점-비교">장단점 비교</a></li>
  <li><a href="#-실무에-쓰는-방법">실무에 쓰는 방법</a></li>
  <li><a href="#-한줄-정리">한줄 정리</a></li>
</ul>

<hr />

<h2 id="-jpa란-java-persistence-api">📌 JPA란? (Java Persistence API)</h2>

<ul>
  <li><strong>자바에서 관계형 데이터베이스(RDB)를 객체로 다룰 수 있게 해주는 표준 API</strong>.</li>
  <li>SQL을 직접 작성하지 않아도 객체처럼 DB 데이터를 저장/조회/수정/삭제 가능.</li>
  <li>구현체 중 가장 유명한 것은 <strong>Hibernate</strong>고, Spring에서 주로 이걸 씀.</li>
</ul>

<hr />

<h2 id="jpa-핵심-용어">JPA 핵심 용어</h2>

<table>
  <thead>
    <tr>
      <th>용어</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Entity</strong></td>
      <td>DB 테이블과 매핑되는 자바 클래스</td>
    </tr>
    <tr>
      <td><strong>EntityManager</strong></td>
      <td>JPA의 핵심! DB와 객체 사이의 작업을 처리하는 도구</td>
    </tr>
    <tr>
      <td><strong>Persistence Context (영속성 컨텍스트)</strong></td>
      <td>엔티티를 관리하는 JPA 내부 메모리 공간</td>
    </tr>
    <tr>
      <td><strong>JPQL (Java Persistence Query Language)</strong></td>
      <td>객체 지향 쿼리 언어. SQL과 유사하지만, 테이블이 아닌 클래스/필드 단위로 작동</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-mybatis란">📌 MyBatis란?</h2>

<ul>
  <li><strong>자바에서 SQL을 직접 작성해서 데이터베이스와 통신할 수 있게 해주는 프레임워크.</strong></li>
  <li>SQL 중심의 프로그래밍이 가능하고, <strong>복잡하고 세밀한 쿼리 제어</strong>에 유리함.</li>
  <li>XML 또는 어노테이션 기반으로 SQL을 작성하고, <strong>쿼리 결과를 자바 객체와 매핑</strong>해줌.</li>
  <li><strong>Spring과도 쉽게 통합 가능</strong>하며, 실무에서는 여전히 널리 사용됨.</li>
</ul>

<hr />

<h2 id="mybatis-핵심-용어">MyBatis 핵심 용어</h2>

<table>
  <thead>
    <tr>
      <th>용어</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Mapper 인터페이스</strong></td>
      <td>SQL 문장을 호출하는 자바 인터페이스. XML과 1:1 매칭되어 동작함</td>
    </tr>
    <tr>
      <td><strong>Mapper XML</strong></td>
      <td>실제 SQL이 작성되는 파일. <code class="language-plaintext highlighter-rouge">&lt;select&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;insert&gt;</code> 등 태그로 구성됨</td>
    </tr>
    <tr>
      <td><strong>SqlSession</strong></td>
      <td>DB 연결과 SQL 실행을 담당하는 핵심 객체 (JDBC의 Connection 역할)</td>
    </tr>
    <tr>
      <td><strong>ResultMap</strong></td>
      <td>쿼리 결과를 자바 객체에 <strong>정밀하게 매핑</strong>할 때 사용하는 설정</td>
    </tr>
    <tr>
      <td><strong>#{} / ${}</strong></td>
      <td>SQL 파라미터 바인딩 방식. <code class="language-plaintext highlighter-rouge">#{}</code>는 안전한 바인딩, <code class="language-plaintext highlighter-rouge">${}</code>는 SQL 인젝션 주의</td>
    </tr>
    <tr>
      <td><strong>TypeAlias</strong></td>
      <td>자바 클래스의 이름을 짧게 별칭으로 사용할 수 있도록 하는 기능</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-jpa-vs-mybatis">🔍 JPA vs MyBatis</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>JPA</th>
      <th>MyBatis</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>개발 방식</td>
      <td><strong>자동 매핑</strong> (객체 중심)</td>
      <td><strong>수동 매핑</strong> (SQL 중심)</td>
    </tr>
    <tr>
      <td>핵심 개념</td>
      <td>객체를 DB에 자동 매핑</td>
      <td>직접 SQL 작성 + 매핑</td>
    </tr>
    <tr>
      <td>학습 곡선</td>
      <td>좀 더 높음 (추상화 많음)</td>
      <td>비교적 쉬움 (SQL 그대로 작성)</td>
    </tr>
    <tr>
      <td>유연성</td>
      <td>추상화 많아 덜 유연함</td>
      <td>SQL 작성 자유로움</td>
    </tr>
    <tr>
      <td>성능 제어</td>
      <td>ORM에 맡김 (튜닝 어려움)</td>
      <td>직접 SQL 작성으로 제어 쉬움</td>
    </tr>
    <tr>
      <td>대표 도구</td>
      <td>Hibernate (JPA 구현체)</td>
      <td>MyBatis 프레임워크</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="jpa-vs-mybatis-비유로-이해하기">JPA vs MyBatis 비유로 이해하기</h2>

<h3 id="️-jpa--자동세탁기-">☝️ JPA = 자동세탁기 👕</h3>

<ul>
  <li><strong>세탁기 안에 옷(객체)</strong>을 넣으면<br />
→ 알아서 물(쿼리) 넣고, 빨고, 말리고<br />
→ 깨끗한 결과(조회된 객체)를 자동으로 꺼내줌!</li>
</ul>

<blockquote>
  <p>→ 개발자는 <strong>“옷만 넣고 결과만 받으면 됨”</strong><br />
→ 단, 세탁 방식은 기계가 알아서 함 (튜닝 어려움)</p>
</blockquote>

<hr />

<h3 id="️-mybatis--손빨래-">✌️ MyBatis = 손빨래 🧼</h3>

<ul>
  <li><strong>개발자가 직접</strong> 물 붓고, 비비고, 헹구고</li>
  <li>어떤 SQL 쿼리를 쓰고, 어떤 칼럼을 어떤 필드에 넣을지도 <strong>직접 지정</strong></li>
</ul>

<blockquote>
  <p>→ 개발자는 <strong>“컨트롤을 많이 할 수 있음”</strong><br />
→ 다만 <strong>귀찮고 실수할 가능성 있음</strong></p>
</blockquote>

<hr />

<h2 id="-jpa-vs-mybatis-코드로-비교하기">🧩 JPA vs MyBatis 코드로 비교하기</h2>

<h3 id="-jpa-예제-hibernate-기반">✅ JPA 예제 (Hibernate 기반)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 저장</span>
<span class="nc">Member</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"Sungwoo"</span><span class="o">);</span>
<span class="n">entityManager</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>

<span class="c1">// 조회</span>
<span class="nc">Member</span> <span class="n">result</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
</code></pre></div></div>

<p>👉 SQL 없이 객체만 조작하면 됨!<br />
→ <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">SELECT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, <code class="language-plaintext highlighter-rouge">DELETE</code>를 <strong>자동으로 처리</strong></p>

<hr />

<h3 id="-mybatis-예제">✅ MyBatis 예제</h3>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- mapper.xml --&gt;</span>
<span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"findMemberById"</span> <span class="na">parameterType=</span><span class="s">"long"</span> <span class="na">resultType=</span><span class="s">"Member"</span><span class="nt">&gt;</span>
  SELECT id, name FROM members WHERE id = #{id}
<span class="nt">&lt;/select&gt;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 자바 코드</span>
<span class="nc">Member</span> <span class="n">m</span> <span class="o">=</span> <span class="n">memberMapper</span><span class="o">.</span><span class="na">findMemberById</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
</code></pre></div></div>

<p>👉 SQL을 내가 직접 작성함<br />
→ DB 구조가 복잡하거나 튜닝이 필요할 땐 <strong>더 유리</strong></p>

<hr />

<h2 id="-사용-방식-차이-요약">✅ 사용 방식 차이 요약</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>JPA</th>
      <th>MyBatis</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SQL 작성</td>
      <td>❌ 안 함 (자동)</td>
      <td>✅ 직접 함</td>
    </tr>
    <tr>
      <td>객체 ↔ DB 매핑</td>
      <td>자동 처리</td>
      <td>명시적 지정</td>
    </tr>
    <tr>
      <td>코드 양</td>
      <td>적음</td>
      <td>많음</td>
    </tr>
    <tr>
      <td>유지보수</td>
      <td>테이블 구조 바뀌면 자동 적용</td>
      <td>SQL 전부 수정해야 함</td>
    </tr>
    <tr>
      <td>복잡한 쿼리</td>
      <td>어려움 (JPQL, QueryDSL)</td>
      <td>자유롭고 세밀하게 가능</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-장단점-비교">✅ 장단점 비교</h2>

<h3 id="-jpa의-장점">🟢 JPA의 장점</h3>

<ul>
  <li>생산성 높음 (코드 적게 작성)</li>
  <li>객체 지향적으로 설계 가능</li>
  <li>유지보수 편함 (쿼리 덜 바꿈)</li>
  <li>캐싱, 지연 로딩, 영속성 컨텍스트 등 부가기능 풍부</li>
  <li><code class="language-plaintext highlighter-rouge">JapRepository</code>를 상속하면 Spring Data JPA가 자동으로 구현체를 만들어서 사용할 수 있게 해줌
    <ul>
      <li>자세히 정리한 포스트 👉 <a href="https://nan0silver.github.io/spring/2025-04-17-query-method/">JPA Query Method</a></li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="-jpa의-단점">🔴 JPA의 단점</h3>

<ul>
  <li>처음 배울 때 어렵고 추상화가 깊음</li>
  <li>성능 튜닝 어려움</li>
  <li>복잡한 쿼리 작성이 불편함 (<code class="language-plaintext highlighter-rouge">JOIN</code>, <code class="language-plaintext highlighter-rouge">GROUP BY</code> 등)</li>
</ul>

<hr />

<h3 id="-mybatis의-장점">🟢 MyBatis의 장점</h3>

<ul>
  <li>SQL을 자유롭게 짤 수 있어 → DB 성능 튜닝 유리</li>
  <li>복잡한 쿼리나 데이터 조작에 강함</li>
  <li>개발자 컨트롤이 높음</li>
</ul>

<hr />

<h3 id="-mybatis의-단점">🔴 MyBatis의 단점</h3>

<ul>
  <li>반복 코드 많음 (SQL + 매핑 따로)</li>
  <li>유지보수 힘듦 (테이블 구조 바뀌면 SQL 전부 바꿔야 함)</li>
  <li>객체 지향 구조 만들기 어렵고, 연결이 느슨함</li>
</ul>

<hr />

<h2 id="-실무에-쓰는-방법">✅ 실무에 쓰는 방법</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>실무 선택</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>단순한 CRUD 위주의 서비스</td>
      <td>JPA (빠르고 코드 간결)</td>
    </tr>
    <tr>
      <td>복잡한 SQL 다루는 시스템</td>
      <td>MyBatis</td>
    </tr>
    <tr>
      <td>대기업/공공 시스템</td>
      <td>아직도 MyBatis 많음</td>
    </tr>
    <tr>
      <td>스타트업/신규 프로젝트</td>
      <td>JPA + QueryDSL 조합 인기</td>
    </tr>
    <tr>
      <td>둘 다 필요</td>
      <td>일부는 JPA, 일부는 MyBatis 혼용 (실제로 많음)</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-한줄-정리">📌 한줄 정리</h2>

<blockquote>
  <p>“JPA는 객체 중심의 ORM 프레임워크로, DB와의 데이터 처리를 추상화해 코드 생산성을 높여줍니다. 반면 MyBatis는 SQL 중심의 프레임워크로, 복잡한 쿼리나 성능 튜닝이 필요한 경우에 유리합니다. 프로젝트 성격에 따라 두 기술을 선택하거나 병행할 수 있습니다.”</p>
</blockquote>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[JPA vs MyBatis에 대 알아보자.]]></summary></entry><entry><title type="html">[Spring] DTO vs VO vs Entity</title><link href="https://nan0silver.github.io/spring/2025-04-02-dto-vo/" rel="alternate" type="text/html" title="[Spring] DTO vs VO vs Entity" /><published>2025-04-02T00:00:00+00:00</published><updated>2025-04-28T11:12:06+00:00</updated><id>https://nan0silver.github.io/spring/dto-vo</id><content type="html" xml:base="https://nan0silver.github.io/spring/2025-04-02-dto-vo/"><![CDATA[<ul>
  <li><a href="#dto-vs-vo-vs-entity">DTO vs VO vs Entity</a></li>
  <li><a href="#-dto-vs-vo">📦 DTO vs VO</a></li>
  <li><a href="#-entity-vs-vo">📦 Entity vs VO</a></li>
  <li><a href="#-entity와-dto로-분리해야하는-이유">📦 Entity와 DTO로 분리해야하는 이유</a></li>
  <li><a href="#코드-예제">코드 예제</a></li>
  <li><a href="#-면접-시-설명-예시">💬 면접 시 설명 예시</a></li>
  <li><a href="#-java-17부터는-record로-vo를-만들기-더-쉬워짐">🚀 Java 17부터는 <code class="language-plaintext highlighter-rouge">record</code>로 VO를 만들기 더 쉬워짐!</a></li>
</ul>

<hr />

<h2 id="dto-vs-vo-vs-entity">DTO vs VO vs Entity</h2>

<blockquote>
  <p>Entity는 DB와 매핑되는 핵심 객체, DTO는 데이터 전달용 객체, VO는 값 자체에 의미가 있는 불변 객체
Entity는 저장용, DTO는 전달용, VO는 표현용 객체</p>
</blockquote>

<ul>
  <li>
    <p>DTO : Data Transfer Object ➡️ 데이터 전달용 객체 (계층 간, 네트워크 등)</p>

    <ul>
      <li>🚐 손님에게 배달될 포장된 도시락
        <ul>
          <li>음식점 → 배달기사 → 고객까지 전달하는 용도
            <ul>
              <li>💡 클라이언트와 데이터 주고받는 운반용 객체! 💡</li>
            </ul>
          </li>
          <li>메뉴명, 수량, 요청사항 등 담겨 있고, 전달 중에 수정될 수도 있음 (상황에 따라 포장을 다르게 담을 수 있다.)</li>
        </ul>
      </li>
      <li>외부에 노출되는 API요청이나 응답은 Entity가 아닌 DTO를 통해 전달함으로써 보안성과 유연성을 확보</li>
    </ul>

    <blockquote>
      <p>🔴 DTO는 데이터를 <strong>“옮기는 상자”</strong></p>
    </blockquote>
  </li>
  <li>
    <p>VO : Value Object ➡️ 값을 표현하는 객체 (의미 있는 불변 값)</p>

    <ul>
      <li>🍱 도시락 자체
        <ul>
          <li>만들어지면 바꿀 수 없음 (불변)</li>
          <li>메뉴가 같으면 같은 도시락 취급</li>
          <li>값 자체가 의미 있음 - 예: 좌표, 돈, 날짜, 주소 등</li>
        </ul>
      </li>
    </ul>

    <blockquote>
      <p>🔴 VO는 의미 있는 값을 담은 <strong>“정체성 있는 객체”</strong></p>

      <blockquote>
        <p>“무엇을 나타내는 값인지”가 중요한 객체</p>
      </blockquote>
    </blockquote>
  </li>
  <li>
    <p>Entity ➡️ 실제 DB 테이블과 연결된 핵심 객체</p>

    <ul>
      <li>🍱 도시락 안의 구성 요소 (밥, 반찬, 소스 등)
        <ul>
          <li>소중하기 때문에 주방 안에서만 써야 함</li>
        </ul>
      </li>
      <li>Entity는 VO를 포함할 수 있음</li>
      <li>DB와 직접 연결된 객체이기 때문에 식별자가 존재하며 상태가 바뀔 수 있음</li>
    </ul>

    <blockquote>
      <p>🔴 Entity는 “누구인지”를 <strong>식별할 수 있는 객체</strong></p>
    </blockquote>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/nan0silver/nan0silver.github.io/7ddb58f4af0e22814e7e85a4f7111495d9cd25eb/assets/img/blog/2025-04-02-dto-vo.png" alter="DTOvsVOvsEntity" /></p>

<h2 id="-dto-vs-vo">📦 DTO vs VO</h2>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>DTO</th>
      <th>VO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>목적</td>
      <td><strong>데이터 전달</strong></td>
      <td><strong>값 표현</strong></td>
    </tr>
    <tr>
      <td>가변성</td>
      <td><strong>가변(mutable)</strong></td>
      <td><strong>불변(immutable)</strong></td>
    </tr>
    <tr>
      <td>equals/hashCode 기준</td>
      <td>주소 (기본)</td>
      <td><strong>값 기준으로 재정의</strong></td>
    </tr>
    <tr>
      <td>주 사용 위치</td>
      <td>Controller ↔ Service ↔ API</td>
      <td>도메인 내부, 로직 내 값 처리</td>
    </tr>
    <tr>
      <td>예시</td>
      <td>회원 요청 객체, 응답 DTO 등</td>
      <td>Money, Address, Coordinate 등</td>
    </tr>
    <tr>
      <td>생성 시</td>
      <td>언제든 생성 가능</td>
      <td>생성 후에는 값 변경 ❌</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-entity-vs-vo">📦 Entity vs VO</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Entity</th>
      <th>VO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>의미</td>
      <td><strong>DB 테이블과 1:1 매핑되는 객체</strong></td>
      <td><strong>의미 있는 작은 값 단위 객체</strong></td>
    </tr>
    <tr>
      <td>식별자 (ID)</td>
      <td><strong>있음 (PK, 고유값)</strong></td>
      <td><strong>없음 (값 자체로 구별)</strong></td>
    </tr>
    <tr>
      <td>불변성</td>
      <td>보통 가변</td>
      <td><strong>보통 불변 (<code class="language-plaintext highlighter-rouge">final</code>)</strong></td>
    </tr>
    <tr>
      <td>관리 위치</td>
      <td>DB와 연결되는 핵심 모델</td>
      <td>Entity 안의 필드나 계산용 값</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-entity와-dto로-분리해야하는-이유">📦 Entity와 DTO로 분리해야하는 이유</h2>

<blockquote>
  <p>굳이 클래스를 2개로 나누지 않고 그냥 Entity 하나로 다 처리하면 안 되는 이유!</p>
</blockquote>

<ul>
  <li>구체적인 이유 5가지
    <ol>
      <li>보안
        <ul>
          <li>Entity에는 민감한 필드(비밀번호 등)가 있을 수 있음 ➡️ 그대로 외부에 노출하면 위험</li>
        </ul>
      </li>
      <li>유연성
        <ul>
          <li>API 요청/응답마다 필요한 필드가 다름 ➡️ DTO로 맞춤 설계 가능</li>
        </ul>
      </li>
      <li>엔티티 보호
        <ul>
          <li>DTO로 외부와 통신 ➡️ Entity는 내부에서만 안전하게 관리</li>
        </ul>
      </li>
      <li>유효성 검사 분리
        <ul>
          <li><code class="language-plaintext highlighter-rouge">@Valid</code>, <code class="language-plaintext highlighter-rouge">@NotNull</code>등 검증 로직은 DTO에만 적용
            <blockquote>
              <p>Entity는 DB와 연결된 순수한 모델이여야 함으로 비즈니스 룰, 요청 유효성 검증 같은 책임이 없어야 한다.</p>

              <blockquote>
                <p>JPA의 역할은 저장, 조회인데 검증 로직이 섞이면 책임이 뒤엉킴 (SRP(Single Responsibility Principle) 위반)</p>
              </blockquote>
            </blockquote>
          </li>
        </ul>
      </li>
      <li>레이어 분리 원칙
        <ul>
          <li>Controller ↔ Service ↔ Repository 역할 구분이 명확해짐
            <blockquote>
              <p>“Controller” : 클라이언트와 통신 (DTO 입출력)
“Service” : 비즈니스 로직 (DTO 🔁 Entity 변환, 로직 처리)
“Repository” : DB 접근 (Entity 전용)</p>

              <blockquote>
                <p>DTO와 Entity를 나누지 않고 Controller, Service에서 Entity를 직접 다루면</p>

                <ul>
                  <li>한 객체가 너무 많은 계층을 넘나듬 (의존성 얽힘)</li>
                  <li>책임이 명확하지 않음 (수정 시 어디를 고쳐야 할지 모름)</li>
                  <li>보안 이슈 발생 가능 (불필요한 필드 노출)</li>
                </ul>
              </blockquote>
            </blockquote>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<hr />

<h2 id="코드-예제">코드 예제</h2>

<h3 id="-dto-값-전달용-가변-객체">✅ DTO (값 전달용, 가변 객체)</h3>

<ul>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberDTO</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
      <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

      <span class="c1">// 생성자</span>
      <span class="kd">public</span> <span class="nf">MemberDTO</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
          <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="c1">// getter &amp; setter (값 변경 가능!)</span>
      <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>

      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>setName(), setAge()처럼 값은 변경 가능</li>
  <li>주로 Controller 🔁 Service 🔁 Client 간 데이터 전달용</li>
</ul>

<h3 id="-vo-값-표현용-불변-객체">✅ VO (값 표현용, 불변 객체)</h3>

<ul>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Money</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">;</span>

      <span class="kd">public</span> <span class="nf">Money</span><span class="o">(</span><span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">amount</span> <span class="o">=</span> <span class="n">amount</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAmount</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">amount</span><span class="o">;</span> <span class="o">}</span>

      <span class="c1">// 값 기반 equals, hashCode</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
          <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Money</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
          <span class="nc">Money</span> <span class="n">money</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Money</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
          <span class="k">return</span> <span class="n">amount</span> <span class="o">==</span> <span class="n">money</span><span class="o">.</span><span class="na">amount</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">amount</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>필드가 <code class="language-plaintext highlighter-rouge">final</code>, setter없음 → 불변 객체</li>
  <li>equals() 재정의 → 값이 같으면 같은 객체로 간주</li>
  <li>주로 비즈니스 로직 내부에서 의미 있는 값 표현용</li>
</ul>

<h3 id="-entity">✅ Entity</h3>

<ul>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>  <span class="c1">// 노출되면 안 되는 정보</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="-면접-시-설명-예시">💬 면접 시 설명 예시</h2>

<blockquote>
  <p>“DTO는 계층 간 데이터를 전달할 때 사용하는 객체로, 보통 가변이고 네트워크나 컨트롤러에 노출됩니다. 반면 VO는 불변 객체로, 값 자체가 의미를 가지며 equals와 hashCode를 통해 같은 값을 같다고 간주해 도메인 모델 내에서 활용됩니다. Entity는 DB와 직접 연결된 객체로 식별자가 존재하며 상태가 바뀔 수 있습니다. 외부에 노출되는 API 요청이나 응답은 Entity가 아닌 DTO를 통해 전달함으로써 보안성과 유연성을 확보할 수 있습니다.”</p>
</blockquote>

<hr />

<h2 id="-java-17부터는-record로-vo를-만들기-더-쉬워짐">🚀 Java 17부터는 <code class="language-plaintext highlighter-rouge">record</code>로 VO를 만들기 더 쉬워짐!</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">Coordinate</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">final</code>, 불변성, equals/hashCode 자동 구현!</li>
  <li><strong>값 객체(VO)</strong>를 표현할 때 <strong>record는 아주 강력한 도구</strong></li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="spring" /><summary type="html"><![CDATA[Spring에서 데이터를 다루는 객체인 DTO, VO, Entity의 차이점에 대해 알아보자.]]></summary></entry></feed>