<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-11-11T05:28:33+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[친구하자] Capacitor로 웹을 앱으로 빌드해보자!</title><link href="https://nan0silver.github.io/projectdiary/2025-11-10-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor로 웹을 앱으로 빌드해보자!" /><published>2025-11-10T00:00:00+00:00</published><updated>2025-11-11T05:27:50+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-10-diary/"><![CDATA[<ul>
  <li>지난 글에서는 Capacitor로 Android, iOS 앱 빌드하는 방법에 대해 다뤘다.</li>
  <li>이번 글에서는 Capacitor로 빌드한 Android 앱에서 로그인 연동을 하는 방법에 대해 다뤄보겠다.</li>
  <li>특히 CORS 에러 해결에 대해 다뤄보겠다..
    <blockquote>
      <p>저번에 한번 여기까진 해결을 했었는데,, 다 밀고 다시하는 과정에서 까먹어서.. 이번에도 삽질을 했다..🥲 진짜 울뻔함</p>
    </blockquote>
  </li>
</ul>

<h2 id="문제-상황">문제 상황</h2>

<ul>
  <li>일단 내 프로젝트의 상황을 말하자면</li>
</ul>

<ol>
  <li>React로 웹 빌드시 nginx 사용하고 있음</li>
  <li>Android 앱 빌드 (Capacitor로 감싸고 있음)</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>앱/웹] → HTTPS <span class="o">(</span>443<span class="o">)</span> → <span class="o">[</span>Nginx] → HTTP <span class="o">(</span>8080<span class="o">)</span> → <span class="o">[</span>Spring Boot]
</code></pre></div></div>

<ul>
  <li>
    <p>Nginx의 역할은</p>

    <ol>
      <li>SSL 종료
        <ul>
          <li>HTTPS를 HTTP로 변환</li>
        </ul>
      </li>
      <li>리버스 프록시
        <ul>
          <li>요청을 8080포트로 전달</li>
        </ul>
      </li>
      <li>‼️ 문제 : OPTIONS preflight 요청이 여기서 자꾸 막혔다.🤮</li>
    </ol>

    <p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-10-pic1.png?raw=true" alt="에러 이미지" />
<img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-10-pic2.png?raw=true" alt="에러 이미지2" /></p>
  </li>
</ul>

<h3 id="왜-웹은-되고-앱은-안될까">왜 웹은 되고 앱은 안될까?</h3>

<ul>
  <li>웹 브라우저와 Capacitor WebView는 preflight OPTIONS 요청을 다르게 보낸다.</li>
</ul>

<ol>
  <li>웹
    <ul>
      <li>Origin이 <code class="language-plaintext highlighter-rouge">https://chingoohaja.app</code> -&gt; Nginx가 통과시킴</li>
    </ul>
  </li>
  <li>앱
    <ul>
      <li>Origin이 <code class="language-plaintext highlighter-rouge">https:/localhost</code> -&gt; Nginx가 의심
        <blockquote>
          <p>Capacitor의 URL/orign은 아래와 같다</p>

          <blockquote>
            <p>iOS: capacitor://localhost
Android: http://localhost</p>
          </blockquote>
        </blockquote>
      </li>
    </ul>
  </li>
</ol>

<ul>
  <li>서버에서 Cors설정과 Security설정은 다 해놨다.</li>
  <li>그런데도 CORS 에러가 해결되지않아서 Nginx 설정 파일을 손을 댔다
    <ul>
      <li>도메인들을 Nginx에서 동적으로 orign 반환하는 형식으로도 수정을 해봤고..</li>
      <li>모든 도메인을 다 허용도 해봤고..</li>
    </ul>
  </li>
  <li>그런데 CORS 문제는 해결이 되지않았다..!</li>
  <li>하지만 해결방법은 생각보다 간단했다..</li>
</ul>

<h2 id="해결-방법">해결 방법</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">capacitor.config.ts</code>파일에 capacitor의 HTTP 플러그인을 추가해준다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plugins: {
    CapacitorHttp: {
      enabled: true,
    },
  },
</code></pre></div></div>

<ul>
  <li>
    <p>물론 서버에서 설정을 다 해준 다음 이 코드도 추가해줘야한다.</p>
  </li>
  <li>이틀간의 삽질이 끝났다..</li>
  <li>이제 리다이렉트 지옥이 시작임</li>
</ul>

<h3 id="참고-문헌">참고 문헌</h3>

<ul>
  <li><a href="https://stackoverflow.com/questions/75192411/cors-in-capacitor-for-android">StackOverFlow가 짱이야</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[Capacitor로 빌드한 Android 앱 로그인 연동 해보자! - CORS 에러 해결에 대해 다룹니다.]]></summary></entry><entry><title type="html">[친구하자] Capacitor로 웹을 앱으로 빌드해보자!</title><link href="https://nan0silver.github.io/projectdiary/2025-11-06-diary/" rel="alternate" type="text/html" title="[친구하자] Capacitor로 웹을 앱으로 빌드해보자!" /><published>2025-11-06T00:00:00+00:00</published><updated>2025-11-11T05:27:50+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-11-06-diary/"><![CDATA[<ul>
  <li>“친구하자”를 웹으로 MVP 완성을 하니, 이걸 앱으로 빌드해서 사용자들이 더 쉽게 사용할 수 있으면 좋겠다고 생각했다.</li>
  <li>원래는.. 개발자의 입장으로 링크로 이동하는 방식이 쉬울꺼라고 생각했는데, 막상 사용자에게 링크를 보내주니까 어려움을 토로하거나 방식에 의문을 가지는 사람들이 많았다..
    <ul>
      <li>링크는 일단 어디 저장해놓고 찾아서 연결해야하고..</li>
      <li>핸드폰에서 링크를 통해 이동하는 방식이 익숙하지 않은 사람들이 더 많았다.. (일회용 링크정도만 다들 사용하는 것 같았다.)</li>
    </ul>
  </li>
  <li>네이티브 앱으로 개발하는건 일단 시간이 많이 드니까 최대한 빠른 방법을 찾아보다가 Capacitor 플러그인을 찾게 되었다.</li>
</ul>

<h2 id="capacitor">Capacitor</h2>

<ul>
  <li><a href="https://capacitorjs.com/">Capacitor</a>는 기존 React웹을 네이티브 앱 컨테이너에 담아주는 플러그인이다.</li>
  <li>기존의 React 코드베이스를 거의 건들이지 않고 모바일 앱을 만들 수 있게 해준다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>기존 React 웹 앱
         ↓
    Capacitor 추가
         ↓
네이티브 WebView에서 실행
(iOS/Android 앱으로 패키징)
</code></pre></div></div>

<ul>
  <li>설치만 해서 간단하게 앱으로 빌드할 수 있다!</li>
  <li>일단 나는 ios로 빌드하는 것을 아래에 보여주겠다.</li>
</ul>

<h2 id="capacitor로-ios-앱-빌드하기">Capacitor로 iOS 앱 빌드하기</h2>

<ul>
  <li>
    <p>일단 내 기존 프론트 프로젝트 스펙을 정리하자면</p>

    <ul>
      <li>많은 의존성을 가짐(특히 @radix-ui/* 패키지들)</li>
      <li>React 18 + TypeScript + Vite 스택</li>
      <li>Express 서버 통합</li>
    </ul>
  </li>
  <li>따라서 npm이 아닌 pnpm을 사용하고 있다.</li>
  <li>capacitor 공식문서에는 npm으로 설명이 나와있는데, 그냥 pnpm 명령어로만 바꿔서 똑같이 진행해줬다.</li>
</ul>

<h3 id="1-capacitor의-메인-의존성-설치">1. Capacitor의 메인 의존성 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pnpm add @capacitor/core @capacitor/cli
</code></pre></div></div>

<p>프로젝트 루트 디렉토리에 위의 명령어를 입력!</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic1.png?raw=true" alt="성공 이미지" /></p>

<h3 id="2-capacitor-config-초기화">2. Capacitor Config 초기화</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npx cap init
</code></pre></div></div>

<ul>
  <li>여기서는 이름과, Project ID를 입력하라고 한다.</li>
  <li>Project ID는 도메인 네임 형태로 적어주면 된다. (예: com.example.app)</li>
  <li>나는 프론트 도메인을 사놓은게 있어서 그대로 넣었다.</li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic2.png?raw=true" alt="성공 이미지2" /></p>

<h3 id="3-플랫폼-추가-android-ios">3. 플랫폼 추가 (android, iOS)</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Android</span>
pnpm add @capacitor/android

<span class="c"># iOS (macOS에서만)</span>
pnpm add @capacitor/android
</code></pre></div></div>

<ul>
  <li>
    <p>나는 맥북에서 작업하고 있기 때문에 둘다 추가해줬다.</p>

    <blockquote>
      <p>ios 만들고 싶어서 3년전에 맥북 샀던 기억..</p>
    </blockquote>
  </li>
  <li>
    <p>성공하면 아래와 같은 메시지가 나온다.</p>
  </li>
</ul>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic3.png?raw=true" alt="성공 이미지3" /></p>

<h3 id="이제-실행해보자">이제 실행해보자!!</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Android</span>
npx cap run android

<span class="c"># iOS</span>
npx cap run ios
</code></pre></div></div>

<p>일단 ios로 아래와 같이 실행 성공!</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic4.png?raw=true" alt="성공 이미지4" height="500" /></p>

<p><br />
다음에 android studio 업데이트를 좀 하고.. (안한지 넘 오래됌..) 아래와 같이 빌드 성공!</p>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-11-06-pic5.png?raw=true" alt="성공 이미지5" height="500" /></p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[웹을 앱으로 빠르게 빌드하기 위해 Capacitor를 사용해보기]]></summary></entry><entry><title type="html">[Algorithm] 코테에서 자주 쓰이는 Collection 모음</title><link href="https://nan0silver.github.io/algorithm/2025-10-23-collections/" rel="alternate" type="text/html" title="[Algorithm] 코테에서 자주 쓰이는 Collection 모음" /><published>2025-10-23T00:00:00+00:00</published><updated>2025-11-11T05:27:50+00:00</updated><id>https://nan0silver.github.io/algorithm/collections</id><content type="html" xml:base="https://nan0silver.github.io/algorithm/2025-10-23-collections/"><![CDATA[<ol>
  <li><a href="#️-1️⃣-hashmapk-v--key-value-형태로-빠르게-찾고-세는-용도">HashMap</a></li>
  <li><a href="#-2️⃣-hashset--중복-없는-데이터-저장">HashSet</a></li>
  <li><a href="#-3️⃣-arraylist--순서-있는-리스트-인덱스-접근-가능">ArrayList</a></li>
  <li><a href="#-4️⃣-priorityqueue--우선순위-큐-힙">PriorityQueue</a></li>
  <li><a href="#-5️⃣-stack--queue-deque--선형-구조">Stack / Queue</a></li>
  <li><a href="#-6️⃣-collections--arrays-유틸리티-메서드">Collections / Arrays</a></li>
  <li><a href="#-추천-연습문제-유형별-활용-예시">추천 연습문제 유형별 활용 예시</a></li>
</ol>

<hr />

<h2 id="️-1️⃣-hashmapk-v--key-value-형태로-빠르게-찾고-세는-용도">🗂️ 1️⃣ HashMap&lt;K, V&gt; — key-value 형태로 빠르게 찾고 세는 용도</h2>

<h3 id="-핵심-활용-상황">💡 핵심 활용 상황</h3>

<ul>
  <li>“이 값이 몇 번 나왔는가?”</li>
  <li>“이 key가 이미 존재하나?”</li>
  <li>“카테고리별 개수 세기 (위장 문제 등)”</li>
</ul>

<h3 id="-자주-쓰는-메서드">🚀 자주 쓰는 메서드</h3>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
      <th>예시 코드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">put(K key, V value)</code></td>
      <td>값 삽입 (덮어씀)</td>
      <td><code class="language-plaintext highlighter-rouge">map.put("apple", 3);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">get(K key)</code></td>
      <td>key로 value 조회</td>
      <td><code class="language-plaintext highlighter-rouge">int v = map.get("apple");</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">getOrDefault(K key, V defaultVal)</code></td>
      <td>key 없으면 기본값 반환</td>
      <td><code class="language-plaintext highlighter-rouge">map.getOrDefault("pear", 0);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">containsKey(K key)</code></td>
      <td>key 존재 여부</td>
      <td><code class="language-plaintext highlighter-rouge">if (map.containsKey("apple"))</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(K key)</code></td>
      <td>key/value 쌍 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">map.remove("apple");</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">keySet()</code></td>
      <td>모든 key 조회</td>
      <td><code class="language-plaintext highlighter-rouge">for (String k : map.keySet())</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">values()</code></td>
      <td>모든 value 조회</td>
      <td><code class="language-plaintext highlighter-rouge">for (int v : map.values())</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">entrySet()</code></td>
      <td>key+value 동시 접근</td>
      <td>`for (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) {</td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> System.out.println(e.getKey() + " → " + e.getValue());
</code></pre></div></div>

<p>}<code class="language-plaintext highlighter-rouge">|
|</code>size()<code class="language-plaintext highlighter-rouge">| 원소 수 |</code>map.size();<code class="language-plaintext highlighter-rouge">|
|</code>clear()<code class="language-plaintext highlighter-rouge">| 모두 삭제 |</code>map.clear();` |</p>

<hr />

<h2 id="-2️⃣-hashset--중복-없는-데이터-저장">🧩 2️⃣ HashSet — 중복 없는 데이터 저장</h2>

<h3 id="-핵심-활용-상황-1">💡 핵심 활용 상황</h3>

<ul>
  <li>“이미 나온 적 있는 값인가?”</li>
  <li>“교집합, 중복 제거”</li>
  <li>“전화번호부 접두사, 참가자 중 완주 못한 사람 찾기 등”</li>
</ul>

<h3 id="-자주-쓰는-메서드-1">🚀 자주 쓰는 메서드</h3>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
      <th>예시 코드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(E e)</code></td>
      <td>원소 추가</td>
      <td><code class="language-plaintext highlighter-rouge">set.add("apple");</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">contains(E e)</code></td>
      <td>포함 여부 확인</td>
      <td><code class="language-plaintext highlighter-rouge">if (set.contains("apple"))</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(E e)</code></td>
      <td>원소 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">set.remove("apple");</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td>원소 개수</td>
      <td><code class="language-plaintext highlighter-rouge">set.size();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">clear()</code></td>
      <td>모두 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">set.clear();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td>비었는지 확인</td>
      <td><code class="language-plaintext highlighter-rouge">if (set.isEmpty())</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">iterator()</code></td>
      <td>순회용 Iterator 생성</td>
      <td><code class="language-plaintext highlighter-rouge">for (String s : set) System.out.println(s);</code></td>
    </tr>
  </tbody>
</table>

<p>or
<code class="language-plaintext highlighter-rouge">Iterator&lt;String&gt; it = set.iterator();
while (it.hasNext()) {
      System.out.println(it.next());
}</code> |</p>

<blockquote>
  <p>💡 참고: HashSet은 내부적으로 HashMap을 사용하므로 add, contains 모두 O(1)입니다.</p>
</blockquote>

<hr />

<h2 id="-3️⃣-arraylist--순서-있는-리스트-인덱스-접근-가능">📋 3️⃣ ArrayList — 순서 있는 리스트 (인덱스 접근 가능)</h2>

<h3 id="-핵심-활용-상황-2">💡 핵심 활용 상황</h3>

<ul>
  <li>“순차적 접근”, “정렬”, “조합/순열 저장”</li>
  <li>BFS/DFS에서 방문 순서 저장 등</li>
</ul>

<h3 id="-자주-쓰는-메서드-2">🚀 자주 쓰는 메서드</h3>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
      <th>예시 코드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(E e)</code></td>
      <td>끝에 추가</td>
      <td><code class="language-plaintext highlighter-rouge">list.add(5);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(int idx, E e)</code></td>
      <td>인덱스에 삽입</td>
      <td><code class="language-plaintext highlighter-rouge">list.add(1, 10);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">get(int idx)</code></td>
      <td>특정 인덱스 조회</td>
      <td><code class="language-plaintext highlighter-rouge">list.get(0);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">set(int idx, E e)</code></td>
      <td>특정 위치 값 수정</td>
      <td><code class="language-plaintext highlighter-rouge">list.set(2, 99);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(int idx)</code></td>
      <td>인덱스로 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">list.remove(1);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">contains(E e)</code></td>
      <td>포함 여부</td>
      <td><code class="language-plaintext highlighter-rouge">if (list.contains(5))</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td>크기 확인</td>
      <td><code class="language-plaintext highlighter-rouge">list.size();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">clear()</code></td>
      <td>모두 삭제</td>
      <td><code class="language-plaintext highlighter-rouge">list.clear();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sort(Comparator&lt;? super E&gt; c)</code></td>
      <td>정렬</td>
      <td>`Arrays.sort(arr, new Comparator<String>() {</String></td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        @Override
        public int compare(String o1, String o2) {
            if (o1.length()==o2.length()) {
                return o1.compareTo(o2);
            } else {
                return o1.length()-o2.length();
            }}});` |
</code></pre></div></div>

<hr />

<h2 id="-4️⃣-priorityqueue--우선순위-큐-힙">🧮 4️⃣ PriorityQueue — 우선순위 큐 (힙)</h2>

<h3 id="-핵심-활용-상황-3">💡 핵심 활용 상황</h3>

<ul>
  <li>“가장 작은/큰 값”을 반복적으로 꺼낼 때 (Dijkstra, HeapSort, 스케줄링 문제 등)</li>
</ul>

<h3 id="-자주-쓰는-메서드-3">🚀 자주 쓰는 메서드</h3>

<table>
  <thead>
    <tr>
      <th>메서드</th>
      <th>설명</th>
      <th>예시 코드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(E e)</code></td>
      <td>원소 추가</td>
      <td><code class="language-plaintext highlighter-rouge">pq.add(10);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">peek()</code></td>
      <td>최상단 원소 확인(삭제 안 함)</td>
      <td><code class="language-plaintext highlighter-rouge">int top = pq.peek();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">poll()</code></td>
      <td>최상단 원소 꺼내기</td>
      <td><code class="language-plaintext highlighter-rouge">int top = pq.poll();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td>비었는지 확인</td>
      <td><code class="language-plaintext highlighter-rouge">if (pq.isEmpty())</code></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>💡 디폴트는 오름차순(최소 힙) → 작은 숫자가 먼저 나옴</p>

  <p>내림차순은 <code class="language-plaintext highlighter-rouge">new PriorityQueue&lt;&gt;(Collections.reverseOrder());</code></p>
</blockquote>

<hr />

<h2 id="-5️⃣-stack--queue-deque--선형-구조">🧰 5️⃣ Stack / Queue (Deque) — 선형 구조</h2>

<h3 id="-queue">💡 Queue</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>

<h3 id="-stack-deque로-대체-권장">💡 Stack (Deque로 대체 권장)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>

<hr />

<h2 id="-6️⃣-collections--arrays-유틸리티-메서드">💎 6️⃣ Collections / Arrays 유틸리티 메서드</h2>

<table>
  <thead>
    <tr>
      <th>클래스</th>
      <th>메서드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Collections.sort(list)</code></td>
      <td>리스트 정렬</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Collections.reverse(list)</code></td>
      <td>역순 정렬</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Collections.max(list)</code></td>
      <td>최댓값</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Collections.min(list)</code></td>
      <td>최솟값</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Arrays.sort(arr)</code></td>
      <td>배열 정렬</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Arrays.equals(arr1, arr2)</code></td>
      <td>배열 비교</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Arrays.toString(arr)</code></td>
      <td>배열 출력용</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-추천-연습문제-유형별-활용-예시">📘 추천 연습문제 유형별 활용 예시</h2>

<table>
  <thead>
    <tr>
      <th>유형</th>
      <th>핵심 자료구조/메서드</th>
      <th>예시 문제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Hash (중복, 완주하지 못한 선수 등)</td>
      <td><code class="language-plaintext highlighter-rouge">HashMap</code>, <code class="language-plaintext highlighter-rouge">HashSet</code></td>
      <td><code class="language-plaintext highlighter-rouge">map.getOrDefault</code>, <code class="language-plaintext highlighter-rouge">set.contains</code></td>
    </tr>
    <tr>
      <td>Stack/Queue</td>
      <td><code class="language-plaintext highlighter-rouge">Deque</code>, <code class="language-plaintext highlighter-rouge">LinkedList</code></td>
      <td>괄호 검사, 기능개발</td>
    </tr>
    <tr>
      <td>정렬</td>
      <td><code class="language-plaintext highlighter-rouge">Arrays.sort</code>, <code class="language-plaintext highlighter-rouge">Collections.sort</code></td>
      <td>H-index, K번째 수</td>
    </tr>
    <tr>
      <td>이중 루프 회피</td>
      <td><code class="language-plaintext highlighter-rouge">HashMap</code> lookup</td>
      <td>전화번호 목록</td>
    </tr>
    <tr>
      <td>우선순위 문제</td>
      <td><code class="language-plaintext highlighter-rouge">PriorityQueue</code></td>
      <td>더 맵게, 디스크 컨트롤러</td>
    </tr>
    <tr>
      <td>그래프/BFS/DFS</td>
      <td><code class="language-plaintext highlighter-rouge">Queue</code>, <code class="language-plaintext highlighter-rouge">ArrayList</code></td>
      <td>미로 탐색, 네트워크</td>
    </tr>
  </tbody>
</table>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="algorithm" /><summary type="html"><![CDATA[코딩테스트 대비 JAVA Collections의 사용처 및 메서드를 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자] Agora Cloud Recording 구현 시 Hibernate 에러 트러블슈팅</title><link href="https://nan0silver.github.io/projectdiary/2025-10-20-diary/" rel="alternate" type="text/html" title="[친구하자] Agora Cloud Recording 구현 시 Hibernate 에러 트러블슈팅" /><published>2025-10-20T00:00:00+00:00</published><updated>2025-11-11T05:27:50+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-10-20-diary/"><![CDATA[<ul>
  <li><a href="#1-문제-발견">1. 문제 발견</a></li>
  <li><a href="#2-lazyinitializationexception-이해하기">2. LazyInitializationException 이해하기</a></li>
  <li><a href="#3-optimisticlockingfailureexception-이해하기">3. OptimisticLockingFailureException 이해하기</a></li>
  <li><a href="#4-문제-원인-분석">4. 문제 원인 분석</a></li>
  <li><a href="#5-해결-방법">5. 해결 방법</a></li>
  <li><a href="#6-핵심-개념-정리">6. 핵심 개념 정리</a></li>
</ul>

<h2 id="음성-통화-녹음-기능은-동작하는데-에러가">음성 통화 녹음, 기능은 동작하는데 에러가?</h2>

<blockquote>
  <p>Agora Cloud Recording을 이용한 음성 통화 녹음 기능을 구현했다. 녹음 시작과 중지는 정상적으로 동작하는 것처럼 보였지만, 통화 종료 직후 콘솔에 예외 스택이 연속으로 출력되었다. LazyInitializationException과 OptimisticLockingFailureException… 둘 다 뭔가 익숙한데 동시에 발생하다니..🥲</p>
</blockquote>

<h2 id="1-문제-발견">1. 문제 발견</h2>

<h3 id="상황">상황</h3>

<p>Agora Cloud Recording을 사용하여 음성 통화 녹음 기능을 구현하던 중, 통화는 정상적으로 시작되고 녹음도 시작되지만, <strong>통화 종료 시점에 예외가 연달아 발생</strong>했다.</p>

<p>구조는 다음과 같았다:</p>

<ul>
  <li>통화 종료 → 비동기로 녹음 중지 API 호출</li>
  <li>녹음 정보를 DB에 저장하는 과정에서 에러 발생</li>
</ul>

<h3 id="에러-로그">에러 로그</h3>

<p><strong>첫 번째 에러:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>org.hibernate.LazyInitializationException: Could not initialize proxy
[com.example.domain.Call#1] - no session
	at org.hibernate.proxy.AbstractLazyInitializer.initialize(...)
	at RecordingResponse.from(RecordingResponse.java:76)
</code></pre></div></div>

<p><strong>두 번째 에러:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>org.springframework.orm.ObjectOptimisticLockingFailureException:
Row was updated or deleted by another transaction

Caused by: org.hibernate.StaleObjectStateException:
Row was updated or deleted by another transaction
</code></pre></div></div>

<blockquote>
  <p>“분명히 <code class="language-plaintext highlighter-rouge">@Transactional</code>도 붙였고, 엔티티도 제대로 조회했는데 왜 세션이 없다는 거지? 그리고 왜 낙관적 락 충돌이 발생하는 거야?”</p>
</blockquote>

<hr />

<h2 id="2-lazyinitializationexception-이해하기">2. LazyInitializationException 이해하기</h2>

<h3 id="에러의-의미">에러의 의미</h3>

<p><code class="language-plaintext highlighter-rouge">LazyInitializationException</code>은 Hibernate에서 <strong>지연 로딩(Lazy Loading)으로 설정된 연관 엔티티에 접근하려 할 때, 이미 영속성 컨텍스트(Persistence Context)가 닫혀있어서 발생</strong>하는 에러다.</p>

<h3 id="일반적인-발생-상황">일반적인 발생 상황</h3>

<p><strong>1. 트랜잭션 밖에서 Lazy 프록시 접근</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="nc">User</span> <span class="nf">findUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>  <span class="c1">// User.orders는 LAZY</span>
<span class="o">}</span>

<span class="c1">// 트랜잭션 밖</span>
<span class="n">user</span><span class="o">.</span><span class="na">getOrders</span><span class="o">().</span><span class="na">size</span><span class="o">();</span>  <span class="c1">// ❌ LazyInitializationException!</span>
</code></pre></div></div>

<p><strong>2. 비동기 작업에서 접근</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processOrder</span><span class="o">(</span><span class="nc">Long</span> <span class="n">orderId</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">findOrder</span><span class="o">(</span><span class="n">orderId</span><span class="o">);</span>
    <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">runAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">order</span><span class="o">.</span><span class="na">getUser</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>  <span class="c1">// ❌ 세션 종료 후 접근</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="내-경우의-원인">내 경우의 원인</h3>

<p>엔티티 구조:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">class</span> <span class="nc">CallRecording</span> <span class="o">{</span>
    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>  <span class="c1">// ← LAZY 로딩</span>
    <span class="kd">private</span> <span class="nc">Call</span> <span class="n">call</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>문제 흐름:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">@Async</code>로 비동기 스레드에서 녹음 중지 로직 실행</li>
  <li><code class="language-plaintext highlighter-rouge">CallRecording</code> 조회 (이때 <code class="language-plaintext highlighter-rouge">Call</code>은 프록시 상태)</li>
  <li>DTO 변환 시 <code class="language-plaintext highlighter-rouge">call.getChannelName()</code> 호출</li>
  <li><strong>프록시 초기화 시도하지만 이미 세션 종료 → 에러!</strong></li>
</ol>

<p>핵심은 <strong>비동기 스레드는 별도의 영속성 컨텍스트를 가지며</strong>, 연관 엔티티가 LAZY로 설정되어 있으면 세션 밖에서 접근 시 문제가 발생한다는 점이다.</p>

<hr />

<h2 id="3-optimisticlockingfailureexception-이해하기">3. OptimisticLockingFailureException 이해하기</h2>

<h3 id="에러의-의미-1">에러의 의미</h3>

<p><code class="language-plaintext highlighter-rouge">OptimisticLockingFailureException</code>은 <strong>낙관적 락(Optimistic Lock) 검증 실패</strong> 시 발생한다. JPA의 <code class="language-plaintext highlighter-rouge">@Version</code>을 사용한 엔티티에서 <strong>다른 트랜잭션이 이미 해당 레코드를 수정하여 버전이 증가했을 때</strong> 발생한다.</p>

<h3 id="낙관적-락이란">낙관적 락이란?</h3>

<p>동시성 제어 방법 중 하나로, 실제 충돌이 자주 발생하지 않을 것이라고 “낙관적으로” 가정한다.</p>

<p><strong>동작 방식:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">class</span> <span class="nc">CallRecording</span> <span class="o">{</span>
    <span class="nd">@Version</span>
    <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">version</span><span class="o">;</span>  <span class="c1">// 수정될 때마다 자동 증가</span>
<span class="o">}</span>
</code></pre></div></div>

<ol>
  <li>엔티티 조회 시 version 값 함께 조회</li>
  <li>업데이트 시 WHERE 절에 version 조건 추가</li>
</ol>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">UPDATE</span> <span class="n">call_recordings</span>
   <span class="k">SET</span> <span class="n">status</span> <span class="o">=</span> <span class="s1">'COMPLETED'</span><span class="p">,</span> <span class="k">version</span> <span class="o">=</span> <span class="k">version</span> <span class="o">+</span> <span class="mi">1</span>
   <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="k">version</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<ol>
  <li>영향받은 행이 0개면 → <strong>OptimisticLockingFailureException!</strong></li>
</ol>

<h3 id="일반적인-발생-상황-1">일반적인 발생 상황</h3>

<p><strong>동시에 같은 엔티티 수정:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 트랜잭션 1</span>
<span class="nc">Recording</span> <span class="n">rec</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>  <span class="c1">// version = 0</span>
<span class="n">rec</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="no">COMPLETED</span><span class="o">);</span>
<span class="n">repo</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">rec</span><span class="o">);</span>  <span class="c1">// version = 1</span>

<span class="c1">// 트랜잭션 2 (동시 실행)</span>
<span class="nc">Recording</span> <span class="n">rec</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>  <span class="c1">// version = 0 (조회 시점)</span>
<span class="n">rec</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="no">FAILED</span><span class="o">);</span>
<span class="n">repo</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">rec</span><span class="o">);</span>  <span class="c1">// ❌ version이 이미 1이라 실패!</span>
</code></pre></div></div>

<h3 id="내-경우의-원인-1">내 경우의 원인</h3>

<p>문제 흐름:</p>

<ol>
  <li>메인 로직에서 <code class="language-plaintext highlighter-rouge">recording.complete()</code> 호출 → version 증가</li>
  <li>비동기 스레드에서도 같은 recording 접근</li>
  <li>에러 발생 → <code class="language-plaintext highlighter-rouge">recording.fail()</code> 호출</li>
  <li>저장 시도 → <strong>이미 version이 변경되어 충돌!</strong></li>
</ol>

<hr />

<h2 id="4-문제-원인-분석">4. 문제 원인 분석</h2>

<h3 id="근본-원인">근본 원인</h3>

<p>두 에러가 동시에 발생한 이유는 <strong>비동기 처리와 동시성 제어의 조합</strong> 때문이었다.</p>

<p><strong>시나리오:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 통화 종료 이벤트 발생
2. @Async 메서드로 녹음 중지 로직 실행 (별도 스레드)
3. CallRecording 조회 (Call은 LAZY 프록시 상태)
4. DTO 변환 시 Call 접근 → LazyInitializationException
5. 예외 처리 로직에서 recording.fail() 호출
6. 다른 트랜잭션이 이미 recording을 수정 → OptimisticLockingFailureException
</code></pre></div></div>

<p><strong>핵심 문제점:</strong></p>

<ul>
  <li>LAZY 로딩된 연관 엔티티를 비동기 컨텍스트에서 접근</li>
  <li>동일 엔티티에 대한 동시 업데이트 시도</li>
</ul>

<hr />

<h2 id="5-해결-방법">5. 해결 방법</h2>

<h3 id="해결-전략">해결 전략</h3>

<ol>
  <li><strong>LazyInitializationException</strong>: 연관 엔티티를 미리 로드</li>
  <li><strong>OptimisticLockingFailureException</strong>: 예외 처리 전략 수립</li>
</ol>

<h3 id="1-join-fetch로-연관-엔티티-즉시-로딩">1) JOIN FETCH로 연관 엔티티 즉시 로딩</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Query</span><span class="o">(</span><span class="s">"SELECT cr FROM CallRecording cr "</span> <span class="o">+</span>
       <span class="s">"JOIN FETCH cr.call "</span> <span class="o">+</span>
       <span class="s">"WHERE cr.call.id = :callId"</span><span class="o">)</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">CallRecording</span><span class="o">&gt;</span> <span class="nf">findByCallIdWithCall</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">"callId"</span><span class="o">)</span> <span class="nc">Long</span> <span class="n">callId</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>효과:</strong></p>

<ul>
  <li>한 번의 쿼리로 <code class="language-plaintext highlighter-rouge">CallRecording</code>과 <code class="language-plaintext highlighter-rouge">Call</code>을 함께 조회</li>
  <li>LAZY 프록시 문제 해결</li>
</ul>

<h3 id="2-dto-생성-시-필요한-데이터만-전달">2) DTO 생성 시 필요한 데이터만 전달</h3>

<p>기존의 프록시 객체에서 데이터를 꺼내는 대신, <strong>이미 로드된 엔티티를 명시적으로 전달</strong>하는 방식으로 변경:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Before: recording에서 call을 꺼내려 시도 (프록시 초기화)</span>
<span class="nc">RecordingResponse</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">recording</span><span class="o">);</span>

<span class="c1">// After: 이미 로드된 call을 직접 전달</span>
<span class="nc">RecordingResponse</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">recording</span><span class="o">,</span> <span class="n">call</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="3-비동기-메서드에-transactional-추가">3) 비동기 메서드에 @Transactional 추가</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Async</span>
<span class="nd">@Transactional</span>  <span class="c1">// ← 비동기 스레드에도 트랜잭션 컨텍스트</span>
<span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">autoStopRecording</span><span class="o">(</span><span class="nc">Long</span> <span class="n">callId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 새로운 영속성 컨텍스트에서 실행</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="4-낙관적-락-예외-처리">4) 낙관적 락 예외 처리</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="n">recording</span><span class="o">.</span><span class="na">fail</span><span class="o">();</span>
    <span class="n">repository</span><span class="o">.</span><span class="na">saveAndFlush</span><span class="o">(</span><span class="n">recording</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">OptimisticLockException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 이미 다른 트랜잭션에서 처리됨 - 무시</span>
    <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"낙관적 락 충돌 (무시): callId={}"</span><span class="o">,</span> <span class="n">callId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>전략:</strong></p>

<ul>
  <li>이미 처리된 경우 무시 (재시도 불필요)</li>
  <li><code class="language-plaintext highlighter-rouge">saveAndFlush()</code>로 즉시 DB 반영</li>
</ul>

<h3 id="5-적용-후-개선된-흐름">5) 적용 후 개선된 흐름</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 통화 종료
2. JOIN FETCH로 Call과 함께 CallRecording 조회
3. 필요한 데이터를 DTO에 전달 (프록시 접근 없음)
4. 업데이트 시 낙관적 락 충돌 발생 시 적절히 처리
</code></pre></div></div>

<hr />

<h2 id="6-핵심-개념-정리">6. 핵심 개념 정리</h2>

<h3 id="lazy-loading">Lazy Loading</h3>

<p><strong>개념:</strong><br />
연관된 엔티티를 실제로 사용할 때까지 조회를 미루는 전략</p>

<p><strong>장점:</strong></p>

<ul>
  <li>불필요한 쿼리 감소</li>
  <li>성능 최적화</li>
</ul>

<p><strong>단점:</strong></p>

<ul>
  <li>영속성 컨텍스트 밖에서 접근 시 LazyInitializationException</li>
</ul>

<p><strong>해결 방법:</strong></p>

<ul>
  <li>JOIN FETCH로 즉시 로딩</li>
  <li>DTO 변환 시점 조정</li>
  <li>EAGER 로딩 (신중하게)</li>
</ul>

<h3 id="낙관적-락-vs-비관적-락">낙관적 락 vs 비관적 락</h3>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>낙관적 락</th>
      <th>비관적 락</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>가정</td>
      <td>충돌이 적을 것</td>
      <td>충돌이 많을 것</td>
    </tr>
    <tr>
      <td>락 시점</td>
      <td>업데이트 시</td>
      <td>조회 시</td>
    </tr>
    <tr>
      <td>구현</td>
      <td>@Version</td>
      <td>@Lock(PESSIMISTIC_WRITE)</td>
    </tr>
    <tr>
      <td>적합한 경우</td>
      <td>읽기가 많은 경우</td>
      <td>쓰기가 많은 경우</td>
    </tr>
  </tbody>
</table>

<p><strong>낙관적 락 동작:</strong></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 조회</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">recordings</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">-- version = 0</span>

<span class="c1">-- 업데이트</span>
<span class="k">UPDATE</span> <span class="n">recordings</span>
<span class="k">SET</span> <span class="n">status</span> <span class="o">=</span> <span class="s1">'COMPLETED'</span><span class="p">,</span> <span class="k">version</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="k">version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">-- 버전 체크</span>

<span class="c1">-- 영향받은 행이 0개면 실패 → 예외 발생</span>
</code></pre></div></div>

<h3 id="비동기-처리와-영속성-컨텍스트">비동기 처리와 영속성 컨텍스트</h3>

<p><strong>주의사항:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@Async</code> 메서드는 별도 스레드에서 실행</li>
  <li>각 스레드는 독립적인 영속성 컨텍스트</li>
  <li>LAZY 엔티티는 미리 로드하거나 별도 트랜잭션 필요</li>
</ul>

<hr />

<h2 id="7-학습-포인트">7. 학습 포인트</h2>

<h3 id="이번-트러블슈팅을-통해-배운-것">이번 트러블슈팅을 통해 배운 것</h3>

<ol>
  <li>
    <p><strong>비동기 처리 시 영속성 컨텍스트 관리의 중요성</strong></p>

    <ul>
      <li>JOIN FETCH로 필요한 데이터 미리 로드</li>
      <li>비동기 컨텍스트에는 별도의 트랜잭션 필요</li>
    </ul>
  </li>
  <li>
    <p><strong>동시성 제어 전략 선택</strong></p>

    <ul>
      <li>낙관적 락: 충돌이 적을 때 효율적</li>
      <li>예외 처리로 재시도 또는 무시 전략 구현</li>
    </ul>
  </li>
  <li>
    <p><strong>트랜잭션 범위와 데이터 일관성</strong></p>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">saveAndFlush()</code>로 즉시 반영</li>
      <li>에러 처리 시 최신 데이터 재조회 고려</li>
    </ul>
  </li>
</ol>

<h3 id="더-나은-설계를-위한-고민">더 나은 설계를 위한 고민</h3>

<ul>
  <li>비동기 작업에서는 ID만 전달하고 내부에서 재조회</li>
  <li>DTO 변환은 서비스 레이어에서 완료</li>
  <li>동시성이 중요한 엔티티는 비관적 락 고려</li>
</ul>

<hr />

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html">Hibernate User Guide - LazyInitializationException</a></li>
  <li><a href="https://www.baeldung.com/jpa-optimistic-locking">Baeldung - JPA Optimistic Locking</a></li>
  <li><a href="https://docs.spring.io/spring-framework/reference/integration/scheduling.html">Spring Framework - Async Execution</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[음성 통화 녹음 기능 구현 중 비동기 처리에서 발생한 LazyInitializationException과 OptimisticLockingFailureException을 해결한 과정을 정리했습니다.]]></summary></entry><entry><title type="html">[친구하자] 크로스 도메인 환경에서 Refresh Token 쿠키 소실 문제 #2</title><link href="https://nan0silver.github.io/projectdiary/2025-10-16-diary/" rel="alternate" type="text/html" title="[친구하자] 크로스 도메인 환경에서 Refresh Token 쿠키 소실 문제 #2" /><published>2025-10-16T00:00:00+00:00</published><updated>2025-11-11T05:27:50+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-10-16-diary/"><![CDATA[<ul>
  <li><a href="#1-csrf-토큰-패턴">1. CSRF 토큰 패턴</a></li>
  <li><a href="#2-originreferer-검증">2. Origin/Referer 검증</a></li>
  <li><a href="#3-jwt의-이중-검증">3. JWT의 이중 검증</a></li>
  <li><a href="#4-samsite--csrf-토큰-조합">4. SamSite + CSRF 토큰 조합</a></li>
</ul>

<h2 id="크로스-도메인-환경에서-refresh-token-쿠키-소실-트러블슈팅-2">크로스 도메인 환경에서 Refresh Token 쿠키 소실 트러블슈팅 2</h2>

<blockquote>
  <p>저번 편에서 해결까지는 다뤘지만, 그로 인해 발생하는 CSRF 공격에 대한 약한 방어를 방지하는 로직에 대해서는 이번 편에서 다루기로 한다. (너무 길어져서..)</p>
</blockquote>

<h2 id="csrf-공격-방어">CSRF 공격 방어</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SamSite=None</code>으로 하면 CSRF 공격을 방어할 수 없다. 따라서 추가 설정을 해줘야 한다.</li>
  <li>방어 방법들은 아래와 같다.</li>
</ul>

<h3 id="1-csrf-토큰-패턴">1. CSRF 토큰 패턴</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SecurityConfig.java</span>
<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">SecurityFilterChain</span> <span class="nf">filterChain</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">http</span>
            <span class="o">.</span><span class="na">csrf</span><span class="o">(</span><span class="n">csrf</span> <span class="o">-&gt;</span> <span class="n">csrf</span>
                <span class="o">.</span><span class="na">csrfTokenRepository</span><span class="o">(</span><span class="nc">CookieCsrfTokenRepository</span><span class="o">.</span><span class="na">withHttpOnlyFalse</span><span class="o">())</span>
                <span class="o">.</span><span class="na">csrfTokenRequestHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">SpaCsrfTokenRequestHandler</span><span class="o">())</span>
            <span class="o">)</span>
            <span class="c1">// ... 나머지 설정</span>
            <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 프론트엔드</span>
<span class="kd">const</span> <span class="nx">csrfToken</span> <span class="o">=</span> <span class="nx">getCookie</span><span class="p">(</span><span class="dl">"</span><span class="s2">XSRF-TOKEN</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">axios</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="dl">"</span><span class="s2">/api/v1/users/delete</span><span class="dl">"</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">X-XSRF-TOKEN</span><span class="dl">"</span><span class="p">:</span> <span class="nx">csrfToken</span><span class="p">,</span> <span class="c1">// CSRF 토큰 포함</span>
  <span class="p">},</span>
<span class="p">});</span>
</code></pre></div></div>

<ul>
  <li>이렇게 하면 악의적인 사이트는
    <ul>
      <li>JavaScript로 쿠키를 읽을 수 없음</li>
      <li>따라서 헤더에 토큰을 포함할 수 없음</li>
    </ul>
  </li>
</ul>

<h3 id="2-originreferer-검증">2. Origin/Referer 검증</h3>

<ul>
  <li>서버에서 요청의 <code class="language-plaintext highlighter-rouge">Origin</code> 또는 <code class="language-plaintext highlighter-rouge">Referer</code> 헤더를 확인하여 신뢰할 수 있는 도메인에서 온 요청인지 검증</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// CorsConfig.java</span>
<span class="nd">@Bean</span>
<span class="nd">@Profile</span><span class="o">(</span><span class="s">"prod"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">CorsConfigurationSource</span> <span class="nf">prodCorsConfigurationSource</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">CorsConfiguration</span> <span class="n">configuration</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CorsConfiguration</span><span class="o">();</span>

    <span class="c1">// ✅ 허용된 출처만 명시</span>
    <span class="n">configuration</span><span class="o">.</span><span class="na">setAllowedOriginPatterns</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
        <span class="s">"https://chingoo-frontend.vercel.app"</span><span class="o">,</span>
        <span class="s">"https://www.chingoo-frontend.vercel.app"</span>
    <span class="o">));</span>

    <span class="n">configuration</span><span class="o">.</span><span class="na">setAllowCredentials</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 하면</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DELETE https://your-backend.com/api/v1/users/delete
Origin: https://evil.com  ← 이 값으로 검증!
Cookie: refreshToken=...
</code></pre></div></div>

<ul>
  <li>백엔드가 <code class="language-plaintext highlighter-rouge">Origin</code> 헤더 확인:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">evail.com</code>은 허용 목록에 없음</li>
      <li>CORS 오류 발생으로 요청 차단</li>
    </ul>
  </li>
  <li>이 방법의 단점이 있다.
    <ul>
      <li>Origin 헤더를 조작할 수 있는 환경에서는 우회 가능</li>
      <li>브라우저가 아닌 요청(Postman, curl)에서는 검증 안됨</li>
    </ul>
  </li>
</ul>

<h3 id="3-jwt의-이중-검증">3. JWT의 이중 검증</h3>

<ul>
  <li>가장 현대적인 방법이다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JwtAuthenticationFilter.java</span>
<span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span>
                                <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span>
                                <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// 1️⃣ 쿠키에서 RefreshToken 추출</span>
    <span class="nc">String</span> <span class="n">refreshTokenFromCookie</span> <span class="o">=</span> <span class="n">extractTokenFromCookie</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>

    <span class="c1">// 2️⃣ 헤더에서 AccessToken 추출</span>
    <span class="nc">String</span> <span class="n">accessTokenFromHeader</span> <span class="o">=</span> <span class="n">extractTokenFromHeader</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>

    <span class="c1">// 3️⃣ 둘 다 검증</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isValidToken</span><span class="o">(</span><span class="n">refreshTokenFromCookie</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">isValidToken</span><span class="o">(</span><span class="n">accessTokenFromHeader</span><span class="o">))</span> <span class="o">{</span>

        <span class="c1">// 4️⃣ 토큰의 userId가 일치하는지 확인</span>
        <span class="nc">Long</span> <span class="n">userIdFromRefresh</span> <span class="o">=</span> <span class="n">getUserIdFromToken</span><span class="o">(</span><span class="n">refreshTokenFromCookie</span><span class="o">);</span>
        <span class="nc">Long</span> <span class="n">userIdFromAccess</span> <span class="o">=</span> <span class="n">getUserIdFromToken</span><span class="o">(</span><span class="n">accessTokenFromHeader</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">userIdFromRefresh</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">userIdFromAccess</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// ✅ 인증 성공</span>
            <span class="nc">SecurityContextHolder</span><span class="o">.</span><span class="na">getContext</span><span class="o">()</span>
                <span class="o">.</span><span class="na">setAuthentication</span><span class="o">(</span><span class="n">createAuthentication</span><span class="o">(</span><span class="n">userIdFromAccess</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>쿠키(Refresh Token)이 자동으로 포함됨</li>
  <li>하지만 해더(Access Token)는 JavaScript로 명시적으로 설정해야함</li>
  <li>악의적인 사이트는 정상 사이트의 localStorage에 접근 불가 (Cross-Origin)</li>
  <li>따라서 Access Token을 얻을 수 없음</li>
</ul>

<h3 id="4-samsite--csrf-토큰-조합">4. SamSite + CSRF 토큰 조합</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="nd">@Profile</span><span class="o">(</span><span class="s">"prod"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">SecurityFilterChain</span> <span class="nf">prodFilterChain</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">http</span>
            <span class="c1">// CSRF 토큰 활성화</span>
            <span class="o">.</span><span class="na">csrf</span><span class="o">(</span><span class="n">csrf</span> <span class="o">-&gt;</span> <span class="n">csrf</span>
                <span class="o">.</span><span class="na">csrfTokenRepository</span><span class="o">(</span><span class="nc">CookieCsrfTokenRepository</span><span class="o">.</span><span class="na">withHttpOnlyFalse</span><span class="o">())</span>
            <span class="o">)</span>
            <span class="c1">// CORS 설정 (Origin 검증)</span>
            <span class="o">.</span><span class="na">cors</span><span class="o">(</span><span class="n">cors</span> <span class="o">-&gt;</span> <span class="n">cors</span><span class="o">.</span><span class="na">configurationSource</span><span class="o">(</span><span class="n">corsConfigurationSource</span><span class="o">))</span>
            <span class="c1">// ...</span>
            <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># application-prod.yml</span>
<span class="na">app</span><span class="pi">:</span>
  <span class="na">cookie</span><span class="pi">:</span>
    <span class="na">secure</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">same-site</span><span class="pi">:</span> <span class="s">None</span> <span class="c1"># 크로스 도메인 지원</span>
    <span class="na">max-age</span><span class="pi">:</span> <span class="m">2592000</span>
</code></pre></div></div>

<ul>
  <li>이렇게 하면 다중 방어선이 만들어진다.
    <ul>
      <li>Origin 검증 (CORS)</li>
      <li>CSRF 토큰 검증</li>
      <li>JWT 검증</li>
    </ul>
  </li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[백엔드, 프론트 도메인이 다른 크로스 도메인의 Production 환경에서 Refresh Token이 사라지는 문제에 대해 정리해보았습니다!]]></summary></entry><entry><title type="html">[친구하자] 크로스 도메인 환경에서 Refresh Token 쿠키 소실 문제</title><link href="https://nan0silver.github.io/projectdiary/2025-10-15-diary/" rel="alternate" type="text/html" title="[친구하자] 크로스 도메인 환경에서 Refresh Token 쿠키 소실 문제" /><published>2025-10-15T00:00:00+00:00</published><updated>2025-11-11T05:27:50+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-10-15-diary/"><![CDATA[<ul>
  <li><a href="#문제-상황">문제 상황</a></li>
  <li><a href="#원인-분석">원인 분석</a></li>
  <li><a href="#해결-방법">해결방법</a></li>
  <li><a href="#참고-사항">참고사항</a></li>
</ul>

<h2 id="크로스-도메인-환경에서-refresh-token-쿠키-소실-트러블슈팅">크로스 도메인 환경에서 Refresh Token 쿠키 소실 트러블슈팅</h2>

<ul>
  <li>개발 환경에서는 token관련 문제가 전혀 없었다. 그런데 배포한 후 로그인이 새로운 탭에서 유지되지 않는 문제를 해결하려고 하다가 Refresh Token이 새로고침하면 사라지는걸 발견하였다.
    <blockquote>
      <p>어디갔어.. 내 refresh token 🥲</p>
    </blockquote>
  </li>
  <li>로그인이 유지되지 않는 문제는 왜인지 알았기 때문에 금방 해결하였지만, refresh token이 사라지는 문제가 더 나를 힘들게 만들었다..</li>
  <li>따라서 왜 그런 문제가 발생하는지 좀 더 알아보고자 했다.</li>
</ul>

<h2 id="문제-상황">문제 상황</h2>

<ul>
  <li>Local 환경: Refresh Token 쿠키가 정상적으로 유지됨 ✅</li>
  <li>Production 환경 : 로그인은 성공하지만, 새로고침하면 Refresh Token 쿠키가 사라짐 👻 (Refresh Token은 HttpOnly Cookie에 저장함)</li>
  <li>
    <p>브라우저 개발자 도구에서 확인한 쿠키 만료 시간: 30일 ✅</p>

    <blockquote>
      <p>처음엔 만료 시간이 잘못 설정되어있는줄 알았다.</p>
    </blockquote>
  </li>
  <li>
    <p>환경 정보</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Local 환경:
- Frontend: http://localhost:3000
- Backend:  http://localhost:8080
- 동일 호스트(localhost), 다른 포트 → Same-Site

Production 환경:
- Frontend: https://chingoo-frontend.vercel.app
- Backend:  https://your-backend-domain.com
- 다른 도메인 → Cross-Site
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="원인-분석">원인 분석</h2>

<h3 id="1-잘못된-쿠키-설정">1. 잘못된 쿠키 설정</h3>

<p>application-prod.yml의 문제:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">app:
  cookie:
    secure: false     # ❌ HTTPS 환경인데 false
    sam-site: Lax     # ❌ 크로스 도메인인데 Lax
    max-age: 2592000  # ✅ 30일 (정상)
</span></code></pre></div></div>

<h3 id="2-samsite-쿠키-정책-이해하기">2. SamSite 쿠키 정책 이해하기</h3>

<h4 id="samsite-속성이란">SamSite 속성이란?</h4>

<ul>
  <li>
    <p>CSRF(Cross-Site Request Forgery) 공격을 방어하기 위해 도입된 쿠키 정책으로, 언제 쿠키를 전송할지를 제어</p>

    <blockquote>
      <p>CSRF공격 이란?</p>

      <blockquote>
        <p>사용자가 자신의 의지와는 상관없이 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 하는 공격
공격자가 사용자의 세션을 가로채는 방식으로 일어난다.</p>
      </blockquote>
    </blockquote>
  </li>
  <li>
    <p>SamSite 3가지 값</p>
    <ol>
      <li>Strict
        <ul>
          <li>동일 사이트에서만 쿠키 전공</li>
          <li>모든 크로스 사이트 요청에서 차단</li>
          <li>최고 수준 보안이 필요한 경우에 사용 (매우 엄격해서 잘 안씀)</li>
        </ul>
      </li>
      <li>Lax (기본값)
        <ul>
          <li>TOP-LEVEL 네비게이션 + GET 요청만 허용</li>
          <li>POST, PUT, DELETE 등은 차단</li>
          <li>일반적인 Sam-Site 환경 (프론트엔드와 벡엔드가 같은 도메인)</li>
        </ul>
      </li>
      <li>None
        <ul>
          <li>모든 크로스 사이트 요청에서 쿠키전송</li>
          <li>단, <code class="language-plaintext highlighter-rouge">Secure=true</code> 필수 (HTTPS)</li>
          <li>크로스 도메인 환경 (프론트엔트와 백엔드 도메인 다름)</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h4 id="브라우서의-samsitelax-동작-분석">브라우서의 SamSite=Lax 동작 분석</h4>

<h4 id="시나리오-1-로그인-시-최초-요청">시나리오 1: 로그인 시 (최초 요청)</h4>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">POST https://your-backend.com/api/v1/auth/login
Origin: https://your-frontend.com
Content-Type: application/json

{"email": "user@example.com", "password": "..."}
</span></code></pre></div></div>

<p>백엔드 응답:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
Set-Cookie: refreshToken=eyJhbGc...;
            Path=/;
            Max-Age=2592000;
            HttpOnly;
            Secure;
            SameSite=Lax  ← 여기가 문제! ❌
Access-Control-Allow-Origin: https://chingoo-frontend.vercel.app
Access-Control-Allow-Credentials: true
</code></pre></div></div>

<ul>
  <li>쿠키는 설정됨 (브라우저가 Set-Cookie 헤더를 받아서 저장)</li>
  <li>개발자 도구에서 쿠키 확인 가능</li>
  <li>Expires/Max-Age도 30일로 정상</li>
</ul>

<h4 id="시나리오-2-새로고침-시-두번째-요청">시나리오 2: 새로고침 시 (두번째 요청)</h4>

<ul>
  <li>사용자가 새로고침 또는 페이지 이동 시, 프론트엔드가 자동으로 사용자 정보를 가져오는 API 호출:</li>
</ul>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">// 프론트엔드 코드 (자동 실행)
useEffect(() =&gt; {
  axios.get('https://your-backend.com/api/v1/users/me', {
    withCredentials: true  // 쿠키 전송 요청
  });
}, []);
</span></code></pre></div></div>

<p>브라우저의 요청:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET https://your-backend.com/api/v1/users/me
Origin: https://your-frontend.com
Cookie: (없음!) &lt;- SamSite=Lax가 쿠키 전송을 차단!
</code></pre></div></div>

<ul>
  <li>TOP-LEVEL 네비게이션이 아니고 JavaScript 요청이기 때문에 쿠키 전송이 안됌
    <blockquote>
      <p>TOP-LEVEL 네비게이션은 아래와 같다.</p>

      <blockquote>
        <ol>
          <li>주소창에 URL을 직접 입력</li>
          <li><code class="language-plaintext highlighter-rouge">&lt;a href = "..."&gt;</code> 링크 클릭</li>
          <li><code class="language-plaintext highlighter-rouge">window.location.href</code> 변경
            <blockquote>
              <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   // ❌ 이런 JavaScript 요청은 TOP-LEVEL 네비게이션이 아님
   axios.get('https://api.example.com/user');

   // ✅ 이런 요청만 TOP-LEVEL 네비게이션으로 인정
   window.location.href = 'https://api.example.com/user';
   &lt;a href="https://api.example.com/user"&gt;클릭&lt;/a&gt;
</code></pre></div>              </div>
            </blockquote>
          </li>
        </ol>
      </blockquote>
    </blockquote>
  </li>
</ul>

<h4 id="시나리오-3-post-요청">시나리오 3: POST 요청</h4>

<ul>
  <li>사용자가 폼을 제출하는 등 POST 요청을 보낼 때:</li>
</ul>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">POST https://your-backend.com/api/v1/some-action
Origin: https://your-frontend.com
Cookie: (없음!) &lt;- SamSite=Lax가 쿠키 전송을 차단
</span></code></pre></div></div>

<p>결과:</p>

<ul>
  <li>Refresh Token 쿠키가 전송되지 않음</li>
  <li>백엔드에서 인증 실패 (401 Unauthorized)</li>
  <li>사용자는 다시 로그인해야함</li>
</ul>

<h2 id="해결">해결</h2>

<ul>
  <li>application-prod.yml 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>app:
  cookie:
    secure: true       # HTTPS 필수
    same-site: None    # 크로스 도메인 허용
    max-age: 2592000   # 30일
</code></pre></div></div>

<ul>
  <li>이로 인한 CSRF 공격에 대한 방어는 다음 편에서 다루기로 한다.</li>
</ul>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite">MDN: SamSite cookies</a></li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[백엔드, 프론트 도메인이 다른 크로스 도메인의 Production 환경에서 Refresh Token이 사라지는 문제에 대해 정리해보았습니다! (해결은 다음편)]]></summary></entry><entry><title type="html">[친구하자] Redis 데이터 초기화 트러블 슈팅</title><link href="https://nan0silver.github.io/projectdiary/2025-10-14-diary/" rel="alternate" type="text/html" title="[친구하자] Redis 데이터 초기화 트러블 슈팅" /><published>2025-10-14T00:00:00+00:00</published><updated>2025-11-11T05:27:50+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-10-14-diary/"><![CDATA[<ul>
  <li><a href="#문제-상황">문제 상황</a></li>
  <li><a href="#원인">원인</a></li>
  <li><a href="#해결-방법">해결방법</a></li>
  <li><a href="#참고-사항">참고사항</a></li>
</ul>

<h2 id="redis-데이터-초기화-트러블슈팅">Redis 데이터 초기화 트러블슈팅</h2>

<ul>
  <li>
    <p>나는 로컬 환경에서 Docker Compose로 Redis, MySQL룰 컨테이너화해서 실행하고 있다.</p>

    <blockquote>
      <p>Redis 7 Alpine 이미지 기반의 컨테이너를 오케스트레이션</p>
    </blockquote>
  </li>
  <li>Redis(인메모리 캐시)는 실시간 매칭 대기열 관리에 사용되고,</li>
  <li>
    <p>MySQL은 매칭 결과 및 사용자 정보 저장에 사용된다.</p>

    <blockquote>
      <p>매칭 대기열에서 Redis를 사용한 플로우와 이유에 대해서는 다음 게시글에서 다루겠다.</p>
    </blockquote>
  </li>
  <li>Spring Boot로 로컬 개발을 하며 매칭 - 통화 - 통화 평가 프로세스 구축에 시간을 많이 썼다.</li>
  <li>Redis, WebSocke을 이용한 개발이 처음이기도 하고, 공부하면서 개발했기 때문에 시행착오를 많이 거쳤다.</li>
  <li>이 과정에서 계속 DB를 초기화 하고.. 로직을 엎고.. 하는 일들이 많았는데</li>
  <li>
    <p>여러번 반복적으로 Redis를 초기화 할때는 외워서 했지만 프론트와 연동하며 오랜만에 매칭 관련 코드를 뜯어보다 문제가 생겨 Redis를 초기화 하려니 생각이 하나도 안나는 것이다!!</p>
  </li>
  <li>그래서 그냥 정리해두기로 했다.</li>
</ul>

<h2 id="문제-상황">문제 상황</h2>

<ul>
  <li>Spring Boot 애플리케이션에서 매칭 대기열에 사용자가 계속 남아있는 문제가 발생하였다.</li>
  <li>
    <p>MySQL은 초기화 한 상황, user가 한명도 없는데도 userID만 redis에 계속 저장되어있는 상황</p>

    <ul>
      <li>MySQL은 spring boot 재실행만으로도 초기화가 쉽게 되는데 redis는 어떻게 했더라.. 문제 발생</li>
    </ul>
  </li>
  <li><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-10-14-image.png?raw=true" alt="계속 남아있는 매칭 대기열의 유령들" />
    <blockquote>
      <p>계속 남아있는 매칭 대기열의 유령들</p>
    </blockquote>
  </li>
</ul>

<h2 id="원인">원인</h2>

<ul>
  <li>위에도 말했지만 Docker Compose로 MySQL 컨테이너를 재시작해서 데이터베이스는 초기화됨</li>
  <li>하지만 Redis는 인메모리 데이터베이스이면서도 <code class="language-plaintext highlighter-rouge">redis_data</code>볼륨애 데이터를 영구 저장</li>
  <li>컨테이너를 재시작해도 볼륨에 저장된 데이터는 유지됨..</li>
  <li>결과적으로 DB에는 없는 사용자가 Redis에만 남아있는 불일치 상태 발생</li>
</ul>

<h2 id="해결-방법">해결 방법</h2>

<h3 id="방법-1--redis-cli로-데이터-삭제">방법 1 : Redis CLI로 데이터 삭제</h3>

<blockquote>
  <p>나는 이걸로 해결</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Redis 컨테이너에 접속
docker exec -it &lt;내 redis 이름&gt; redis-cli

# 모든 데이터 삭제
127.0.0.1:6379&gt; FLUSHALL

# 삭제 확인
127.0.0.1:6379&gt; KEYS *

# 종료
127.0.0.1:6379&gt; exit
</code></pre></div></div>

<p><img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-10-14-image-1.png?raw=true" alt="캡쳐 사진" /></p>

<p>-&gt; 금방 해결!</p>

<h3 id="방법-2--명령어-한줄로-실행">방법 2 : 명령어 한줄로 실행</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker exec -it chingoo-redis redis-cli FLUSHALL
</code></pre></div></div>

<h3 id="방법-3--docker-볼륨까지-완전-삭제">방법 3 : Docker 볼륨까지 완전 삭제</h3>

<ul>
  <li>더 확실한 초기화 방법</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># docker 디렉토리로 이동
cd docker

# 컨테이너 중지 및 볼륨 삭제
docker-compose down -v

# 컨테이너 재시작
docker-compose up -d
</code></pre></div></div>

<ul>
  <li>볼륨까지 삭제되므로 Redis 데이터가 완전히 초기화됨</li>
  <li>‼ <code class="language-plaintext highlighter-rouge">-v</code>옵션은 MySQL 데이터도 삭제하므로 주의가 필요!</li>
</ul>

<h2 id="해결">해결</h2>

<p>이렇게 하면
<img src="https://github.com/nan0silver/nan0silver.github.io/blob/main/assets/img/blog/2025-10-14-image-2.png?raw=true" alt="alt text" /></p>

<blockquote>
  <p>매칭 대기열이 깨끗해진 모습
이렇게 유령들이 사라진다.</p>
</blockquote>

<h2 id="참고-사항">참고 사항</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FLUSHALL</code>: 모든 데이터베이스의 모든 키 삭제</li>
  <li><code class="language-plaintext highlighter-rouge">FLUSHDB</code>: 현재 선택된 데이터베이스의 키만 삭제</li>
  <li>Redis는 기본적으로 데이터베이스 0~15번까지 16개를 제공</li>
  <li>운영환경에서는 절대 <code class="language-plaintext highlighter-rouge">FLUSHALL</code>을 실행하면 안됨!</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[가끔 발생했던 Redis 데이터 초기화 방법과 관련해 정리]]></summary></entry><entry><title type="html">[친구하자] WebRTC란 무엇일까?</title><link href="https://nan0silver.github.io/projectdiary/2025-09-30-diary/" rel="alternate" type="text/html" title="[친구하자] WebRTC란 무엇일까?" /><published>2025-09-30T00:00:00+00:00</published><updated>2025-11-11T05:27:50+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-09-30-diary/"><![CDATA[<ul>
  <li><a href="#-1-webrtc의-정의">1. WebRTC의 정의</a></li>
  <li><a href="#-2-webrtc의-주요-구성-요소">2. WebRTC의 주요 구성 요소</a></li>
  <li><a href="#️-3-동작-흐름-signaling-포함">3. 동작 흐름 (Signaling 포함)</a></li>
  <li><a href="#-4-왜-agora를-사용하는가">4. 왜 Agora를 사용하는가</a></li>
  <li><a href="#-5-보안-측면">5. 보안 측면</a></li>
  <li><a href="#-6-오늘의-정리">6. 오늘의 정리</a></li>
</ul>

<hr />

<h2 id="-1-webrtc의-정의">🧩 1. WebRTC의 정의</h2>

<p><strong>WebRTC (Web Real-Time Communication)</strong>는
웹 브라우저나 모바일 앱끼리 <strong>실시간 음성, 영상, 데이터</strong>를 직접 주고받을 수 있게 해주는 오픈소스 기술이다.
즉, 중간 서버를 거치지 않고 <strong>클라이언트 간 P2P 통신</strong>을 가능하게 만든다.</p>

<p>브라우저끼리 “전화기처럼” 연결된다고 생각하면 쉽다.
별도 플러그인이나 설치 과정 없이 JavaScript API로 바로 통화 기능을 구현할 수 있다.</p>

<hr />

<h2 id="-2-webrtc의-주요-구성-요소">🌐 2. WebRTC의 주요 구성 요소</h2>

<table>
  <thead>
    <tr>
      <th>구성 요소</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>MediaStream (getUserMedia)</strong></td>
      <td>사용자의 카메라, 마이크 데이터를 캡처하는 API</td>
    </tr>
    <tr>
      <td><strong>RTCPeerConnection</strong></td>
      <td>실제 P2P 연결을 담당. 네트워크 경로 설정, 코덱 협상, 암호화 등을 수행</td>
    </tr>
    <tr>
      <td><strong>RTCDataChannel</strong></td>
      <td>파일 전송, 채팅 등 실시간 데이터 교환용 채널</td>
    </tr>
    <tr>
      <td><strong>ICE (Interactive Connectivity Establishment)</strong></td>
      <td>NAT(공유기 등) 환경에서도 통신이 가능하도록 IP 후보 탐색 및 연결 시도</td>
    </tr>
    <tr>
      <td><strong>STUN / TURN 서버</strong></td>
      <td>STUN: 공용 IP 확인용 / TURN: 직접 연결이 안될 때 중계 서버 역할</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="️-3-동작-흐름-signaling-포함">🛰️ 3. 동작 흐름 (Signaling 포함)</h2>

<ol>
  <li>
    <p><strong>Signaling 단계</strong></p>

    <ul>
      <li>두 클라이언트가 연결 정보를 교환 (SDP, ICE candidates 등)</li>
      <li>이 단계는 WebRTC 외부에서 처리해야 하며, 보통 WebSocket, Socket.io, REST API 등을 사용</li>
    </ul>
  </li>
  <li>
    <p><strong>P2P 연결</strong></p>

    <ul>
      <li>서로의 연결 정보를 받은 뒤 <code class="language-plaintext highlighter-rouge">RTCPeerConnection</code>으로 직접 연결 시도</li>
      <li>STUN 서버로 외부 IP 탐색, 필요 시 TURN 서버를 통한 중계</li>
    </ul>
  </li>
  <li>
    <p><strong>미디어 스트림 전송</strong></p>

    <ul>
      <li>연결이 완료되면 오디오/비디오/데이터 스트림이 실시간으로 교환됨</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="️-4-왜-agora를-사용하는가">⚙️ 4. 왜 Agora를 사용하는가</h2>

<p>WebRTC 자체는 “기술 표준”일 뿐, 실서비스에는 <strong>보완이 필요</strong>하다.
예를 들어,</p>

<ul>
  <li>TURN 서버 트래픽 비용과 관리 부담</li>
  <li>네트워크 불안정 시 끊김</li>
  <li>다자간 통화 (SFU/Mesh 방식) 구현 복잡성</li>
</ul>

<p>이 때문에 Agora, Twilio, Daily 같은 <strong>WebRTC 기반 클라우드 SDK</strong>를 이용하면
복잡한 signaling, TURN 운영, QoS 튜닝을 대신 처리해준다.</p>

<p>👉 <strong>친구하자 서비스</strong>에서도 Agora를 이용해</p>

<ul>
  <li>빠른 1:1 매칭 통화</li>
  <li>안정적인 통화 품질</li>
  <li>통화 종료 후 감정분석 AI 연결</li>
</ul>

<p>까지 구현할 수 있다.</p>

<blockquote>
  <p>여러 SDK를 비교한 후, 가격 성능 서비스 부분에서 Agora를 선택했다.</p>
</blockquote>

<hr />

<h2 id="-5-보안-측면">🔐 5. 보안 측면</h2>

<ul>
  <li>모든 WebRTC 통신은 <strong>DTLS (Datagram Transport Layer Security)</strong> 로 암호화</li>
  <li>미디어 스트림은 <strong>SRTP (Secure RTP)</strong> 로 암호화되어 안전하게 전송</li>
  <li>HTTPS 환경에서만 동작 (브라우저 정책상 보안 채널 필수)</li>
</ul>

<hr />

<h2 id="-6-오늘의-정리">💡 6. 오늘의 정리</h2>

<table>
  <thead>
    <tr>
      <th>키워드</th>
      <th>요약</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>WebRTC</strong></td>
      <td>브라우저 간 실시간 통신 기술</td>
    </tr>
    <tr>
      <td><strong>Signaling</strong></td>
      <td>SDP/ICE 교환을 위한 외부 과정</td>
    </tr>
    <tr>
      <td><strong>STUN/TURN</strong></td>
      <td>NAT 환경에서도 연결을 돕는 서버</td>
    </tr>
    <tr>
      <td><strong>Agora</strong></td>
      <td>WebRTC 기반 실시간 통화 SDK</td>
    </tr>
    <tr>
      <td><strong>보안</strong></td>
      <td>DTLS + SRTP 기반 암호화</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="️-7-개인-메모">✍️ 7. 개인 메모</h2>

<blockquote>
  <p>Agora SDK를 직접 사용하며 느낀 점</p>
</blockquote>

<ul>
  <li>브라우저 단에서 PeerConnection을 직접 제어하는 것보다 훨씬 안정적이다.</li>
  <li>특히 네트워크 품질이 낮은 환경에서 TURN 관리가 자동화되어 있다는 점이 큰 장점.</li>
  <li>이후 자체 STUN/TURN 구축을 통해 비용 절감을 검토할 예정.</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[친구하자 프로젝트 개발 중 Agora WebRTC 통화 구현 전 이해하기!]]></summary></entry><entry><title type="html">[JAVA] Java 알고리즘 문제 풀이 시, 자주 쓰이는 Steam API 함수들</title><link href="https://nan0silver.github.io/java/2025-09-12-stream/" rel="alternate" type="text/html" title="[JAVA] Java 알고리즘 문제 풀이 시, 자주 쓰이는 Steam API 함수들" /><published>2025-09-12T00:00:00+00:00</published><updated>2025-11-11T05:27:50+00:00</updated><id>https://nan0silver.github.io/java/stream</id><content type="html" xml:base="https://nan0silver.github.io/java/2025-09-12-stream/"><![CDATA[<ul>
  <li><a href="#1-배열--스트림">1. 배열 → 스트림</a></li>
  <li><a href="#2-형-변환-mapping">2. 형 변환 (Mapping)</a></li>
  <li><a href="#3-집계-연산-aggregation">3. 집계 연산 (Aggregation)</a></li>
  <li><a href="#4-정렬--수집">4. 정렬 / 수집</a></li>
  <li><a href="#5-foreach--joining">5. forEach / joining</a></li>
</ul>

<hr />

<h1 id="자주-쓰이는-stream-api-함수들">자주 쓰이는 Stream API 함수들</h1>

<h3 id="1-배열--스트림">1. <strong>배열 → 스트림</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Arrays.stream(arr)</code> : <code class="language-plaintext highlighter-rouge">int[]</code>, <code class="language-plaintext highlighter-rouge">double[]</code>, <code class="language-plaintext highlighter-rouge">long[]</code> 같은 <strong>primitive 배열</strong>을 스트림으로 변환</li>
  <li><code class="language-plaintext highlighter-rouge">Stream.of(array)</code> : <code class="language-plaintext highlighter-rouge">String[]</code> 같은 <strong>객체 배열</strong>을 스트림으로 변환</li>
</ul>

<p>예:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>

<span class="nc">String</span><span class="o">[]</span> <span class="n">strArr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">};</span>
<span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">strArr</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<h3 id="2-형-변환-mapping">2. <strong>형 변환 (Mapping)</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">mapToInt(Integer::parseInt)</code> : 문자열 스트림 → 정수 스트림</li>
  <li><code class="language-plaintext highlighter-rouge">map(String::length)</code> : 문자열 스트림 → 문자열 길이 스트림</li>
</ul>

<p>예:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">};</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">intArr</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">).</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">parseInt</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<h3 id="3-집계-연산-aggregation">3. <strong>집계 연산 (Aggregation)</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.min().getAsInt()</code> / <code class="language-plaintext highlighter-rouge">.max().getAsInt()</code> : 최솟값 / 최댓값</li>
  <li><code class="language-plaintext highlighter-rouge">.sum()</code> : 합계</li>
  <li><code class="language-plaintext highlighter-rouge">.average().getAsDouble()</code> : 평균</li>
</ul>

<p>예:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
<span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">).</span><span class="na">min</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">).</span><span class="na">max</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<h3 id="4-정렬--수집">4. <strong>정렬 / 수집</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.sorted()</code> : 정렬</li>
  <li><code class="language-plaintext highlighter-rouge">.toArray()</code> : 배열로 다시 변환</li>
  <li><code class="language-plaintext highlighter-rouge">.collect(Collectors.toList())</code> : 리스트로 변환</li>
</ul>

<p>예:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"3"</span><span class="o">,</span> <span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">};</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">parseInt</span><span class="o">)</span>
        <span class="o">.</span><span class="na">sorted</span><span class="o">()</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<hr />

<h3 id="5-foreach--joining">5. <strong>forEach / joining</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.forEach(System.out::println)</code> : 요소 출력</li>
  <li><code class="language-plaintext highlighter-rouge">.collect(Collectors.joining(" "))</code> : 문자열 합치기</li>
</ul>

<p>예:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">};</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">(</span><span class="s">", "</span><span class="o">));</span>  <span class="c1">// "a, b, c"</span>
</code></pre></div></div>

<hr />

<h2 id="-이-문제를-stream으로-풀면-이렇게도-가능">🎯 이 문제를 Stream으로 풀면 이렇게도 가능</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">String</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">IntSummaryStatistics</span> <span class="n">stats</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">))</span>
            <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">parseInt</span><span class="o">)</span>
            <span class="o">.</span><span class="na">summaryStatistics</span><span class="o">();</span>  <span class="c1">// count, min, max, sum, average 한번에</span>

    <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="na">getMin</span><span class="o">()</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">stats</span><span class="o">.</span><span class="na">getMax</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>👉 <code class="language-plaintext highlighter-rouge">IntSummaryStatistics</code>를 쓰면 <strong>최소값/최대값/합계/평균</strong>을 다 구할 수 있어서 깔끔!</p>

<hr />

<p>💡 정리
비슷한 문제에서 빠르게 풀고 싶으면 최소한 아래 3개는 꼭 익혀두자:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">mapToInt(Integer::parseInt)</code></li>
  <li><code class="language-plaintext highlighter-rouge">min() / max() / sum() / average()</code></li>
  <li><code class="language-plaintext highlighter-rouge">summaryStatistics()</code></li>
</ol>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="java" /><summary type="html"><![CDATA[알고리즘 문제풀이 시, 코드를 예쁘고 빠르게 만들어주는 Steam API를 정리해보았습니다.]]></summary></entry><entry><title type="html">[친구하자] 매칭 대기열 만들면서 정리한 Redis 명령어 치트시트 (SET/ZSET편)</title><link href="https://nan0silver.github.io/projectdiary/2025-09-03-diary/" rel="alternate" type="text/html" title="[친구하자] 매칭 대기열 만들면서 정리한 Redis 명령어 치트시트 (SET/ZSET편)" /><published>2025-09-03T00:00:00+00:00</published><updated>2025-11-11T05:27:50+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-09-03-diary/"><![CDATA[<blockquote>
  <p>카테고리별 2인 매칭을 구현하며 실제로 쓴(또는 고민했던) 명령어들을 짧게 정리.
예시 키는 <code class="language-plaintext highlighter-rouge">{cat:123}</code> 해시태그로 Redis Cluster 슬롯을 고정하는 패턴을 사용.</p>
</blockquote>

<hr />

<h2 id="zset-sorted-set--순번대기시간우선순위가-필요할-때">ZSET (Sorted Set) — 순번/대기시간/우선순위가 필요할 때</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZADD key score member [score member ...]</code>
멤버 추가/갱신. <strong>score</strong>가 작을수록 앞쪽.</p>

    <pre><code class="language-redis">ZADD wait:z:{cat:123} 1725430000123 101
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZRANGE key start stop [WITHSCORES | REV | BYSCORE ...]</code>
<strong>정렬 순서대로 조회</strong>. 삭제는 아님!</p>

    <pre><code class="language-redis">ZRANGE wait:z:{cat:123} 0 1              # 가장 오래 기다린 2명
ZRANGE wait:z:{cat:123} 0 9 WITHSCORES    # 상위 10명 + score
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZRANK key member</code>
멤버의 <strong>순위(0-base)</strong>.</p>

    <pre><code class="language-redis">ZRANK wait:z:{cat:123} 101               # 0이면 1번째
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZSCORE key member</code>
멤버의 score(대기 시작 시각 등).</p>

    <pre><code class="language-redis">ZSCORE wait:z:{cat:123} 101
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZCARD key</code>
멤버 수.</p>

    <pre><code class="language-redis">ZCARD wait:z:{cat:123}
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZREM key member [member ...]</code>
멤버 삭제.</p>

    <pre><code class="language-redis">ZREM wait:z:{cat:123} 101 205
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZRANDMEMBER key [count] [WITHSCORES]</code> <em>(6.2+)</em>
<strong>무작위 조회</strong>(삭제 아님).</p>

    <pre><code class="language-redis">ZRANDMEMBER wait:z:{cat:123} 2
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ZPOPMIN key [count]</code> / <code class="language-plaintext highlighter-rouge">ZPOPMAX</code>
<strong>꺼내며 삭제</strong>(원자). 대기순 매칭에 유용.</p>

    <pre><code class="language-redis">ZPOPMIN wait:z:{cat:123} 2
</code></pre>
  </li>
</ul>

<hr />

<h2 id="set-집합--중복-없는-랜덤-풀">SET (집합) — 중복 없는 랜덤 풀</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SADD key member [member ...]</code> / <code class="language-plaintext highlighter-rouge">SREM key member [...]</code>
추가/삭제 (중복 불가).</p>

    <pre><code class="language-redis">SADD matching:queue:{cat:123} 101
SREM matching:queue:{cat:123} 101
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SPOP key [count]</code>
<strong>무작위 추출+삭제</strong>(원자). 랜덤 매칭에 간단·빠름.</p>

    <pre><code class="language-redis">SPOP matching:queue:{cat:123} 2
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SCARD key</code>
멤버 수.</p>

    <pre><code class="language-redis">SCARD matching:queue:{cat:123}
</code></pre>
  </li>
</ul>

<hr />

<h2 id="ttl키-유틸-대기-상태-자동-청소용">TTL/키 유틸 (대기 상태 자동 청소용)</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SET key value EX &lt;sec&gt; NX</code>
<strong>선점 + TTL</strong>(중복 입장 방지).</p>

    <pre><code class="language-redis">SET user:index:42 "cat=123|queue=q_..." EX 600 NX
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">EXPIRE key &lt;sec&gt;</code> / <code class="language-plaintext highlighter-rouge">TTL key</code>
키 만료/조회.
<strong>주의:</strong> TTL은 <strong>키 전체</strong>에 붙음(멤버 단위 X).</p>
  </li>
</ul>

<blockquote>
  <p>베스트 프랙티스: <strong>대기열 컬렉션(SET/ZSET)엔 TTL 금지</strong>, 개별 사용자 상태 키에만 TTL.</p>
</blockquote>

<hr />

<h2 id="매칭에서-자주-쓰는-레시피">매칭에서 자주 쓰는 <strong>레시피</strong></h2>

<h3 id="1-대기순공정성-매칭">1) 대기순(공정성) 매칭</h3>

<ul>
  <li>
    <p>방법 A(2단계): <code class="language-plaintext highlighter-rouge">ZRANGE</code>로 상위 N 조회 → <strong><code class="language-plaintext highlighter-rouge">ZREM</code>로 제거</strong></p>

    <pre><code class="language-redis">ZRANGE wait:z:{cat:123} 0 1         # 후보 조회
ZREM   wait:z:{cat:123} 101 205     # 확정 후 제거
</code></pre>
  </li>
  <li>
    <p>방법 B(원자): <code class="language-plaintext highlighter-rouge">ZPOPMIN wait:z:{cat:123} 2</code>
(조회+삭제가 한 번에)</p>
  </li>
</ul>

<h3 id="2-랜덤-매칭">2) 랜덤 매칭</h3>

<ul>
  <li>
    <p>ZSET만 쓸 때(원자화는 Lua 추천):</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">ZRANDMEMBER</code>로 조회 → <strong>같은 로직 안에서 <code class="language-plaintext highlighter-rouge">ZREM</code></strong></li>
    </ul>
  </li>
  <li>
    <p>SET을 함께 쓸 때:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">SPOP matching:queue:{cat:123} 2</code> (원자 랜덤 추출)</li>
    </ul>
  </li>
</ul>

<h3 id="3-하이브리드랜덤-80--대기순-20">3) 하이브리드(랜덤 80% + 대기순 20%)</h3>

<ul>
  <li>
    <p>하나의 <strong>Lua/Functions</strong>에서 분기:</p>

    <ul>
      <li>랜덤: <code class="language-plaintext highlighter-rouge">ZRANDMEMBER</code> → <code class="language-plaintext highlighter-rouge">ZREM</code></li>
      <li>대기순: <code class="language-plaintext highlighter-rouge">ZRANGE</code> → <code class="language-plaintext highlighter-rouge">ZREM</code> (또는 <code class="language-plaintext highlighter-rouge">ZPOPMIN</code>)</li>
    </ul>
  </li>
</ul>

<h3 id="4-원자성-보장동시성-안전">4) 원자성 보장(동시성 안전)</h3>

<ul>
  <li>
    <p><strong>조회(선정)와 삭제를 한 덩어리로</strong>: Lua/Functions로 감싸기</p>

    <ul>
      <li>“이미 다른 워커가 먼저 가져간” 케이스를 **<code class="language-plaintext highlighter-rouge">ZREM</code> 반환값(0/1)**로 판단해 필터링.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="흔한-실수--주의">흔한 실수 &amp; 주의</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ZRANGE</code>/<code class="language-plaintext highlighter-rouge">ZRANDMEMBER</code> <strong>만</strong> 호출하고 <code class="language-plaintext highlighter-rouge">ZREM</code>을 빼먹음 → 큐에 그대로 남아 <strong>중복 매칭</strong> 발생.</li>
  <li><strong>컬렉션 키에 TTL</strong>을 걸어 전체 대기열이 사라짐.
TTL은 <strong>개별 사용자 키</strong>(예: <code class="language-plaintext highlighter-rouge">user:queued:{cat:123}:42</code>)에만.</li>
  <li>Redis Cluster 사용 시, <strong>스크립트 KEYS는 같은 해시태그</strong>(<code class="language-plaintext highlighter-rouge">{cat:123}</code>)로 묶기. 전역 키는 Lua에서 다루지 말고 자바에서만.</li>
</ul>

<hr />

<h2 id="시간-복잡도">시간 복잡도</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ZADD/ZREM/ZRANK</code> ≈ <strong>O(log N)</strong></li>
  <li><code class="language-plaintext highlighter-rouge">ZRANGE</code> ≈ <strong>O(k)</strong> (반환 수)</li>
  <li><code class="language-plaintext highlighter-rouge">ZPOPMIN/MAX</code> ≈ <strong>O(k log N)</strong></li>
  <li><code class="language-plaintext highlighter-rouge">SADD/SREM/SPOP</code> ≈ <strong>평균 O(1)</strong></li>
</ul>

<hr />

<h2 id="미니-예시-대기열-입장--매칭">미니 예시: 대기열 입장 &amp; 매칭</h2>

<pre><code class="language-redis"># 입장
ZADD wait:z:{cat:123} 1725430000456 101          # 대기 시작 시각(밀리초)
SET  user:queued:{cat:123}:101 q_101_123 EX 600   # 개별 TTL

# 대기순 매칭 2명 (원자)
ZPOPMIN wait:z:{cat:123} 2                        # -&gt; [101,score],[205,score]

# 랜덤 매칭 2명 (Lua로 원자화 권장)
-- 조회
ZRANDMEMBER wait:z:{cat:123} 2
-- 같은 로직 안에서 제거
ZREM wait:z:{cat:123} 101 205
</code></pre>

<hr />

<h2 id="한-줄-정리">한 줄 정리</h2>

<ul>
  <li><strong>ZSET = 순번/대기시간/공정성</strong>, <strong>SET = 단순 랜덤 풀</strong></li>
  <li><code class="language-plaintext highlighter-rouge">ZRANGE/ZRANDMEMBER</code>(조회) 뒤엔 <strong>반드시 <code class="language-plaintext highlighter-rouge">ZREM</code>(삭제)</strong></li>
  <li>경쟁 환경에선 <strong>Lua로 “조회→삭제”를 원자화</strong></li>
  <li><strong>TTL은 개별 상태 키에만</strong>, 대기열 컬렉션엔 금지</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[친구하자 프로젝트 개발 중 랜덤 매칭 대기열을 만들면서 정리한 Redis 명령어 모음집입니다.]]></summary></entry></feed>