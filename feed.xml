<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-08-25T06:24:14+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[JAVA] Queue는 왜 안되고 Queue는 왜 될까?</title><link href="https://nan0silver.github.io/java/2025-08-25-queue-int/" rel="alternate" type="text/html" title="[JAVA] Queue는 왜 안되고 Queue는 왜 될까?" /><published>2025-08-25T00:00:00+00:00</published><updated>2025-08-25T06:23:33+00:00</updated><id>https://nan0silver.github.io/java/queue-int</id><content type="html" xml:base="https://nan0silver.github.io/java/2025-08-25-queue-int/"><![CDATA[<ul>
  <li><a href="#-record란-java-14">record란?</a></li>
  <li><a href="#1️⃣-record의-특징">record의 특징</a></li>
  <li><a href="#2️⃣-기존-클래스-vs-record-비교">기존 클래스 vs record 비교</a></li>
  <li><a href="#3️⃣-record의-내부-동작">record 내부 동작</a></li>
  <li><a href="#4️⃣-record의-주요-기능">record 주요 기능</a></li>
  <li><a href="#5️⃣-record를-언제-사용할까">record 사용 방법</a></li>
  <li><a href="#6️⃣-정리">정리</a></li>
</ul>

<hr />

<h1 id="왜-queueint는-안-되고-queueinteger는-될까">왜 <code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code>는 안 되고 <code class="language-plaintext highlighter-rouge">Queue&lt;Integer&gt;</code>는 될까?</h1>

<p>Java 제네릭을 쓰다 보면 한 번씩 멈칫하게 되는 질문입니다. “왜 <code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code>는 안 되는데 <code class="language-plaintext highlighter-rouge">Queue&lt;Integer&gt;</code>는 되지?” 이 글은 그 이유를 **타입 소거(type erasure)**와 <strong>참조 타입만 허용하는 제네릭 규칙</strong>에서 차근차근 풀어 설명합니다. 실전 성능 팁과 BFS 같은 알고리즘 코드 패턴도 함께 담았습니다.</p>

<hr />

<h2 id="정리">정리</h2>

<ul>
  <li><strong>제네릭 타입 인자(T)는 참조 타입만 가능</strong>합니다. (<code class="language-plaintext highlighter-rouge">T extends Object</code>가 암묵적 전제)</li>
  <li><strong>타입 소거</strong>로 인해 런타임에는 제네릭 정보가 지워지고, 메서드 시그니처가 사실상 <code class="language-plaintext highlighter-rouge">Object</code> 기반으로 동작합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">int</code> 같은 <strong>원시 타입(primitive)</strong> 은 <code class="language-plaintext highlighter-rouge">Object</code>가 아니므로 <strong>제네릭 인자로 쓸 수 없습니다.</strong> ⇒ <code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code> 금지</li>
  <li><strong>배열은 참조 타입</strong>이므로 <code class="language-plaintext highlighter-rouge">Queue&lt;int[]&gt;</code>는 가능합니다. (배열 자체는 객체)</li>
  <li>알고리즘 큐에는 <strong><code class="language-plaintext highlighter-rouge">int[]</code> 또는 <code class="language-plaintext highlighter-rouge">record/class</code>로 상태를 묶어</strong> 넣으면 <strong>박싱 없이</strong> 빠르고 메모리 친화적입니다.</li>
</ul>

<hr />

<h2 id="1-제네릭은-왜-쓰나">1) 제네릭은 왜 쓰나?</h2>

<p>컴파일 타임에 타입을 체크해 <strong>타입 안전성</strong>을 높이고, 캐스트를 없애 <strong>가독성</strong>과 <strong>유지보수성</strong>을 올리기 위해서입니다.
<a href="https://nan0silver.github.io/java/2025-01-29-generic/">제네릭에 대해 정리한 블로그 글 참고</a></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 제네릭 없음: 캐스트 필요</span>
<span class="nc">List</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">();</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"hi"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

<span class="c1">// 제네릭 사용: 컴파일 타임에 체크, 캐스트 제거</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">list2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"hi"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">y</span> <span class="o">=</span> <span class="n">list2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<h2 id="2-타입-소거type-erasure란">2) 타입 소거(type erasure)란?</h2>

<p>자바의 제네릭은 <strong>런타임에 사라집니다.</strong> 컴파일러가 제네릭 코드를 검사·보정한 뒤, <strong>실행 시점에는 타입 매개변수를 지운(Object로 대체한)</strong> 형태로 동작합니다.</p>

<p>개념적으로 다음과 같습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 원본</span>
<span class="kd">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="no">T</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
  <span class="no">T</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// (개념적) 컴파일 후 - T가 지워지고 Object 중심으로</span>
<span class="kd">class</span> <span class="nc">Box</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Object</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
  <span class="nc">Object</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>컴파일러가 <strong>캐스트 삽입</strong>과 <strong>오토박싱/언박싱</strong>으로 타입 안전을 보정해 줍니다(필요 시 브리지 메서드도 생성).</p>

<hr />

<h2 id="3-t는-왜-참조-타입만-될-수-있나">3) T는 왜 ‘참조 타입’만 될 수 있나?</h2>

<p>자바 언어 규칙상 **모든 타입 매개변수는 암묵적으로 <code class="language-plaintext highlighter-rouge">T extends Object</code>**로 취급됩니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Integer</code>, <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">MyClass</code> 같은 <strong>참조 타입(reference type)</strong> 은 <code class="language-plaintext highlighter-rouge">Object</code>의 하위 타입이므로 OK.</li>
  <li><code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">boolean</code> 같은 <strong>원시 타입(primitive)</strong> 은 <code class="language-plaintext highlighter-rouge">Object</code>가 아니므로 <strong>제네릭 타입 인자로 금지</strong>됩니다.</li>
</ul>

<p>즉, <code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code>는 <strong>언어 차원에서 성립하지 않습니다.</strong></p>

<blockquote>
  <p>포인트: <strong>타입 소거 후의 세계는 <code class="language-plaintext highlighter-rouge">Object</code> 중심</strong>이라, 그 세계로 들어올 수 있는 타입(=참조 타입)만 제네릭 인자가 될 수 있습니다.</p>
</blockquote>

<hr />

<h2 id="4-그렇다면-queueinteger는-왜-되나">4) 그렇다면 <code class="language-plaintext highlighter-rouge">Queue&lt;Integer&gt;</code>는 왜 되나?</h2>

<p><code class="language-plaintext highlighter-rouge">Integer</code>는 <code class="language-plaintext highlighter-rouge">int</code>의 <strong>래퍼 클래스</strong>(참조 타입)입니다. 제네릭 인자로 쓸 수 있고, <code class="language-plaintext highlighter-rouge">q.offer(1)</code>처럼 쓰면 <strong>오토박싱</strong>이 자동으로 일어나 <code class="language-plaintext highlighter-rouge">int -&gt; Integer</code>가 됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>      <span class="c1">// int가 Integer로 오토박싱</span>
<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span> <span class="c1">// Integer가 int로 언박싱</span>
</code></pre></div></div>

<p>단, 이 과정은 <strong>객체 할당/GC 비용</strong>이 들 수 있습니다. 대량 연산에서는 체감될 수 있어요.</p>

<hr />

<h2 id="5-queueint는-왜-가능한가">5) <code class="language-plaintext highlighter-rouge">Queue&lt;int[]&gt;</code>는 왜 가능한가?</h2>

<p>배열은 <strong>항상 참조 타입</strong>입니다. 원소가 원시 타입이든 말든, <strong>배열 자체는 힙 객체</strong>니까 제네릭 인자로 사용 가능해요.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">});</span> <span class="c1">// 배열 참조를 넣음</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<h2 id="6-성능메모리-관점-오토박싱을-피하자">6) 성능·메모리 관점: 오토박싱을 피하자</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Queue&lt;Integer&gt;</code>는 <strong>원소마다 <code class="language-plaintext highlighter-rouge">Integer</code> 객체</strong>가 생길 수 있어</p>

    <ul>
      <li>오토박싱/언박싱 비용</li>
      <li>객체 헤더 + 포인터 오버헤드</li>
      <li>GC 부담
이 발생합니다.</li>
    </ul>
  </li>
  <li>
    <p>알고리즘(특히 BFS/DFS, 다익스트라 등)에서는 <strong>박싱을 피하는 게 유리</strong>합니다.</p>
  </li>
</ul>

<h3 id="권장-1-int로-상태-묶기-가볍고-빠름">권장 1) <code class="language-plaintext highlighter-rouge">int[]</code>로 상태 묶기 (가볍고 빠름)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// {r, c, breakUsed, dist}</span>
<span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">});</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</code></pre></div></div>

<h3 id="권장-2-record로-가독성--java-16">권장 2) <code class="language-plaintext highlighter-rouge">record</code>로 가독성 ↑ (Java 16+)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">State</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{}</span>
<span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">State</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
<span class="nc">State</span> <span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</code></pre></div></div>

<blockquote>
  <p>팁: 큐 구현체는 **<code class="language-plaintext highlighter-rouge">ArrayDeque</code>**가 일반적으로 <code class="language-plaintext highlighter-rouge">LinkedList</code>보다 빠르고 메모리 효율적입니다.</p>
</blockquote>

<hr />

<h2 id="7-실전-faq">7) 실전 FAQ</h2>

<p><strong>Q1. “런타임에 진짜 <code class="language-plaintext highlighter-rouge">Queue&lt;Object&gt;</code>로 동작하나요?”</strong>
개념적으로는 <strong>그와 유사</strong>합니다(타입 소거). 실제로는 컴파일러가 캐스트/브리지 메서드 등으로 타입 안전을 맞춰 줍니다. 핵심은 <strong>런타임에 타입 인자 정보가 없고 <code class="language-plaintext highlighter-rouge">Object</code> 중심으로 호출</strong>된다는 점입니다.</p>

<p><strong>Q2. 그렇다면 왜 컴파일러가 <code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code>도 자동으로 <code class="language-plaintext highlighter-rouge">Queue&lt;Integer&gt;</code>로 바꿔주지 않나요?</strong>
언어 규칙상 <strong>제네릭 인자는 참조 타입만</strong> 허용합니다. 타입 인자 자체를 바꾸는 묵시적 변환은 <strong>설계상 모호성과 함정</strong>(예: <code class="language-plaintext highlighter-rouge">T</code>가 원시로 선언됐는데 실제론 참조로 다뤄짐)을 낳기에 금지됩니다. 명시적으로 <code class="language-plaintext highlighter-rouge">Integer</code>를 써 주세요.</p>

<p><strong>Q3. 원시 타입 컬렉션이 꼭 필요합니다. 방법이 없나요?</strong>
표준 라이브러리는 제공하지 않지만, <strong>전용 라이브러리</strong>가 있습니다.</p>

<ul>
  <li>fastutil (<code class="language-plaintext highlighter-rouge">IntArrayList</code>, <code class="language-plaintext highlighter-rouge">IntOpenHashSet</code>, …)</li>
  <li>HPPC (High Performance Primitive Collections)</li>
  <li>Eclipse Collections (primitive collections)
대량 데이터·고성능 시나리오에서 유용합니다.</li>
</ul>

<hr />

<h2 id="8-bfs-예시-박싱-없이-깔끔하게">8) BFS 예시: 박싱 없이 깔끔하게</h2>

<p>아래는 “벽을 한 번만 부술 수 있는” BFS 패턴입니다. <code class="language-plaintext highlighter-rouge">int[]</code>로 상태를 묶어 <strong>박싱을 회피</strong>합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dc</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="no">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">boolean</span><span class="o">[][][]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">});</span> <span class="c1">// r, c, breakUsed, dist</span>
        <span class="n">visited</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">b</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="n">d</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="no">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="no">M</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">d</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span> <span class="o">}</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">dr</span><span class="o">[</span><span class="n">k</span><span class="o">],</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">dc</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nr</span> <span class="o">&gt;=</span> <span class="no">N</span> <span class="o">||</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nc</span> <span class="o">&gt;=</span> <span class="no">M</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">nr</span><span class="o">][</span><span class="n">nc</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">nr</span><span class="o">][</span><span class="n">nc</span><span class="o">][</span><span class="n">b</span><span class="o">])</span> <span class="o">{</span> <span class="n">visited</span><span class="o">[</span><span class="n">nr</span><span class="o">][</span><span class="n">nc</span><span class="o">][</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nr</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">});</span> <span class="o">}</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="o">[</span><span class="n">nr</span><span class="o">][</span><span class="n">nc</span><span class="o">][</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">visited</span><span class="o">[</span><span class="n">nr</span><span class="o">][</span><span class="n">nc</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nr</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">});</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ans</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="9-한눈에-요약-체크리스트">9) 한눈에 요약 체크리스트</h2>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />제네릭 인자 = <strong>참조 타입만</strong> (암묵적 <code class="language-plaintext highlighter-rouge">T extends Object</code>)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />런타임 = <strong>타입 소거</strong> (제네릭 정보 없음, <code class="language-plaintext highlighter-rouge">Object</code> 중심)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code> ❌, <code class="language-plaintext highlighter-rouge">Queue&lt;Integer&gt;</code> ⭕</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><code class="language-plaintext highlighter-rouge">Queue&lt;int[]&gt;</code> ⭕ (배열은 참조 타입)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />성능 중요: <strong>박싱 피하기</strong> (가능하면 <code class="language-plaintext highlighter-rouge">int[]</code>/<code class="language-plaintext highlighter-rouge">record</code> 사용)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />큐 구현체는 보통 <strong><code class="language-plaintext highlighter-rouge">ArrayDeque</code></strong> 추천</li>
</ul>

<hr />

<h2 id="마무리">마무리</h2>

<p><code class="language-plaintext highlighter-rouge">Queue&lt;int&gt;</code>가 금지되는 이유는 단순히 “문법이 그렇다”가 아니라, <strong>타입 소거라는 실행 모델</strong>과 <strong>참조 타입만 허용하는 제네릭 설계</strong>가 맞물린 결과입니다. 오늘부터는 알고리즘에서 <strong>박싱 없는 상태 표현</strong>으로 깔끔하고 빠른 코드를 써 보세요!</p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="java" /><summary type="html"><![CDATA["왜 Queue는 안 되는데 Queue는 되지?"에 대한 이유를 설명합니다.]]></summary></entry><entry><title type="html">[친구하자] 매칭 대기열 설계 기록 : 왜 DB + Redis 하이브리드로 갔나</title><link href="https://nan0silver.github.io/projectdiary/2025-08-25-diary/" rel="alternate" type="text/html" title="[친구하자] 매칭 대기열 설계 기록 : 왜 DB + Redis 하이브리드로 갔나" /><published>2025-08-25T00:00:00+00:00</published><updated>2025-08-25T06:23:33+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-08-25-diary/"><![CDATA[<ul>
  <li><a href="#문제-배경">문제 배경</a></li>
  <li><a href="#tldr">TL;DR</a></li>
  <li><a href="#1-내가-왜-이런-고민을-하게-됐나-맥락">1. 내가 왜 이런 고민을 하게 됐나</a></li>
  <li><a href="#2-현재-구현의-문제-정리-redis-단독일-때">2. 현재 구현의 문제 정리 (Redis 단독일 때)</a></li>
  <li><a href="#3-하이브리드-설계-원칙">3. 하이브리드 설계 원칙</a></li>
  <li><a href="#4-개선된-데이터-흐름">4. 개선된 데이터 흐름</a></li>
  <li><a href="#5-redis-자료구조-선택과-이유">5. Redis 자료구조 선택과 이유</a></li>
  <li><a href="#6-원자적-매칭-lua-스크립트-예시개념">6. 원자적 매칭: Lua 스크립트 예시(개념)</a></li>
  <li><a href="#7-복구-메커니즘서버-재기동장애-대비">7. 복구 메커니즘(서버 재기동/장애 대비)</a></li>
  <li><a href="#8-스키마인덱스-설계">8. 스키마/인덱스 설계</a></li>
  <li><a href="#9-시스템-구성개념-아키텍처">9. 시스템 구성(개념 아키텍처)</a></li>
  <li><a href="#10-실무에서의-선택지-비교">10. 실무에서의 선택지 비교</a></li>
  <li><a href="#11-테스트운영-시나리오">11. 테스트/운영 시나리오</a></li>
  <li><a href="#12-내가-배운-점--선택의-근거">12. 내가 배운 점 &amp; 선택의 근거</a></li>
  <li><a href="#13-next-steps-로드맵">13. Next Steps (로드맵)</a></li>
  <li><a href="#부록-a-코드-스니펫개념">부록 A. 코드 스니펫(개념)</a></li>
</ul>

<blockquote>
  <p>“대기열=실시간성, 기록/분석/복구=영속성.”
이 두 욕심을 동시에 만족시키려다 보니 하이브리드(DB+Redis)가 자연스럽게 답이 되었다.</p>
</blockquote>

<hr />

<h2 id="문제-배경">문제 배경</h2>

<ul>
  <li>친구하자 구현 중 핵심인 통화 매칭 부분을 구현하는 중이였다.</li>
  <li>초반 설계에서는 Redis만 사용해서 구현하기로 하여 하고있었는데, 이렇게 하면 대기열 기록이 되지않아 나중에 시스템 분석 및 복구에 어려움이 있어보였다.</li>
  <li>따라서 DB와 함께 구현하는 방식이 많이 사용되는 방식인지, 어떤 부분에 장단점이 있고 고려해야하는 부분은 어떤 것인지 궁금했다.</li>
  <li>또한 관련되서 더 심화된 기술은 어떤 것이 있는지 알아보고싶었다.</li>
</ul>

<hr />

<h2 id="tldr">TL;DR</h2>

<ul>
  <li><strong>문제의식</strong>: Redis만 쓰면 빠르지만 휘발성·운영/분석/복구가 약하다. DB만 쓰면 영속적이지만 지연·경합에 취약하다.</li>
  <li><strong>결론</strong>: <strong>DB(사실의 원천, 이력/분석/복구) + Redis(실시간 대기열/매칭)</strong> 를 분리한 하이브리드 구조.</li>
  <li><strong>실무 팁</strong>: 아웃박스 패턴으로 <strong>이중 쓰기 일관성</strong>, Redis <strong>ZSET</strong>+<strong>Lua</strong>로 <strong>원자적 매칭</strong>, <strong>멱등키/TTL/청소잡/AOF+복제</strong>로 운영 내구성 확보.</li>
  <li><strong>대안</strong>: 규모·요구사항에 따라 Redis Streams, RabbitMQ, Kafka, SQS, Postgres SKIP LOCKED도 선택지.</li>
</ul>

<hr />

<h2 id="1-내가-왜-이런-고민을-하게-됐나-맥락">1) 내가 왜 이런 고민을 하게 됐나 (맥락)</h2>

<p>친구하자는 <strong>1분 내 매칭</strong> 같은 <strong>저지연 실시간성</strong>이 핵심이다. 그래서 처음엔 <strong>Redis 단독</strong>이 끌렸다.
하지만 곧바로 다음 현실에 부딪혔다.</p>

<ul>
  <li><strong>휘발성 vs 영속성</strong>: Redis는 빠르지만(메모리) 장애/재시작 시 <strong>데이터 유실</strong> 리스크.</li>
  <li><strong>운영/디버깅</strong>: 매칭 실패/타임아웃/취소 이슈를 <strong>재현</strong>하고 <strong>원인 추적</strong>하려면 <strong>이력 테이블</strong>이 꼭 필요.</li>
  <li><strong>통계/제품개선</strong>: 카테고리별 대기시간·매칭률·시간대 부하 같은 <strong>지표</strong>는 DB가 편하다.</li>
  <li><strong>복구 시나리오</strong>: 서버/Redis 재기동 시 <strong>“누가 줄에 서 있었나?”</strong> 를 복원하려면 DB에 근거가 있어야 한다.</li>
</ul>

<p>결국 “<strong>실시간 처리=Redis</strong>”, “<strong>이력/분석/복구=DB</strong>”로 역할을 나누는 하이브리드가 합리적이라는 결론에 도달했다.</p>

<hr />

<h2 id="2-현재-구현의-문제-정리-redis-단독일-때">2) 현재 구현의 문제 정리 (Redis 단독일 때)</h2>

<ol>
  <li><strong>데이터 영속성</strong>: 서버/Redis 재시작 시 대기열 유실 가능</li>
  <li><strong>통계/분석 취약</strong>: 매칭 히스토리/패턴 분석이 어려움</li>
  <li><strong>디버깅 곤란</strong>: 실패 재현·CS 대응 근거 부족</li>
  <li><strong>복구 어려움</strong>: 장애 시 대기열/상태 재구성이 힘듦</li>
</ol>

<hr />

<h2 id="3-하이브리드-설계-원칙">3) 하이브리드 설계 원칙</h2>

<h3 id="1-단일-출처single-source-of-truth-sot-명확화">(1) 단일 출처(Single Source of Truth, SOT) 명확화</h3>

<ul>
  <li><strong>대기열의 SOT = Redis</strong> (실시간 기준)</li>
  <li><strong>이력/상태의 SOT = DB</strong> (사실 기준)</li>
</ul>

<h3 id="2-일관성-경계-정의">(2) 일관성 경계 정의</h3>

<ul>
  <li>두 저장소에 <strong>언제/어떤 순서로</strong> 쓸지 고정.</li>
  <li>권장: <strong>DB 트랜잭션</strong>으로 <code class="language-plaintext highlighter-rouge">matching_queue(WAITING)</code> + <strong>아웃박스 이벤트</strong>를 함께 기록 → 워커가 <strong>Redis에 enqueue</strong> (재시도 가능)</li>
</ul>

<h3 id="3-멱등성중복-방지">(3) 멱등성/중복 방지</h3>

<ul>
  <li>사용자 중복 등록 방지: <code class="language-plaintext highlighter-rouge">SET user:{id}:queued 1 NX EX 600</code></li>
  <li>매칭 결과 멱등 업데이트: <code class="language-plaintext highlighter-rouge">match_id</code> <strong>UNIQUE</strong> 제약 등</li>
</ul>

<hr />

<h2 id="4-개선된-데이터-흐름">4) 개선된 데이터 흐름</h2>

<ol>
  <li>
    <p><strong>참가(Enqueue)</strong>:</p>

    <ul>
      <li>DB 트랜잭션: <code class="language-plaintext highlighter-rouge">matching_queue(WAITING)</code> + <code class="language-plaintext highlighter-rouge">outbox(enqueue_event)</code></li>
      <li>Outbox Consumer가 Redis <strong>ZSET</strong>에 등록</li>
    </ul>
  </li>
  <li>
    <p><strong>매칭(Match)</strong>:</p>

    <ul>
      <li>Redis에서 <strong>원자적으로 두 명을 Pop</strong> (Lua 스크립트)</li>
      <li>DB에 <code class="language-plaintext highlighter-rouge">MATCHING → MATCHED</code> 상태 전이(멱등)</li>
    </ul>
  </li>
  <li>
    <p><strong>통계/리포트</strong>:</p>

    <ul>
      <li>DB 이력 기반 분석/대시보드</li>
    </ul>
  </li>
  <li>
    <p><strong>실시간 조회</strong>:</p>
    <ul>
      <li>Redis 대기열 길이, 평균 대기시간(샘플링) 즉시 응답</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="5-redis-자료구조-선택과-이유">5) Redis 자료구조 선택과 이유</h2>

<ul>
  <li>
    <p><strong>ZSET(정렬집합)</strong> 권장</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">score = 대기 시작 시각 or 우선순위</code></li>
      <li><strong>공정성(FCFS)/우선순위</strong>/타임아웃 처리 쉽다.</li>
      <li>꺼낼 때 <strong>원자성</strong>을 위해 Lua 스크립트 사용.</li>
    </ul>
  </li>
  <li>
    <p><strong>덧붙임</strong></p>

    <ul>
      <li><strong>SET NX</strong>로 중복 등록 방지</li>
      <li><strong>HASH</strong>(<code class="language-plaintext highlighter-rouge">queue:{queueId}</code>)로 사용자·카테고리·TTL 메타 저장</li>
      <li><strong>TTL + 정리잡</strong>으로 고아 항목 청소</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>단순 리스트(LLEN/LPOP)는 쉽지만 공정성·타임아웃·중복 제어를 구조적으로 풀기 어렵다.
<strong>Streams</strong>는 컨슈머 그룹/ACK로 내구성이 좋지만 매칭 “쌍짓기”엔 별도 설계가 필요.</p>
</blockquote>

<hr />

<h2 id="6-원자적-매칭-lua-스크립트-예시개념">6) 원자적 매칭: Lua 스크립트 예시(개념)</h2>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- KEYS[1]=zset key, ARGV[1]=score(복원용)</span>
<span class="kd">local</span> <span class="n">k</span> <span class="o">=</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="kd">local</span> <span class="n">a</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'ZRANGE'</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">if</span> <span class="o">#</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span> <span class="k">return</span> <span class="p">{}</span> <span class="k">end</span>
<span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'ZREM'</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="kd">local</span> <span class="n">b</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'ZRANGE'</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">if</span> <span class="o">#</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span>
  <span class="c1">-- 짝이 없으면 되돌리기</span>
  <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'ZADD'</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">return</span> <span class="p">{}</span>
<span class="k">end</span>
<span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'ZREM'</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="c1">-- 필요 시 락/마킹/TTL 등 추가</span>
<span class="k">return</span> <span class="p">{</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
</code></pre></div></div>

<blockquote>
  <p>실전에서는 <strong>되돌리기/락/타임아웃/카테고리 필터</strong>까지 넣어야 한다.</p>
</blockquote>

<hr />

<h2 id="7-복구-메커니즘서버-재기동장애-대비">7) 복구 메커니즘(서버 재기동/장애 대비)</h2>

<ul>
  <li>Redis는 <strong>AOF(append-only)</strong> + <strong>영속 볼륨</strong> + <strong>복제/센티넬</strong>로 내구성 강화</li>
  <li>그래도 안전망으로 <strong>“최근 WAITING만 DB→Redis 재적재”</strong> 수행</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 서버 기동 시 안전 복구(개념)</span>
<span class="nd">@PostConstruct</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">recoverQueuesFromDatabase</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">active</span> <span class="o">=</span> <span class="n">matchingQueueRepository</span><span class="o">.</span><span class="na">findByQueueStatusAndCreatedAtAfter</span><span class="o">(</span>
        <span class="nc">QueueStatus</span><span class="o">.</span><span class="na">WAITING</span><span class="o">,</span>
        <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">minusMinutes</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
    <span class="o">);</span>
    <span class="n">active</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">queue</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="c1">// Redis 재적재 로직(ZSET + 메타 HSET 등)</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>운영에선 <strong>ApplicationRunner + 분산락</strong>으로 <strong>중복 복구 방지</strong>를 권장.</p>
</blockquote>

<hr />

<h2 id="8-스키마인덱스-설계">8) 스키마/인덱스 설계</h2>

<p><strong>matching_queue</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">id, user_id, category, status(WAITING/MATCHING/MATCHED/EXPIRED/CANCELLED), created_at, updated_at</code></li>
  <li>인덱스: <code class="language-plaintext highlighter-rouge">(status, created_at)</code>, <code class="language-plaintext highlighter-rouge">(user_id, status)</code></li>
</ul>

<p><strong>match_events</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">match_id(UNIQUE), user_a, user_b, started_at, ended_at, result, reason</code></li>
  <li>멱등키: <code class="language-plaintext highlighter-rouge">match_id UNIQUE</code></li>
</ul>

<p><strong>outbox</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">event_id, type, payload, created_at, processed_at NULLABLE</code></li>
  <li>워커가 <code class="language-plaintext highlighter-rouge">processed_at IS NULL</code>만 읽고 성공 시 채움(재시도 가능)</li>
</ul>

<hr />

<h2 id="9-시스템-구성개념-아키텍처">9) 시스템 구성(개념 아키텍처)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[API] ──(Tx)──&gt; [DB] ──(Outbox)──&gt; [Outbox Consumer] ──&gt; [Redis ZSET]
  │                                              │
  └──────────────(조회/이력)──────────────────────┘

[Matching Worker] &lt;──&gt; [Redis ZSET + Lua + TTL]
      │                            │
      └────(멱등 업데이트)──────&gt; [DB: 상태/이력]
</code></pre></div></div>

<p>운영 필수 체크:</p>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Redis <strong>AOF + 복제/센티넬</strong></li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>아웃박스/재시도</strong>로 DB↔Redis <strong>일관성 보장</strong></li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>SET NX/TTL/청소잡/분산락</strong></li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>대기열 길이/평균 대기시간/타임아웃률/매칭 성공률</strong> 메트릭</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>enqueue/match/cancel/timeout</strong> 이벤트 로깅</li>
</ul>

<hr />

<h2 id="10-실무에서의-선택지-비교">10) 실무에서의 선택지 비교</h2>

<table>
  <thead>
    <tr>
      <th>시나리오</th>
      <th>권장 스택</th>
      <th>핵심 포인트</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>저지연 실시간 매칭 (MVP~중규모)</strong></td>
      <td><strong>Redis (ZSET/Streams) + DB</strong></td>
      <td>속도·복잡도 밸런스 좋음</td>
    </tr>
    <tr>
      <td><strong>내구성 높은 큐/재처리/다중소비자</strong></td>
      <td><strong>Redis Streams</strong> or <strong>RabbitMQ</strong> + DB</td>
      <td>ACK/리트라이/가시성 타임아웃 쉬움</td>
    </tr>
    <tr>
      <td><strong>대규모 분산/리플레이</strong></td>
      <td><strong>Kafka</strong> (+ Redis 캐시)</td>
      <td>파티셔닝·재처리 강점, 매칭 로직은 앱에서</td>
    </tr>
    <tr>
      <td><strong>아주 단순/저QPS</strong></td>
      <td><strong>Postgres</strong> (<code class="language-plaintext highlighter-rouge">FOR UPDATE SKIP LOCKED</code>)</td>
      <td>운영 단순, 지연·경합은 감수</td>
    </tr>
    <tr>
      <td><strong>관리형 간단 큐</strong></td>
      <td><strong>SQS</strong></td>
      <td>쉬움+내구성, 초저지연 매칭은 보완 필요</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>친구하자의 <strong>“1분 내 매칭·공정성·운영 용이성”</strong> 기준에선 현재 <strong>Redis ZSET + DB</strong>가 가장 적합. 추후 트래픽 급증 시 <strong>Streams/Kafka</strong>로 확장 가능.</p>
</blockquote>

<hr />

<h2 id="11-테스트운영-시나리오">11) 테스트/운영 시나리오</h2>

<ul>
  <li><strong>부하 테스트</strong>: 카테고리별 동시 1k~5k 등록, 평균/95p 대기시간, 매칭 성공률 측정</li>
  <li><strong>경합 테스트</strong>: 동시 매칭 워커 2~10개, 중복 매칭/유실 여부</li>
  <li><strong>장애 시나리오</strong>: Redis 재시작, 네트워크 분리, DB 쓰기 실패 시 재시도 동작</li>
  <li><strong>복구 리허설</strong>: DB→Redis 재적재 로직의 <strong>멱등성/중복 방지</strong> 검증</li>
</ul>

<hr />

<h2 id="12-내가-배운-점--선택의-근거">12) 내가 배운 점 &amp; 선택의 근거</h2>

<ul>
  <li>실시간성만 보면 Redis 단독이 매력적이지만, <strong>운영·분석·복구</strong>까지 생각하면 <strong>DB 하이브리드</strong>가 필수.</li>
  <li><strong>단일 출처</strong>를 나누고(<strong>대기열=Redis, 이력=DB</strong>), <strong>이중 쓰기 일관성</strong>(아웃박스/재시도)을 확보하면 MVP 이후에도 <strong>확장 가능한 길</strong>이 열린다.</li>
  <li>Redis에선 <strong>ZSET + Lua</strong>가 <strong>공정성/타임아웃/원자성</strong>을 한 번에 잡는 실전 해법이었다.</li>
</ul>

<hr />

<h2 id="13-next-steps-로드맵">13) Next Steps (로드맵)</h2>

<ol>
  <li><strong>아웃박스 컨슈머</strong> 도입 및 재시도/백오프</li>
  <li><strong>Lua 스크립트</strong>에 락/타임아웃/복원 로직 보강</li>
  <li><strong>AOF+복제/센티넬</strong> 운영화</li>
  <li><strong>메트릭/알람</strong>: 대기열 길이·대기시간·타임아웃률·에러율</li>
  <li>트래픽 증가 시 <strong>Streams</strong> 도입 검토(컨슈머 그룹 기반), 더 커지면 <strong>Kafka</strong> 병행</li>
</ol>

<hr />

<h3 id="부록-a-코드-스니펫개념">부록 A. 코드 스니펫(개념)</h3>

<p><strong>DB → Outbox 트랜잭션</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">enqueue</span><span class="o">(</span><span class="nc">Long</span> <span class="n">userId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">category</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">MatchingQueue</span> <span class="n">q</span> <span class="o">=</span> <span class="n">matchingQueueRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span>
        <span class="nc">MatchingQueue</span><span class="o">.</span><span class="na">waiting</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">category</span><span class="o">)</span>
    <span class="o">);</span>
    <span class="n">outboxRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="nc">OutboxEvent</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">category</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>Outbox Consumer → Redis</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">OutboxEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"mq:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getCategory</span><span class="o">();</span>
    <span class="c1">// 중복 방지</span>
    <span class="nc">Boolean</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="na">setIfAbsent</span><span class="o">(</span><span class="s">"user:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getUserId</span><span class="o">()</span> <span class="o">+</span> <span class="s">":queued"</span><span class="o">,</span> <span class="s">"1"</span><span class="o">,</span> <span class="nc">Duration</span><span class="o">.</span><span class="na">ofMinutes</span><span class="o">(</span><span class="mi">10</span><span class="o">));</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">Boolean</span><span class="o">.</span><span class="na">TRUE</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ok</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">redis</span><span class="o">.</span><span class="na">zAdd</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getEnqueuedAt</span><span class="o">().</span><span class="na">toEpochSecond</span><span class="o">(</span><span class="nc">ZoneOffset</span><span class="o">.</span><span class="na">UTC</span><span class="o">),</span> <span class="n">e</span><span class="o">.</span><span class="na">getQueueId</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="n">outboxRepository</span><span class="o">.</span><span class="na">markProcessed</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="마무리">마무리</h2>

<p>이번 설계는 “<strong>현재 요구(저지연)</strong>”와 “<strong>미래 요구(운영/분석/복구/확장)</strong>”를 동시에 충족시키기 위한 <strong>균형점</strong>을 찾는 과정이었다.
<strong>DB+Redis 하이브리드</strong>는 그 균형점 위에서 <strong>실무적으로 검증된 길</strong>이며, MVP에서 시작해 <strong>Streams/Kafka</strong>로 확장 가능한 <strong>진화 경로</strong>를 갖는다.
친구하자의 성격(실시간 매칭 + 장기 운영/분석 필요)에 <strong>정합한 선택</strong>이라고 생각한다.</p>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[친구하자 프로젝트 개발 중 매칭 대기열을 구현하다가 생긴 고민을 정리해보았습니다.]]></summary></entry><entry><title type="html">[TIL] A/B 테스트</title><link href="https://nan0silver.github.io/til/2025-08-23-til/" rel="alternate" type="text/html" title="[TIL] A/B 테스트" /><published>2025-08-23T00:00:00+00:00</published><updated>2025-08-23T00:36:49+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-08-23-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
📅 <strong>작성일</strong>: 2025-08-23<br />
🔄 <strong>최종 수정</strong>: 2025년 08월 25일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h1 id="ab-테스트란">A/B 테스트란?</h1>

<ul>
  <li><strong>정의</strong>: 같은 목표를 두고 <strong>두 버전(A=기준, B=변경안)</strong> 을 <strong>동시에 무작위로</strong> 사용자에게 나눠 보여준 뒤, <strong>어느 쪽이 더 성과가 좋은지</strong> 통계적으로 비교하는 실험.</li>
  <li><strong>목적</strong>: 느낌/감이 아니라 <strong>데이터로 의사결정</strong>. 버튼 문구, 화면 배치, 가격 제안, 푸시 타이밍 등 “실제로” 지표가 개선되는지 검증.</li>
</ul>

<h1 id="기본-용어">기본 용어</h1>

<ul>
  <li><strong>변수(Variant)</strong>: A(컨트롤) vs B(실험안). 3개 이상이면 A/B/n.</li>
  <li><strong>지표(Metric)</strong>: 실험의 <strong>목표</strong>(예: 등록 전환율, 1일차 잔존, 통화 완료율).</li>
  <li><strong>유의수준 α</strong>: 오탐 허용(보통 0.05).</li>
  <li><strong>검정력 Power(1−β)</strong>: 진짜 차이가 있을 때 잡아낼 확률(보통 0.8).</li>
  <li><strong>MDE</strong>(최소 검출 가능 효과): “이 정도 차이는 나야 성공이라 본다” 최소 개선 폭(예: +2%p).</li>
</ul>

<h1 id="어떻게-하는가-실전-절차-7단계">어떻게 하는가 (실전 절차 7단계)</h1>

<ol>
  <li>
    <p><strong>가설 세우기</strong></p>

    <ul>
      <li>예) “대기시간 안내 문구를 바꾸면 <strong>매칭 시작 클릭률</strong>이 ↑한다.”</li>
    </ul>
  </li>
  <li>
    <p><strong>지표 딱 하나만 주지표로</strong></p>

    <ul>
      <li>주지표: 매칭 시작 클릭률</li>
      <li>보조지표(가드레일): 이탈률, 고객불만 접수율 등 “부작용 체크”</li>
    </ul>
  </li>
  <li>
    <p><strong>표본수(기간) 계획</strong></p>

    <ul>
      <li>대략의 규칙: <strong>차이를 작게 보고 싶을수록, 베이스 전환율이 낮을수록 → 더 많은 트래픽/기간</strong>이 필요.</li>
      <li>
        <p>(참고 공식 – <strong>이해만</strong>):</p>

        <ul>
          <li>
            <p>비율형 지표의 각 그룹 표본수 n ≈ <code class="language-plaintext highlighter-rouge">2 * (zα/2 + zβ)^2 * p̄(1-p̄) / Δ^2</code></p>

            <ul>
              <li><code class="language-plaintext highlighter-rouge">p̄</code>: 기준 전환율 추정, <code class="language-plaintext highlighter-rouge">Δ</code>: 검증하고 싶은 차이(절대값)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>무작위 배정 &amp; 고정</strong></p>

    <ul>
      <li><strong>사용자 단위</strong>로 50/50 랜덤 분배(세션/페이지뷰 단위 X).</li>
      <li>실험 중엔 <strong>변형하지 말기</strong>(중간에 디자인을 또 바꾸지 않기).</li>
    </ul>
  </li>
  <li>
    <p><strong>정확한 로깅</strong></p>

    <ul>
      <li>모든 이벤트에 <code class="language-plaintext highlighter-rouge">experiment_id</code>, <code class="language-plaintext highlighter-rouge">variant</code>(A/B) 파라미터를 함께 로깅.</li>
      <li><strong>SRM</strong>(sample ratio mismatch) 체크: 50/50이 크게 깨지면(예: 60/40) 실험 무효.</li>
    </ul>
  </li>
  <li>
    <p><strong>기간 고정 &amp; ‘엿보기’ 금지</strong></p>

    <ul>
      <li><strong>종료 조건 전</strong>에 유의성만 보고 중단하면 거짓 양성↑.</li>
      <li>꼭 필요하면 <strong>사전 정의된 순차검정</strong>(group-sequential)이나 <strong>베이즈 접근</strong>을 사용.</li>
    </ul>
  </li>
  <li>
    <p><strong>해석 &amp; 롤아웃</strong></p>

    <ul>
      <li>통계 유의 + <strong>실무 유의</strong>(임팩트/비용/부작용) 함께 본 뒤, 점진적 롤아웃(예: 10%→30%→100%).</li>
    </ul>
  </li>
</ol>

<h1 id="ga4앱에서-바로-쓰는-구성-팁">GA4/앱에서 바로 쓰는 구성 팁</h1>

<ul>
  <li>
    <p>이벤트 설계 예:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">event_name: start_match_click</code></li>
      <li>
        <p>파라미터:</p>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">experiment_id: "wait_copy_v1"</code></li>
          <li><code class="language-plaintext highlighter-rouge">variant: "A"|"B"</code></li>
          <li>사용자 ID 또는 설치 ID(사용자 기준 배정 유지)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>빅쿼리 연동</strong> 시 쿼리로 <code class="language-plaintext highlighter-rouge">variant</code>별 전환율 비교가 쉬워짐.</li>
  <li><strong>SRM 빠른 체킹</strong>: 실시간 대시보드에서 A/B 트래픽이 49–51% 근처인지 확인.</li>
</ul>

<h1 id="ab-테스트-3가지-예시">A/B 테스트 3가지 예시</h1>

<ol>
  <li>
    <p><strong>대기시간 안내 문구</strong></p>

    <ul>
      <li>A: “곧 연결됩니다”</li>
      <li>B: “평균 30초 내 연결됩니다 · 취소 가능”</li>
      <li>주지표: <code class="language-plaintext highlighter-rouge">start_match_click / 방문자</code></li>
      <li>가드레일: 즉시 이탈률, 고객불만</li>
    </ul>
  </li>
  <li>
    <p><strong>통화 후 피드백 수집 방식</strong></p>

    <ul>
      <li>A: 5점 척도만</li>
      <li>B: 5점 + “칭찬 한마디” 한줄 텍스트</li>
      <li>주지표: 피드백 제출률</li>
      <li>가드레일: 피드백 작성 시간, 다음날 재방문율</li>
    </ul>
  </li>
  <li>
    <p><strong>안심케어(유료) 소개 타이밍</strong></p>

    <ul>
      <li>A: 첫 3회 통화 후 페이월</li>
      <li>B: 첫 1회 통화 후 페이월</li>
      <li>주지표: 7일 내 결제 전환율</li>
      <li>가드레일: 7일 유지율, 평균 통화시간 변화</li>
    </ul>
  </li>
</ol>

<h1 id="설계-체크리스트-붙여넣어-쓰기">설계 체크리스트 (붙여넣어 쓰기)</h1>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />가설과 <strong>주지표 1개</strong> 명확</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>MDE</strong>와 <strong>기간/표본수</strong> 사전 정의</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>사용자 단위 랜덤</strong> 배정 + 고정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>experiment_id / variant</strong> 로깅</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong>SRM</strong> 모니터링</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />중도 엿보기 금지(혹은 순차검정 채택)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />통계 유의 + <strong>비즈니스 유의</strong> 함께 판단</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />롤아웃/롤백 플랜 준비</li>
</ul>

<h1 id="자주-하는-실수">자주 하는 실수</h1>

<ul>
  <li>여러 요소를 한꺼번에 바꾸기 → <strong>원인 분리 불가</strong></li>
  <li>주지표를 여러 개로 두기 → 해석 혼란</li>
  <li>세션/페이지뷰 단위 랜덤화 → 사용자 경험이 섞여 <strong>오염</strong></li>
  <li>주중/주말, 마케팅 캠페인 겹침 <strong>시즌성 영향</strong> 무시</li>
  <li>결과가 좋게 나올 때까지만 <strong>계속 엿보기</strong></li>
</ul>

<h1 id="참고-빈도주의-vs-베이즈">(참고) 빈도주의 vs 베이즈</h1>

<ul>
  <li><strong>빈도주의</strong>: p-value/신뢰구간, 고정 표본 설계에 적합.</li>
  <li><strong>베이즈</strong>: “B가 A보다 좋을 확률”처럼 <strong>직관적 해석</strong>과 <strong>순차적 의사결정</strong>에 유리.
둘 다 장단점 있어요—팀의 익숙함/툴링에 따라 선택.</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><category term="Git" /><category term="ML" /><summary type="html"><![CDATA[2025-08-23 TIL]]></summary></entry><entry><title type="html">[친구하자] Hidden Technical Debt in Machine Learning Systems</title><link href="https://nan0silver.github.io/projectdiary/2025-08-17-diary/" rel="alternate" type="text/html" title="[친구하자] Hidden Technical Debt in Machine Learning Systems" /><published>2025-08-17T00:00:00+00:00</published><updated>2025-08-25T06:23:33+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-08-17-diary/"><![CDATA[<ul>
  <li><a href="#1-오늘-읽은-내용-요약">1. 오늘 읽은 내용 요약</a></li>
  <li><a href="#2-나에게-필요했던-이유--친구하자-적용-사례">2. 나에게 필요했던 이유 — <strong>친구하자</strong> 적용 사례</a></li>
  <li><a href="#3-느낀-점--인사이트">3. 느낀 점 &amp; 인사이트</a></li>
  <li><a href="#4-다음-액션-아이템">4. 다음 액션 아이템</a></li>
  <li><a href="#-핵심-요약">💡 핵심 요약</a></li>
</ul>

<hr />

<blockquote>
  <p>이번에는 서울 AI 허브 특강을 듣다가 알게 된 ML관련 논문을 읽고 지금 하고있는 “친구하자” 프로젝트의 어떤 부분에서 도움을 받을 수 있을지에 대해 알아보았다.</p>
</blockquote>

<p><strong>논문</strong>: [Hidden Technical Debt in Machine Learning Systems (NIPS 2015)]
<strong>작성자</strong>: D. Sculley외 10인 (Google, Inc.)</p>

<ul>
  <li><a href="https://nan0silver.github.io/til/2025-08-16-til/">논문에 대한 TIL 작성</a></li>
</ul>

<hr />

<h3 id="1-오늘-읽은-내용-요약">1. 오늘 읽은 내용 요약</h3>

<blockquote>
  <p><strong>핵심 주제</strong>: 머신러닝 시스템에서는 단순히 모델 성능을 높이는 것보다 <strong>데이터 흐름 관리, 파이프라인 구조, 의존성 관리</strong>가 더 중요하다는 점을 강조.</p>
</blockquote>

<ul>
  <li>
    <p><strong>기술 부채(Technical Debt)</strong></p>

    <ul>
      <li>ML 시스템은 빠르게 개발 가능하지만, 장기 유지보수 비용은 전통적인 소프트웨어보다 훨씬 높음.</li>
      <li>숨은 부채는 코드 수준이 아니라 <strong>시스템 수준</strong>에서 쌓이기 때문에 발견하기 어렵고 비용이 급격히 커짐.</li>
    </ul>
  </li>
  <li>
    <p><strong>주요 이슈와 원인</strong></p>

    <ol>
      <li>
        <p><strong>CACE 원칙</strong> <em>(Changing Anything Changes Everything)</em></p>

        <ul>
          <li>피처, 하이퍼파라미터, 데이터셋 중 하나만 바꿔도 전체 모델 성능이 예측 불가능하게 바뀜.</li>
        </ul>
      </li>
      <li>
        <p><strong>데이터 의존성</strong></p>

        <ul>
          <li>불안정한 입력 신호, 중복 피처, 과도한 데이터 연결은 장애 가능성을 높임.</li>
        </ul>
      </li>
      <li>
        <p><strong>Pipeline Jungle</strong></p>

        <ul>
          <li>데이터 전처리 단계가 쌓이면 유지보수가 어려워지고 에러 포인트가 증가.</li>
        </ul>
      </li>
      <li>
        <p><strong>모델 간 숨은 피드백 루프</strong></p>

        <ul>
          <li>하나의 모델 변경이 다른 시스템의 입력 데이터에 간접적으로 영향을 미침.</li>
        </ul>
      </li>
      <li>
        <p><strong>실시간 모니터링 부족</strong></p>

        <ul>
          <li>모델 업데이트 후 이상 징후를 늦게 발견하면 복구 비용이 기하급수적으로 커짐.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="2-나에게-필요했던-이유--친구하자-적용-사례">2. 나에게 필요했던 이유 — <strong>친구하자</strong> 적용 사례</h3>

<h4 id="1-발화화행-분석-모델-파이프라인-설계-시-고려할-점">(1) 발화/화행 분석 모델 파이프라인 설계 시 고려할 점</h4>

<ul>
  <li>
    <p><strong>현재 시나리오</strong></p>

    <ul>
      <li>통화 음성 → 스펙트로그램 변환 → 감정/화행 분석 모델 → 사용자 인지 지표 산출</li>
      <li>향후 <strong>AI 기반 발화 분석 모델</strong>을 도입해 지남력, 유창성, 어휘력, 주의집중력 등의 점수를 자동 산출할 계획.</li>
    </ul>
  </li>
  <li>
    <p><strong>적용 포인트</strong></p>

    <ul>
      <li>
        <p><strong>데이터 버저닝 필요성</strong></p>

        <ul>
          <li>예: 스펙트로그램 생성 방식을 바꿀 경우, 기존 학습 데이터와 호환성이 깨질 수 있음.</li>
          <li>→ DVC나 MLflow 같은 도구를 도입해 음성 데이터, 스펙트로그램, 학습된 모델을 <strong>버전 단위로 관리</strong>해야 함.</li>
        </ul>
      </li>
      <li>
        <p><strong>Pipeline Jungle 방지</strong></p>

        <ul>
          <li>현재는 음성 → 텍스트 → 감정 점수 산출이라는 단순 구조지만, 향후 발화 분석, 화행 분석, 치매 위험 예측까지 추가되면 <strong>중간 파이프라인이 폭발적으로 늘어남</strong>.</li>
          <li>→ 파이프라인을 계층적으로 나누고, 데이터 입출력 포맷을 표준화하는 설계가 필요.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="2-실시간-통화-분석-시스템-설계-시-고려할-점">(2) 실시간 통화 분석 시스템 설계 시 고려할 점</h4>

<ul>
  <li>
    <p><strong>현재 시나리오</strong></p>

    <ul>
      <li>WebRTC 기반 통화 → 통화 녹음 → 분석 API 호출 → 사용자/보호자 알림</li>
      <li>향후 실시간 음성 분석을 통해 <strong>통화 중 인지 저하, 우울감 등 감지</strong> 시 알림을 제공하는 기능을 목표.</li>
    </ul>
  </li>
  <li>
    <p><strong>적용 포인트</strong></p>

    <ul>
      <li>
        <p><strong>실시간 피처 드리프트 모니터링</strong></p>

        <ul>
          <li>예: 고령 사용자들의 발화 속도나 어휘 다양성이 계절, 이벤트에 따라 달라질 수 있음.</li>
          <li>→ 실시간으로 <strong>데이터 분포 변화를 감시</strong>해 학습 데이터와 입력 데이터의 괴리를 탐지하는 모니터링 필요.</li>
        </ul>
      </li>
      <li>
        <p><strong>모델 업데이트 전략(A/B Testing)</strong></p>

        <ul>
          <li>새로운 화행 분석 모델을 도입할 때, <strong>전체 사용자에게 바로 적용</strong>하면 위험.</li>
          <li>→ 전체 롤아웃 전 <strong>소규모 샘플 그룹</strong>에서 먼저 성능을 검증하고, 이상 징후 시 자동 롤백하는 시스템 필요.</li>
        </ul>
      </li>
      <li>
        <p><strong>경계 침식 문제 해결</strong></p>

        <ul>
          <li>통화 감정 분석 결과가 <strong>다른 추천 시스템</strong>(예: 대화 주제 추천)에도 입력될 경우, 모델 간 강한 의존성이 생김.</li>
          <li>→ API 수준에서 <strong>의존성 추적 및 제어</strong> 기능을 설계해 시스템 분리를 유지해야 함.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="3-느낀-점--인사이트">3. 느낀 점 &amp; 인사이트</h3>

<ul>
  <li>발화/화행 분석 모델처럼 <strong>실시간 데이터 기반 ML 시스템</strong>은 전통적인 오프라인 예측 모델보다 훨씬 <strong>기술 부채 리스크</strong>가 큼.</li>
  <li>
    <p>특히 이 논문에서 제시한 <strong>CACE 원칙</strong>을 그대로 체감할 수 있음:</p>

    <blockquote>
      <p>“스펙트로그램 해상도만 살짝 바꿨는데 전체 감정 분석 성능이 붕괴될 수도 있다.”</p>
    </blockquote>
  </li>
  <li>결론적으로, <strong>친구하자</strong>에서는 모델 성능 향상보다 <strong>데이터/파이프라인 안정성</strong>을 우선시해야 함.</li>
  <li><strong>모델 버저닝</strong>, <strong>실시간 모니터링</strong>, <strong>A/B 테스트</strong>, <strong>피처 관리 자동화</strong>는 반드시 초기에 설계해야 장기 비용을 줄일 수 있음.</li>
</ul>

<hr />

<h3 id="4-다음-액션-아이템">4. 다음 액션 아이템</h3>

<ul>
  <li><strong>DVC/MLflow</strong> 도입 → 발화/화행 분석 모델, 음성 데이터, 스펙트로그램 버전 관리</li>
  <li>데이터 파이프라인 표준화 → 입력/출력 포맷 및 계층 구조 설계</li>
  <li><strong>실시간 데이터 분포 모니터링</strong> 및 알림 시스템 구축</li>
  <li><strong>A/B 테스트 기반 모델 롤아웃 전략</strong> 설계 및 자동 롤백 기능 구현</li>
  <li>서비스 아키텍처에 <strong>모델 간 의존성 추적 기능</strong> 추가</li>
</ul>

<hr />

<h3 id="-핵심-요약">💡 핵심 요약</h3>

<blockquote>
  <p><strong>친구하자</strong>의 실시간 발화/화행 분석 시스템에서 기술 부채를 최소화하려면:</p>

  <p><strong>버전 관리</strong>: 데이터·모델·파이프라인을 모두 버전 단위로 관리
<strong>모니터링</strong>: 실시간 데이터 드리프트 및 예측 이상 징후 자동 탐지
<strong>분리 설계</strong>: 모델 간 강한 의존성 최소화
<strong>안전한 업데이트</strong>: A/B 테스트 기반 롤아웃 + 자동 롤백 전략 필수</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[친구하자 프로젝트 개발 중 논문 내용을 읽고 프로젝트 개발을 구체화한 내용입니다.]]></summary></entry><entry><title type="html">[TIL] Hidden Technical Debt in Machine Learning Systems</title><link href="https://nan0silver.github.io/til/2025-08-16-til/" rel="alternate" type="text/html" title="[TIL] Hidden Technical Debt in Machine Learning Systems" /><published>2025-08-16T00:00:00+00:00</published><updated>2025-08-16T00:36:49+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-08-16-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
📅 <strong>작성일</strong>: 2025-08-16<br />
🔄 <strong>최종 수정</strong>: 2025년 08월 16일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<p><strong>논문</strong>: [Hidden Technical Debt in Machine Learning Systems (NIPS 2015)]
<strong>작성자</strong>: D. Sculley외 10인 (Google, Inc.)</p>

<h3 id="1-오늘-읽은-내용-요약">1. 오늘 읽은 내용 요약</h3>

<blockquote>
  <p><strong>핵심 주제</strong>: 머신러닝 시스템에서 발생하는 <strong>숨은 기술 부채(hidden technical debt)</strong> 문제를 설명하고, 시스템 설계 단계에서 고려해야 할 위험 요소를 다룸.</p>
</blockquote>

<ul>
  <li>
    <p><strong>기술 부채(Technical Debt) 개념</strong></p>

    <ul>
      <li>ML 시스템은 개발과 배포는 빠르지만 <strong>유지보수가 어렵고 비용이 많이 드는 구조적 특성</strong>을 가짐.</li>
      <li>코드 수준의 문제보다 <strong>시스템 전반에서의 복잡성</strong>이 더 큰 원인.</li>
      <li>숨은 부채는 누적되며, 발견 시에는 비용이 급격히 커짐.</li>
    </ul>
  </li>
  <li>
    <p><strong>ML 시스템에서 기술 부채가 생기는 주요 원인</strong></p>

    <ol>
      <li><strong>경계 침식(Boundary Erosion)</strong>: 모델이 여러 신호를 섞어 사용하기 때문에 한 부분을 바꾸면 전체가 변함 (<strong>CACE 원칙: Changing Anything Changes Everything</strong>).</li>
      <li><strong>데이터 의존성(Data Dependencies)</strong>: 불안정하거나 과도한 데이터 의존성으로 인해 작은 변화가 큰 장애를 일으킴.</li>
      <li><strong>피드백 루프(Feedback Loops)</strong>: 모델이 자신의 입력 데이터를 간접적으로 바꾸는 경우 → 예측 정확도에 예기치 못한 영향을 미침.</li>
      <li>
        <p><strong>시스템 안티패턴(System Anti-Patterns)</strong>:</p>

        <ul>
          <li><strong>Glue Code</strong>: 다양한 패키지를 연결하는 코드가 과도해져 유지보수 비용 증가.</li>
          <li><strong>Pipeline Jungles</strong>: 데이터 처리 파이프라인이 점점 복잡해져 관리가 어려워짐.</li>
          <li><strong>Dead Experimental Codepaths</strong>: 실험을 위해 만든 코드가 방치되어 예기치 못한 오류를 유발.</li>
        </ul>
      </li>
      <li><strong>구성(Configuration) 부채</strong>: 피처, 하이퍼파라미터, 로깅 설정 등 방대한 설정이 누적되어 관리가 어려워짐.</li>
      <li><strong>외부 세계 변화</strong>: 환경, 사용자 행동, 시장 조건의 변화가 모델 성능에 직접적인 영향을 미침.</li>
    </ol>
  </li>
  <li>
    <p><strong>해결 방안</strong></p>

    <ul>
      <li>데이터 및 모델 <strong>의존성 관리 도구</strong> 구축 (버저닝, 자동화된 피처 관리 등).</li>
      <li><strong>모니터링 &amp; 자동화 대응</strong> 필수.</li>
      <li>실험적 코드 정리 및 중복 제거.</li>
      <li>연구팀과 엔지니어링팀 간 <strong>하이브리드 협업 구조</strong> 필요.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="2-나에게-필요했던-이유">2. 나에게 필요했던 이유</h3>

<blockquote>
  <p>이에 대한 자세한 내용은 (깃블로그)[링크]에서 볼 수 있습니다.</p>
</blockquote>

<ul>
  <li>
    <p>현재 진행 중인 <strong>AI 기반 발화/화행 분석 모델</strong>과 <strong>친구하자</strong> 서비스의 ML 시스템에 적용할 수 있음:</p>

    <ul>
      <li><strong>데이터 버저닝</strong> 필요성 → 감정 분석 모델 학습 시 <strong>피처 변경</strong>이 있을 경우 예기치 못한 성능 저하 방지.</li>
      <li><strong>파이프라인 관리</strong> 중요성 → 통화 음성 데이터 → 스펙트로그램 변환 → 감정 분석 → 저장 단계에서 발생할 수 있는 <strong>Pipeline Jungle</strong> 방지.</li>
      <li><strong>모델 업데이트 전략</strong> → 모델 개선이 실제 서비스에서 <strong>사용자 경험을 악화시킬 수 있는 위험</strong> 방지 필요.</li>
      <li><strong>실시간 모니터링</strong> 필요 → 모델 성능 저하나 데이터 분포 변화에 빠르게 대응 가능해야 함.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="3-느낀-점--인사이트">3. 느낀 점 &amp; 인사이트</h3>

<ul>
  <li>단순히 모델 성능을 높이는 것보다, <strong>시스템 전반의 유지보수성</strong>과 <strong>데이터 흐름 관리</strong>가 훨씬 중요하다는 걸 깨달음.</li>
  <li>
    <p>특히 <strong>CACE 원칙</strong>은 실무에서 체감할 가능성이 큼:</p>

    <blockquote>
      <p>“하나 바꾸면 다 바뀐다” → 모델 입력 피처 변경 시 전체 시스템의 예측 성능이 흔들릴 수 있음.</p>
    </blockquote>
  </li>
  <li>앞으로 <strong>AI 모델 성능 향상보다 안정적인 시스템 아키텍처 설계</strong>에 우선순위를 둬야겠다고 느낌.</li>
  <li>
    <p><strong>친구하자</strong> 서비스에서도:</p>

    <ul>
      <li>데이터 파이프라인 설계를 단순하게 유지.</li>
      <li>모델을 <strong>엔드 투 엔드로 한 번에 학습</strong>하는 방법과 <strong>서브모델 앙상블 방식</strong>의 트레이드오프를 고려해야 함.</li>
      <li>장기적으로 <strong>모델 버저닝 + 모니터링 시스템</strong>을 도입해 기술 부채를 최소화할 필요 있음.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="4-다음-액션-아이템">4. 다음 액션 아이템</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />데이터 버저닝 전략 조사 및 설계 (e.g., DVC, MLflow)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />음성 데이터 파이프라인 단순화 → Glue Code 최소화</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />실시간 성능 모니터링 및 알림 시스템 설계</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />모델 업데이트 시 A/B 테스트 기반 롤아웃 전략 도입</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><category term="Git" /><category term="ML" /><summary type="html"><![CDATA[2025-08-16 TIL]]></summary></entry><entry><title type="html">[Etc] FastAPI vs Flask: Python 백엔드 프레임워크 비교</title><link href="https://nan0silver.github.io/miscellaneous/til/2025-07-20-flask-fastAPI/" rel="alternate" type="text/html" title="[Etc] FastAPI vs Flask: Python 백엔드 프레임워크 비교" /><published>2025-07-20T00:00:00+00:00</published><updated>2025-07-23T16:30:00+00:00</updated><id>https://nan0silver.github.io/miscellaneous/til/flask-fastAPI</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/til/2025-07-20-flask-fastAPI/"><![CDATA[<ul>
  <li><a href="#-새롭게-배운-것">새롭게 배운 것</a></li>
  <li><a href="#-오늘의-문제-상황--해결-과정">오늘의 문제 상황 &amp; 해결 과정</a></li>
  <li><a href="#-pydantic이란">Pydantic이란?</a></li>
  <li><a href="#-spring-boot-dto와-pydantic의-비교">Spring Boot DTO와 Pydantic의 비교</a></li>
  <li><a href="#-느낀-점">느낀 점</a></li>
</ul>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<ul>
  <li>Python 백엔드 프레임워크인 <strong>FastAPI</strong>와 <strong>Flask</strong>를 비교해보았다.</li>
  <li>두 프레임워크 모두 경량 웹 서버를 빠르게 개발할 수 있도록 도와주지만, 철학과 기능 면에서 차이가 존재한다.</li>
  <li>주요 비교 항목: 비동기 처리, 타입 힌트 지원, 성능, 문서 자동화, 커뮤니티 및 생태계 등</li>
</ul>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th><strong>FastAPI</strong></th>
      <th><strong>Flask</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>출시 연도</strong></td>
      <td>2018</td>
      <td>2010</td>
    </tr>
    <tr>
      <td><strong>비동기 지원</strong></td>
      <td><code class="language-plaintext highlighter-rouge">async/await</code> 기반 비동기 처리 완전 지원</td>
      <td>기본은 동기, 비동기 처리는 별도 패키지 필요</td>
    </tr>
    <tr>
      <td><strong>타입 힌트</strong></td>
      <td>필수적으로 사용하며, 자동 문서화 및 검증에 활용</td>
      <td>선택적 사용, 검증은 외부 라이브러리 의존</td>
    </tr>
    <tr>
      <td><strong>문서 자동화</strong></td>
      <td>Swagger UI 및 Redoc 자동 생성</td>
      <td>기본 제공 없음 (Flasgger 등으로 보완)</td>
    </tr>
    <tr>
      <td><strong>성능</strong></td>
      <td>매우 빠름 (Starlette 기반, Uvicorn 활용)</td>
      <td>상대적으로 느림</td>
    </tr>
    <tr>
      <td><strong>러닝 커브</strong></td>
      <td>초기 진입 장벽이 다소 높음 (타입, Pydantic 등)</td>
      <td>매우 쉬운 진입, 학습 곡선 완만</td>
    </tr>
    <tr>
      <td><strong>커뮤니티</strong></td>
      <td>빠르게 성장 중</td>
      <td>매우 크고 안정적인 생태계</td>
    </tr>
    <tr>
      <td><strong>데이터 검증</strong></td>
      <td>Pydantic 기반의 자동 검증</td>
      <td>별도 유효성 검사 코드 필요</td>
    </tr>
    <tr>
      <td><strong>REST API 개발</strong></td>
      <td>RESTful 설계에 최적화</td>
      <td>자유도가 높음, 규칙이 느슨함</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-오늘의-문제-상황--해결-과정">🍎 오늘의 문제 상황 &amp; 해결 과정</h2>

<ul>
  <li>지금까지는 Flask의 간결함과 진입 장벽이 낮은 점이 마음에 들어 주로 Flask를 사용해왔다.</li>
  <li>하지만 이번에는 FastAPI를 직접 적용해보고 싶어 새 프로젝트에 도입해보았다.</li>
  <li>특히 <code class="language-plaintext highlighter-rouge">Pydantic</code> 모델이 처음엔 어렵게 느껴질까 걱정했지만, 막상 사용해보니 <strong>Spring Boot의 DTO와 매우 유사한 느낌</strong>이 들어 빠르게 익숙해졌다.</li>
  <li>타입 기반 구조와 자동 검증, 문서화 덕분에 프로젝트가 자연스럽게 구조화되고 개발 속도도 빨랐다.</li>
</ul>

<hr />

<h2 id="-pydantic이란">📌 Pydantic이란?</h2>

<ul>
  <li><strong>Pydantic</strong>은 FastAPI에서 입력/출력 데이터의 구조를 정의하고, 유효성을 검사하며, JSON 직렬화를 자동으로 처리하는 핵심 컴포넌트다.</li>
  <li>Python의 <strong>타입 힌트(type hint)</strong>를 기반으로 동작하며, <code class="language-plaintext highlighter-rouge">BaseModel</code>을 상속하여 필드와 제약 조건을 선언할 수 있다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(...,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">age</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">email</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div></div>

<ul>
  <li>위와 같이 작성하면, FastAPI는 요청 데이터가 이 조건을 만족하는지 자동으로 검증하고, Swagger 문서까지 자동 생성해준다.</li>
</ul>

<hr />

<h2 id="-spring-boot-dto와-pydantic의-비교">🔍 Spring Boot DTO와 Pydantic의 비교</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Spring Boot DTO</th>
      <th>FastAPI Pydantic Model</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>역할</strong></td>
      <td>요청/응답 객체 정의 + 유효성 검사</td>
      <td>요청/응답 객체 정의 + 유효성 검사</td>
    </tr>
    <tr>
      <td><strong>유효성 검사 도구</strong></td>
      <td>JSR 380 (e.g., <code class="language-plaintext highlighter-rouge">@NotNull</code>, <code class="language-plaintext highlighter-rouge">@Size</code>)</td>
      <td>Pydantic (<code class="language-plaintext highlighter-rouge">Field</code>, <code class="language-plaintext highlighter-rouge">validator</code>)</td>
    </tr>
    <tr>
      <td><strong>직렬화/역직렬화</strong></td>
      <td>Jackson 사용</td>
      <td>내장 기능으로 자동 처리</td>
    </tr>
    <tr>
      <td><strong>중첩 구조 지원</strong></td>
      <td>중첩 DTO 클래스</td>
      <td>중첩 <code class="language-plaintext highlighter-rouge">BaseModel</code>을 통한 자연스러운 처리</td>
    </tr>
    <tr>
      <td><strong>문서화 연동</strong></td>
      <td>Swagger/OpenAPI 설정 필요</td>
      <td>FastAPI에 자동 내장</td>
    </tr>
    <tr>
      <td><strong>확장성</strong></td>
      <td>Bean Validation 위주</td>
      <td>타입 변환, 커스텀 직렬화 등 더 다양한 기능 내장</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>결론적으로 <strong>Pydantic은 Spring의 DTO와 유사한 사용 경험을 제공하면서도</strong>, 그 이상의 기능(데이터 직렬화, 문서화, 타입 변환 등)을 하나의 모델에서 처리할 수 있다는 점에서 <strong>DTO + Validator + Mapper + Serializer의 통합체</strong>로 볼 수 있다.</p>
</blockquote>

<hr />

<h2 id="-느낀-점">🦄 느낀 점</h2>

<ul>
  <li>Flask는 여전히 빠른 개발과 간단한 구조를 원할 때 유용한 선택지다.</li>
  <li>반면 FastAPI는 프로젝트 구조를 더 명확히 하고, 자동화된 유효성 검사 및 문서화 기능까지 갖추고 있어 <strong>중·대형 규모 프로젝트나 협업 시에 훨씬 효율적</strong>이라는 점을 느꼈다.</li>
  <li>개인적으로는 Pydantic이 예상보다 익숙했고, Spring Boot의 DTO를 써본 경험이 FastAPI 적응에 큰 도움이 되었다.</li>
  <li>앞으로는 프로젝트의 성격에 따라 Flask와 FastAPI를 유연하게 선택하며, 각 도구의 장점을 상황에 맞게 활용할 계획이다.</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><category term="til" /><category term="TIL" /><category term="FastAPI" /><category term="Flask" /><category term="Backend" /><summary type="html"><![CDATA[2025-07-20 FastAPI vs Flask]]></summary></entry><entry><title type="html">[TIL] Jenkins vs GitHub Actions, IaaS vs PaaS vs SaaS</title><link href="https://nan0silver.github.io/til/2025-05-27-til/" rel="alternate" type="text/html" title="[TIL] Jenkins vs GitHub Actions, IaaS vs PaaS vs SaaS" /><published>2025-05-27T00:00:00+00:00</published><updated>2025-05-28T00:36:49+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-27-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/62">#62</a><br />
📅 <strong>작성일</strong>: 2025-05-27<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 28일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<ul>
  <li>AI Tech 2025 : AI 융합 비즈니스 개발 컨퍼런스 후기 작성 완료!
    <ul>
      <li><a href="https://silvernh.tistory.com/3">Tistory</a></li>
    </ul>
  </li>
</ul>

<h3 id="1️⃣-jenkins-vs-github-actions">1️⃣ <strong>Jenkins vs GitHub Actions</strong></h3>

<p>둘 다 **CI/CD(지속적 통합/지속적 배포)**를 자동화하는 도구다.
개발자가 코드를 push하면 <strong>자동으로 빌드하고, 테스트하고, 배포</strong>까지 해주는 파이프라인 역할.</p>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Jenkins</th>
      <th>GitHub Actions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>배포 방식</td>
      <td>직접 서버에 설치 (온프레미스, 클라우드)</td>
      <td>GitHub 내장 서비스 (클라우드 기반)</td>
    </tr>
    <tr>
      <td>파이프라인 구성</td>
      <td>Groovy 기반 DSL (Jenkinsfile)</td>
      <td>YAML 기반 설정 (.github/workflows/)</td>
    </tr>
    <tr>
      <td>UI/플러그인</td>
      <td>수많은 플러그인과 커스터마이징 가능</td>
      <td>GitHub 생태계에 최적화된 워크플로우</td>
    </tr>
    <tr>
      <td>설정 난이도</td>
      <td>다소 복잡 (서버 관리 필요)</td>
      <td>상대적으로 간단하고 빠른 적용 가능</td>
    </tr>
    <tr>
      <td>장점</td>
      <td>유연한 환경 설정, 다양한 툴 연동 가능</td>
      <td>GitHub와 완벽하게 통합, 설정이 간단</td>
    </tr>
    <tr>
      <td>단점</td>
      <td>서버 유지보수 필요, 러닝커브 있음</td>
      <td>GitHub 내에서만 동작 (GitLab, Bitbucket X)</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>✅ GitHub Actions는 빠르게 CI/CD를 도입하고 싶은 팀에 좋고,
✅ Jenkins는 복잡한 환경이나 내부망에서의 CI/CD가 필요할 때 적합하다.</p>
</blockquote>

<p>—å</p>

<h3 id="-간단-예시--github-actions">🧪 간단 예시 – GitHub Actions</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># .github/workflows/deploy.yml</span>
<span class="na">name</span><span class="pi">:</span> <span class="s">Build and Deploy</span>

<span class="na">on</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">push</span><span class="pi">]</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>
      <span class="pi">-</span> <span class="na">run</span><span class="pi">:</span> <span class="s">./gradlew build</span>
</code></pre></div></div>

<hr />

<h3 id="2️⃣-iaas-vs-paas-vs-saas">2️⃣ <strong>IaaS vs PaaS vs SaaS</strong></h3>

<p>클라우드 서비스 모델을 구분할 때 자주 등장하는 세 가지 개념.
“내가 어디까지 책임지고, 어디서부터는 제공자가 해주는가?”가 핵심.</p>

<h4 id="-개념-요약">✅ 개념 요약</h4>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>설명</th>
      <th>예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>IaaS (Infrastructure as a Service)</td>
      <td>인프라만 제공받고, OS부터 직접 설치</td>
      <td>AWS EC2, Google Compute Engine</td>
    </tr>
    <tr>
      <td>PaaS (Platform as a Service)</td>
      <td>실행 환경까지 제공, 앱 코드만 올리면 됨</td>
      <td>Heroku, Google App Engine, Render</td>
    </tr>
    <tr>
      <td>SaaS (Software as a Service)</td>
      <td>소프트웨어 완제품 사용</td>
      <td>Gmail, Notion, Slack</td>
    </tr>
  </tbody>
</table>

<h4 id="-비교-예시">✅ 비교 예시</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>IaaS</th>
      <th>PaaS</th>
      <th>SaaS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>서버 관리</td>
      <td>내가 함</td>
      <td>클라우드가 함</td>
      <td>필요 없음</td>
    </tr>
    <tr>
      <td>개발 유연성</td>
      <td>높음</td>
      <td>중간</td>
      <td>거의 없음</td>
    </tr>
    <tr>
      <td>배포 편의성</td>
      <td>낮음 (직접 설정)</td>
      <td>높음 (코드만 배포)</td>
      <td>매우 높음 (사용만 하면 됨)</td>
    </tr>
    <tr>
      <td>대상 사용자</td>
      <td>인프라 엔지니어, DevOps</td>
      <td>백엔드 개발자</td>
      <td>일반 사용자, 마케터 등</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-요약-정리">🧠 요약 정리</h3>

<table>
  <thead>
    <tr>
      <th>질문</th>
      <th>답변</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Jenkins랑 GitHub Actions 중 뭐가 더 쉽지?</td>
      <td>GitHub Actions! 설정이 YAML이고 GitHub랑 연동이 편함</td>
    </tr>
    <tr>
      <td>IaaS는 언제 써야 해?</td>
      <td>서버에 대해 완전히 커스터마이징이 필요할 때</td>
    </tr>
    <tr>
      <td>SaaS는 어떤 거야?</td>
      <td>구글 드라이브, 노션, 슬랙처럼 바로 쓰는 서비스</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>오늘의 핵심:
✅ CI/CD 도구는 “내가 코드를 어떻게 자동화할지”에 따라 고르고,
✅ 클라우드 서비스 모델은 “어디까지 직접 관리할지”에 따라 고른다.</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><category term="Git" /><category term="DevOps" /><category term="Cloud" /><summary type="html"><![CDATA[2025-05-27 TIL]]></summary></entry><entry><title type="html">[TIL] Nginx, 리버스 프록시, 로드 밸런서</title><link href="https://nan0silver.github.io/til/2025-05-24-til/" rel="alternate" type="text/html" title="[TIL] Nginx, 리버스 프록시, 로드 밸런서" /><published>2025-05-24T00:00:00+00:00</published><updated>2025-05-27T05:35:43+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-24-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/61">#61</a><br />
📅 <strong>작성일</strong>: 2025-05-24<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-nginx란">1️⃣ <strong>Nginx란?</strong></h3>

<ul>
  <li>**Nginx(엔진엑스)**는 고성능 웹 서버 소프트웨어다.</li>
  <li>원래는 정적 콘텐츠 제공을 위한 웹 서버였지만, 현재는 <strong>리버스 프록시</strong>, <strong>로드 밸런서</strong>, <strong>API Gateway</strong>, <strong>캐시 서버</strong> 등 다용도로 활용된다.</li>
</ul>

<hr />

<h3 id="-nginx의-주요-기능">✅ Nginx의 주요 기능</h3>

<table>
  <thead>
    <tr>
      <th>기능</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>웹 서버</td>
      <td>HTML, CSS, JS 같은 <strong>정적 파일 제공</strong></td>
    </tr>
    <tr>
      <td>리버스 프록시</td>
      <td>클라이언트 요청을 <strong>내부 서버에 전달</strong></td>
    </tr>
    <tr>
      <td>로드 밸런서</td>
      <td>여러 서버에 트래픽을 <strong>분산</strong>하여 처리</td>
    </tr>
    <tr>
      <td>캐시 서버</td>
      <td>응답을 <strong>캐싱</strong>해 성능 향상</td>
    </tr>
    <tr>
      <td>SSL 종단 처리</td>
      <td>HTTPS 인증서 처리 (Let’s Encrypt 등과 연동)</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-리버스-프록시란">🔄 리버스 프록시란?</h3>

<ul>
  <li>클라이언트는 Nginx에 요청을 보내고, Nginx는 **백엔드 서버(Apache, Spring, Node 등)**에 요청을 전달한 후 응답을 다시 클라이언트에 전송한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Client] → [Nginx] → [Spring Server]
</code></pre></div></div>

<ul>
  <li>보안, 로드 밸런싱, 서버 분리 등 다양한 이유로 활용됨</li>
</ul>

<hr />

<h3 id="️-로드-밸런서">⚖️ 로드 밸런서</h3>

<ul>
  <li>요청을 <strong>여러 서버에 고르게 분산</strong>시켜 트래픽 집중을 막고 <strong>가용성</strong>을 높임</li>
</ul>

<h4 id="nginx에서-로드-밸런싱-구성-예시">Nginx에서 로드 밸런싱 구성 예시:</h4>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">upstream</span> <span class="s">backend</span> <span class="p">{</span>
    <span class="kn">server</span> <span class="s">backend1.example.com</span><span class="p">;</span>
    <span class="kn">server</span> <span class="s">backend2.example.com</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://backend</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">upstream</code> 블록을 통해 백엔드 서버를 그룹핑하고, Nginx가 자동으로 라운드로빈 방식으로 분산 처리</p>
</blockquote>

<hr />

<h3 id="-정적-파일-서버로의-활용">📦 정적 파일 서버로의 활용</h3>

<ul>
  <li>HTML/CSS/JS 파일을 빠르게 서빙할 수 있음</li>
  <li>WAS(Spring, Node 등)에서 정적 리소스를 분리하면 서버 부하를 줄일 수 있음</li>
</ul>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">root</span> <span class="n">/usr/share/nginx/html</span><span class="p">;</span>
        <span class="kn">index</span> <span class="s">index.html</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="-https-설정">🔒 HTTPS 설정</h3>

<ul>
  <li>Let’s Encrypt와 Certbot을 이용해 무료 SSL 인증서 발급 가능</li>
  <li>HTTPS로 종단 보안(SSL Termination)을 적용하여 <strong>보안 강화</strong></li>
</ul>

<hr />

<h2 id="-함께-알아두면-좋은-심화-키워드">🧠 함께 알아두면 좋은 심화 키워드</h2>

<table>
  <thead>
    <tr>
      <th>키워드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>리버스 프록시</td>
      <td>Nginx가 중간에 서서 내부 서버 대신 요청 응답 처리</td>
    </tr>
    <tr>
      <td>포워드 프록시</td>
      <td>사용자의 요청을 <strong>외부로 보낼 때</strong> 중개하는 프록시</td>
    </tr>
    <tr>
      <td>CDN (Content Delivery Network)</td>
      <td>정적 리소스를 전 세계에 분산 저장하여 빠르게 전송</td>
    </tr>
    <tr>
      <td>캐싱 정책</td>
      <td><code class="language-plaintext highlighter-rouge">Cache-Control</code>, <code class="language-plaintext highlighter-rouge">ETag</code>를 이용한 정적 자원 캐싱</td>
    </tr>
    <tr>
      <td>Blue-Green Deployment</td>
      <td>Nginx로 배포 서버를 스위칭하여 무중단 배포 실현</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="️-오늘의-요약">✍️ 오늘의 요약</h2>

<ul>
  <li>Nginx는 단순 웹 서버 그 이상으로, <strong>프론트와 백엔드 사이의 허브 역할</strong>을 한다.</li>
  <li>리버스 프록시, 로드 밸런서, 정적 파일 서버, SSL 처리까지 담당할 수 있는 멀티플레이어</li>
  <li>실제 운영 환경에서는 <strong>Spring Boot와 Nginx 연동</strong>, <strong>HTTPS 적용</strong>, <strong>EC2 배포 시 로드밸런싱 구성</strong> 등을 할 수 있도록 익숙해져야 한다</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-24 TIL]]></summary></entry><entry><title type="html">[TIL] Grafana &amp;amp; Prometheus, Rolling Policy, 시계열 메트릭</title><link href="https://nan0silver.github.io/til/2025-05-23-til/" rel="alternate" type="text/html" title="[TIL] Grafana &amp;amp; Prometheus, Rolling Policy, 시계열 메트릭" /><published>2025-05-23T00:00:00+00:00</published><updated>2025-05-27T05:34:31+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-23-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/60">#60</a><br />
📅 <strong>작성일</strong>: 2025-05-23<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-grafana--prometheus--시계열-메트릭-시각화-도구">1️⃣ <strong>Grafana &amp; Prometheus – 시계열 메트릭 시각화 도구</strong></h3>

<h4 id="-prometheus">📊 Prometheus</h4>

<ul>
  <li>CNCF(Cloud Native Computing Foundation)에서 관리하는 <strong>시계열 메트릭 수집 도구</strong></li>
  <li>주로 <strong>인프라/애플리케이션 성능 모니터링</strong>에 사용됨</li>
  <li><strong>Pull 방식</strong>으로 타겟 서버의 메트릭을 주기적으로 수집함</li>
  <li>메트릭 쿼리 언어: <strong>PromQL</strong></li>
  <li>내장된 시계열 DB에 메트릭 저장</li>
</ul>

<blockquote>
  <p>예시 메트릭:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http_requests_total{method="GET", status="200"} 1523
cpu_usage_seconds_total{core="1"} 82.3
</code></pre></div></div>

<h4 id="-grafana">📈 Grafana</h4>

<ul>
  <li><strong>Prometheus 등의 시계열 데이터 소스를 시각화하는 대시보드 도구</strong></li>
  <li>사용자가 커스터마이징 가능한 <strong>대시보드/그래프/알람</strong>을 만들 수 있음</li>
  <li>Prometheus 외에도 <strong>Loki(로그), InfluxDB, MySQL, Elasticsearch 등 다양한 소스</strong>와 연동 가능</li>
  <li>
    <p>주요 사용 예:</p>

    <ul>
      <li>CPU/메모리/디스크 사용률 실시간 모니터링</li>
      <li>서비스 요청 응답 시간 추적</li>
      <li>메트릭 기반 알림 설정 (ex. 5분간 에러율이 5% 넘으면 슬랙 알림)</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="-grafana--prometheus--devops-핵심-콤보">🧩 Grafana + Prometheus = DevOps 핵심 콤보</h3>

<table>
  <thead>
    <tr>
      <th>도구</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Prometheus</td>
      <td>메트릭 수집 및 저장</td>
    </tr>
    <tr>
      <td>Grafana</td>
      <td>메트릭 시각화 및 알람</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>두 도구는 함께 사용할 때 진가를 발휘한다.
Prometheus가 메트릭 데이터를 모으고, Grafana가 이를 시각적으로 표현해준다.</p>
</blockquote>

<hr />

<h3 id="2️⃣-rolling-policy-로그-롤링-정책">2️⃣ <strong>Rolling Policy (로그 롤링 정책)</strong></h3>

<h4 id="-개념">🧾 개념</h4>

<ul>
  <li>로그 파일이 커지거나 오래되었을 때, <strong>자동으로 새로운 파일로 교체하거나 백업</strong>하는 정책</li>
  <li>로그 관리를 자동화해서 디스크 과부하를 방지하고, 오래된 로그를 보관하거나 삭제할 수 있게 해줌</li>
</ul>

<h4 id="-적용-예--logback-springxml-예시">📁 적용 예 – <code class="language-plaintext highlighter-rouge">logback-spring.xml</code> 예시:</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;rollingPolicy</span> <span class="na">class=</span><span class="s">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;fileNamePattern&gt;</span>logs/app-%d{yyyy-MM-dd}.log<span class="nt">&lt;/fileNamePattern&gt;</span>
    <span class="nt">&lt;maxHistory&gt;</span>30<span class="nt">&lt;/maxHistory&gt;</span> <span class="c">&lt;!-- 30일간 보관 --&gt;</span>
<span class="nt">&lt;/rollingPolicy&gt;</span>
</code></pre></div></div>

<h4 id="️-주요-타입">🎛️ 주요 타입</h4>

<table>
  <thead>
    <tr>
      <th>정책 유형</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TimeBasedRollingPolicy</td>
      <td>날짜별로 로그 파일 분리 (<code class="language-plaintext highlighter-rouge">app-2025-05-14.log</code>)</td>
    </tr>
    <tr>
      <td>SizeBasedTriggeringPolicy</td>
      <td>특정 크기 초과 시 새로운 파일 생성 (<code class="language-plaintext highlighter-rouge">app.log.1</code>, <code class="language-plaintext highlighter-rouge">.2</code>…)</td>
    </tr>
    <tr>
      <td>FixedWindowRollingPolicy</td>
      <td>번호 기반 순환 롤링 (<code class="language-plaintext highlighter-rouge">app.1.log</code>, <code class="language-plaintext highlighter-rouge">app.2.log</code>)</td>
    </tr>
  </tbody>
</table>

<h4 id="-왜-중요한가">🚧 왜 중요한가?</h4>

<ul>
  <li>로그 파일이 무한히 커지지 않도록 제어</li>
  <li>백업 및 운영에 필요한 로그만 유지 가능</li>
  <li>ELK/EFK 스택과 연동할 때도 파일 기반 로그를 안정적으로 관리</li>
</ul>

<blockquote>
  <p>정리하자면, **“로그를 무한정 쌓지 말고, 잘라서 보관하고, 오래된 건 지우자!”**는 개념이다.</p>
</blockquote>

<hr />

<h3 id="-오늘의-요약">📌 오늘의 요약</h3>

<table>
  <thead>
    <tr>
      <th>개념</th>
      <th>핵심 기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Prometheus</td>
      <td>메트릭 수집 및 저장 (시계열 DB)</td>
    </tr>
    <tr>
      <td>Grafana</td>
      <td>메트릭 시각화 및 알림</td>
    </tr>
    <tr>
      <td>Rolling Policy</td>
      <td>로그 용량/시간 기준 자동 분할 및 관리</td>
    </tr>
  </tbody>
</table>

<h3 id="3️⃣--시계열-메트릭time-series-metrics이란">3️⃣ 🕐 시계열 메트릭(Time Series Metrics)이란?</h3>

<ul>
  <li><strong>시간(Time)</strong> + <strong>값(Value)</strong> 이 쌍으로 구성된 데이터</li>
  <li>특정 지표가 <strong>시간에 따라 어떻게 변하는지</strong>를 보여줌</li>
</ul>

<h4 id="-예시">📊 예시:</h4>

<table>
  <thead>
    <tr>
      <th>시간</th>
      <th>CPU 사용률 (%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2025-05-14 10:00:00</td>
      <td>30</td>
    </tr>
    <tr>
      <td>2025-05-14 10:01:00</td>
      <td>35</td>
    </tr>
    <tr>
      <td>2025-05-14 10:02:00</td>
      <td>70</td>
    </tr>
  </tbody>
</table>

<p>이처럼 “시간에 따른 수치 변화”를 기록한 데이터가 바로 <strong>시계열 메트릭</strong></p>

<hr />

<h4 id="-시계열-메트릭-수집-도구란">📦 시계열 메트릭 수집 도구란?</h4>

<blockquote>
  <p>이런 <strong>시간 기반 데이터</strong>를 <strong>자동으로 수집, 저장, 관리</strong>해주는 도구를 말합니다.</p>
</blockquote>

<ul>
  <li>대표적인 도구:
    <ul>
      <li><strong>Prometheus</strong></li>
      <li>InfluxDB</li>
      <li>Graphite</li>
      <li>OpenTSDB</li>
    </ul>
  </li>
</ul>

<p>이들은 서버나 애플리케이션에서 CPU, 메모리, 요청 수, 에러율 같은 수치를 <strong>주기적으로 수집</strong>해서 시계열 DB에 저장한다.</p>

<h4 id="️-예를-들어-prometheus는">🛠️ 예를 들어 Prometheus는?</h4>

<ul>
  <li>15초마다 모든 서버의 CPU 사용률, HTTP 요청 수 등을 수집</li>
  <li>내부에 <strong>시계열 전용 데이터베이스</strong>를 가지고 있어 시간 순서대로 저장</li>
  <li>나중에 Grafana 같은 도구로 꺾은선 그래프를 그릴 수 있음</li>
</ul>

<h4 id="-정리">📌 정리</h4>

<table>
  <thead>
    <tr>
      <th>용어</th>
      <th>의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>시계열 데이터</td>
      <td>시간에 따라 변화하는 수치 데이터 (예: CPU 70% → 50%)</td>
    </tr>
    <tr>
      <td>시계열 메트릭 도구</td>
      <td>시간 기반 데이터를 주기적으로 수집/저장하는 시스템</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>시계열 메트릭 도구는 결국 **“시간의 흐름에 따라 시스템이 어떻게 작동하고 있는지 보여주는 도구”**</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-23 TIL]]></summary></entry><entry><title type="html">[TIL] 메테리얼 디자인 vs 쿠퍼티노 디자인, Log vs Metrics, Structure…</title><link href="https://nan0silver.github.io/til/2025-05-22-til/" rel="alternate" type="text/html" title="[TIL] 메테리얼 디자인 vs 쿠퍼티노 디자인, Log vs Metrics, Structure…" /><published>2025-05-22T00:00:00+00:00</published><updated>2025-05-27T03:54:57+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-22-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/59">#59</a><br />
📅 <strong>작성일</strong>: 2025-05-22<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-메테리얼-디자인material-design-vs-쿠퍼티노-디자인cupertino-design">1️⃣ <strong>메테리얼 디자인(Material Design) vs 쿠퍼티노 디자인(Cupertino Design)</strong></h3>

<h4 id="-메테리얼-디자인-material-design">🎨 메테리얼 디자인 (Material Design)</h4>

<ul>
  <li>Google에서 만든 디자인 시스템</li>
  <li>Android 앱에서 기본적으로 사용되는 UI 가이드라인</li>
  <li>
    <p>특징:</p>

    <ul>
      <li>실제 종이처럼 동작하는 “표면” 개념 → <strong>레이어, 그림자, 깊이감</strong></li>
      <li><strong>굵은 색상, 명확한 애니메이션, 카드 UI</strong></li>
      <li>일관된 컴포넌트 구조 (Button, Dialog 등)</li>
      <li>다양한 화면 크기 및 접근성 고려가 잘 되어 있음</li>
    </ul>
  </li>
</ul>

<h4 id="-쿠퍼티노-디자인-cupertino-design">🍏 쿠퍼티노 디자인 (Cupertino Design)</h4>

<ul>
  <li>Apple이 만든 iOS용 디자인 철학</li>
  <li>Flutter에서는 <code class="language-plaintext highlighter-rouge">CupertinoWidget</code>으로 구현</li>
  <li>
    <p>특징:</p>

    <ul>
      <li><strong>심플하고 정갈한 UI</strong>, 얇은 폰트, 미니멀한 구성</li>
      <li>iOS의 네이티브한 느낌을 충실히 재현</li>
      <li>스크롤, 네비게이션, 토글 스위치 등에서 iOS 특유의 인터랙션 존재</li>
    </ul>
  </li>
</ul>

<h4 id="비교-요약">비교 요약:</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Material Design</th>
      <th>Cupertino Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>주요 플랫폼</td>
      <td>Android, Web, Desktop</td>
      <td>iOS</td>
    </tr>
    <tr>
      <td>디자인 철학</td>
      <td>종이+레이어+애니메이션</td>
      <td>단순함+미려함+일관성</td>
    </tr>
    <tr>
      <td>주요 사용 예</td>
      <td>Google 앱, Android 앱</td>
      <td>Apple 앱, iOS 앱</td>
    </tr>
    <tr>
      <td>Flutter 적용</td>
      <td><code class="language-plaintext highlighter-rouge">MaterialApp</code></td>
      <td><code class="language-plaintext highlighter-rouge">CupertinoApp</code></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>요약: Android 앱은 Material 위주, iOS는 Cupertino 스타일을 따르며, <strong>Flutter는 둘 다 지원</strong>해 플랫폼에 맞는 UI를 쉽게 만들 수 있다!</p>
</blockquote>

<hr />

<h3 id="2️⃣-log-vs-metrics">2️⃣ <strong>Log vs Metrics</strong></h3>

<p>백엔드/운영 환경에서 시스템 상태를 추적할 때 자주 쓰이는 두 가지 개념을 비교해 보았다.</p>

<h4 id="-로그-log">📄 로그 (Log)</h4>

<ul>
  <li>
    <p><strong>시간 순으로 발생한 이벤트 기록</strong></p>
  </li>
  <li>
    <p>보통 텍스트 기반이며, 문제가 발생했을 때 <strong>무슨 일이 있었는지</strong> 파악하는 데 유용</p>
  </li>
  <li>
    <p>예:</p>

    <ul>
      <li>사용자가 로그인에 실패했습니다.</li>
      <li>서버에서 500 에러가 발생했습니다.</li>
    </ul>
  </li>
  <li>
    <p>특징:</p>

    <ul>
      <li>구조화가 느슨함 (JSON 또는 단순 텍스트)</li>
      <li>디버깅, 감사 추적에 용이</li>
      <li><strong>사후 분석</strong>에 효과적</li>
      <li>저장 공간 많이 차지할 수 있음</li>
    </ul>
  </li>
  <li>
    <p>예시:</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2025-05-13T12:45:00"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"level"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ERROR"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Login failed for user ID 123"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<h4 id="-메트릭-metrics">📊 메트릭 (Metrics)</h4>

<ul>
  <li>
    <p><strong>수치로 측정 가능한 시스템의 상태</strong></p>
  </li>
  <li>
    <p>시간에 따라 변화하는 수치 → CPU 사용량, 요청 수, 응답 시간 등</p>
  </li>
  <li>
    <p>예:</p>

    <ul>
      <li>서버 응답 시간 평균 120ms</li>
      <li>현재 접속 사용자 수 300명</li>
    </ul>
  </li>
  <li>
    <p>특징:</p>

    <ul>
      <li>구조화된 데이터</li>
      <li>시각화 및 대시보드 구성에 유리</li>
      <li>알림(경고) 설정에 적합</li>
      <li>보통 <strong>Prometheus</strong>, <strong>Grafana</strong>와 같이 사용됨</li>
    </ul>
  </li>
  <li>
    <p>예시:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http_requests_total{method="GET", status="200"} 3456
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="비교-요약-1">비교 요약:</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>로그(Log)</th>
      <th>메트릭(Metrics)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>목적</td>
      <td>이벤트 디버깅, 추적</td>
      <td>상태 모니터링, 성능 추적</td>
    </tr>
    <tr>
      <td>형식</td>
      <td>텍스트 기반, 구조 유동적</td>
      <td>수치 기반, 구조화됨</td>
    </tr>
    <tr>
      <td>저장</td>
      <td>로그 파일, ELK Stack</td>
      <td>시계열 DB (Prometheus 등)</td>
    </tr>
    <tr>
      <td>시각화</td>
      <td>Kibana, Logtail 등</td>
      <td>Grafana 등</td>
    </tr>
    <tr>
      <td>실시간성</td>
      <td>낮음 (분석 중심)</td>
      <td>높음 (모니터링, 알림에 적합)</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>로그는 “<strong>무슨 일이 일어났는가</strong>”를 알려주고,
메트릭은 “<strong>현재 시스템이 어떤 상태인가</strong>”를 알려준다.
둘은 보완 관계로 함께 사용하는 것이 가장 효과적이다!</p>
</blockquote>

<h2 id="3️⃣-structured-logging-구조화된-로그">3️⃣ <strong>Structured Logging (구조화된 로그)</strong></h2>

<h3 id="-개념">✅ 개념</h3>

<ul>
  <li>일반 로그는 텍스트 형식으로 사람이 읽기 쉽게 쓰는 반면,
<strong>Structured Logging</strong>은 로그를 <strong>JSON 같은 구조화된 형태로 기록</strong>하는 방식입니다.</li>
</ul>

<h3 id="-예시-비교">🔍 예시 비교</h3>

<p><strong>❌ 일반 로그 (Unstructured)</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User 1234 failed to login due to wrong password
</code></pre></div></div>

<p><strong>✅ 구조화 로그 (Structured)</strong>:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2025-05-13T10:42:00Z"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"level"</span><span class="p">:</span><span class="w"> </span><span class="s2">"WARN"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"event"</span><span class="p">:</span><span class="w"> </span><span class="s2">"login_failed"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"user_id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1234</span><span class="p">,</span><span class="w">
  </span><span class="nl">"reason"</span><span class="p">:</span><span class="w"> </span><span class="s2">"wrong_password"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="-장점">✨ 장점</h3>

<ul>
  <li>기계가 파싱하기 쉽고, <strong>검색/필터링/집계</strong>에 유리</li>
  <li>로그 수집 도구(예: Elasticsearch, Datadog)와 연동할 때 편함</li>
  <li>실시간 모니터링이나 <strong>경고 시스템</strong>과 연계 가능</li>
</ul>

<blockquote>
  <p>구조화 로그는 결국 “<strong>로그도 데이터다</strong>”라는 관점에서 관리하는 것!</p>
</blockquote>

<hr />

<h2 id="4️⃣-elk-vs-efk-스택">4️⃣ <strong>ELK vs EFK 스택</strong></h2>

<h3 id="-공통-목적">✅ 공통 목적</h3>

<ul>
  <li><strong>분산 로그 수집, 저장, 분석, 시각화</strong>를 위한 스택입니다.</li>
  <li>대규모 시스템에서 수많은 서버 로그를 한 곳으로 모아서 검색·분석하기 위해 사용합니다.</li>
</ul>

<hr />

<h3 id="-elk-stack">🧩 <strong>ELK Stack</strong></h3>

<ul>
  <li><strong>E</strong>lasticsearch: 로그를 저장하고 검색 가능한 DB</li>
  <li><strong>L</strong>ogstash: 로그 수집기. 다양한 소스에서 로그를 받아 필터링/변환</li>
  <li><strong>K</strong>ibana: 시각화 도구 (대시보드, 검색 UI 등)</li>
</ul>

<h4 id="장점">장점</h4>

<ul>
  <li>오래된 구성으로 안정적이고 성숙함</li>
  <li>다양한 입력 소스를 지원 (DB, 파일, MQ 등)</li>
</ul>

<h4 id="단점">단점</h4>

<ul>
  <li>Logstash가 무거움 → <strong>리소스 많이 사용</strong></li>
  <li>설정 복잡함</li>
</ul>

<hr />

<h3 id="-efk-stack">🧩 <strong>EFK Stack</strong></h3>

<ul>
  <li><strong>E</strong>lasticsearch</li>
  <li><strong>F</strong>luentd: 경량 로그 수집기 (Logstash 대체)</li>
  <li><strong>K</strong>ibana</li>
</ul>

<h4 id="장점-1">장점</h4>

<ul>
  <li><strong>Kubernetes 환경에 더 적합</strong></li>
  <li>Fluentd는 가볍고 플러그인으로 유연하게 확장 가능</li>
  <li>최근 클라우드 환경에서 더 많이 사용됨</li>
</ul>

<h4 id="단점-1">단점</h4>

<ul>
  <li>복잡한 변환/파이프라인 처리 시엔 Logstash보다 기능 제한 있음</li>
</ul>

<hr />

<h3 id="비교-요약표">비교 요약표:</h3>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>ELK</th>
      <th>EFK</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>로그 수집기</td>
      <td>Logstash (무거움)</td>
      <td>Fluentd (가볍고 유연함)</td>
    </tr>
    <tr>
      <td>시각화</td>
      <td>Kibana</td>
      <td>Kibana</td>
    </tr>
    <tr>
      <td>주 사용 환경</td>
      <td>온프레미스, 레거시 시스템</td>
      <td>클라우드, Kubernetes</td>
    </tr>
    <tr>
      <td>구성 난이도</td>
      <td>다소 복잡</td>
      <td>상대적으로 단순</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-결론">📌 결론</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>추천</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Kubernetes 기반 마이크로서비스</td>
      <td>✅ <strong>EFK Stack</strong></td>
    </tr>
    <tr>
      <td>다양한 로그 소스와 복잡한 처리 필요</td>
      <td>✅ <strong>ELK Stack</strong></td>
    </tr>
    <tr>
      <td>단순한 파일 로그 수집 및 시각화</td>
      <td>✅ 둘 다 가능, 구조화 로그 필수</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>실제로는 <strong>EFK + Structured Logging</strong> 조합이 요즘 가장 트렌디한 방식입니다.
로그를 JSON 형태로 남기고, Fluentd를 통해 Elasticsearch에 넣은 뒤 Kibana로 시각화하면 아주 강력한 로그 분석 시스템이 됩니다.</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-22 TIL]]></summary></entry></feed>