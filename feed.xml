<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://nan0silver.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nan0silver.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-08-20T05:17:32+00:00</updated><id>https://nan0silver.github.io/feed.xml</id><title type="html">NAHYUN BLOG</title><subtitle>Nahyun’s Development Blog
Hi, I’m Nahyun Eun, a student from South Korea studying backend development with Java.  In this blog, I organize and share my learning journey in programming, with notes and insights on backend concepts and practical examples.
 Follow along as I dive into the world of coding!
</subtitle><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><entry><title type="html">[친구하자] Hidden Technical Debt in Machine Learning Systems</title><link href="https://nan0silver.github.io/projectdiary/2025-08-17-diary/" rel="alternate" type="text/html" title="[친구하자] Hidden Technical Debt in Machine Learning Systems" /><published>2025-08-17T00:00:00+00:00</published><updated>2025-08-20T05:16:51+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-08-17-diary/"><![CDATA[<ul>
  <li><a href="#1-jjwt-라이브러리-버전에-따른-변경-사항">JJWT 라이브러리 버전에 따른 변경 사항</a></li>
</ul>

<hr />

<blockquote>
  <p>이번에는 서울 AI 허브 특강을 듣다가 알게 된 ML관련 논문을 읽고 지금 하고있는 “친구하자” 프로젝트의 어떤 부분에서 도움을 받을 수 있을지에 대해 알아보았다.</p>
</blockquote>

<p><strong>논문</strong>: [Hidden Technical Debt in Machine Learning Systems (NIPS 2015)]
<strong>작성자</strong>: D. Sculley외 10인 (Google, Inc.)</p>

<ul>
  <li><a href="https://nan0silver.github.io/til/2025-08-16-til/">논문에 대한 TIL 작성</a></li>
</ul>

<hr />

<h3 id="1-오늘-읽은-내용-요약">1. 오늘 읽은 내용 요약</h3>

<blockquote>
  <p><strong>핵심 주제</strong>: 머신러닝 시스템에서는 단순히 모델 성능을 높이는 것보다 <strong>데이터 흐름 관리, 파이프라인 구조, 의존성 관리</strong>가 더 중요하다는 점을 강조.</p>
</blockquote>

<ul>
  <li>
    <p><strong>기술 부채(Technical Debt)</strong></p>

    <ul>
      <li>ML 시스템은 빠르게 개발 가능하지만, 장기 유지보수 비용은 전통적인 소프트웨어보다 훨씬 높음.</li>
      <li>숨은 부채는 코드 수준이 아니라 <strong>시스템 수준</strong>에서 쌓이기 때문에 발견하기 어렵고 비용이 급격히 커짐.</li>
    </ul>
  </li>
  <li>
    <p><strong>주요 이슈와 원인</strong></p>

    <ol>
      <li>
        <p><strong>CACE 원칙</strong> <em>(Changing Anything Changes Everything)</em></p>

        <ul>
          <li>피처, 하이퍼파라미터, 데이터셋 중 하나만 바꿔도 전체 모델 성능이 예측 불가능하게 바뀜.</li>
        </ul>
      </li>
      <li>
        <p><strong>데이터 의존성</strong></p>

        <ul>
          <li>불안정한 입력 신호, 중복 피처, 과도한 데이터 연결은 장애 가능성을 높임.</li>
        </ul>
      </li>
      <li>
        <p><strong>Pipeline Jungle</strong></p>

        <ul>
          <li>데이터 전처리 단계가 쌓이면 유지보수가 어려워지고 에러 포인트가 증가.</li>
        </ul>
      </li>
      <li>
        <p><strong>모델 간 숨은 피드백 루프</strong></p>

        <ul>
          <li>하나의 모델 변경이 다른 시스템의 입력 데이터에 간접적으로 영향을 미침.</li>
        </ul>
      </li>
      <li>
        <p><strong>실시간 모니터링 부족</strong></p>

        <ul>
          <li>모델 업데이트 후 이상 징후를 늦게 발견하면 복구 비용이 기하급수적으로 커짐.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="2-나에게-필요했던-이유--친구하자-적용-사례">2. 나에게 필요했던 이유 — <strong>친구하자</strong> 적용 사례</h3>

<h4 id="1-발화화행-분석-모델-파이프라인-설계-시-고려할-점">(1) 발화/화행 분석 모델 파이프라인 설계 시 고려할 점</h4>

<ul>
  <li>
    <p><strong>현재 시나리오</strong></p>

    <ul>
      <li>통화 음성 → 스펙트로그램 변환 → 감정/화행 분석 모델 → 사용자 인지 지표 산출</li>
      <li>향후 <strong>AI 기반 발화 분석 모델</strong>을 도입해 지남력, 유창성, 어휘력, 주의집중력 등의 점수를 자동 산출할 계획.</li>
    </ul>
  </li>
  <li>
    <p><strong>적용 포인트</strong></p>

    <ul>
      <li>
        <p><strong>데이터 버저닝 필요성</strong></p>

        <ul>
          <li>예: 스펙트로그램 생성 방식을 바꿀 경우, 기존 학습 데이터와 호환성이 깨질 수 있음.</li>
          <li>→ DVC나 MLflow 같은 도구를 도입해 음성 데이터, 스펙트로그램, 학습된 모델을 <strong>버전 단위로 관리</strong>해야 함.</li>
        </ul>
      </li>
      <li>
        <p><strong>Pipeline Jungle 방지</strong></p>

        <ul>
          <li>현재는 음성 → 텍스트 → 감정 점수 산출이라는 단순 구조지만, 향후 발화 분석, 화행 분석, 치매 위험 예측까지 추가되면 <strong>중간 파이프라인이 폭발적으로 늘어남</strong>.</li>
          <li>→ 파이프라인을 계층적으로 나누고, 데이터 입출력 포맷을 표준화하는 설계가 필요.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="2-실시간-통화-분석-시스템-설계-시-고려할-점">(2) 실시간 통화 분석 시스템 설계 시 고려할 점</h4>

<ul>
  <li>
    <p><strong>현재 시나리오</strong></p>

    <ul>
      <li>WebRTC 기반 통화 → 통화 녹음 → 분석 API 호출 → 사용자/보호자 알림</li>
      <li>향후 실시간 음성 분석을 통해 <strong>통화 중 인지 저하, 우울감 등 감지</strong> 시 알림을 제공하는 기능을 목표.</li>
    </ul>
  </li>
  <li>
    <p><strong>적용 포인트</strong></p>

    <ul>
      <li>
        <p><strong>실시간 피처 드리프트 모니터링</strong></p>

        <ul>
          <li>예: 고령 사용자들의 발화 속도나 어휘 다양성이 계절, 이벤트에 따라 달라질 수 있음.</li>
          <li>→ 실시간으로 <strong>데이터 분포 변화를 감시</strong>해 학습 데이터와 입력 데이터의 괴리를 탐지하는 모니터링 필요.</li>
        </ul>
      </li>
      <li>
        <p><strong>모델 업데이트 전략(A/B Testing)</strong></p>

        <ul>
          <li>새로운 화행 분석 모델을 도입할 때, <strong>전체 사용자에게 바로 적용</strong>하면 위험.</li>
          <li>→ 전체 롤아웃 전 <strong>소규모 샘플 그룹</strong>에서 먼저 성능을 검증하고, 이상 징후 시 자동 롤백하는 시스템 필요.</li>
        </ul>
      </li>
      <li>
        <p><strong>경계 침식 문제 해결</strong></p>

        <ul>
          <li>통화 감정 분석 결과가 <strong>다른 추천 시스템</strong>(예: 대화 주제 추천)에도 입력될 경우, 모델 간 강한 의존성이 생김.</li>
          <li>→ API 수준에서 <strong>의존성 추적 및 제어</strong> 기능을 설계해 시스템 분리를 유지해야 함.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="3-느낀-점--인사이트">3. 느낀 점 &amp; 인사이트</h3>

<ul>
  <li>발화/화행 분석 모델처럼 <strong>실시간 데이터 기반 ML 시스템</strong>은 전통적인 오프라인 예측 모델보다 훨씬 <strong>기술 부채 리스크</strong>가 큼.</li>
  <li>
    <p>특히 이 논문에서 제시한 <strong>CACE 원칙</strong>을 그대로 체감할 수 있음:</p>

    <blockquote>
      <p>“스펙트로그램 해상도만 살짝 바꿨는데 전체 감정 분석 성능이 붕괴될 수도 있다.”</p>
    </blockquote>
  </li>
  <li>결론적으로, <strong>친구하자</strong>에서는 모델 성능 향상보다 <strong>데이터/파이프라인 안정성</strong>을 우선시해야 함.</li>
  <li><strong>모델 버저닝</strong>, <strong>실시간 모니터링</strong>, <strong>A/B 테스트</strong>, <strong>피처 관리 자동화</strong>는 반드시 초기에 설계해야 장기 비용을 줄일 수 있음.</li>
</ul>

<hr />

<h3 id="4-다음-액션-아이템">4. 다음 액션 아이템</h3>

<ul>
  <li><strong>DVC/MLflow</strong> 도입 → 발화/화행 분석 모델, 음성 데이터, 스펙트로그램 버전 관리</li>
  <li>데이터 파이프라인 표준화 → 입력/출력 포맷 및 계층 구조 설계</li>
  <li><strong>실시간 데이터 분포 모니터링</strong> 및 알림 시스템 구축</li>
  <li><strong>A/B 테스트 기반 모델 롤아웃 전략</strong> 설계 및 자동 롤백 기능 구현</li>
  <li>서비스 아키텍처에 <strong>모델 간 의존성 추적 기능</strong> 추가</li>
</ul>

<hr />

<h3 id="-핵심-요약">💡 핵심 요약</h3>

<blockquote>
  <p><strong>친구하자</strong>의 실시간 발화/화행 분석 시스템에서 기술 부채를 최소화하려면:</p>

  <p><strong>버전 관리</strong>: 데이터·모델·파이프라인을 모두 버전 단위로 관리
<strong>모니터링</strong>: 실시간 데이터 드리프트 및 예측 이상 징후 자동 탐지
<strong>분리 설계</strong>: 모델 간 강한 의존성 최소화
<strong>안전한 업데이트</strong>: A/B 테스트 기반 롤아웃 + 자동 롤백 전략 필수</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[친구하자 프로젝트 개발 중 논문 내용을 읽고 프로젝트 개발을 구체화한 내용입니다.]]></summary></entry><entry><title type="html">[TIL] Hidden Technical Debt in Machine Learning Systems</title><link href="https://nan0silver.github.io/til/2025-08-16-til/" rel="alternate" type="text/html" title="[TIL] Hidden Technical Debt in Machine Learning Systems" /><published>2025-08-16T00:00:00+00:00</published><updated>2025-08-16T00:36:49+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-08-16-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
📅 <strong>작성일</strong>: 2025-08-16<br />
🔄 <strong>최종 수정</strong>: 2025년 08월 16일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<p><strong>논문</strong>: [Hidden Technical Debt in Machine Learning Systems (NIPS 2015)]
<strong>작성자</strong>: D. Sculley외 10인 (Google, Inc.)</p>

<h3 id="1-오늘-읽은-내용-요약">1. 오늘 읽은 내용 요약</h3>

<blockquote>
  <p><strong>핵심 주제</strong>: 머신러닝 시스템에서 발생하는 <strong>숨은 기술 부채(hidden technical debt)</strong> 문제를 설명하고, 시스템 설계 단계에서 고려해야 할 위험 요소를 다룸.</p>
</blockquote>

<ul>
  <li>
    <p><strong>기술 부채(Technical Debt) 개념</strong></p>

    <ul>
      <li>ML 시스템은 개발과 배포는 빠르지만 <strong>유지보수가 어렵고 비용이 많이 드는 구조적 특성</strong>을 가짐.</li>
      <li>코드 수준의 문제보다 <strong>시스템 전반에서의 복잡성</strong>이 더 큰 원인.</li>
      <li>숨은 부채는 누적되며, 발견 시에는 비용이 급격히 커짐.</li>
    </ul>
  </li>
  <li>
    <p><strong>ML 시스템에서 기술 부채가 생기는 주요 원인</strong></p>

    <ol>
      <li><strong>경계 침식(Boundary Erosion)</strong>: 모델이 여러 신호를 섞어 사용하기 때문에 한 부분을 바꾸면 전체가 변함 (<strong>CACE 원칙: Changing Anything Changes Everything</strong>).</li>
      <li><strong>데이터 의존성(Data Dependencies)</strong>: 불안정하거나 과도한 데이터 의존성으로 인해 작은 변화가 큰 장애를 일으킴.</li>
      <li><strong>피드백 루프(Feedback Loops)</strong>: 모델이 자신의 입력 데이터를 간접적으로 바꾸는 경우 → 예측 정확도에 예기치 못한 영향을 미침.</li>
      <li>
        <p><strong>시스템 안티패턴(System Anti-Patterns)</strong>:</p>

        <ul>
          <li><strong>Glue Code</strong>: 다양한 패키지를 연결하는 코드가 과도해져 유지보수 비용 증가.</li>
          <li><strong>Pipeline Jungles</strong>: 데이터 처리 파이프라인이 점점 복잡해져 관리가 어려워짐.</li>
          <li><strong>Dead Experimental Codepaths</strong>: 실험을 위해 만든 코드가 방치되어 예기치 못한 오류를 유발.</li>
        </ul>
      </li>
      <li><strong>구성(Configuration) 부채</strong>: 피처, 하이퍼파라미터, 로깅 설정 등 방대한 설정이 누적되어 관리가 어려워짐.</li>
      <li><strong>외부 세계 변화</strong>: 환경, 사용자 행동, 시장 조건의 변화가 모델 성능에 직접적인 영향을 미침.</li>
    </ol>
  </li>
  <li>
    <p><strong>해결 방안</strong></p>

    <ul>
      <li>데이터 및 모델 <strong>의존성 관리 도구</strong> 구축 (버저닝, 자동화된 피처 관리 등).</li>
      <li><strong>모니터링 &amp; 자동화 대응</strong> 필수.</li>
      <li>실험적 코드 정리 및 중복 제거.</li>
      <li>연구팀과 엔지니어링팀 간 <strong>하이브리드 협업 구조</strong> 필요.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="2-나에게-필요했던-이유">2. 나에게 필요했던 이유</h3>

<blockquote>
  <p>이에 대한 자세한 내용은 (깃블로그)[링크]에서 볼 수 있습니다.</p>
</blockquote>

<ul>
  <li>
    <p>현재 진행 중인 <strong>AI 기반 발화/화행 분석 모델</strong>과 <strong>친구하자</strong> 서비스의 ML 시스템에 적용할 수 있음:</p>

    <ul>
      <li><strong>데이터 버저닝</strong> 필요성 → 감정 분석 모델 학습 시 <strong>피처 변경</strong>이 있을 경우 예기치 못한 성능 저하 방지.</li>
      <li><strong>파이프라인 관리</strong> 중요성 → 통화 음성 데이터 → 스펙트로그램 변환 → 감정 분석 → 저장 단계에서 발생할 수 있는 <strong>Pipeline Jungle</strong> 방지.</li>
      <li><strong>모델 업데이트 전략</strong> → 모델 개선이 실제 서비스에서 <strong>사용자 경험을 악화시킬 수 있는 위험</strong> 방지 필요.</li>
      <li><strong>실시간 모니터링</strong> 필요 → 모델 성능 저하나 데이터 분포 변화에 빠르게 대응 가능해야 함.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="3-느낀-점--인사이트">3. 느낀 점 &amp; 인사이트</h3>

<ul>
  <li>단순히 모델 성능을 높이는 것보다, <strong>시스템 전반의 유지보수성</strong>과 <strong>데이터 흐름 관리</strong>가 훨씬 중요하다는 걸 깨달음.</li>
  <li>
    <p>특히 <strong>CACE 원칙</strong>은 실무에서 체감할 가능성이 큼:</p>

    <blockquote>
      <p>“하나 바꾸면 다 바뀐다” → 모델 입력 피처 변경 시 전체 시스템의 예측 성능이 흔들릴 수 있음.</p>
    </blockquote>
  </li>
  <li>앞으로 <strong>AI 모델 성능 향상보다 안정적인 시스템 아키텍처 설계</strong>에 우선순위를 둬야겠다고 느낌.</li>
  <li>
    <p><strong>친구하자</strong> 서비스에서도:</p>

    <ul>
      <li>데이터 파이프라인 설계를 단순하게 유지.</li>
      <li>모델을 <strong>엔드 투 엔드로 한 번에 학습</strong>하는 방법과 <strong>서브모델 앙상블 방식</strong>의 트레이드오프를 고려해야 함.</li>
      <li>장기적으로 <strong>모델 버저닝 + 모니터링 시스템</strong>을 도입해 기술 부채를 최소화할 필요 있음.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="4-다음-액션-아이템">4. 다음 액션 아이템</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />데이터 버저닝 전략 조사 및 설계 (e.g., DVC, MLflow)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />음성 데이터 파이프라인 단순화 → Glue Code 최소화</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />실시간 성능 모니터링 및 알림 시스템 설계</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />모델 업데이트 시 A/B 테스트 기반 롤아웃 전략 도입</li>
</ul>

<hr />]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><category term="Git" /><category term="ML" /><summary type="html"><![CDATA[2025-08-16 TIL]]></summary></entry><entry><title type="html">[Etc] FastAPI vs Flask: Python 백엔드 프레임워크 비교</title><link href="https://nan0silver.github.io/miscellaneous/til/2025-07-20-flask-fastAPI/" rel="alternate" type="text/html" title="[Etc] FastAPI vs Flask: Python 백엔드 프레임워크 비교" /><published>2025-07-20T00:00:00+00:00</published><updated>2025-07-23T16:30:00+00:00</updated><id>https://nan0silver.github.io/miscellaneous/til/flask-fastAPI</id><content type="html" xml:base="https://nan0silver.github.io/miscellaneous/til/2025-07-20-flask-fastAPI/"><![CDATA[<ul>
  <li><a href="#-새롭게-배운-것">새롭게 배운 것</a></li>
  <li><a href="#-오늘의-문제-상황--해결-과정">오늘의 문제 상황 &amp; 해결 과정</a></li>
  <li><a href="#-pydantic이란">Pydantic이란?</a></li>
  <li><a href="#-spring-boot-dto와-pydantic의-비교">Spring Boot DTO와 Pydantic의 비교</a></li>
  <li><a href="#-느낀-점">느낀 점</a></li>
</ul>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<ul>
  <li>Python 백엔드 프레임워크인 <strong>FastAPI</strong>와 <strong>Flask</strong>를 비교해보았다.</li>
  <li>두 프레임워크 모두 경량 웹 서버를 빠르게 개발할 수 있도록 도와주지만, 철학과 기능 면에서 차이가 존재한다.</li>
  <li>주요 비교 항목: 비동기 처리, 타입 힌트 지원, 성능, 문서 자동화, 커뮤니티 및 생태계 등</li>
</ul>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th><strong>FastAPI</strong></th>
      <th><strong>Flask</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>출시 연도</strong></td>
      <td>2018</td>
      <td>2010</td>
    </tr>
    <tr>
      <td><strong>비동기 지원</strong></td>
      <td><code class="language-plaintext highlighter-rouge">async/await</code> 기반 비동기 처리 완전 지원</td>
      <td>기본은 동기, 비동기 처리는 별도 패키지 필요</td>
    </tr>
    <tr>
      <td><strong>타입 힌트</strong></td>
      <td>필수적으로 사용하며, 자동 문서화 및 검증에 활용</td>
      <td>선택적 사용, 검증은 외부 라이브러리 의존</td>
    </tr>
    <tr>
      <td><strong>문서 자동화</strong></td>
      <td>Swagger UI 및 Redoc 자동 생성</td>
      <td>기본 제공 없음 (Flasgger 등으로 보완)</td>
    </tr>
    <tr>
      <td><strong>성능</strong></td>
      <td>매우 빠름 (Starlette 기반, Uvicorn 활용)</td>
      <td>상대적으로 느림</td>
    </tr>
    <tr>
      <td><strong>러닝 커브</strong></td>
      <td>초기 진입 장벽이 다소 높음 (타입, Pydantic 등)</td>
      <td>매우 쉬운 진입, 학습 곡선 완만</td>
    </tr>
    <tr>
      <td><strong>커뮤니티</strong></td>
      <td>빠르게 성장 중</td>
      <td>매우 크고 안정적인 생태계</td>
    </tr>
    <tr>
      <td><strong>데이터 검증</strong></td>
      <td>Pydantic 기반의 자동 검증</td>
      <td>별도 유효성 검사 코드 필요</td>
    </tr>
    <tr>
      <td><strong>REST API 개발</strong></td>
      <td>RESTful 설계에 최적화</td>
      <td>자유도가 높음, 규칙이 느슨함</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-오늘의-문제-상황--해결-과정">🍎 오늘의 문제 상황 &amp; 해결 과정</h2>

<ul>
  <li>지금까지는 Flask의 간결함과 진입 장벽이 낮은 점이 마음에 들어 주로 Flask를 사용해왔다.</li>
  <li>하지만 이번에는 FastAPI를 직접 적용해보고 싶어 새 프로젝트에 도입해보았다.</li>
  <li>특히 <code class="language-plaintext highlighter-rouge">Pydantic</code> 모델이 처음엔 어렵게 느껴질까 걱정했지만, 막상 사용해보니 <strong>Spring Boot의 DTO와 매우 유사한 느낌</strong>이 들어 빠르게 익숙해졌다.</li>
  <li>타입 기반 구조와 자동 검증, 문서화 덕분에 프로젝트가 자연스럽게 구조화되고 개발 속도도 빨랐다.</li>
</ul>

<hr />

<h2 id="-pydantic이란">📌 Pydantic이란?</h2>

<ul>
  <li><strong>Pydantic</strong>은 FastAPI에서 입력/출력 데이터의 구조를 정의하고, 유효성을 검사하며, JSON 직렬화를 자동으로 처리하는 핵심 컴포넌트다.</li>
  <li>Python의 <strong>타입 힌트(type hint)</strong>를 기반으로 동작하며, <code class="language-plaintext highlighter-rouge">BaseModel</code>을 상속하여 필드와 제약 조건을 선언할 수 있다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(...,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">age</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">email</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div></div>

<ul>
  <li>위와 같이 작성하면, FastAPI는 요청 데이터가 이 조건을 만족하는지 자동으로 검증하고, Swagger 문서까지 자동 생성해준다.</li>
</ul>

<hr />

<h2 id="-spring-boot-dto와-pydantic의-비교">🔍 Spring Boot DTO와 Pydantic의 비교</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Spring Boot DTO</th>
      <th>FastAPI Pydantic Model</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>역할</strong></td>
      <td>요청/응답 객체 정의 + 유효성 검사</td>
      <td>요청/응답 객체 정의 + 유효성 검사</td>
    </tr>
    <tr>
      <td><strong>유효성 검사 도구</strong></td>
      <td>JSR 380 (e.g., <code class="language-plaintext highlighter-rouge">@NotNull</code>, <code class="language-plaintext highlighter-rouge">@Size</code>)</td>
      <td>Pydantic (<code class="language-plaintext highlighter-rouge">Field</code>, <code class="language-plaintext highlighter-rouge">validator</code>)</td>
    </tr>
    <tr>
      <td><strong>직렬화/역직렬화</strong></td>
      <td>Jackson 사용</td>
      <td>내장 기능으로 자동 처리</td>
    </tr>
    <tr>
      <td><strong>중첩 구조 지원</strong></td>
      <td>중첩 DTO 클래스</td>
      <td>중첩 <code class="language-plaintext highlighter-rouge">BaseModel</code>을 통한 자연스러운 처리</td>
    </tr>
    <tr>
      <td><strong>문서화 연동</strong></td>
      <td>Swagger/OpenAPI 설정 필요</td>
      <td>FastAPI에 자동 내장</td>
    </tr>
    <tr>
      <td><strong>확장성</strong></td>
      <td>Bean Validation 위주</td>
      <td>타입 변환, 커스텀 직렬화 등 더 다양한 기능 내장</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>결론적으로 <strong>Pydantic은 Spring의 DTO와 유사한 사용 경험을 제공하면서도</strong>, 그 이상의 기능(데이터 직렬화, 문서화, 타입 변환 등)을 하나의 모델에서 처리할 수 있다는 점에서 <strong>DTO + Validator + Mapper + Serializer의 통합체</strong>로 볼 수 있다.</p>
</blockquote>

<hr />

<h2 id="-느낀-점">🦄 느낀 점</h2>

<ul>
  <li>Flask는 여전히 빠른 개발과 간단한 구조를 원할 때 유용한 선택지다.</li>
  <li>반면 FastAPI는 프로젝트 구조를 더 명확히 하고, 자동화된 유효성 검사 및 문서화 기능까지 갖추고 있어 <strong>중·대형 규모 프로젝트나 협업 시에 훨씬 효율적</strong>이라는 점을 느꼈다.</li>
  <li>개인적으로는 Pydantic이 예상보다 익숙했고, Spring Boot의 DTO를 써본 경험이 FastAPI 적응에 큰 도움이 되었다.</li>
  <li>앞으로는 프로젝트의 성격에 따라 Flask와 FastAPI를 유연하게 선택하며, 각 도구의 장점을 상황에 맞게 활용할 계획이다.</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="miscellaneous" /><category term="til" /><category term="TIL" /><category term="FastAPI" /><category term="Flask" /><category term="Backend" /><summary type="html"><![CDATA[2025-07-20 FastAPI vs Flask]]></summary></entry><entry><title type="html">[TIL] Jenkins vs GitHub Actions, IaaS vs PaaS vs SaaS</title><link href="https://nan0silver.github.io/til/2025-05-27-til/" rel="alternate" type="text/html" title="[TIL] Jenkins vs GitHub Actions, IaaS vs PaaS vs SaaS" /><published>2025-05-27T00:00:00+00:00</published><updated>2025-05-28T00:36:49+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-27-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/62">#62</a><br />
📅 <strong>작성일</strong>: 2025-05-27<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 28일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<ul>
  <li>AI Tech 2025 : AI 융합 비즈니스 개발 컨퍼런스 후기 작성 완료!
    <ul>
      <li><a href="https://silvernh.tistory.com/3">Tistory</a></li>
    </ul>
  </li>
</ul>

<h3 id="1️⃣-jenkins-vs-github-actions">1️⃣ <strong>Jenkins vs GitHub Actions</strong></h3>

<p>둘 다 **CI/CD(지속적 통합/지속적 배포)**를 자동화하는 도구다.
개발자가 코드를 push하면 <strong>자동으로 빌드하고, 테스트하고, 배포</strong>까지 해주는 파이프라인 역할.</p>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Jenkins</th>
      <th>GitHub Actions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>배포 방식</td>
      <td>직접 서버에 설치 (온프레미스, 클라우드)</td>
      <td>GitHub 내장 서비스 (클라우드 기반)</td>
    </tr>
    <tr>
      <td>파이프라인 구성</td>
      <td>Groovy 기반 DSL (Jenkinsfile)</td>
      <td>YAML 기반 설정 (.github/workflows/)</td>
    </tr>
    <tr>
      <td>UI/플러그인</td>
      <td>수많은 플러그인과 커스터마이징 가능</td>
      <td>GitHub 생태계에 최적화된 워크플로우</td>
    </tr>
    <tr>
      <td>설정 난이도</td>
      <td>다소 복잡 (서버 관리 필요)</td>
      <td>상대적으로 간단하고 빠른 적용 가능</td>
    </tr>
    <tr>
      <td>장점</td>
      <td>유연한 환경 설정, 다양한 툴 연동 가능</td>
      <td>GitHub와 완벽하게 통합, 설정이 간단</td>
    </tr>
    <tr>
      <td>단점</td>
      <td>서버 유지보수 필요, 러닝커브 있음</td>
      <td>GitHub 내에서만 동작 (GitLab, Bitbucket X)</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>✅ GitHub Actions는 빠르게 CI/CD를 도입하고 싶은 팀에 좋고,
✅ Jenkins는 복잡한 환경이나 내부망에서의 CI/CD가 필요할 때 적합하다.</p>
</blockquote>

<p>—å</p>

<h3 id="-간단-예시--github-actions">🧪 간단 예시 – GitHub Actions</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># .github/workflows/deploy.yml</span>
<span class="na">name</span><span class="pi">:</span> <span class="s">Build and Deploy</span>

<span class="na">on</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">push</span><span class="pi">]</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>
      <span class="pi">-</span> <span class="na">run</span><span class="pi">:</span> <span class="s">./gradlew build</span>
</code></pre></div></div>

<hr />

<h3 id="2️⃣-iaas-vs-paas-vs-saas">2️⃣ <strong>IaaS vs PaaS vs SaaS</strong></h3>

<p>클라우드 서비스 모델을 구분할 때 자주 등장하는 세 가지 개념.
“내가 어디까지 책임지고, 어디서부터는 제공자가 해주는가?”가 핵심.</p>

<h4 id="-개념-요약">✅ 개념 요약</h4>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>설명</th>
      <th>예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>IaaS (Infrastructure as a Service)</td>
      <td>인프라만 제공받고, OS부터 직접 설치</td>
      <td>AWS EC2, Google Compute Engine</td>
    </tr>
    <tr>
      <td>PaaS (Platform as a Service)</td>
      <td>실행 환경까지 제공, 앱 코드만 올리면 됨</td>
      <td>Heroku, Google App Engine, Render</td>
    </tr>
    <tr>
      <td>SaaS (Software as a Service)</td>
      <td>소프트웨어 완제품 사용</td>
      <td>Gmail, Notion, Slack</td>
    </tr>
  </tbody>
</table>

<h4 id="-비교-예시">✅ 비교 예시</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>IaaS</th>
      <th>PaaS</th>
      <th>SaaS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>서버 관리</td>
      <td>내가 함</td>
      <td>클라우드가 함</td>
      <td>필요 없음</td>
    </tr>
    <tr>
      <td>개발 유연성</td>
      <td>높음</td>
      <td>중간</td>
      <td>거의 없음</td>
    </tr>
    <tr>
      <td>배포 편의성</td>
      <td>낮음 (직접 설정)</td>
      <td>높음 (코드만 배포)</td>
      <td>매우 높음 (사용만 하면 됨)</td>
    </tr>
    <tr>
      <td>대상 사용자</td>
      <td>인프라 엔지니어, DevOps</td>
      <td>백엔드 개발자</td>
      <td>일반 사용자, 마케터 등</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-요약-정리">🧠 요약 정리</h3>

<table>
  <thead>
    <tr>
      <th>질문</th>
      <th>답변</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Jenkins랑 GitHub Actions 중 뭐가 더 쉽지?</td>
      <td>GitHub Actions! 설정이 YAML이고 GitHub랑 연동이 편함</td>
    </tr>
    <tr>
      <td>IaaS는 언제 써야 해?</td>
      <td>서버에 대해 완전히 커스터마이징이 필요할 때</td>
    </tr>
    <tr>
      <td>SaaS는 어떤 거야?</td>
      <td>구글 드라이브, 노션, 슬랙처럼 바로 쓰는 서비스</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>오늘의 핵심:
✅ CI/CD 도구는 “내가 코드를 어떻게 자동화할지”에 따라 고르고,
✅ 클라우드 서비스 모델은 “어디까지 직접 관리할지”에 따라 고른다.</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><category term="Git" /><category term="DevOps" /><category term="Cloud" /><summary type="html"><![CDATA[2025-05-27 TIL]]></summary></entry><entry><title type="html">[TIL] Nginx, 리버스 프록시, 로드 밸런서</title><link href="https://nan0silver.github.io/til/2025-05-24-til/" rel="alternate" type="text/html" title="[TIL] Nginx, 리버스 프록시, 로드 밸런서" /><published>2025-05-24T00:00:00+00:00</published><updated>2025-05-27T05:35:43+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-24-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/61">#61</a><br />
📅 <strong>작성일</strong>: 2025-05-24<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-nginx란">1️⃣ <strong>Nginx란?</strong></h3>

<ul>
  <li>**Nginx(엔진엑스)**는 고성능 웹 서버 소프트웨어다.</li>
  <li>원래는 정적 콘텐츠 제공을 위한 웹 서버였지만, 현재는 <strong>리버스 프록시</strong>, <strong>로드 밸런서</strong>, <strong>API Gateway</strong>, <strong>캐시 서버</strong> 등 다용도로 활용된다.</li>
</ul>

<hr />

<h3 id="-nginx의-주요-기능">✅ Nginx의 주요 기능</h3>

<table>
  <thead>
    <tr>
      <th>기능</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>웹 서버</td>
      <td>HTML, CSS, JS 같은 <strong>정적 파일 제공</strong></td>
    </tr>
    <tr>
      <td>리버스 프록시</td>
      <td>클라이언트 요청을 <strong>내부 서버에 전달</strong></td>
    </tr>
    <tr>
      <td>로드 밸런서</td>
      <td>여러 서버에 트래픽을 <strong>분산</strong>하여 처리</td>
    </tr>
    <tr>
      <td>캐시 서버</td>
      <td>응답을 <strong>캐싱</strong>해 성능 향상</td>
    </tr>
    <tr>
      <td>SSL 종단 처리</td>
      <td>HTTPS 인증서 처리 (Let’s Encrypt 등과 연동)</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-리버스-프록시란">🔄 리버스 프록시란?</h3>

<ul>
  <li>클라이언트는 Nginx에 요청을 보내고, Nginx는 **백엔드 서버(Apache, Spring, Node 등)**에 요청을 전달한 후 응답을 다시 클라이언트에 전송한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Client] → [Nginx] → [Spring Server]
</code></pre></div></div>

<ul>
  <li>보안, 로드 밸런싱, 서버 분리 등 다양한 이유로 활용됨</li>
</ul>

<hr />

<h3 id="️-로드-밸런서">⚖️ 로드 밸런서</h3>

<ul>
  <li>요청을 <strong>여러 서버에 고르게 분산</strong>시켜 트래픽 집중을 막고 <strong>가용성</strong>을 높임</li>
</ul>

<h4 id="nginx에서-로드-밸런싱-구성-예시">Nginx에서 로드 밸런싱 구성 예시:</h4>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">upstream</span> <span class="s">backend</span> <span class="p">{</span>
    <span class="kn">server</span> <span class="s">backend1.example.com</span><span class="p">;</span>
    <span class="kn">server</span> <span class="s">backend2.example.com</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://backend</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">upstream</code> 블록을 통해 백엔드 서버를 그룹핑하고, Nginx가 자동으로 라운드로빈 방식으로 분산 처리</p>
</blockquote>

<hr />

<h3 id="-정적-파일-서버로의-활용">📦 정적 파일 서버로의 활용</h3>

<ul>
  <li>HTML/CSS/JS 파일을 빠르게 서빙할 수 있음</li>
  <li>WAS(Spring, Node 등)에서 정적 리소스를 분리하면 서버 부하를 줄일 수 있음</li>
</ul>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">root</span> <span class="n">/usr/share/nginx/html</span><span class="p">;</span>
        <span class="kn">index</span> <span class="s">index.html</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="-https-설정">🔒 HTTPS 설정</h3>

<ul>
  <li>Let’s Encrypt와 Certbot을 이용해 무료 SSL 인증서 발급 가능</li>
  <li>HTTPS로 종단 보안(SSL Termination)을 적용하여 <strong>보안 강화</strong></li>
</ul>

<hr />

<h2 id="-함께-알아두면-좋은-심화-키워드">🧠 함께 알아두면 좋은 심화 키워드</h2>

<table>
  <thead>
    <tr>
      <th>키워드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>리버스 프록시</td>
      <td>Nginx가 중간에 서서 내부 서버 대신 요청 응답 처리</td>
    </tr>
    <tr>
      <td>포워드 프록시</td>
      <td>사용자의 요청을 <strong>외부로 보낼 때</strong> 중개하는 프록시</td>
    </tr>
    <tr>
      <td>CDN (Content Delivery Network)</td>
      <td>정적 리소스를 전 세계에 분산 저장하여 빠르게 전송</td>
    </tr>
    <tr>
      <td>캐싱 정책</td>
      <td><code class="language-plaintext highlighter-rouge">Cache-Control</code>, <code class="language-plaintext highlighter-rouge">ETag</code>를 이용한 정적 자원 캐싱</td>
    </tr>
    <tr>
      <td>Blue-Green Deployment</td>
      <td>Nginx로 배포 서버를 스위칭하여 무중단 배포 실현</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="️-오늘의-요약">✍️ 오늘의 요약</h2>

<ul>
  <li>Nginx는 단순 웹 서버 그 이상으로, <strong>프론트와 백엔드 사이의 허브 역할</strong>을 한다.</li>
  <li>리버스 프록시, 로드 밸런서, 정적 파일 서버, SSL 처리까지 담당할 수 있는 멀티플레이어</li>
  <li>실제 운영 환경에서는 <strong>Spring Boot와 Nginx 연동</strong>, <strong>HTTPS 적용</strong>, <strong>EC2 배포 시 로드밸런싱 구성</strong> 등을 할 수 있도록 익숙해져야 한다</li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-24 TIL]]></summary></entry><entry><title type="html">[TIL] Grafana &amp;amp; Prometheus, Rolling Policy, 시계열 메트릭</title><link href="https://nan0silver.github.io/til/2025-05-23-til/" rel="alternate" type="text/html" title="[TIL] Grafana &amp;amp; Prometheus, Rolling Policy, 시계열 메트릭" /><published>2025-05-23T00:00:00+00:00</published><updated>2025-05-27T05:34:31+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-23-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/60">#60</a><br />
📅 <strong>작성일</strong>: 2025-05-23<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-grafana--prometheus--시계열-메트릭-시각화-도구">1️⃣ <strong>Grafana &amp; Prometheus – 시계열 메트릭 시각화 도구</strong></h3>

<h4 id="-prometheus">📊 Prometheus</h4>

<ul>
  <li>CNCF(Cloud Native Computing Foundation)에서 관리하는 <strong>시계열 메트릭 수집 도구</strong></li>
  <li>주로 <strong>인프라/애플리케이션 성능 모니터링</strong>에 사용됨</li>
  <li><strong>Pull 방식</strong>으로 타겟 서버의 메트릭을 주기적으로 수집함</li>
  <li>메트릭 쿼리 언어: <strong>PromQL</strong></li>
  <li>내장된 시계열 DB에 메트릭 저장</li>
</ul>

<blockquote>
  <p>예시 메트릭:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http_requests_total{method="GET", status="200"} 1523
cpu_usage_seconds_total{core="1"} 82.3
</code></pre></div></div>

<h4 id="-grafana">📈 Grafana</h4>

<ul>
  <li><strong>Prometheus 등의 시계열 데이터 소스를 시각화하는 대시보드 도구</strong></li>
  <li>사용자가 커스터마이징 가능한 <strong>대시보드/그래프/알람</strong>을 만들 수 있음</li>
  <li>Prometheus 외에도 <strong>Loki(로그), InfluxDB, MySQL, Elasticsearch 등 다양한 소스</strong>와 연동 가능</li>
  <li>
    <p>주요 사용 예:</p>

    <ul>
      <li>CPU/메모리/디스크 사용률 실시간 모니터링</li>
      <li>서비스 요청 응답 시간 추적</li>
      <li>메트릭 기반 알림 설정 (ex. 5분간 에러율이 5% 넘으면 슬랙 알림)</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="-grafana--prometheus--devops-핵심-콤보">🧩 Grafana + Prometheus = DevOps 핵심 콤보</h3>

<table>
  <thead>
    <tr>
      <th>도구</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Prometheus</td>
      <td>메트릭 수집 및 저장</td>
    </tr>
    <tr>
      <td>Grafana</td>
      <td>메트릭 시각화 및 알람</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>두 도구는 함께 사용할 때 진가를 발휘한다.
Prometheus가 메트릭 데이터를 모으고, Grafana가 이를 시각적으로 표현해준다.</p>
</blockquote>

<hr />

<h3 id="2️⃣-rolling-policy-로그-롤링-정책">2️⃣ <strong>Rolling Policy (로그 롤링 정책)</strong></h3>

<h4 id="-개념">🧾 개념</h4>

<ul>
  <li>로그 파일이 커지거나 오래되었을 때, <strong>자동으로 새로운 파일로 교체하거나 백업</strong>하는 정책</li>
  <li>로그 관리를 자동화해서 디스크 과부하를 방지하고, 오래된 로그를 보관하거나 삭제할 수 있게 해줌</li>
</ul>

<h4 id="-적용-예--logback-springxml-예시">📁 적용 예 – <code class="language-plaintext highlighter-rouge">logback-spring.xml</code> 예시:</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;rollingPolicy</span> <span class="na">class=</span><span class="s">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;fileNamePattern&gt;</span>logs/app-%d{yyyy-MM-dd}.log<span class="nt">&lt;/fileNamePattern&gt;</span>
    <span class="nt">&lt;maxHistory&gt;</span>30<span class="nt">&lt;/maxHistory&gt;</span> <span class="c">&lt;!-- 30일간 보관 --&gt;</span>
<span class="nt">&lt;/rollingPolicy&gt;</span>
</code></pre></div></div>

<h4 id="️-주요-타입">🎛️ 주요 타입</h4>

<table>
  <thead>
    <tr>
      <th>정책 유형</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TimeBasedRollingPolicy</td>
      <td>날짜별로 로그 파일 분리 (<code class="language-plaintext highlighter-rouge">app-2025-05-14.log</code>)</td>
    </tr>
    <tr>
      <td>SizeBasedTriggeringPolicy</td>
      <td>특정 크기 초과 시 새로운 파일 생성 (<code class="language-plaintext highlighter-rouge">app.log.1</code>, <code class="language-plaintext highlighter-rouge">.2</code>…)</td>
    </tr>
    <tr>
      <td>FixedWindowRollingPolicy</td>
      <td>번호 기반 순환 롤링 (<code class="language-plaintext highlighter-rouge">app.1.log</code>, <code class="language-plaintext highlighter-rouge">app.2.log</code>)</td>
    </tr>
  </tbody>
</table>

<h4 id="-왜-중요한가">🚧 왜 중요한가?</h4>

<ul>
  <li>로그 파일이 무한히 커지지 않도록 제어</li>
  <li>백업 및 운영에 필요한 로그만 유지 가능</li>
  <li>ELK/EFK 스택과 연동할 때도 파일 기반 로그를 안정적으로 관리</li>
</ul>

<blockquote>
  <p>정리하자면, **“로그를 무한정 쌓지 말고, 잘라서 보관하고, 오래된 건 지우자!”**는 개념이다.</p>
</blockquote>

<hr />

<h3 id="-오늘의-요약">📌 오늘의 요약</h3>

<table>
  <thead>
    <tr>
      <th>개념</th>
      <th>핵심 기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Prometheus</td>
      <td>메트릭 수집 및 저장 (시계열 DB)</td>
    </tr>
    <tr>
      <td>Grafana</td>
      <td>메트릭 시각화 및 알림</td>
    </tr>
    <tr>
      <td>Rolling Policy</td>
      <td>로그 용량/시간 기준 자동 분할 및 관리</td>
    </tr>
  </tbody>
</table>

<h3 id="3️⃣--시계열-메트릭time-series-metrics이란">3️⃣ 🕐 시계열 메트릭(Time Series Metrics)이란?</h3>

<ul>
  <li><strong>시간(Time)</strong> + <strong>값(Value)</strong> 이 쌍으로 구성된 데이터</li>
  <li>특정 지표가 <strong>시간에 따라 어떻게 변하는지</strong>를 보여줌</li>
</ul>

<h4 id="-예시">📊 예시:</h4>

<table>
  <thead>
    <tr>
      <th>시간</th>
      <th>CPU 사용률 (%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2025-05-14 10:00:00</td>
      <td>30</td>
    </tr>
    <tr>
      <td>2025-05-14 10:01:00</td>
      <td>35</td>
    </tr>
    <tr>
      <td>2025-05-14 10:02:00</td>
      <td>70</td>
    </tr>
  </tbody>
</table>

<p>이처럼 “시간에 따른 수치 변화”를 기록한 데이터가 바로 <strong>시계열 메트릭</strong></p>

<hr />

<h4 id="-시계열-메트릭-수집-도구란">📦 시계열 메트릭 수집 도구란?</h4>

<blockquote>
  <p>이런 <strong>시간 기반 데이터</strong>를 <strong>자동으로 수집, 저장, 관리</strong>해주는 도구를 말합니다.</p>
</blockquote>

<ul>
  <li>대표적인 도구:
    <ul>
      <li><strong>Prometheus</strong></li>
      <li>InfluxDB</li>
      <li>Graphite</li>
      <li>OpenTSDB</li>
    </ul>
  </li>
</ul>

<p>이들은 서버나 애플리케이션에서 CPU, 메모리, 요청 수, 에러율 같은 수치를 <strong>주기적으로 수집</strong>해서 시계열 DB에 저장한다.</p>

<h4 id="️-예를-들어-prometheus는">🛠️ 예를 들어 Prometheus는?</h4>

<ul>
  <li>15초마다 모든 서버의 CPU 사용률, HTTP 요청 수 등을 수집</li>
  <li>내부에 <strong>시계열 전용 데이터베이스</strong>를 가지고 있어 시간 순서대로 저장</li>
  <li>나중에 Grafana 같은 도구로 꺾은선 그래프를 그릴 수 있음</li>
</ul>

<h4 id="-정리">📌 정리</h4>

<table>
  <thead>
    <tr>
      <th>용어</th>
      <th>의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>시계열 데이터</td>
      <td>시간에 따라 변화하는 수치 데이터 (예: CPU 70% → 50%)</td>
    </tr>
    <tr>
      <td>시계열 메트릭 도구</td>
      <td>시간 기반 데이터를 주기적으로 수집/저장하는 시스템</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>시계열 메트릭 도구는 결국 **“시간의 흐름에 따라 시스템이 어떻게 작동하고 있는지 보여주는 도구”**</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-23 TIL]]></summary></entry><entry><title type="html">[TIL] 메테리얼 디자인 vs 쿠퍼티노 디자인, Log vs Metrics, Structure…</title><link href="https://nan0silver.github.io/til/2025-05-22-til/" rel="alternate" type="text/html" title="[TIL] 메테리얼 디자인 vs 쿠퍼티노 디자인, Log vs Metrics, Structure…" /><published>2025-05-22T00:00:00+00:00</published><updated>2025-05-27T03:54:57+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-22-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/59">#59</a><br />
📅 <strong>작성일</strong>: 2025-05-22<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-메테리얼-디자인material-design-vs-쿠퍼티노-디자인cupertino-design">1️⃣ <strong>메테리얼 디자인(Material Design) vs 쿠퍼티노 디자인(Cupertino Design)</strong></h3>

<h4 id="-메테리얼-디자인-material-design">🎨 메테리얼 디자인 (Material Design)</h4>

<ul>
  <li>Google에서 만든 디자인 시스템</li>
  <li>Android 앱에서 기본적으로 사용되는 UI 가이드라인</li>
  <li>
    <p>특징:</p>

    <ul>
      <li>실제 종이처럼 동작하는 “표면” 개념 → <strong>레이어, 그림자, 깊이감</strong></li>
      <li><strong>굵은 색상, 명확한 애니메이션, 카드 UI</strong></li>
      <li>일관된 컴포넌트 구조 (Button, Dialog 등)</li>
      <li>다양한 화면 크기 및 접근성 고려가 잘 되어 있음</li>
    </ul>
  </li>
</ul>

<h4 id="-쿠퍼티노-디자인-cupertino-design">🍏 쿠퍼티노 디자인 (Cupertino Design)</h4>

<ul>
  <li>Apple이 만든 iOS용 디자인 철학</li>
  <li>Flutter에서는 <code class="language-plaintext highlighter-rouge">CupertinoWidget</code>으로 구현</li>
  <li>
    <p>특징:</p>

    <ul>
      <li><strong>심플하고 정갈한 UI</strong>, 얇은 폰트, 미니멀한 구성</li>
      <li>iOS의 네이티브한 느낌을 충실히 재현</li>
      <li>스크롤, 네비게이션, 토글 스위치 등에서 iOS 특유의 인터랙션 존재</li>
    </ul>
  </li>
</ul>

<h4 id="비교-요약">비교 요약:</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Material Design</th>
      <th>Cupertino Design</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>주요 플랫폼</td>
      <td>Android, Web, Desktop</td>
      <td>iOS</td>
    </tr>
    <tr>
      <td>디자인 철학</td>
      <td>종이+레이어+애니메이션</td>
      <td>단순함+미려함+일관성</td>
    </tr>
    <tr>
      <td>주요 사용 예</td>
      <td>Google 앱, Android 앱</td>
      <td>Apple 앱, iOS 앱</td>
    </tr>
    <tr>
      <td>Flutter 적용</td>
      <td><code class="language-plaintext highlighter-rouge">MaterialApp</code></td>
      <td><code class="language-plaintext highlighter-rouge">CupertinoApp</code></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>요약: Android 앱은 Material 위주, iOS는 Cupertino 스타일을 따르며, <strong>Flutter는 둘 다 지원</strong>해 플랫폼에 맞는 UI를 쉽게 만들 수 있다!</p>
</blockquote>

<hr />

<h3 id="2️⃣-log-vs-metrics">2️⃣ <strong>Log vs Metrics</strong></h3>

<p>백엔드/운영 환경에서 시스템 상태를 추적할 때 자주 쓰이는 두 가지 개념을 비교해 보았다.</p>

<h4 id="-로그-log">📄 로그 (Log)</h4>

<ul>
  <li>
    <p><strong>시간 순으로 발생한 이벤트 기록</strong></p>
  </li>
  <li>
    <p>보통 텍스트 기반이며, 문제가 발생했을 때 <strong>무슨 일이 있었는지</strong> 파악하는 데 유용</p>
  </li>
  <li>
    <p>예:</p>

    <ul>
      <li>사용자가 로그인에 실패했습니다.</li>
      <li>서버에서 500 에러가 발생했습니다.</li>
    </ul>
  </li>
  <li>
    <p>특징:</p>

    <ul>
      <li>구조화가 느슨함 (JSON 또는 단순 텍스트)</li>
      <li>디버깅, 감사 추적에 용이</li>
      <li><strong>사후 분석</strong>에 효과적</li>
      <li>저장 공간 많이 차지할 수 있음</li>
    </ul>
  </li>
  <li>
    <p>예시:</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2025-05-13T12:45:00"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"level"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ERROR"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Login failed for user ID 123"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<h4 id="-메트릭-metrics">📊 메트릭 (Metrics)</h4>

<ul>
  <li>
    <p><strong>수치로 측정 가능한 시스템의 상태</strong></p>
  </li>
  <li>
    <p>시간에 따라 변화하는 수치 → CPU 사용량, 요청 수, 응답 시간 등</p>
  </li>
  <li>
    <p>예:</p>

    <ul>
      <li>서버 응답 시간 평균 120ms</li>
      <li>현재 접속 사용자 수 300명</li>
    </ul>
  </li>
  <li>
    <p>특징:</p>

    <ul>
      <li>구조화된 데이터</li>
      <li>시각화 및 대시보드 구성에 유리</li>
      <li>알림(경고) 설정에 적합</li>
      <li>보통 <strong>Prometheus</strong>, <strong>Grafana</strong>와 같이 사용됨</li>
    </ul>
  </li>
  <li>
    <p>예시:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http_requests_total{method="GET", status="200"} 3456
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="비교-요약-1">비교 요약:</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>로그(Log)</th>
      <th>메트릭(Metrics)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>목적</td>
      <td>이벤트 디버깅, 추적</td>
      <td>상태 모니터링, 성능 추적</td>
    </tr>
    <tr>
      <td>형식</td>
      <td>텍스트 기반, 구조 유동적</td>
      <td>수치 기반, 구조화됨</td>
    </tr>
    <tr>
      <td>저장</td>
      <td>로그 파일, ELK Stack</td>
      <td>시계열 DB (Prometheus 등)</td>
    </tr>
    <tr>
      <td>시각화</td>
      <td>Kibana, Logtail 등</td>
      <td>Grafana 등</td>
    </tr>
    <tr>
      <td>실시간성</td>
      <td>낮음 (분석 중심)</td>
      <td>높음 (모니터링, 알림에 적합)</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>로그는 “<strong>무슨 일이 일어났는가</strong>”를 알려주고,
메트릭은 “<strong>현재 시스템이 어떤 상태인가</strong>”를 알려준다.
둘은 보완 관계로 함께 사용하는 것이 가장 효과적이다!</p>
</blockquote>

<h2 id="3️⃣-structured-logging-구조화된-로그">3️⃣ <strong>Structured Logging (구조화된 로그)</strong></h2>

<h3 id="-개념">✅ 개념</h3>

<ul>
  <li>일반 로그는 텍스트 형식으로 사람이 읽기 쉽게 쓰는 반면,
<strong>Structured Logging</strong>은 로그를 <strong>JSON 같은 구조화된 형태로 기록</strong>하는 방식입니다.</li>
</ul>

<h3 id="-예시-비교">🔍 예시 비교</h3>

<p><strong>❌ 일반 로그 (Unstructured)</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User 1234 failed to login due to wrong password
</code></pre></div></div>

<p><strong>✅ 구조화 로그 (Structured)</strong>:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2025-05-13T10:42:00Z"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"level"</span><span class="p">:</span><span class="w"> </span><span class="s2">"WARN"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"event"</span><span class="p">:</span><span class="w"> </span><span class="s2">"login_failed"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"user_id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1234</span><span class="p">,</span><span class="w">
  </span><span class="nl">"reason"</span><span class="p">:</span><span class="w"> </span><span class="s2">"wrong_password"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="-장점">✨ 장점</h3>

<ul>
  <li>기계가 파싱하기 쉽고, <strong>검색/필터링/집계</strong>에 유리</li>
  <li>로그 수집 도구(예: Elasticsearch, Datadog)와 연동할 때 편함</li>
  <li>실시간 모니터링이나 <strong>경고 시스템</strong>과 연계 가능</li>
</ul>

<blockquote>
  <p>구조화 로그는 결국 “<strong>로그도 데이터다</strong>”라는 관점에서 관리하는 것!</p>
</blockquote>

<hr />

<h2 id="4️⃣-elk-vs-efk-스택">4️⃣ <strong>ELK vs EFK 스택</strong></h2>

<h3 id="-공통-목적">✅ 공통 목적</h3>

<ul>
  <li><strong>분산 로그 수집, 저장, 분석, 시각화</strong>를 위한 스택입니다.</li>
  <li>대규모 시스템에서 수많은 서버 로그를 한 곳으로 모아서 검색·분석하기 위해 사용합니다.</li>
</ul>

<hr />

<h3 id="-elk-stack">🧩 <strong>ELK Stack</strong></h3>

<ul>
  <li><strong>E</strong>lasticsearch: 로그를 저장하고 검색 가능한 DB</li>
  <li><strong>L</strong>ogstash: 로그 수집기. 다양한 소스에서 로그를 받아 필터링/변환</li>
  <li><strong>K</strong>ibana: 시각화 도구 (대시보드, 검색 UI 등)</li>
</ul>

<h4 id="장점">장점</h4>

<ul>
  <li>오래된 구성으로 안정적이고 성숙함</li>
  <li>다양한 입력 소스를 지원 (DB, 파일, MQ 등)</li>
</ul>

<h4 id="단점">단점</h4>

<ul>
  <li>Logstash가 무거움 → <strong>리소스 많이 사용</strong></li>
  <li>설정 복잡함</li>
</ul>

<hr />

<h3 id="-efk-stack">🧩 <strong>EFK Stack</strong></h3>

<ul>
  <li><strong>E</strong>lasticsearch</li>
  <li><strong>F</strong>luentd: 경량 로그 수집기 (Logstash 대체)</li>
  <li><strong>K</strong>ibana</li>
</ul>

<h4 id="장점-1">장점</h4>

<ul>
  <li><strong>Kubernetes 환경에 더 적합</strong></li>
  <li>Fluentd는 가볍고 플러그인으로 유연하게 확장 가능</li>
  <li>최근 클라우드 환경에서 더 많이 사용됨</li>
</ul>

<h4 id="단점-1">단점</h4>

<ul>
  <li>복잡한 변환/파이프라인 처리 시엔 Logstash보다 기능 제한 있음</li>
</ul>

<hr />

<h3 id="비교-요약표">비교 요약표:</h3>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>ELK</th>
      <th>EFK</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>로그 수집기</td>
      <td>Logstash (무거움)</td>
      <td>Fluentd (가볍고 유연함)</td>
    </tr>
    <tr>
      <td>시각화</td>
      <td>Kibana</td>
      <td>Kibana</td>
    </tr>
    <tr>
      <td>주 사용 환경</td>
      <td>온프레미스, 레거시 시스템</td>
      <td>클라우드, Kubernetes</td>
    </tr>
    <tr>
      <td>구성 난이도</td>
      <td>다소 복잡</td>
      <td>상대적으로 단순</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-결론">📌 결론</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>추천</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Kubernetes 기반 마이크로서비스</td>
      <td>✅ <strong>EFK Stack</strong></td>
    </tr>
    <tr>
      <td>다양한 로그 소스와 복잡한 처리 필요</td>
      <td>✅ <strong>ELK Stack</strong></td>
    </tr>
    <tr>
      <td>단순한 파일 로그 수집 및 시각화</td>
      <td>✅ 둘 다 가능, 구조화 로그 필수</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p>실제로는 <strong>EFK + Structured Logging</strong> 조합이 요즘 가장 트렌디한 방식입니다.
로그를 JSON 형태로 남기고, Fluentd를 통해 Elasticsearch에 넣은 뒤 Kibana로 시각화하면 아주 강력한 로그 분석 시스템이 됩니다.</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-22 TIL]]></summary></entry><entry><title type="html">[TIL] RPM, 앙상블, 비용, WSL, Windows Subsystem for Linux …</title><link href="https://nan0silver.github.io/til/2025-05-21-til/" rel="alternate" type="text/html" title="[TIL] RPM, 앙상블, 비용, WSL, Windows Subsystem for Linux …" /><published>2025-05-21T00:00:00+00:00</published><updated>2025-05-27T03:53:22+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-21-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/58">#58</a><br />
📅 <strong>작성일</strong>: 2025-05-21<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 27일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<h3 id="1️⃣-rpm-앙상블-비용">1️⃣ <strong>RPM, 앙상블, 비용</strong></h3>

<ul>
  <li>
    <p><strong>RPM (Revolutions Per Minute)</strong></p>

    <ul>
      <li>원래는 하드디스크나 모터 회전 속도를 나타내는 단위지만, **웹/앱 분석에서는 보통 “Revenue Per Mille(천 회당 수익)”**로 사용된다.</li>
      <li>
        <p>광고 업계에서는 광고가 <strong>1,000번 노출될 때 수익이 얼마인지</strong>를 뜻함.</p>

        <ul>
          <li>예: RPM = 5라면, 1,000번 광고 노출 시 수익이 $5</li>
        </ul>
      </li>
      <li>수익성을 평가하는 지표로 자주 사용됨.</li>
    </ul>
  </li>
  <li>
    <p><strong>앙상블 (Ensemble)</strong></p>

    <ul>
      <li>머신러닝에서 여러 모델을 조합해 <strong>예측 정확도를 향상시키는 기법</strong></li>
      <li>
        <p>주요 기법:</p>

        <ul>
          <li><strong>Bagging</strong> (ex. Random Forest)</li>
          <li><strong>Boosting</strong> (ex. XGBoost, LightGBM)</li>
          <li><strong>Stacking</strong> (모델들의 출력값을 다시 모델에 입력)</li>
        </ul>
      </li>
      <li>하나의 모델보다 성능이 좋을 가능성이 높고, 특히 Kaggle 등 실전 대회에서 필수 전략임.</li>
    </ul>
  </li>
  <li>
    <p><strong>비용 (Cost)</strong></p>

    <ul>
      <li>머신러닝에서의 비용은 보통 <strong>오차(error)를 수치화한 값</strong></li>
      <li>
        <p>목표는 이 비용(Cost)을 <strong>최소화하는 모델 파라미터를 찾는 것</strong></p>

        <ul>
          <li>예: 회귀에서는 <strong>MSE (Mean Squared Error)</strong></li>
          <li>분류에서는 <strong>Cross Entropy</strong> 같은 손실 함수 사용</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="2️⃣-wsl-windows-subsystem-for-linux-2">2️⃣ <strong>WSL, Windows Subsystem for Linux 2</strong></h3>

<ul>
  <li>
    <p><strong>WSL (Windows Subsystem for Linux)</strong></p>

    <ul>
      <li>Windows에서 Linux 환경을 사용할 수 있게 해주는 Microsoft의 호환 계층</li>
      <li>
        <p>WSL2는 WSL1과 달리 <strong>실제 Linux 커널을 가상 머신 위에 구동</strong>시킴</p>

        <ul>
          <li>더 빠르고 호환성이 뛰어남 (ex. Docker 사용 가능)</li>
        </ul>
      </li>
      <li>개발자가 <strong>Mac 없이도 Unix/Linux 개발 환경</strong>을 Windows에서 구성할 수 있어 유용함</li>
    </ul>
  </li>
  <li>
    <p><strong>UNIX vs MacOS vs WSL2 vs Tux</strong></p>

    <ul>
      <li><strong>UNIX</strong>: OS 설계 철학/표준, 안정성과 보안성으로 서버 환경에서 많이 사용됨</li>
      <li><strong>MacOS</strong>: BSD 계열의 UNIX 기반 OS → 터미널 환경이 UNIX 명령어와 유사</li>
      <li><strong>WSL2</strong>: 윈도우 안에서 리눅스 환경을 제공해, 리눅스 개발 도구 사용 가능</li>
      <li><strong>Tux</strong>: 리눅스의 공식 마스코트 펭귄 이름 🐧</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>요약: Mac이나 Linux 서버가 없더라도 WSL2를 쓰면 로컬에서 UNIX 개발 환경을 손쉽게 세팅할 수 있다.</p>
</blockquote>

<hr />

<h3 id="3️⃣-phoenix-vs-snowflake">3️⃣ <strong>Phoenix vs Snowflake</strong></h3>

<ul>
  <li>이 두 용어는 <strong>데이터 웨어하우스 시스템</strong> 및 <strong>클라우드 아키텍처</strong> 문맥에서 자주 사용됨.</li>
</ul>

<h4 id="-phoenix-server-불사조-서버">🔥 Phoenix Server (불사조 서버)</h4>

<ul>
  <li>시스템을 중단하지 않고 <strong>점진적으로 설정, 코드, 인프라를 바꾸는 방식</strong></li>
  <li>“죽지 않는 서버”</li>
  <li>실시간으로 코드를 수정하거나, 배포 중에도 유저에게 영향을 주지 않음</li>
  <li>하지만 시간이 지날수록 <strong>기술 부채</strong>가 쌓일 수 있음</li>
</ul>

<h4 id="️-snowflake-server-눈송이-서버">❄️ Snowflake Server (눈송이 서버)</h4>

<ul>
  <li>수작업 설정이 많고, <strong>특정 환경에서만 작동하는 불안정한 서버</strong></li>
  <li>배포마다 설정이 조금씩 달라서, 한번 망가지면 <strong>복원하기 어려움</strong></li>
  <li>
    <p>반의어로 <strong>Immutable Infrastructure</strong> (변경 불가능한 인프라)가 선호됨</p>

    <ul>
      <li>예: 컨테이너 기반 인프라 (Docker + CI/CD)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>요약:</p>

  <ul>
    <li><strong>Phoenix 서버</strong>는 장기적으로 위험이 쌓이고,</li>
    <li><strong>Snowflake 서버</strong>는 설정 의존도가 높아 불안정하며,</li>
    <li>**이 둘을 피하기 위해 IaC(Infrastructure as Code)**와 컨테이너, 배포 자동화를 쓰는 것이 최신 DevOps 흐름이다.</li>
  </ul>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-21 TIL]]></summary></entry><entry><title type="html">[TIL] Ollama</title><link href="https://nan0silver.github.io/til/2025-05-20-til/" rel="alternate" type="text/html" title="[TIL] Ollama" /><published>2025-05-20T00:00:00+00:00</published><updated>2025-05-22T05:33:07+00:00</updated><id>https://nan0silver.github.io/til/til</id><content type="html" xml:base="https://nan0silver.github.io/til/2025-05-20-til/"><![CDATA[<blockquote>
  <p>📝 <strong>TIL (Today I Learned)</strong><br />
🔗 <strong>원본 이슈</strong>: <a href="https://github.com/nan0silver/TIL/issues/57">#57</a><br />
📅 <strong>작성일</strong>: 2025-05-20<br />
🔄 <strong>최종 수정</strong>: 2025년 05월 22일</p>
</blockquote>

<hr />

<h2 id="-새롭게-배운-것">🍀 새롭게 배운 것</h2>

<ul>
  <li>
    <p>Ollama</p>

    <ul>
      <li>로컬 머신에서 대규모 언어 모델(LLM)을 실행할 수 있게 해주는 오픈소스 도구</li>
      <li>주요 특징
        <ul>
          <li>로컬 실행: 모든 처리가 로컬에서 이루어져 개인정보 보호가 가능</li>
          <li>다양한 모델 지원: Llama, Mistral, Gemma 등 다양한 오픈소스 모델 지원</li>
          <li>간단한 API: REST API를 통해 쉽게 통합 가능</li>
          <li>CPU/GPU 지원: 다양한 하드웨어에서 실행 가능</li>
          <li>크로스 플랫폼: Windows, macOS, Linux 지원</li>
        </ul>
      </li>
      <li>Ollama 시작하기
        <ol>
          <li>ollama.com에서 OS에 맞는 버전 다운로드 및 설치</li>
          <li>터미널에서 모델 다운로드 (예: ollama pull llama3.2)</li>
          <li>모델 실행 (예: ollama run llama3.2)</li>
        </ol>
      </li>
      <li>
        <p>API 사용 방법</p>

        <ul>
          <li>Ollama는 http://localhost:11434에서 REST API를 제공합니다:</li>
          <li>
            <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># Python 예제
</span>  <span class="kn">import</span> <span class="nn">requests</span>

  <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="s">'http://localhost:11434/api/generate'</span><span class="p">,</span>
      <span class="n">json</span><span class="o">=</span><span class="p">{</span>
          <span class="s">'model'</span><span class="p">:</span> <span class="s">'llama3.2'</span><span class="p">,</span>
          <span class="s">'prompt'</span><span class="p">:</span> <span class="s">'백엔드 개발에 필요한 기술은?'</span><span class="p">,</span>
          <span class="s">'stream'</span><span class="p">:</span> <span class="bp">False</span>
      <span class="p">})</span>

  <span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">json</span><span class="p">()[</span><span class="s">'response'</span><span class="p">])</span>
</code></pre></div>            </div>
          </li>
          <li>
            <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JavaScript 예제</span>
<span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">http://localhost:11434/api/generate</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span> <span class="p">},</span>
  <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
    <span class="na">model</span><span class="p">:</span> <span class="dl">"</span><span class="s2">llama3.2</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">prompt</span><span class="p">:</span> <span class="dl">"</span><span class="s2">백엔드 개발에 필요한 기술은?</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">stream</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="p">}),</span>
<span class="p">})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">response</span><span class="p">));</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="til" /><category term="TIL" /><summary type="html"><![CDATA[2025-05-20 TIL]]></summary></entry><entry><title type="html">[컨퍼런스] AI Tech 2025 참석 후기</title><link href="https://nan0silver.github.io/projectdiary/2025-05-15-diary/" rel="alternate" type="text/html" title="[컨퍼런스] AI Tech 2025 참석 후기" /><published>2025-05-15T00:00:00+00:00</published><updated>2025-08-20T05:16:51+00:00</updated><id>https://nan0silver.github.io/projectdiary/diary</id><content type="html" xml:base="https://nan0silver.github.io/projectdiary/2025-05-15-diary/"><![CDATA[<ul>
  <li><a href="#1-행사-개요">1. 행사 개요</a></li>
  <li><a href="#2-키노트-요약-embodied-ai와-기술-진화-방향">2. 키노트 요약: Embodied AI와 기술 진화 방향</a></li>
  <li><a href="#3-a2a-시대의-도래-agent-협업-구조">3. A2A 시대의 도래: Agent 협업 구조</a></li>
  <li><a href="#4-ai는-이제-운영의-시대">4. AI는 이제 운영의 시대</a></li>
  <li><a href="#5-실무-적용-사례-및-전략">5. 실무 적용 사례 및 전략</a></li>
  <li><a href="#6-기술-인사이트">6. 기술 인사이트</a></li>
  <li><a href="#7-결론">7. 결론</a></li>
</ul>

<blockquote>
  <p>실무자 중심의 AI 도입 이후 전략, 오케스트레이션 구조, 에이전트 협업 사례 중심</p>
</blockquote>

<hr />

<h2 id="1-행사-개요">1. 행사 개요</h2>

<p><strong>AI Tech 2025</strong>는 단순한 모델 개발이나 비전 소개를 넘어서,<br />
<strong>“AI를 어떻게 현업에 도입하고 운영할 것인가”</strong>를 주제로 구성된 실무 중심의 컨퍼런스였다.<br />
다양한 기업과 기술 리더들이 실제 적용 사례, 인프라 설계, 오케스트레이션 전략을 공유했으며,<br />
AI 도입 이후 단계에서 실질적인 생산성을 확보하기 위한 전략들이 인상 깊었다.</p>

<hr />

<h2 id="2-키노트-요약-embodied-ai와-기술-진화-방향">2. 키노트 요약: Embodied AI와 기술 진화 방향</h2>

<p>서울대 장병탁 교수의 기조연설에서는 <strong>AI의 진화 방향</strong>이 강조되었다.</p>

<ul>
  <li>기존: 디지털 정보 공간 내 추론 중심의 AI</li>
  <li>변화: <strong>실세계와 상호작용하며 학습·판단·행동하는 Embodied AI</strong></li>
</ul>

<blockquote>
  <p>Embodied AI는 물리적 환경을 인식하고 그에 반응할 수 있는 에이전트로, 강화학습 및 체화 학습을 통해 자율성을 확보한다.</p>
</blockquote>

<p><img src="https://github-production-user-asset-6210df.s3.amazonaws.com/82145661/448164887-76d2879b-b852-4e1e-95b9-715a1a9c824a.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250528%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20250528T010443Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=3e1da1f9900847a113d2f60899f7bde3f20244757464ad5a77b3ec544728e0ed&amp;X-Amz-SignedHeaders=host" /><br />
<em>Figure: Embodied AI – 환경 인지, 판단, 행동이 통합된 AI 시스템</em></p>

<hr />

<h2 id="3-a2a-시대의-도래-agent-협업-구조">3. A2A 시대의 도래: Agent 협업 구조</h2>

<h3 id="-a2aagent-to-agent-protocol">🔍 A2A(Agent-to-Agent Protocol)</h3>

<p>이번 행사에서 가장 빈번하게 언급된 개념 중 하나는 <strong>A2A</strong>였다.</p>

<ul>
  <li><strong>의미</strong>: 에이전트 간 데이터 공유 및 협업을 위한 통신 프로토콜</li>
  <li><strong>기능</strong>: 목적 지향형 대화, 작업 분담, 협업형 워크플로우 구성</li>
  <li><strong>사례</strong>: 문서 요약 에이전트 → 일정 정리 에이전트로 결과 전달</li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>요약 에이전트 → 분석 결과 전달 → 일정 에이전트가 회의 제안 자동화
</code></pre></div></div>

<h3 id="-관련-개념">🧩 관련 개념</h3>

<ul>
  <li>
    <p><strong>Agent Hub</strong>: 에이전트 설계/운영 통합 플랫폼</p>

    <ul>
      <li>ADK: Agent Design Kit</li>
      <li>Agent Engine: 배포 및 실행 환경</li>
      <li>Agent Garden: 에이전트 레지스트리/관리</li>
    </ul>
  </li>
</ul>

<p>이와 같은 구조는 기존 **MSA(마이크로서비스 아키텍처)**와 유사하게,
AI 시스템에서도 <strong>다수의 특화 에이전트가 상호작용하는 구조적 전환</strong>을 의미한다.</p>

<hr />

<h2 id="4-ai는-이제-운영의-시대">4. AI는 이제 운영의 시대</h2>

<p>기술보다 중요한 건 <strong>운영과 조율</strong>이다. 특히 다음과 같은 통찰이 강조되었다.</p>

<ul>
  <li>AGI는 단일 모델이 아닌, <strong>여러 특화 에이전트의 조합</strong></li>
  <li>이 조합을 조율하는 <strong>AI 오케스트레이션 계층</strong>이 핵심</li>
  <li>개발자는 모델 사용자에서 <strong>AI 아키텍처 설계자</strong>로 역할 확장 필요</li>
</ul>

<p>A2A는 단순한 API 호출이 아니라, <strong>에이전트 간 협업 흐름을 구성하는 전략적 도구</strong>로 자리잡고 있다.</p>

<hr />

<h2 id="5-실무-적용-사례-및-전략">5. 실무 적용 사례 및 전략</h2>

<h3 id="-주요-사례">📌 주요 사례</h3>

<ul>
  <li><strong>한화생명</strong>: 보험 상담 자동화 (LLM + RAG 기반 챗봇 운영)</li>
  <li><strong>KT</strong>: 기관 문서 기반 검색 시스템 구축</li>
  <li><strong>MARA</strong>: 자산 시장 분석 자동화</li>
  <li><strong>Nota AI</strong>: 엣지 디바이스용 AI 모델 경량화 및 배포</li>
</ul>

<p>이 외에도 다양한 기업들이 AI를 ‘기능’으로서가 아닌,
<strong>문제 해결 도구</strong>로서 어떻게 전략적으로 운영하고 있는지를 소개했다.</p>

<hr />

<h2 id="6-기술-인사이트">6. 기술 인사이트</h2>

<h3 id="️-실용-기술">🛠️ 실용 기술</h3>

<ul>
  <li><strong>Structured Pruning</strong>: 불필요한 파라미터 제거로 경량화</li>
  <li><strong>Filter Decomposition</strong>: 병렬 연산을 직렬화하여 성능 최적화</li>
  <li><strong>RAG 기반 검색</strong>: 문서 기반 답변 정확도 향상</li>
  <li><strong>Agent Workflow</strong>: 도메인 특화 다중 에이전트 협업 구성</li>
</ul>

<hr />

<h2 id="7-결론">7. 결론</h2>

<p>AI 시스템은 이제 단일 모델의 정확도보다,
<strong>어떻게 운영되고 협업 구조를 갖추는가</strong>가 더 중요해지고 있다.</p>

<p>이번 컨퍼런스를 통해 확인한 핵심은 다음과 같다:</p>

<ul>
  <li><strong>AI는 플랫폼이다</strong>: 단일 모델보다 다중 에이전트의 구조화된 조율이 핵심</li>
  <li><strong>A2A는 미래의 기본 요소</strong>: 마이크로서비스처럼 에이전트 협업이 표준화될 것</li>
  <li><strong>운영 전략이 곧 성패를 가른다</strong>: 기술보다 프로덕션 환경 최적화가 우선시됨</li>
</ul>

<blockquote>
  <p>기술을 넘어 전략으로서의 AI를 고민하게 된 의미 있는 자리였다.</p>
</blockquote>]]></content><author><name>Nahyun Eun 은나현</name><email>dmsskgus@sookmyung.ac.kr</email></author><category term="projectdiary" /><summary type="html"><![CDATA[AI Tech 2025 컨퍼런스에서 확인한 LLMOps, A2A, Embodied AI 등 최신 AI 시스템 운영 전략]]></summary></entry></feed>