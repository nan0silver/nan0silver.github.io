var tipuesearch = {"pages": [{
    "title": "[JAVA] Generic",
    "text": "Generic이란? Generic의 장점 Generic 사용법 Generic이란? 클래스나 메서드에서 사용할 데이터 타입을 지정하지 않고, 나중에 사용할 때 타입을 결정하는 기능 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방법 클래스 내부에서 지정하는 것이 아닌, 외부에서 사용자에 의해 지정되는 것을 의미 specific 타입을 미리 지정해주는 것이 아닌 필요에 의해 지정할 수 있도록 하는 generic 타입 제네릭을 사용하면 코드의 재사용성을 높이고, 타입 안정성을 보장할 수 있음 ArrayList&lt;T&gt;, HashMap&lt;K, V&gt;같은 자바 컬렉션 프레임워크에서 많이 사용됨 Generic의 장점 타입 안정성 (Type Safety) 보장 제네릭을 사용하면 컴파일 시점에 타입을 검사해서 타입 오류 방지 가능 예를 들어, ArrayList에 String만 저장하도록 지정하면 다른 타입을 추가하는 실수를 막을 수 있음 형변환(Casting) 불필요 제네릭을 사용하면 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환할 필요 없음 관리하기 편함 코드의 재사용성 증가 같은 로직을 다양한 데이터 타입에 대해 사용할 수 있어 코드의 중복을 줄일 수 있음 Generic 사용법 import java.util.ArrayList; public class WithGenerics { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //제네릭 사용 //ArrayList list = new ArrayList(); 제네릭 미사용 list.add(\"Hello\"); //list.add(123); 오류 발생 (타입 안정성 보장) //제네릭을 사용하지 않으면 오류 발생 X -&gt; 문제 발생 가능 String str = list.get(0); //형변환 없이 바로 사용 가능 System.out.println(str); } } 제네릭 클래스 만들기 // 제네릭 클래스 선언 (T는 타입 매개변수) class Box&lt;T&gt; { private T value; public void setValue(T value) { this.value = value; } public T getValue() { return value; } } public class GenericExample { public static void main(String[] args) { Box&lt;String&gt; stringBox = new Box&lt;&gt;(); //String으로 구체적인 타입 지정 stringBox.setValue(\"Hello\"); System.out.println(stringBox.getValue()); Box&lt;Integer&gt; intBox = new Box&lt;&gt;(); intBox.setValue(100); System.out.println(intBox.getValue()); } } 제네릭 메서드 만들기 class Util { // 제네릭 메서드 선언 public static &lt;T&gt; void printData(T data) { System.out.println(data); } } public class GenericMethodExample { public static void main(String[] args) { Util.printData(\"Hello\"); // String 타입 Util.printData(123); // Integer 타입 Util.printData(3.14); // Double 타입 } } 제네릭 타입 제한 (Bounded Type Parameter) // Number를 상속받은 타입만 사용 가능 (Integer, Double 등) class NumberBox&lt;T extends Number&gt; { private T number; public void setNumber(T number) { this.number = number; } public T getNumber() { return number; } } public class BoundedGenericExample { public static void main(String[] args) { NumberBox&lt;Integer&gt; intBox = new NumberBox&lt;&gt;(); intBox.setNumber(100); System.out.println(intBox.getNumber()); NumberBox&lt;Double&gt; doubleBox = new NumberBox&lt;&gt;(); doubleBox.setNumber(3.14); System.out.println(doubleBox.getNumber()); // NumberBox&lt;String&gt; strBox = new NumberBox&lt;&gt;(); // 오류 발생 (String은 Number가 아님) } } 와일드카드 (? - 제네릭 타입 미지정) 특정 타입을 제한하지 않고 유연하게 사용하고 싶은 경우 import java.util.ArrayList; import java.util.List; class WildcardExample { public static void printList(List&lt;?&gt; list) { // 와일드카드 사용 for (Object obj : list) { System.out.println(obj); } } public static void main(String[] args) { List&lt;String&gt; stringList = new ArrayList&lt;&gt;(); stringList.add(\"Apple\"); stringList.add(\"Banana\"); List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); intList.add(1); intList.add(2); printList(stringList); // 가능 printList(intList); // 가능 } }",
    "tags": "java",
    "url": "/java/2025-01-29-generic/"
  },{
    "title": "[Etc] TDD (Test-Driven Development, 테스트 주도 개발)",
    "text": "TDD란? TDD의 주요 과정 TDD의 장점 TDD 예제 (Java) TDD VS 전통적인 개발 방식 TDD가 필요한 경우 TDD의 단점 xUnit TDD (Test-Driven Development)란? 테스트 주도 개발 소프트웨어 개발 방법론 중 하나로, 테스트 코드를 먼저 작성한 후 실제 기능을 구현하는 방식 테스트 먼저, 코드 작성 나중! 짧은 개발 주기의 반복에 의존하는 개발 프로세스 애자일 방법론 중 하나인 eXtream Programming(XP)의 “Test-First” 개념에 기반을 둔 단순한 설계를 중요시함 eXtream Programming(XP) 미래에 대한 예측을 최대한 하지 않고, 지속적으로 프로토타입을 완성하는 애자일 방법론 중 하나 추가 요구사항이 생기더라도, 실시간으로 반영할 수 있음 TDD의 주요 과정 Red-Green-Refactor 세 단계 반복 1️⃣ Red (실패하는 테스트 작성) 구현할 기능에 대한 테스트 코드 작성 실제 기능이 이 시점에서는 없기 때문에 테스트는 실패 빨간색 = 실패 2️⃣ Green (코드 작성 후 테스트 통과) 테스트를 통과할 최소한의 코드만 작성 코드가 정상적으로 동작하여 테스트가 성공하면 다음 단계로 넘어감 초록색 = 성공 3️⃣ Refactor (리팩토링) 코드의 중복을 제거하고 더 나은 구조로 개선 테스트를 다시 실행하여 리팩토링 후에도 테스트가 성공하는지 확인 성능 개선, 코드 가독성 높이기 TDD의 장점 버그 감소 미리 테스트를 작성하기 때문에 오류를 조기에 발견할 수 있음 리팩토링 용이 테스트 코드가 보장되므로 안심하고 코드를 사용 가능 유지보수성 향상 코드가 변경될 때 기존 기능이 정상적으로 동작하는지 확인 가능 문서 역할 테스트 코드 자체가 기능 명세서 역할을 함 TDD 예제 (Java) 1. 실패하는 테스트 작성 import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; public class CalculatorTest { @Test void testAddition() { Calculator calc = new Calculator(); assertEquals(5, calc.add(2,3)); } } 현재 Calculator 클래스와 add() 메서드가 없어서 테스트 실패 2. 최소한의 코드 작성 (테스트 통과) public class Calculator { public int add (int a, int b) { return a+b; } } 이제 테스트 실행하면 성공! 3. 리팩토링 코드가 복잡한 경우 성능 최적화나 코드 구조 개선 가능 TDD VS 전통적인 개발 방식 구분 전통적인 개발 방식 TDD 순서 기능 구현 → 테스트 작성 테스트 작성 → 기능 구현 목적 기능 개발 후 버그 찾기 처음부터 버그 방지 유지보수 테스트 부족 시 리팩토링 어려움 안전한 리팩토링 가능 TDD가 필요한 경우 복잡한 로직이 포함된 코드 알고리즘, 비즈니스 로직 장기적으로 유지보수해야하는 프로젝트 협업이 필요한 개발 환경 테스트 코드가 문서 역할을 하므로 이해하기 쉬움 TDD의 단점 간단한 코드에는 불필요한 오버헤드가 발생할 수 있음 초기 개발 속도가 느려질 수 있음 xUnit 단위 테스트를 위한 프레임워크 JUnit(for JAVA)을 시작으로 여러 xUnit 프레임워크가 탄생함 xUnit 이름 해당 언어 관련 사이트 CUnit C CUnit CppUnit C++ CppUnit PHPUnit PHP PHPUnit PyUnit Python PyUnit JUnit Java JUnit",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-28-tdd/"
  },{
    "title": "[JavaScript] 단축 평가 (Short-circuit evaluation)",
    "text": "단축 평가란? 단축 평가 동작 방식 단축 평가 활용 예시 주의사항 단축 평가란? 논리 연산자 (&amp;&amp;, ||) 를 평가할 때, 결과를 미리 결정할 수 있다면 나머지 표현식을 평가하지 않고 곧바로 결과를 반환하는 것 &amp;&amp; (AND) 연산자: 두 피연산자가 모두 true 일 때만 true 를 반환합니다. || (OR) 연산자: 두 피연산자 중 하나라도 true 이면 true 를 반환합니다. 논리 연산자의 동작 방식을 이용하여 불필요한 연산을 줄이고, 코드 실행 효율성을 높임. &amp;&amp; (AND) 와 || (OR) 연산자를 조건문 없이 사용하는 코드를 가능하게 함 단축 평가 동작 방식 1. &amp;&amp; (AND) 연산자 &amp;&amp; 연산자는 좌항부터 평가 좌항이 false 라면: &amp;&amp; 연산의 결과는 항상 false 이므로, 우항을 평가하지 않고 곧바로 false 를 반환 좌항이 true 라면: &amp;&amp; 연산의 결과는 우항에 따라 결정되므로, 우항을 평가하고 그 결과를 반환 console.log(false &amp;&amp; true); //falsk //(좌항이 false이므로 우항을 평가하지 않고 false 반환) console.log(true &amp;&amp; false); //false //(좌항이 true이므로 우항을 평가하여 false 반환) console.log(true &amp;&amp; true); //true //(좌항이 true이므로 우항을 평가하여 true 반환) 2. || (OR) 연산자 || 연산자는 &amp;&amp; 연산자와 마찬가지로 좌항부터 평가 좌항이 true 라면: || 연산의 결과는 항상 true 이므로, 우항을 평가하지 않고 곧바로 true 를 반환 좌항이 false 라면: || 연산의 결과는 우항에 따라 결정되므로, 우항을 평가하고 그 결과를 반환 console.log(true || false); //true //(좌항이 true이므로 우항을 평가하지 않고 true 반환) console.log(false || true); //true //(좌항이 false이므로 우항을 평가하여 true 반환) console.log(false || false); //false //(좌항이 false이므로 우항을 평가하여 false 반환) 단축 평가 활용 예시 1. 객체의 속성에 접근할 때 객체의 속성에 접근하기 전에 객체가 null 또는 undefined 인지 확인하는 코드를 단축 평가로 간결하게 작성 가능 const person = { name: \"Alice\" }; // const person = null; // person이 null인 경우 // 조건문 사용 let name; if (person) { name = person.name; } else { name = \"Unknown\"; } console.log(name); // Alice // 단축 평가 사용 const name2 = person &amp;&amp; person.name; console.log(name2); // Alice (person이 truthy 값이므로 person.name 평가) const person2 = null; const name3 = person2 &amp;&amp; person2.name; console.log(name3); // null (person2가 falsy 값이므로 person2 그대로 반환) // || 연산자를 사용한 기본값 설정 const name4 = person2 || { name: \"Unknown\" }; console.log(name4); // { name: 'Unknown' } (person2가 falsy 값이므로 { name: 'Unknown' } 반환) console.log(name4.name); // Unknown 2. 함수 매개변수에 기본값 설정 함수 매개변수에 기본값을 설정할 때 || 연산자를 사용하여 코드를 간결하게 만들 수 있다. function greet(name) { // 조건문 사용 const userName = name ? name : \"Guest\"; console.log(`Hello, ${userName}!`); } greet(\"Bob\"); // Hello, Bob! greet(); // Hello, Guest! function greet2(name) { // 단축 평가 사용 const userName = name || \"Guest\"; console.log(`Hello, ${userName}!`); } greet2(\"Charlie\"); // Hello, Charlie! greet2(); // Hello, Guest! 3. 조건부 렌더링 (React) React와 같은 UI 라이브러리에서 조건부 렌더링을 구현할 때 단축 평가를 유용하게 사용할 수 있다. function MyComponent({ items }) { return ( &lt;div&gt; {/_ items가 존재하고 배열인 경우에만 목록 렌더링 _/} {items &amp;&amp; Array.isArray(items) &amp;&amp; ( &lt;ul&gt; {items.map((item) =&gt; ( &lt;li key={item.id}&gt;{item.name}&lt;/li&gt; ))} &lt;/ul&gt; )} {/_ items가 없거나 배열이 아닌 경우 메시지 표시 _/} {!items &amp;&amp; &lt;div&gt;No items to display.&lt;/div&gt;} {items || &lt;div&gt;No items to display.&lt;/div&gt;} {/_ || 연산자 사용 _/} &lt;/div&gt; ); } 주의사항 단축 평가는 코드를 간결하게 만들어주지만, 남용하면 코드의 가독성을 해칠 수 있음. 적절한 상황에서 사용하는 것이 중요합니다. &amp;&amp; 와 || 연산자는 boolean 값이 아닌 값도 반환 가능 단축 평가의 반환 값은 마지막으로 평가된 표현식의 결과이다.",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-27-javascript-short-circuit-evaluation/"
  },{
    "title": "[Git] git rebase",
    "text": "git rebase git rebase VS git merge git rebase 사용법 장점 주의 사항 git rebase Git에서 브랜치의 커밋 히스토리를 재구성할 때 사용하는 명령어 이를 통해 브랜치의 히스토리를 “정리(clean)”하거나 최신 상태를 기반으로 변경사항을 다시 적용할 수 있음 git rebase VS git merge 일반적으로 merge와 같은 목적으로 사용되지만, 다른 방식으로 작동 merge 두 브랜치의 히스토리를 합치면서, 새로운 병합 커밋을 생성 rebase 한 브랜치의 커밋을 다른 브랜치의 끝으로 옮겨서, 히스토리가 마치 일렬로 정리된 것처럼 보임 예시 이미지 16d0e75 커밋 아래는 merge 흔적 16d0e75 커밋 위는 rebase로 인한 선형 히스토리 git rebase 사용법 업스트림 브랜치로 리베이스 git swicth -c feature git rebase main feature 브랜치에서 작업한 커밋을들 main 브랜치의 최신 상태를 기반으로 재적용 interactive rebase git rebase -i HEAD~n 마지막 n개의 커밋을 선택적으로 수정하거나 합칠 수 있음 실행하면 편집 모드가 열리며, 옵션을 선택할 수 있음 pick, reword, edit, squash, drop등 장점 히스토리 정리 불필요한 merge 커밋 제거 최신 상태 유지 주의 사항 리베이스 중 충돌 이미 푸시된 브랜치에 리베이스 금지 git pull --rebase 원격 브랜치의 변경 사항을 병합 대신 리베이스로 가져올 때 사용",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-23-git-rebase/"
  },{
    "title": "[JAVA] int와 long의 차이 ➡️ 범위와 오버플로우 문제 완벽 정리",
    "text": "int와 long의 차이 int와 long의 입력값 연산 결과의 최대값 예상하기 문제를 보고 빠르게 판단하는 팁 int와 long의 차이 자꾸 문제를 풀다 int와 long을 혼동해서 문제를 틀리는 경우가 있어서 완벽 정리하려고 한다. 입력값의 범위와 연산 결과의 최댓값을 기준으로 판단하는 습관을 들여야 함 int와 long의 입력값 int : 약 -2,147,483,648 ~ 2,147,483,648 long : 약 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,808 문제에 입력값이 명시되어 있다면 -2,000,000,000 &lt;= N,M &lt;= 2,000,000,000 int는 처리 가능. 하지만 연산 결과를 생각해야 함 범위가 int의 한계와 가깝다면, 입력값은 int로 가능하더라도 연산 결과가 범위를 초과할 수 있기 때문에 long을 사용하는 것이 안전 판단 기준 입력값이 -10^9 ~ 10^9 사이일 경우 단순한 덧셈이나 뺄셈은 int로 처리 가능 곱셈, 제곱 연산, 누적 합계 등은 long이 필요할 수 있음 입력값이 -10^{10} 이상이거나, 결과적으로 큰 숫자가 나올 가능성이 있다면 무조건 long 사용 연산 결과의 최대값 예상하기 문제에서 요구하는 연산 결과 예상하기 예) 누적합 문제 배열의 크기가 1,000,000이고, 각 원소가 최대 10^6이라면, 누적합은 최대 10^12가 될 수 있음 이 경우 int의 범위를 초과하므로 long을 사용해야 함 문제를 보고 빠르게 판단하는 팁 입력 범위 확인 연산의 종류 확인 규칙 만들기 “입력값이 10^9 이상이면 무조건 long으로 처리한다” 테스트 데이터 체크 극단적인 입력값을 대입해보기",
    "tags": "java",
    "url": "/java/2025-01-23-int-long/"
  },{
    "title": "[Etc] Naming Convention",
    "text": "Naming Convention이란? 케밥 케이스 (Kebab-case) 카멜 케이스 (camelCase) 스네이크 케이스 (snake_case) 파스칼 케이스 (PascalCase) 선택 기준 Naming Convention이란? 프로그래밍에서 변수, 함수, 클래스 이름 등을 작성하는 규칙 1. 케밥 케이스 (Kebab-case) 단어를 하이픈(-)으로 구분하며, 모든 문자를 소문자로 작성 모양이 케밥을 닮았다고 해서 붙여진 이름 특징 가독성이 좋음 HTML, CSS에서 자주 사용됨 언어에 따라 변수나 함수이름으로는 사용할 수 없는 경우도 있음 하이픈이 연산자로 해석될 수 있어서 예시 /* CSS 클래스 이름 */ .button-primary { background-color: blue; color: white; } /* 파일 이름 */ my-awesome-file.js 2. 카멜 케이스 (camelCase) 첫 단어는 소문자로 시작하고, 이후 단어의 첫 글자를 대문자로 작성 이름이 낙타의 등처럼 튀어나온 형태를 닮아서 붙인 이름 특징 JavaScript, Java, C#, Python 등에서 변수와 함수 이름으로 자주 사용됨 대문자 없이 단어를 연결해 코드 가독성을 높이는 데 도움을 줌 예시 // JavaScript 변수와 함수 let userName = \"Alice\"; function getUserData() { return userName; } 3. 스네이크 케이스 (snake_case) 단어를 밑줄(_)로 구분하며, 모든 문자를 소문자로 작성 뱀이 기어다니는 모양을 닮아서 붙여진 이름 특징 Python, SQL, Ruby, C, C++, PHP, JSON 데이터 스키마에서 변수와 함수 이름으로 자주 사용됨 예시 # Python 변수 이름 user_name = \"Alice\" # Python 함수 이름 def get_user_data(): return user_name 4. 파스칼 케이스 (PascalCase) 각 단어의 첫 글자를 대문자로 작성 카멜 케이스와 비슷하지만 첫 단어도 대문자 특징 Java, TypeScript등의 클래스 이름과 타입 이름으로 자주 사용됨 예시 // Java 클래스 이름 public class UserAccount { private String UserName; public UserAccount(String userName) { this.UserName = userName; } } 선택 기준 언어/환경의 표준에 따라 케이스를 선택 JavaScript, Java camelCase (변수/함수) PascalCase (클래스) Python snake_case CSS/HTML kebab-case 팀 또는 프로젝트의 코딩 컨벤션에 따라 일관성 유지가 중요 (가독성을 위해)",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-22-naming-convention/"
  },{
    "title": "[Git] git clone VS git fork",
    "text": "git clone git fork 주요 차이점 정리 워크플로우 실전 예시 git clone 역할 원격 저장소를 로컬 컴퓨터에 복제 작업 대상 원격 저장소 특징 저장소의 완전한 복사본(전체 커밋 내역, 브랜치 등)을 가져옴 복제 후, 원격 저장소가 자동으로 origin이라는 이름으로 연결됨 로컬에서 작업한 내용을 원격 저장소에 반영하려면 push사용 동작 방식 Git 저장소 초기화 (git init) 새로 생성된 폴더는 Git 저장소로 설정됨 .git 디렉터리가 자동으로 생성됨 원격 저장소 설정 (git remote add origin) 복제한 원격 저장소가 자동으로 origin이라는 이름으로 연결됨 로컬에서 원격 저장소와 동기화(push, pull)를 가능하게 함 브랜치 체크아웃 기본 브랜치(main or master)의 최신 상태가 복제됨 이 브랜치는 로컬 저장소로 가져와 자동으로 체크아웃됨 파일 다운로드 원격 저장소에 있는 모든 파일과 폴더가 로컬 디렉토리에 다운로드됨 git clone 명령을 실행하면, 다운받은 폴더는 자동으로 Git 저장소로 초기화되고, 원격 저장소와도 연결된 상태임 git init이나 git remote add를 실행할 필요가 없음 git fork 역할 원격 저장소를 자신의 원격 계정으로 복제 작업 대상 GitHub/GitLab 계정 상의 저장소 특징 원본 저장소의 복사본이 내 계정의 원격 저장소로 생성됨 내 계정에서 관리할 수 있는 원격 저장소를 만든다는 것이 핵심 원본 저장소와 연결은 유지되지만, 독립적인 저장소로 사용됨 추가 단계 포크 후, 로컬에 복사하려면 git clone을 사용해야 함 사용 시기 오픈소스 프로젝트에 기여할 때, 원본 저장소를 수정하지 않고 내 계정에서 관리 가능한 복사본을 만들어야 할 때 사용 Pull Request를 보내기 위한 준비 단계로 사용 주요 차이점 정리 특징 git clone git fork 복제 대상 원격 저장소 ➡️ 로컬 저장소 원격 저장소 ➡️ 내 원격 저장소 저장소 위치 로컬에서 작업 내 계정의 원격 저장소에서 작업 연결된 원격 저장소 origin으로 원본 저장소 연결 내 계정의 원격 저장소 (원본 저장소는 upstream으로 연결 가능) 사용 목적 로컬에서 작업하고 원본 저장소에 반영 내 계정에서 독립적으로 원격 저장소 관리 주로 사용 상황 협업 프로젝트에 바로 참여 오픈소스 프로젝트에 기여 (Pull Request 준비) 워크플로우 일반적으로 Fork → Clone → Push → Pull Request가 오픈 소스 협업의 표준 워크플로우 Fork 저장소 생성 먼저, 해당 저장소를 Fork하여 내 계정으로 복사 GitHub에서 기여하고자 하는 저장소 페이지로 이동 우측 상단의 Fork 버튼을 클릭 그러면 내 계정에 저장소 복사본이 생성됨 Fork 저장소 Clone Fork된 저장소를 로컬로 복제 git clone https://github.com/your-username/repository.git your-username은 GitHub 계정 이름으로 대체 Clone이 완료되면 로컬 환경에서 작업 가능 원본 저장소 추가 (선택 사항) 원본 저장소와 동기화를 유지하려면, 원본 저장소를 upstream으로 추가 git remote add upstream https://github.com/original-owner/repository.git original-owner는 원본 저장소의 소유자 이름으로 대체 git remote -v 명령을 사용하여 설정이 제대로 되었는지 확인 가능 로컬에서 작업 새로운 파일을 추가하거나 수정 후 커밋 git add . git commit -m \"Add new feature\" Fork된 저장소에 Push 로컬에서 작업한 내용을 자신의 Fork 저장소에 Push git push origin main 여기서 main은 사용하는 브랜치 이름 Pull Request 생성 GitHub로 돌아가, Fork된 저장소에서 원본 저장소로 Pull Request를 생성 내 Fork 저장소 페이지에서 “Contribute” 버튼 클릭. “Open Pull Request” 버튼 클릭. 변경 사항에 대한 설명을 작성하고 Pull Request를 제출합니다. ✅ 요약 다른 사람의 저장소에 기여하기 위한 전체 과정 Fork: 저장소를 내 계정으로 복제. Clone: 내 계정에 있는 저장소를 로컬로 복제. 원본 저장소 추가: 원본 저장소와 동기화(선택 사항). 작업: 로컬에서 파일 수정 및 커밋. Push: 작업 내용을 내 계정 저장소로 업로드. Pull Request: 원본 저장소에 변경 사항을 제안. 실전 예시 git clone만 사용하는 경우 팀 프로젝트에서 기존 저장소를 복제하여 작업 후, 원본 저장소에 바로 push git clone &lt;repository-url&gt; cd &lt;repository-folder&gt; # 작업 후 git push origin &lt;branch-name&gt; git fork와 git clone을 함께 사용하는 경우 오픈소스 프로젝트에서 자신의 계정으로 fork 후, 로컬에서 복제하여 작업 후 pull request 보냄 # GitHub에서 Fork한 후 git clone &lt;forked-repository-url&gt; cd &lt;repository-folder&gt; # 원본 저장소를 upstream으로 추가 git remote add upstream &lt;original-repository-url&gt; git fetch upstream # 작업 후, 내 계정 원격 저장소에 Push git push origin &lt;branch-name&gt;",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-22-git-clone-fork/"
  },{
    "title": "[HTML] CSS Flex",
    "text": "Flex(Flexbox) 주요 Flexbox 속성 20개 예제: 통합 코드 flex를 이용한 게임 Flex(Flexbox) Flexbox(Flexible Box Layout Module) 컨테이너 내의 아이템 간 공간 배분과 정렬 기능을 제공하는 1차원 레이아웃 모델 주로 행이나 열 단위로 작동하며, 복잡한 계산 없이도 요소들의 크기와 순서를 유연하게 배치할 수 있음 장점 복잡한 레이아웃을 간단하게 구현 컨테이너 내 요소의 크기가 불명확하거나 동적인 경우에도 효과적으로 대응 요소의 순서를 CSS로 변경할 수 있어 반응형 디자인에 유용 float나 Position을 사용할 때보다 코드가 간결해짐 주요 Flexbox 속성 CSS3 Flexbox에서 가장 많이 사용되는 20개의 속성(property)을 아래에 정리했습니다. 각각의 속성에 대한 간략한 설명과 함께 예제 코드를 제공합니다. 1. display: flex Flexbox를 활성화. .container { display: flex; } 2. flex-direction 주축의 방향 설정. row (기본값), row-reverse, column, column-reverse. .container { flex-direction: column; } 3. justify-content 주축에서 항목 정렬. flex-start, flex-end, center, space-between, space-around, space-evenly. .container { justify-content: space-between; } 4. align-items 교차축에서 항목 정렬. stretch (기본값), flex-start, flex-end, center, baseline. .container { align-items: center; } 5. align-content 여러 줄에서 교차축 정렬. stretch, flex-start, flex-end, center, space-between, space-around. .container { align-content: space-around; } 6. flex-wrap 항목이 컨테이너를 초과하면 줄 바꿈 여부. nowrap (기본값), wrap, wrap-reverse. .container { flex-wrap: wrap; } 7. flex 개별 항목의 크기 설정 (약어). flex: grow shrink basis; .item { flex: 1 1 auto; } 8. flex-grow 남은 공간을 차지할 비율. 기본값: 0. .item { flex-grow: 2; } 9. flex-shrink 공간 부족 시 줄어드는 비율. 기본값: 1. .item { flex-shrink: 0; } 10. flex-basis 항목의 기본 크기 설정. .item { flex-basis: 100px; } 11. order 항목의 배치 순서. 기본값: 0. .item { order: 2; } 12. gap 항목 간 간격 설정. .container { gap: 20px; } 13. row-gap 가로축 항목 간 간격 설정. .container { row-gap: 15px; } 14. column-gap 세로축 항목 간 간격 설정. .container { column-gap: 10px; } 15. align-self 개별 항목의 교차축 정렬 설정. auto, flex-start, flex-end, center, baseline, stretch. .item { align-self: flex-end; } 16. min-width 항목의 최소 너비. .item { min-width: 100px; } 17. max-width 항목의 최대 너비. .item { max-width: 200px; } 18. min-height 항목의 최소 높이. .item { min-height: 50px; } 19. max-height 항목의 최대 높이. .item { max-height: 150px; } 20. place-content justify-content와 align-content를 한 번에 설정. center, stretch, space-between 등. .container { place-content: center; } 예제: 통합 코드 &lt;div class=\"container\"&gt; &lt;div class=\"item\"&gt;Item 1&lt;/div&gt; &lt;div class=\"item\"&gt;Item 2&lt;/div&gt; &lt;div class=\"item\"&gt;Item 3&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .container { display: flex; flex-direction: row; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; height: 300px; } .item { flex: 1 1 100px; align-self: stretch; min-width: 100px; max-width: 300px; } &lt;/style&gt; flex를 이용한 게임 https://flexboxfroggy.com/#ko 다 깼다!",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-21-css-flex/"
  },{
    "title": "[Etc] Responsive VS Reactive",
    "text": "Responsive Reactive Responsive VS Reactive 결합된 활용 Responsive (반응형) Responsive는 주로 UI/UX 디자인이나 프론트엔트 개발에서 사용되는 개념 애플리케이션 또는 웹 페이지가 화면 크기, 해상도, 디바이스 특성에 따라 적절히 변하도록 설계된 것을 의미 특징 주요 초점 레이아웃 및 디자인이 다양한 화면 환경(데스크톱, 태블릿, 모바일)에 적응 기술 주로 CSS, Flexbox, Grid, Viewport 등을 사용 목적 사용자 경험을 개선하고, 어떤 장치에서도 보기 좋은 디자인을 제공 예시 웹사이트 반응형 디자인 큰 화면에서는 여러 열(column)을 보여주고, 작은 화면에서는 한 열로 정렬 이미지와 텍스트 사이즈가 디바이스 크기에 따라 자동으로 조정 부트스트랩 (Bootstrap) col-m-6와 같은 클래스 이름을 사용하여 화면 크기에 따라 레이아웃을 조정 Reactive (반응형) Reactive는 주로 프로그래밍 패러다임과 관련이 있음 시스템이 변화를 감지하고 즉각적으로 동작을 수행하는 것을 의미 특징 주요 초점 데이터와 상태의 변화에 따라 UI가 자동으로 업데이트 기술 Reactive Programming과 관련된 라이브러리와 프레임워크를 활용 ex) RxJS, React, Vue, Svelte 등 목적 상태 관리와 데이터 흐름을 단순화하고, 사용자 입력 또는 데이터 변화에 실시간으로 반응 예시 React.js에서의 State변화 사용자가 버튼을 클릭하면 상태가 변경되고, 해당 상태에 따라 UI가 즉각적으로 업데이트 import React, { useState } from \"react\"; function Counter() { const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;Count: {count}&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increase&lt;/button&gt; &lt;/div&gt; ); } RxJS 스트림 데이터를 스트림(stream) 형태로 처리하고, 데이터 변경에 실시간으로 반응 import { fromEvent } from \"rxjs\"; const button = document.getElementById(\"myButton\"); const clicks = fromEvent(button, \"click\"); clicks.subscribe(() =&gt; console.log(\"Button clicked!\")); Responsive VS Reactive 측면 Responsive Reactive 적용 범위 주로 UI/UX와 레이아웃 디자인 상태 관리와 데이터 흐름 목적 화면 크기에 따른 레이아웃 및 스타일 변경 데이터 및 상태 변경에 따른 즉각적인 반응 사용 기술 CSS, Flexbox, Grid 등 React, RxJS, Vue 등 상태 기반 프레임워크 초점 디바이스별 최적화된 레이아웃 제공 데이터의 흐름과 UI 동기화 예시 모바일에서 1열 레이아웃, 데스크톱에서 3열 레이아웃 버튼 클릭 시 상태 업데이트 후 UI 리렌더링 결합된 활용 Responsive와 Reactive는 함께 사용될 때 더 큰 효과를 발휘한다. 예를 들어, React.js로 만들어진 SPA(Single Page Application)에서 반응형 디자인(CSS)을 사용해 다양한 디바이스를 지원하면서, React의 상태 관리(State Management)를 통해 UI를 데이터와 동기화할 수 있음. 예시 Reaponsive는 레이아웃과 UI에 초점을 맞추고, Reactive는 데이터와 상태 관리에 집중 둘이 상호보완적! import React, { useState } from 'react'; import './App.css'; // Responsive 스타일 포함 function App() { const [isDarkMode, setIsDarkMode] = useState(false); return ( &lt;div className={`app ${isDarkMode ? 'dark-mode' : ''}`}&gt; &lt;p&gt;Welcome to the responsive and reactive app!&lt;/p&gt; &lt;button onClick={() =&gt; setIsDarkMode(!isDarkMode)}&gt; Toggle Dark Mode &lt;/button&gt; &lt;/div&gt; ); } /* App.css */ .app { padding: 20px; transition: background-color 0.3s; } .dark-mode { background-color: #333; color: #fff; } @media (max-width: 768px) { .app { font-size: 14px; } }",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-20-responsive/"
  },{
    "title": "[HTML] CSS Float",
    "text": "CSS Float란 Clearfix Clear 속성 Clearfix VS Clear Float 사용시 주의사항 결론 CSS Float이란? Float의 기본 개념 요소가 normal flow에서 벗어나 부모 요소의 왼쪽 또는 오른쪽으로 이동한다. 텍스트와 inline 요소들이 float된 요소 주변을 감싼다. Float의 사용 전통적으로 다단 레이아웃을 만드는 데 사용된다. 이미지나 다른 요소를 텍스트 흐름 내에 배치하는 데 유용 Clearfix Float의 문제점 부모 요소 높이 붕괴 float된 요소는 부모 요소의 높이에 영향을 주지 않아 부모 요소가 높이를 잃을 수 있다. Clearfix 이 문제를 해결하기 위해 clearfix 기법이 사용된다. overflow: auto 또는 overflow: hidden을 부모 요소에 적용한다. 가상 요소 (::after)를 사용하여 float를 해제한다. Clearfix 방법: CSS를 이용한 Clearfix: .clearfix::after { content: \"\"; display: block; clear: both; } 부모 요소에 clearfix 클래스를 추가하여 float 문제를 해결한다. Clear 속성 핵심 문제: 특정 요소가 바로 앞에 있는 float 요소의 영향을 받아 원하는 위치에 배치되지 않을 수 있다. clear 속성의 역할: 특정 요소가 이전의 float 요소 아래로 내려가도록 강제하여 float의 영향을 방지한다. float 요소 다음에 나오는 요소에 주로 사용된다. 사용 예시 (clear 속성): .element { clear: both; } clear: both: 왼쪽과 오른쪽의 float 요소로부터 벗어남. 특정 요소 자체의 위치를 조정하기 위한 용도로 사용된다. Clearfix VS Clear 속성 개념 Clearfix Clear 속성 적용 대상 부모 요소가 float된 자식 요소를 감싸도록 해결 특정 요소가 float 요소의 영향을 받지 않도록 해결 해결 문제 부모 요소 높이 붕괴 문제 특정 요소의 위치 문제 주요 방식 overflow 속성, ::after 가상 요소 clear: left/right/both 속성 사용 위치 부모 요소 float 요소 바로 다음에 나오는 요소 부모 요소의 높이 붕괴 문제를 해결하려면 Clearfix를 사용한다. 요소가 float의 영향을 받아 잘못된 위치에 있을 때는 clear 속성을 사용한다. Float 사용 시 주의사항 Float는 레이아웃의 기본적인 도구이지만, Flexbox나 Grid와 같은 현대적인 레이아웃 기술로 대체될 수 있다. 복잡한 레이아웃에서는 유지보수가 어려워질 수 있다. Float의 대안: Flexbox: 1차원 레이아웃에 적합하며, 요소의 정렬 및 간격 조절에 강력하다. CSS Grid: 2차원 레이아웃에 적합하며, 행과 열을 기반으로 복잡한 레이아웃을 만들 수 있다. 결론 CSS Float는 여전히 유용한 기술이지만, 현대적인 레이아웃 기술과 함께 이해하고 사용하는 것이 중요 프로젝트의 요구 사항에 따라 적절한 레이아웃 기술을 선택해야 함",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-19-css-float/"
  },{
    "title": "[HTML] CSS 문법",
    "text": "CSS란? CSS 문법 기초 CSS 적용 방법 CSS 프로퍼티 값의 단위 CSS란? CSS : Cascading Style Sheets 웹 페이지의 시각적 표현을 담당하는 스타일 언어 다양한 디바이스의 화면 크기에 대응하는 반응형 디자인 구현 내용과 디자인의 분리로 유지보수성 향상 HTML VS CSS HTML 웹페이지 구조와 콘텐츠 정의 CSS HTML 요소의 스타일과 레이아웃 지정 CSS 문법 기초 선택자 (Selector) 스타일을 적용할 HTML 요소 지정 /* 요소 선택자 */ p { color: blue; } /* 클래스 선택자 */ .highlight { background-color: yellow; } /* ID 선택자 */ #header { font-size: 24px; } /* 전체 선택자 */ * { margin: 0; padding: 0; } /* 무조건 뒤에 오는게 이긴다. 뒤로 갈수록 덮어씌우는 개념 */ /* 아이디랑 클래스 중 아이디가 이김 */ 속성 (Property) 변경하고자 하는 스타일의 종류 값 (Value) 속성에 적용할 구체적인 스타일 값 선언 (Declaration) 속성과 값의 쌍 규칙 (Rule) 선택자와 선언 블록의 조합 선택자 { 속성: 값; 속성: 값; } /* 구체적인 예시 */ h1 { color: blue; font-size: 18px; } CSS 적용 방법 인라인 스타일 HTML 요소 내부에 직접 스타일 적용 내부 스타일시트 head 섹션 내 style 태그에 CSS 작성 외부 스타일시트 별도의 .css파일에 스타일 정의 HTML 문서의 head 섹션에서 링크로 연결 CSS 프로퍼티 값의 단위 크기 단위 px : 픽셀 단위, 절대값 % : 백분율 단위, 상대값 em : 요소에 지정된 사이즈에 상대적인 배수 단위 rem : 최상위 요소(html)의 사이즈 기준 배수 단위 Viewport 단위 : vh, vw, vmin, vmax",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-18-css/"
  },{
    "title": "[HTML] Emmet",
    "text": "Emmet이란? Emmet의 강력한 단축키 !+Tab Emmet 사용법 Emmet, 어디에서 사용할 수 있나요? Emmet이란? Emmet은 웹 개발자가 HTML, CSS 코드를 훨씬 빠르고 효율적으로 작성할 수 있도록 도와주는 플러그인입니다. 간단한 축약어를 입력하면 Emmet이 알아서 전체 코드로 확장해줍니다. 예를 들어, ul&gt;li*5&gt;a라고 입력하면 다음과 같은 HTML 코드가 자동으로 생성됩니다. &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; Emmet을 사용하면 이런 불필요한 작업을 줄이고, 개발자는 오롯이 로직과 디자인에 집중할 수 있습니다. Emmet의 강력한 단축키 ! + Tab Emmet을 사용하는 가장 대표적인 사례 중 하나는 ! + Tab 단축키입니다. 이 단축키를 입력하면 기본 HTML 문서의 구조가 즉시 생성됩니다. 예를 들어, 빈 파일에서 !를 입력한 후 Tab 키를 누르면 다음과 같은 기본 HTML 문서가 자동으로 작성됩니다. &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 이 기본 구조는 웹 페이지를 시작할 때 반드시 필요한 요소들로 구성되어 있으며, 직접 입력하는 번거로움을 크게 줄여줍니다. 이 기능만 사용해도 초보자부터 숙련된 개발자까지 작업 시간을 크게 단축할 수 있습니다. Emmet 사용법 (굉장히 쉽고 편리함) Emmet의 문법은 간단하면서도 강력합니다. 몇 가지 기본 규칙만 익히면 금방 능숙하게 사용할 수 있습니다. 자식 요소: &gt; 기호를 사용하여 자식 요소를 생성합니다. 예를 들어, div&gt;p는 &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;로 확장됩니다. 형제 요소: + 기호를 사용하여 형제 요소를 생성합니다. 예를 들어, h2+p는 &lt;h2&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;로 확장됩니다. 반복 요소: * 기호를 사용하여 요소를 반복 생성합니다. 예를 들어, li*3는 &lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;로 확장됩니다. 그룹화: () 괄호를 사용하여 요소들을 그룹으로 묶을 수 있습니다. 예를 들어, div&gt;(header&gt;ul&gt;li*2)+footer는 다음과 같이 확장됩니다. &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/div&gt; 속성 추가: [] 괄호를 사용하여 요소에 속성을 추가할 수 있습니다. 예를 들어, a[href=#]는 &lt;a href=\"#\"&gt;&lt;/a&gt;로 확장됩니다. 여러 속성을 추가하려면 a[href=# title=링크]와 같이 작성합니다. 클래스 및 ID 추가: CSS 선택자처럼 . 기호로 클래스를, # 기호로 ID를 추가할 수 있습니다. 예를 들어, div.container는 &lt;div class=\"container\"&gt;&lt;/div&gt;로, div#header는 &lt;div id=\"header\"&gt;&lt;/div&gt;로 확장됩니다. 여러 개의 클래스를 추가하려면 div.container.main처럼 작성합니다. 텍스트 내용 추가: {} 중괄호 안에 텍스트 내용을 입력할 수 있습니다. 예를 들어, p{안녕하세요}는 &lt;p&gt;안녕하세요&lt;/p&gt;로 확장됩니다. 이 외에도 다양한 기능들이 있지만, 이 정도만 알아도 Emmet의 강력함을 충분히 경험할 수 있습니다. Emmet, 어디에서 사용할 수 있나요? Emmet은 대부분의 텍스트 에디터와 IDE에서 플러그인 형태로 제공됩니다. Visual Studio Code, Sublime Text, Atom, IntelliJ IDEA 등 유명한 에디터에서는 기본적으로 Emmet을 지원하거나, 간단한 설치만으로 사용할 수 있습니다.",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-17-emmet/"
  },{
    "title": "[AI] 생성형 AI와 LLM",
    "text": "LLM 생성형 AI GPT Prompt Engineering RTF Framework LLM (Large Language Model) 광범위한 양의 텍스트 데이터를 학습한 모델 인간의 글과 대화 방식을 받아들이며 더욱 정교하고 자연스러운 대화 능력 갖춰감 생성형 AI (Generative AI) 데이터를 분석하고 학습하여 새로운 콘텐츠를 생성하는 인공지능 기술 GPT (Genertive Pre-trained Transformer) OpenAI가 개발한 대형 언어 모델로, 사전 학습된 트렌스포머 구조를 기반으로 한 생성형 AI기술 트렌스포머 구조 Google의 논문 “Attention is All You Need”에서 소개된 딥러닝 모델 구조 Pre-training 방대한 텍스트 데이터를 기반으로 언어의 패턴과 문맥을 학습 Fine-tuning (미세 조정) 특정 목적이나 응용에 맞춰 추가 학습을 진행하여 성능 최적화 생성 능력 기존 데이터를 이해하고 이를 기반으로 새로운 텍스트 생성 ChatGPT 맥락을 파악하는 능력이 뛰어남 환각(Hallucinate) 실제 데이터나 사실을 반영하지 않고 비현실적이거나 오류를 포함하 내용을 만들어내는 경우가 있다 해결 방법 파인 튜닝 프롬프트 엔지니어링 크로스체킹 Prompt Engineering 어떻게 질문을 하느냐에 따라 결과가 달라질 수 있음 필요성 내가 원하는 바를 정확히 주면 줄수록 정확한 대답을 얻을 수 있음 언제나 고급 모델을 쓸수는 없음 (너무 비쌈) Zero-shot Prompting 작업에 대한 지시만 포함하는 프롬프트 방식 One-shot Prompting 작업 예시를 하나 제공하여 AI가 이를 참고로 결과를 생성하도록 하는 방식 Few-shot Prompting 작업 예시를 여러 개 제공하는 방식 복잡한 작업 수행에서 사용 Chain of Thought (CoT) 모델이 단계적으로 사고 과정을 출력하도록 유도 Zero-shot CoT Tree of Thoughts (ToT) 가능한 대안을 모두 도출하고 그 중 촤선의 답변을 선택하도록 하는 방식 “모든 옵션을 평가하고 가장 좋은 대안을 제시하세요” ReAct 결과물을 생성(Reaction)하고 피드백(Reasoning)을 통해 개선해나가는 방식 “예제를 짜고 정상적으로 작동하는지 검증하시오” RTF Framework Role, Task, Format를 명확히 정의해 프롬프트를 설계하는 방법론 Role-based Prompting AI의 역할을 명확히 지정하여 특정 관점이나 전문성으로 답 얻을 수 있음 Task 특정 작업을 지시 프롬프트의 핵심 Format AI의 응답 형식을 지정 (JSON, 엑셀 등) 면접할때 사용 가능 당신은 백엔드 면접관입니다. 주니어 개발자 면접을 진행할 때 어떤 질문을 묻겠습니까? 학습자의 수준에 맞춘 접근 가능",
    "tags": "ai",
    "url": "/ai/2025-01-16-basic/"
  },{
    "title": "[AI] RAG (Retrieval-Augmented Generation) 이란?",
    "text": "RAG RAG의 작동 방식 RAG의 장점 RAG의 활용 분야 결론 RAG (Retrieval-Augmented Generation) 최근 몇 년 동안 인공지능 분야, 특히 자연어 처리(NLP) 분야는 놀라운 발전을 거듭해 왔습니다. 그 중심에는 사용자의 질문에 답변하거나, 글을 창작하거나, 심지어 코드를 생성하는 등 다양한 작업을 수행할 수 있는 거대 언어 모델(LLM)이 있습니다. 하지만 이러한 강력한 모델도 학습 데이터에 없거나 최신 정보에 대해서는 어려움을 겪을 수 있습니다. 이러한 한계를 극복하기 위해 등장한 기술이 바로 RAG (Retrieval-Augmented Generation), 즉 검색 증강 생성입니다. RAG는 언어 모델이 답변을 생성하기 전에 외부 지식 소스에서 관련 정보를 검색하여 답변의 품질과 정확성을 높이는 방법론입니다. 마치 20년차 개발자가 새로운 기술에 대해 설명하기 전에 관련 문서를 찾아보고 이해하는 과정과 유사하다고 볼 수 있습니다. RAG의 작동 방식 검색 (Retrieval) 사용자의 질문이나 요청이 들어오면, RAG 시스템은 미리 구축된 외부 지식 베이스에서 관련 정보를 검색합니다. 이 지식 베이스는 문서, 웹 페이지, 데이터베이스 등 다양한 형태를 가질 수 있습니다. 검색 과정에서는 질문의 의미를 파악하고, 지식 베이스 내의 정보와 유사성을 비교하여 가장 관련성이 높은 정보를 추출합니다. 생성 (Generation) 검색된 관련 정보는 원래의 질문 또는 요청과 함께 언어 모델에 입력됩니다. 언어 모델은 이 정보를 바탕으로 답변을 생성합니다. 이때, 단순히 검색된 정보를 나열하는 것이 아니라, 검색된 정보를 바탕으로 새로운 문장을 구성하거나, 질문에 대한 답변을 논리적으로 도출하는 등 더욱 풍부하고 맥락에 맞는 답변을 생성할 수 있습니다. RAG의 장점 정보의 최신성 확보 언어 모델은 학습 데이터 시점 이후의 최신 정보에 접근하기 어렵습니다. RAG는 외부 지식 베이스를 통해 실시간 또는 최신 정보를 활용하여 답변의 정확성을 높일 수 있습니다. 답변의 근거 제시 RAG는 답변을 생성할 때 사용된 외부 정보의 출처를 제시할 수 있습니다. 이는 답변의 신뢰도를 높이고, 사용자가 정보를 추가적으로 검증할 수 있도록 돕습니다. 모델 업데이트 비용 절감 기존 언어 모델은 새로운 정보를 학습시키기 위해 모델 전체를 재학습해야 하는 경우가 많아 비용과 시간이 많이 소요됩니다. RAG는 외부 지식 베이스만 업데이트하면 되므로 모델 업데이트 비용을 크게 절감할 수 있습니다. 특정 도메인에 대한 전문성 강화 특정 분야의 지식 베이스를 RAG에 활용하면, 언어 모델은 해당 분야에 대한 전문적인 답변을 제공할 수 있습니다. 예를 들어, 의료 분야의 RAG 시스템은 최신 의학 논문을 검색하여 환자에게 정확한 정보를 제공할 수 있습니다. RAG의 활용 분야 챗봇 및 가상 비서 사용자의 질문에 대해 최신 정보를 기반으로 정확하고 상세한 답변을 제공하는 챗봇을 구축할 수 있습니다. 지식 검색 시스템 방대한 양의 문서나 데이터베이스에서 사용자의 질문에 가장 적합한 정보를 빠르게 찾아 제공하는 시스템을 구축할 수 있습니다. 콘텐츠 생성 특정 주제에 대한 최신 정보를 검색하여 블로그 게시물, 기사, 보고서 등 다양한 형태의 콘텐츠를 생성하는 데 활용될 수 있습니다. 교육 및 연구 학생이나 연구자가 특정 주제에 대한 정보를 검색하고 이해하는 과정을 돕는 도구로 활용될 수 있습니다. 결론 RAG (Retrieval-Augmented Generation)은 언어 모델의 잠재력을 한 단계 더 끌어올리는 중요한 기술입니다. 외부 지식 소스를 활용하여 답변의 정확성, 최신성, 신뢰성을 높임으로써, 인공지능이 더욱 유용하고 신뢰할 수 있는 도구로 발전하는 데 기여할 것입니다. 마치 숙련된 개발자가 끊임없이 새로운 정보를 습득하고 활용하여 문제를 해결하는 것처럼, RAG는 인공지능이 더욱 똑똑하게 정보를 처리하고 활용할 수 있도록 돕는 핵심적인 기술입니다.",
    "tags": "ai",
    "url": "/ai/2025-01-15-rag/"
  },{
    "title": "[Algorithm] Linear Time Sorting Algorithm",
    "text": "Counting Sort Radix Sort Order Statistics Randomized Selection Worst-Case Linear-Time Selection 그외 Counting Sort No comparison sort 조건 데이터의 크기 범위가 제한된 경우 데이터의 갯수가 상수개인 경우 CountingSort(A, B, k) { for i = 1 to k C[i] = 0; for j = 1 to n C[A[j]] += 1; for i = 2 to k C[i] = C[i] + C[i-1]; for j = n downto 1 //stable하게 만들기 위해 1 to n이 아닌 n to 1 수행 B[C[A[j]]] = A[j]; C[A[j]] -= 1; } k가 n개 이하일 때 정렬이 가능하다. k가 너무 큰 경우 각 자리수마다 counting sort를 수행하는 방법을 사용할 수 있다. - radix sort 시간 복잡도 : \\(O(n)\\) 장점 stable하다 단점 in-place 알고리즘은 아니다. (extra place 필요) Radix Sort counting sort의 일반 버전 RadixSort(A, d){ for i=1 to d StableSort(A) on digit i //StableSort = counting sort } 시간 복잡도 : \\(d*O(n)\\) Radix Sort의 핵심은 stable한 것이다. counting sort때문에 in-place하진 않다. 자릿수의 최대 값은 \\(logn\\)이다. 따라서 radix sort가 merge sort보다 빠를 수 있다. 한계 길이가 다른 문자열같은 digit이 정확하지 않으면 사용할 수 없다. Order Statistics n개의 요소들 중 i번째로 작은 요소를 고르는 것 minimun은 첫 번째 order statistic Randomized Selection quicksort의 partition()을 사용한다. 하지만 우리는 오직 하나의 subarray만 평가하면 된다. RandomizedSelect(A, l, r, k) if (l == r) then return A[l]; p = RandomizedPartition(A, l, r) if (p == k) then return A[p]; if (p &lt; k) then return RandomizedSelect(A, l, p-1, k); else return RandomizedSelect(A, p+1, r, k); ``` 시간 복잡도 worst case : \\(O(n^2)\\) best, average case : \\(O(n)\\) Worst-Case Linear-Time Selection generte a good partitioning element Randomized selection에서 pivot value를 고르는데 추가로 $\\Theta(n)$시간을 써 업그레이드한 방법 알고리즘 n개의 element들을 5개씩 묶어 그룹을 만든다. 각 그룹의 중간값을 찾는다. -&gt; \\(O(const)\\) Select()를 재귀적으로 사용해 n/5개의 중간값 x를 찾는다. \\[n/5 + n/25 + n/125 + ... &lt; n\\] x를 중심으로 partition을 진행한다. 시간 복잡도 : \\(O(n)\\) Quick sort에서도 해당 알고리즘을 이용해 worst case의 시간복잡도를 \\(O(nlogn)\\)으로 만들 수 있다. 하지만 이 경우 pivot value를 찾는 과정에서 캐쉬가 한번 뒤집혀져 quick sort의 장점 중 하나인 cache friendly 장점이 사라진다. 차라리 merge sort나 heap sort를 사용한다. 그외 Insertion sort \\[O(n^2)\\] Merge sort, Heap sort, Quick sort comparison sort all comparison sorts are \\(\\Omega(nlogn)\\)",
    "tags": "algorithm",
    "url": "/algorithm/2024-12-13-linear-time-sorting/"
  },{
    "title": "[Algorithm] 분할정복 알고리즘 (Divide and conquer)",
    "text": "분할정복 알고리즘 설계 방법 특징 및 장단점 분할정복 알고리즘 (Divide and conquer algorithm) 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법. 대표적인 예로는 정렬 알고리즘 중에서 퀵 정렬이나 합병 정렬과 이진 탐색, 선택 문제, 고속 푸리에 변환(FFT) 문제들이 있음. 설계 방법 1) Divide ∙  원래 문제가 분할하여 비슷한 유형의 더 작은 하위 문제로 분할이 가능할 때 까지 나눈다. 2) Conquer ∙  각 하위 문제를 재귀적으로 해결한다. 하위 문제의 규모가 나눌 수 없는 단위가 되면 탈출 조건을 설정하고 해결한다. 3) Combine ∙  Conquer한 문제들을 통합하여 원래 문제의 답을 얻어 해결한다. 🖋 Divide를 제대로 나누면 Conquer과정은 자동으로 쉬워진다. 그래서 Divide를 잘 설계하는 것이 중요! 🖋 분할정복 알고리즘은 재귀 알고리즘이 많이 사용되는데, 이 부분에서 분할정복 알고리즘의 효율성을 깎아내릴 수 있다. 특징 및 장단점 ∙  분할된 작은 문제는 원래 문제와 성격이 동일하다  -&gt; 입력 크기만 작아짐 ∙  분할된 문제는 서로 독립적이다(중복 제거 X) -&gt; 순환적 분할  및 결과 결합 가능 ∙  분할정복은 Top-down방식으로 재귀 호출의 장단점과 똑같다고 보면 된다. 장점 단점 ∙  Top-down 재귀방식으로 구현하기 때문에 코드가 직관적이다. ∙  재귀함수 호출로 오버헤드가 발생할 수 있다 ∙  문제를 나누어 해결한다는 특징상 병렬적으로 문제를 해결할 수 있다. ∙  스택에 다량의 데이터가 보관되는 경우 오버플로우가 발생할 수 있다.",
    "tags": "algorithm",
    "url": "/algorithm/2024-12-12-divide-conquer/"
  },{
    "title": "[JAVA] Set",
    "text": "목차 텍스트 블록 formatted() 메서드 레코드 패턴 매칭 case문 개선 Set 데이터 자료구조(데이터 컬렉션) 중 하나로, 특정한 값들을 저장하는 추상자료형 List와 다르게 데이터를 중복해서 저장할 수 없음 저장된 데이터를 인덱스로 관리하지 않기 때문에 저장 순서가 보장되지 않음 수학의 유한 집합을 컴퓨터로 구현한 것 특성 데이터를 비순차적으로 저장할 수 있는 순열 자료구조 삽입한 데이터가 순서대로 저장되지 않음 수정 가능(mutable) 중복해서 삽입 불가능 Fast Lookup이 필요할 때 주로 쓰임 대표적인 클래스 HashSet, TreeSet, LinkedHashSet 클래스들의 주요 메소드 add(E e) 리턴타입 : boolean interator() 리턴타입 : Iterator 검색을 위한 반복자 생성 size() 리턴타입 : int clear() 리턴타입 : void remove(Object o) 리턴타입 : boolean HashSet Set 컬랙션을 구현하는 대표적인 클래스 데이터를 중복 저장할 수 없고 순서를 보장하지 않는다. 예시 Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(\"one\"); set.add(\"two\"); Interator&lt;String&gt; iter = set.iterator(); while(iter.hasNext()) { //꺼낼 것이 있다면 true 리턴 System.out.println(iter.next()); //다음 데이터 리턴 } TreeSet 중복된 데이터를 저장할 수 없고 입력한 순서대로 값을 저장하지 않음 TreeSet은 기본적으로 오름차순으로 데이터를 정렬 LinkedHashSet 입력된 순서대로 데이터를 관리한다. 중복된 데이터를 저장할 수는 없음 저장된 데이터의 존재를 빠르게 확인할 수 있지만 내부에 삽입 순서로 정렬된 목록이 포함됨 포켓몬 고와 같은 게임에서 객체가 이미 목록에 있는지 여부를 빠르게 확인하고 목록에 없는 경우 목록에 추가할 수 있음 LinkedHashSet vs HashSet HashSet은 HashMap을 사용해 개체를 저장 LinkedHashSet은 LinkedHashMap을 사용 삽입 순서를 유지할 필요가 없지만 고유한 개체를 저장해야하는 경우 HashSet이 적합 LinkedHashSet의 성능은 HashSet보다 약간 느림",
    "tags": "java",
    "url": "/java/2024-12-08-set/"
  },{
    "title": "[Spring] Spring 매핑 개념과 주요 애너테이션 활용법",
    "text": "Mapping 맵핑 (Mapping) Mapping 클라이언트로 부터 요청이 들어오는 URL과 컨트롤러 메서드를 연결하는 작업 Mapping 애너테이션을 사용해 클라이언트의 요청이 URL로 들어올 때 해당 URL에 맞는 컨트롤러가 있는지 확인하고 해당 컨트롤러를 매핑하여 요청을 처리 @RequestMapping 클라이언트가 특정 URL로 요청을 보낼 때, 이 요청을 처리할 컨트롤러 메서드를 정의하는 것 Get, Post, Put, Delete, Patch등의 URL을 다 포함하고 있으며, 옵션을 통해 종류를 지정할 수 있음 @Controller public class ProductController { @RequestMapping(\"/products\", method = RequestMethod.GET) public String listProducts() { return \"product-list\"; } @RequestMapping(\"/products\", method = RequestMethod.POST) public String addProducts() { return \"product-added\"; } } HTTP 메서드에 특화된 매핑 @GetMapping GET 요청만 받는 애노테이션 @RequestMapping(method = RequestMethod.GET) @PostMapping POST 요청만 받는 애노테이션 @RequestMapping(method = RequestMethod.POST) @PutMapping PUT 요청만 받는 애노테이션 @RequestMapping(method = RequestMethod.PUT) @DeleteMapping DELETE 요청만 받는 애노테이션 @RequestMapping(method = RequestMethod.DELETE) @PatchtMapping PATCT 요청만 받는 애노테이션 @RequestMapping(method = RequestMethod.PATCH)",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2024-12-03-mapping/"
  },{
    "title": "[Spring] Spring Framework의 주요 개념 (IoC, DI, AOP, PSA)",
    "text": "스프링 콘셉트 스프링 콘셉트 스프링 프레임워크의 주요 개념에 대해 다룬다. IoC Inversion of Control 객체의 생성과 관리를 개발자가 아니라 프레임워크가 대신하는 것 public class A { private B b; } 객체를 직접 생성하지 않고(new 키워드 사용하지 않고) 외부에서 관리하는 객체를 가져와 사용 스프링에서는 스프링 컨테이너가 객체를 관리, 제공하는 역할을 함 스프링 컨테이너 빈이 생성되고 소멸되기 까지의 생명주기를 관리하는 것 DI Dependency Injection 외부에서 객체를 주입받아 사용하는 것 예시 (IoC/DI를 기초로 하는 스프링 코드) public class A { //A에서 B를 주입받음 @Autowired B b; } Bean 스프링 컨테이너가 생성하고 관리하는 객체 스프링은 빈을 컨테이너에 등록하기 위해 XML 파일 설정, 애너테이션 추가 등 방법 제공 AOP Aspect Oriented Programming 프로그래밍 시 핵심 관점과 부가 관점을 나누어 개발하는 것 PSA Portable Service Abstraction 어느 기술을 사용하던 일관된 방식으로 처리하도록 하는 것 대표적인 예 클라이언트의 매핑과 클래스, 메서드의 매핑을 위한 애너테이션",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2024-12-02-spring-basic/"
  },{
    "title": "[JAVA] JAVA 메모리 모델과 변수의 종류 : static, 지역변수, 레퍼런스 변수 이해하기",
    "text": "static 변수 Method Area 지역변수 &amp; 레퍼런스 변수 지역 변수 레퍼런스 변수 JAVA 변수들의 특징 및 차이점 요약 static 변수와 지역 변수 비교 static 변수와 레퍼런스 변수 비교 지역 변수와 레퍼런스 변수 비교 static 변수 인스턴스가 아닌 클래스에 귀속 인스턴스가 여러 개 생성되도 static 변수는 딱 하나 클래스가 메모리에 로드될 때 한 번 생성됨 객체가 아닌 클래스 자체에 저장되기 때문에 모든 객체가 동일한 메모리 위치를 공유함 특징 수명 클래스가 메모리에 로드될 때 생성되고, 프로그램이 종료될 때까지 유지됨 일반적인 지역변수와 달리 블록을 벗어나도 소멸되지 않음 메모리 위치 static 변수는 Method Area에 저장됨 static 변수의 객체 독립성 static 변수가 클래스 자체에 속해 있기 때문에, 객체를 생성하지 않아도 해당 클래스 이름만으로 직접 접근 가능 예시 public class Example { static int staticVar = 10; //static 변수 (클래스 변수) int instanceVar = 20; //인스턴스 변수 (객체 변수) public static void main(String[] args) { //static 변수는 클래스 이름으로 접근 가능 System.out.println(\"Static Variable: \" + Example.staticVar); //출력: 10 //객체를 생성하지 않아도 static 변수에 접근 가능 Example.staticVar = 30; System.out.println(\"Static Variable: \" +Example.staticVar); //출력: 30 //객체를 생성해야 인스턴스 변수에 접근 가능 Example obj1 = new Example(); System.out.println(\"Instance Variable: \" + obj1.instanceVar); //출력: 20 } } static 변수 사용 시점 공유 데이터가 필요할 때 모든 객체에서 동일한 값 공유해아 할 때 사용 예: 총 객체 갯수, 공통 설정값 등 객체와 무관하게 동작해야할 때 클래스 자체의 정보를 나타내거나, 객체 없이 사용 가능한 값을 저장할 때 예: 수학 상수 Math.PI, System.out.println()의 out도 static public class TestClass{ static int number; } public class Test{ public static void main(String []arg){ TestClass class1 = new TestClass(); TestClass class2 = new TestClass(); class1.number = 3; class2.number = 5; System.out.println(\"class1의 number: \" + class1.number); System.out.println(\"class2의 number: \" + class2.number); } } // class1의 number: 5 // class2의 number: 5 마지막에 number에 5가 저장되어있기 때문에 5가 두번 출력 Method Area JVM(Java Virtual Machine)의 메모리 구조 중 하나 클래스 수준의 정보를 저장하는 영역 저장되는 데이터 종류 클래스 정보 클래스의 이름, 부모 클래스, 접근 제어자 등의 메타데이터 클래스 변수 (static 변수) 클래스가 로드될 때 메모리에 할당되며 모든 객체에서 공유됨 메서드 정보 메서드의 이름, 리턴 타입, 매개변수 타입 등 메서드의 바이트코드 포함 상수 (Constant Pool) 컴파일 시 생성된 상수(문자열, 숫자 리터럴 등)와 참조(메서드 참조, 클래스 참조)가 저장됨 런타임 상수 풀(Runtime Constant Pool) 런타임 중에 동적으로 생성된 상수와 참조. 특징 JVM내에서 유일 : 모든 스레드가 공유 수명 : JVM이 종료될 때까지 유지 Garbage Collection 대상 아님 : 클래스 정보는 명시적으로 제거되지 않음 지역변수 &amp; 레퍼런스 변수 지역변수 (Local Variable) 특정 블록이나 함수 안에서만 선언되고 사용가능한 변수 해당 블록이나 함수가 실행을 마치면 메모리에서 삭제되며, 외부에서 접근 불가능 특징 유효 범위 (Scope) 변수가 선언된 블록(중괄호 {}로 감싸진 영역) 내에서만 유효 초기화 필요 지역변수는 자동으로 초기화 되지 않음 메모리 관리 지역변수는 함수 호출시 생성되고, 함수 종료 시 자동으로 소멸됨 일반적으로 스택 메모리 사용 예제 public class Example { public static void main(String[] args) { int x = 1; // x는 main 메서드의 지역 변수 if (x &lt; 10) { int y = 20; // y는 if 블록의 지역 변수 } //y는 if블록 밖에서 사용할 수 없음 } } 레퍼런스 변수 (Reference Variable) 객체의 메모리 주소를 저장한는 변수, 즉 객체를 참조하는 데 사용됨 실제 객체 데이터를 직접 저장하지 않고 객체가 메모리에 위치한 주소만 저장 특징 객체와 연결 레퍼런스 변수는 new키워드 등을 통해 생성된 객체를 가리킴 동적 메모리 사용 레퍼런스 변수가 가리키는 객체는 힙(Heap)메모리에 저장됨 null값 가능 초기화되지 않은 레퍼런스 변수는 null값을 가질 수 있음 null값을 참조하려면 NullPointerException이 발생 두 레퍼런스 변수가 동일한 객체를 가리킬 수 있음 한 레퍼런스 변수를 통해 객체를 수정하면 다른 레퍼런스 변수도 수정됨 예제 public class Example{ public static void main(String[] args) { String str = \"Hello\"; //str은 String객체를 참조하는 레퍼런스 변수 System.out.println(str.length()); //참조된 객체의 메서드 호출 가능 str = null; //str이 아무 객체도 참조하지 않음 //System.out.println(str.length()); //NullPointerException 발생 } } public class Example { public static void main(String[] args) { int[] numbers = {1,2,3}; int[] ref = numbers; //같은 객체 참조 ref[0] = 100; //참조를 통해 객체 수정 System.out.println(numbers[0]); //출력: 100 } } Java 변수 비교: static, 지역 변수, 레퍼런스 변수의 특징과 차이점 static 변수와 지역 변수 비교 특징 static 변수 지역 변수 범위(Scope) 클래스 전체에서 접근 가능 (전역적) 선언된 블록(예: 함수) 내에서만 유효 수명(Lifetime) 프로그램 종료 시까지 유지 블록 실행이 끝나면 소멸 공유 모든 객체가 같은 값을 공유 각 함수 호출마다 독립적으로 생성 메모리 위치 메서드 영역(Method Area) 스택(Stack) 메모리 static 변수와 레퍼런스 변수 비교 특징 static 변수 레퍼런스 변수 저장 내용 클래스 수준에서 공유되는 데이터 객체의 메모리 주소를 저장 초기화 여부 명시적 초기화가 없으면 기본값으로 초기화됨 초기화되지 않으면 null 값을 가짐 수명 클래스 로드부터 프로그램 종료까지 유지 변수의 유효 범위 내에서만 사용 가능 클래스 의존성 클래스와 연결 (객체와 무관) 객체를 가리킴 (객체가 없으면 의미 없음) 메모리 위치 메서드 영역(Method Area) 스택(지역 변수일 때) 또는 힙(객체를 참조할 때) 지역 변수와 레퍼런스 변수 비교 특징 지역 변수 레퍼런스 변수 저장 내용 값 자체 객체의 메모리 주소 유효 범위 선언된 블록 내 객체가 참조되는 동안 메모리 위치 스택 메모리 힙 메모리에 저장된 객체를 참조 초기화 필요성 명시적 초기화 필요 초기화되지 않은 경우 null 값을 가질 수 있음",
    "tags": "java",
    "url": "/java/2024-11-20-variable/"
  },{
    "title": "[JAVA] JAVA version 17의 주요 변화",
    "text": "목차 텍스트 블록 formatted() 메서드 레코드 패턴 매칭 case문 개선 텍스트 블록 이전 버전에서는 여러 줄의 텍스트를 작성할때 \\n을 추가해야해서 가독성이 좋지 않은 부분이 개선되었다. 예시 String example11 = \"SELETE * FROM \\\"product\\\"\\n\" + \"WHERE \\\"country\\\" = \\\"KOREA\\\"\\n\" + \"ORDER BY \\\"name\\\";\\n\"; String example17 = \"\"\" SELECT * FROM \"product\" WHERE \"country\" = \"KOREA\" ORDER BY \"name; \"\"\"; //가독성이 훨씬 좋아졌다 formatted() 메서드 값을 파싱하는 데 더 편하게 해주는 formatted() 메서드 제공 예시 String example17 = \"\"\" { \"id\": %d, \"name\": %s } \"\"\".formatted(1, \"nahyun\"); 레코드 데이터 전달을 위한 객체를 더 빠르고 간편하게 만들기 위한 기능 getter를 자동으로 만들어 주기 때문에 애너테이션이나 메서드로 게터를 정의하지 않아도 됨 예시 record Item(String name, int price) { //파라미터가 private final로 정의된다 } Item product1 = new Item(\"product1\", 2500); product1.price(); //2500 패턴 매칭 타입 확인을 위해 사용하던 instanceof 키워드를 개선 이전에는 instanceof 키워드와 형변환 코드를 조합해야 했지만 이제는 바로 형변환 가능 자료형에 맞는 case 처리 switch-case문에서 자료형에 맞게 case 처리 가능 예시 static double getIntegerValue(Object object) { return switch (object) { case Double d -&gt; d.intValue(); case Float f -&gt; f.intValue(); case String s -&gt; Integer.parseInt(s); default -&gt; 0d; }; }",
    "tags": "java",
    "url": "/java/2024-11-15-java17/"
  },{
    "title": "[CS] 컴파일 언어 VS 인터프리터 언어",
    "text": "컴파일 언어와 인터프리터 언어 컴파일 언어 VS 인터프리터 언어 항상 접할때마다 헷갈려서 정리하기로 했다. 컴파일 언어 한번에 통째 번역 컴파일 타임 사용 코드를 기계어로 바꾸는 시간 이 과정을 거쳐 소스코드는 기계어가 되어 실행가능한 상태가 됨 대표적인 예 C, C++, 러스트, JAVA, Go 인터프리터 언어보다 20~100배 이상 빠름 개발 편의성이 떨어져 개발 과정이 힘듬 인터프리터 언어 스크립트 언어 번역과 실행이 동시에 이루어짐 별도의 실행파일이 필요하지 않고, 빌드 시간이 없음 런타임 사용 프로그램을 실행할 때 한 줄씩 읽고 해석한 뒤 실행 모두 실행하는 속도는 컴파일 언어보다 느림 대표적인 예 Python, Ruby python은 C++로 만들어져 있음 컴파일 언어는 빠르지만 개발 편의성이 떨어져 인터프리터 언어를 만드는데 사용되기도 함",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2024-11-08-language/"
  },{
    "title": "[AWS] AWS 기초",
    "text": "목차 AWS란? S3 &amp; Cloudfront AWS 솔루션 실무 적용 사례 AWS 클라우드 인프라의 구성 요소 AWS 네트워크 구성 요소 설명: 캠퍼스 예시로 이해하기 AWS 초기 설정 및 구성 시 주의점 AWS에 대한 기초 내용 AWS란? Amazon Web Service 클라우드 컴퓨팅 플랫폼 인터넷을 통해 IT리소스(서버, 스토리지, 데이터베이스, 네트워킹 등)를 제공하고 관리하는 서비스 특징 확장성 (Scalability) 사용자가 필요에 따라 리소스를 쉽게 확장, 축소 가능 블랙 프라이데이에는 몇 배의 트래픽이 몰림. 이때마다 하드웨어를 사용하는건 비효율적, 이때만 자원을 사용하고 끝나면 반납할 수 있음 유연성 (Flexibility) 다양한 IT 환경에 맞춰 손쉽게 맞춤화 가능 자바스크립트로 백엔드 많이 사용 비용 효율성 (Cost Efficiency) 초기 자본 투자 없이, 사용한 만큼 지불하는 비용 구조 가용성 높은 가용성과 자동 백업, 복구 기능으로 서비스 중간 최소화 람다 서비스를 처음 띄울 때 서울 4개의 구역에 띄워놓을 수 있음. 한 개의 구역에 오류가 나도 다른 구역에서는 잘 쓸 수 있음. AWS 계정 만들어보기 AWS Cloud Practitioner Essentials (Korean) Cloud Practitioner 자격증 있음 공부하는 것 추천함 (따는건 비쌈) 큰 회사에서는 AWS 자격증이 크게 상관없겠지만, 작은 회사에서는 AWS역량이 필수적 S3 &amp; Cloudfront S3 Simple Storage Service AWS 최초의 서비스 클라우드 파일 저장소 AWS 사용하고 있는 회사라면 99%의 확률로 활용하고 있음 S3는 서버사이트 스크립팅(PHP, Python등)이 필요없는 정적 웹사이트에 최적 기본 개념 버킷 (Bucket) S3에서 데이터를 저장하는 컨테이너 모든 S3객체는 반드시 하나의 버킷에 속해 있음 S3 스토리지의 최상위 계층이며, 사용자가 데이터를 저장하고 관리할 수 있는 폴더와 비슷 컴퓨터에서 C드라이브와 비슷한 느낌 각 버킷은 고유한 이름을 가짐(전세걔 유일) 데이터 저장 위치(region), 권한 설정, 버전 관리, 수명 주기 정책 등 관리 가능 Key S3버킷 내 객체(파일)를 고유하게 식별하는 문자열 버킷 내 키는 객체의 “경로”로 생각 가능 디렉토리 구조를 흉내낼 수 있도록 설계됨 그냥 전체가 하나의 키임 사용 방법 AWS Console AWS Cli FTP 프로그램 file transfer protocol 사이버덕, 파일질라 Cloudfront AWS CDN 서비스 Contents Delivery Network 인터넷 사용자에게 웹 콘텐츠를 빠르고 효율적으로 제공하기 위해 설계된 분산형 서버 네트워크 S3를 비롯한 AWS의 다른 서비스와 연동이 쉬움 AWS를 사용하는 회사라면 99% 사용 S3는 저장에 특화, Cloudfront는 전송에 특화 S3는 직접 접근으로 주로 내부 사용자나 제한된 사용자들에게 제공을 많이함 하지만 Cloudfront는 CDN을 통해 접근하기때문에 속도도 빠르고 캐싱도 됨 S3 1GB당 약 0.117$, Cloudfront 1GB당 0.095$ CloudFront는 약정 계약이 가능 AWS 솔루션 실무 적용 사례 이미지 리사이즈 대역폭 및 비용 감소할 수 있음 첫 번째 AWS 활용 포트폴리오 S3에 이미지가 업로드 되면 자동적으로 원하는 크기로 리사이징하여 저장하는 방법 원하는 사이즈의 이미지를 실시간으로 생성하는 방법 본인이 자신있는 프로그래밍 언어를 선택하여 AWS Lambda 기능을 활용해서 작성 ‘aws cloudfront 이미지 리사이징’ 구글 검색 보안 민감정보 보호 방법 Signed URL 특정 사용자에게만 접근 권한을 부여하기 위해 URL에 만료 시간과 암호화된 서명을 포함한 URL Signed Cookie 특정 조건을 만족하는 사용자만 CloudFront를 통해 콘텐츠에 접근할 수 있도록 설정하는 보안 메커니즘 AWS 클라우드 인프라의 구성 요소 EC2 (Elastic Compute Cloud) 개발자가 클라우드 컴퓨팅 작업을 할 수 있도록 설계된 서비스 가상화된 서버를 하나의 인스턴스 형태로 제공하며, 컴퓨팅 요구사항에 맞게 용량 조절 가능 IDC Internet Data Center 물리적 인프라를 제공하는 시설 리전 (Region) 물리적으로 분리된 지리적 위치 각 리전은 여러 개의 데이터 센터(Availability Zone, AZ)로 구성되어 있음 리전 간 데이터 전송은 네트워크 지연 시간(latency)이 발생할 수 있음 각 리전은 법적, 규제 요구 사항을 충족하도록 설계됨 Availability Zone 리전 내에서 독립적으로 운영되는 데이터 센터 각 AZ는 하나 이상의 데이터 센터로 구성되어 있음 VPC (가상 사설 네트워크) Virtual Private Cloud 네트워크 2개 이상의 컴퓨터나 장치가 서로 데이터를 주고 받을 수 있도록 연결된 시스템 사설 공개되지 않은, 외부와 분리되느 특정 사용자나 조직만 접근할 수 있는 가상 물리적인 하드웨어 장비나 네트워크 인프라 없이, 소프트웨어를 통해 논리적으로 격리 AWS 네트워크 구성 요소 설명: 캠퍼스 예시로 이해하기 퍼블릭 서브넷 Public Subnet public : 인터넷과 직접 연결되어있다. subnet : sub + network, 하나의 네트워크를 더 작은 단위의 네트워크로 (부분 집합) 중앙 운동장, 도서관, 기념품샵 등등 프라이빗 서브넷 Private Subnet 인터넷과 직접 연결되어있지 않다. 교수 연구실, 실험실 (아무나 못들어가는) 라우팅 / 라우팅 테이블 Routing Table 라우팅 : 경로, 네트워크 내에서 데이터가 이동할 경로를 결정 캠퍼스 내 길 / 길 안내 지도 인터넷 게이트웨이 학교 정문 NAT 게이트웨이 Network Address Translation Network Address : IP주소 (Internet Protocol) 네트워크 상에서 각 장치를 식별하기 위해 사용되는 고유한 숫자 주소 내부 네트워크의 사설 IP 주소를 공용 IP주소로 변환 경비실, 차량 차단기, 보안 검사대 네트워크 ACL (Access Control List) 전체 구역 통제 시스템 서브넷 단위 Stateless, 상태 비기반, 독립적인 제어 들어올 때도 검사하고 나갈때도 검사함 우선순위가 있음 차단기의 정책, 비행기 탈 때와 비슷 보안 그룹 (Security Group) 개별 사무실 출입 통제 시스템 기본적으로 모든 트래픽은 차단하며 허용 규칙만 있음 stateful, 상태 기반 (신분증 제출하고 출입증 받아가는 느낌) 라우팅 테이블에 인터넷 게이트웨이랑 퍼블릭 서브넷이 연결 반대로 생각하면 퍼블릭 서브넷과 프라이빗 서브넷을 구분짓는 중요한 요소가 됨 AWS 초기 설정 및 구성 시 주의점 AWS에서 처음으로 제공해주는 VPC는 가급적으로 사용하지 말자 람다를 private 서브에 올리고 nat를 사용하는 것을 추천 람다는 실행할 때마다 ip가 바뀜, 문제가 될 수 있음",
    "tags": "aws",
    "url": "/aws/2024-09-02-aws/"
  },{
    "title": "[JAVA] StringBuilder",
    "text": "목차 String StringBuilder String 반복적으로 String을 연결하거나, 수정해야 할 경우, 보통은 아래와 같은 경우로 string을 사용한다. public class Main{ public static void main(String[] args) { String java = \"자바\"; java += \"공부\"; System.out.println(java); } } 하지만 string은 불변(immutable)객체이므로, “자바”메모리에 “공부”가 추가되는 것이 아니라, 새로운 메모리에 “자바공부”가 저장됨 문자열이 수정될 때마다 새로운 메모리를 할당받기 때문에 성능저하가 일어날 수 있음 StringBuilder StringBuilder는 mutable sequence of characters. 문자열이 변경될 때마다 새로운 메모리를 할당받지 않고, 버퍼를 통해 문자열을 관리하다 toStirng()을 통해 Stirng 객체를 생성 StringBuilder가 효율적인 경우 문자열의 반복적인 연결 문자열의 잦은 수정 대량의 문자열을 처리할 때 단점 StringBuilder는 thread-safe하지 않아 멀티쓰레드 환경에서 좋지 않다. 멀티쓰레스 환경에서는 StringBuffer를 추천 StringBuffer는 StringBuilder와 동일한 API를 사용하지만 각각의 메소드에 대해 동기화를 보장하기 때문 String보다는 빠르고 StirngBuilder보다는 느림",
    "tags": "java",
    "url": "/java/2024-08-29-stringbuilder/"
  },{
    "title": "[Algorithm] 서로소 집합과 유니온 파인드",
    "text": "서로소 집합 유니온 파인드 유니온 파인드의 자료구조 유니온 파인드의 예시 트리와 관련된 용어들 루트 노드, 자식노드, 부모노드, 서브트리, 리프노드, 깊이 이 이미지에서 깊이는 5 이진트리 자식 노드가 2개씩 있는 트리 서로소 집합 서로 공통된 원소를 가지고 있지 않은 두 개 이상의 집합 분리 집합 (Disjoint Set)이라고도 부름 사용 용도 서로 다른 원소들이 같은 집합에 속해있는지, 아닌지 판별할 때 사용 사이클이 존재하는지 판별할때 사용 Union-Find 자료구조로 서로소 집합을 표현 유니온 파인드가 다른 고급 알고리즘의 베이스가 됨 (Kruskal Algorithm) 유니온 파인드 유니온 파인드(Union-Find)의 자료구조 init, find, merge(union) 함수들의 형태로 보통 이루어짐 함수명 고정 X init 초기화 함수 Parent 배열에 대해 자신의 인덱스 값을 가지도록 초기화 초기에 자신의 부모 노드는 자신이라는 의미 void init() { for (int i = 1; i &lt;= n; ++i) { parent[i] = i; } } find 자신의 부모 노드를 찾는 함수 재귀 함수로 구현됨 자기 자신을 가리키는 인덱스 (루트 노드)를 찾을 때까지 반복 int find_parent1(int x) { return x == parent[x] ? x : find_parent1(parent[x]); } int find_parent2(int x) { if (x == parent[x]) return x; else return parent[x] = find_parent2(parent[x]); } // memoization을 사용하는 2가 더 빠름 ``` merge 두 노드를 하나의 집합으로 합치는 함수 y의 부모 노드는 x find 함수를 같이 사용 if 문에서 x == y이면? 사이클이 발생하는 경우이므로 제외 void merge_parent(int x, int y) { int x = find_parent(x); int y = find_parent(y); if (x != y) parent[y] = x; } ``` 유니온 파인드의 예시 최종적으로 오직 루트 노드만이 자기 자신을 가리키게 됨 이러한 특서으로 루트 노드 찾을 수 있음",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-18-day9/"
  },{
    "title": "[JAVA] 키보드로 사용자 입력받는 2가지 방법 (BufferdReader, Scanner)",
    "text": "목차 BufferReader, InputStreamReader, System.in Scanner 1. BufferdReader, InputStreamReader, System.in System.in 일반적으로 keyboard 입력을 지칭하는 Standard Input Stream InputStreamReader byte stream을 character stream으로 변경해주는 역할 수행 InputStreamReader 클래스는 생성자의 파라미터로 InputStream 객체를 전달받음 이 InputStream 객체의 종류에 따라 키보드 사용자 입력을 읽어들일수도 있고, 파일 내용을 읽어들일 수도 있음 사용법 InputstreamReader (InputStream in) InputstreamReader (InputStream in, String charsetName) InputstreamReader (InputStream in, Charset cs) InputstreamReader (InputStream in, CharsetDecoder dec) 생성자의 파라미터로 charset 정보를 전달받아 읽어들이는 stream의 charset을 지정할 수도 있음 BufferedReader 효율적으로 문자를 읽어들이기 위해 버퍼링을 해줌 버퍼링 (Buffering) 효율적인 데이터 처리를 위해 중간 저장공간(Buffer)을 사용하는 것 (주로 입출력에서 사용) 디스크 접근은 시간이 오래걸리기 때문에 한번에 데이터를 저장하여 시간을 줄이고, 필요할 때마다 데이터를 읽음 I/O작업은 시간이 많이 걸리기 때문에 버퍼링으로 접근횟수를 줄여 효율적으로 데이터 사용이 가능 기본 버퍼 사이즈를 그대로 이용할 수도, 생성자를 이용해 버퍼 사이즈를 지정할 수도 있음 보통 FileReader, InputStreamReader의 read()와 같이 비용이 많이 드는 Reader를 파라미터로 전달받아 사용함 만약 BufferedReader없이 FileReader나 InputStreamReader를 사용하면 시스템은 바이트별로 사용자의 입력을 받아서 처리하는 동작을 반복함 시스템에서 IO는 자원소모가 많음 하지만 BufferReader를 사용하면, 시스템은 버퍼가 비어있을 때만, 실제 IO를 일으켜서 데이터를 읽어오고, 나머지 경우에는 메모리에 있는 버퍼의 데이터를 읽어서 처리함 데이터를 문자열로 받아오기 때문에, 적절히 데이터를 처리 후 사용해야 한다. BufferdReader, InputStreamReader, System.in를 이용한 예제 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class UserInput { public static void main(String[] args) throws IOExceptio{ //키보드 사용자 입력을 받을 수 있는 객체 생성 BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); // 입력 데이터 읽기 (한 줄) String str = reader.readLine(); // 입력 데이터 출력 System.out.println(str); } } 2. Scanner Scanner 클래스를 이용하면 1번 방법보다 더 쉽게 사용자 키보드 입력을 받을 수 있음 입력받은 데이터를 Scanner클래스 메소드를 사용해 더 쉽게 가공 가능 예제 import java.util.Scanner; public class ScannerLoop { public static void main(String[] args) { // Scanner 선언 Scanner scanner = new Scanner(System.in); //다음으로 읽어들일 token이 있는지 체크 while (scanner.hasNext()) { //token별로 입력값을 읽어 String을 리턴 String str = scanner.next(); System.out.println(str); } scanner.close(); } } token(공백)별로 사용자 입력값을 읽어들이는 예제",
    "tags": "java",
    "url": "/java/2024-07-17-day8/"
  },{
    "title": "[Algorithm] 동적 계획법 (DP)",
    "text": "목차 Dynamic Programming 정의 DP의 종류 DP 사용조건 DP 유의점 동적 계획법 (DP, Dynamic Programming) 예시 문제 1 1000원짜리 커피를 500원짜리 동전과 100원짜리 동전만 사용하여 계산하려고 한다. 동전을 가장 적게 사용하여 계산하려고 할 때, 필요한 동전의 최소 개수는? (단, 동전은 무수히 많다.) Solution (500 * 2) VS (500 * 1 + 100 * 5) VS (100 * 10) 그리디 알고리즘으로 해결 가능 예시 문제 2 23원짜리 커피를 5원짜리 동전과 2원짜리 동전만 사용하여 계산하려고 한다. 동전을 가장 적게 사용하여 계산하려고 할 때, 필요한 동전의 최소 개수는? (단, 동전은 무수히 많다.) Solution 그리디 알고리즘으로 해결 불가능 그리디 알고리즘을 적용할 수 잇는 조건 중 하나인 최적 부분 구조 조건을 만족하지 않기 때문 지역적으로 최적이 전역적으로도 최적이 아님 Dynamic Programming 정의 이전에 계산한 값을 재사용하여, 하나의 문제를 한 번만 풀게 하는 알고리즘 패러다임 Divide &amp; Conquer과 비슷하지만, 중간 결과를 저장하여 효율성을 높인다는 점에서 차이 이전에 계산해둔 값을 메모리(배열 등)에 저장해서 반복 작업을 줄이는 기법이 핵심 하위 문제의 결과를 먼저 저장하고, 이를 나중에 필요할 때 사용 Tabulation(botton-up), Memoization(top-down) DP의 종류 Top-Down DP 가장 큰 문제부터 풀기 시작하여, 작은 문제들을 재귀적으로 호출하여 답을 구하는 방식 주로 재귀를 통해 해결 ${\\color{yellow}메모이제이션(Memoization)}$을 활용하여 복잡도를 줄임 예시 int fibo(int n) { if (n &lt;= 2 ) return 1; int &amp;ret = dp[n] if (ret != -1) return ret; return ret = fibo(n-1) + fibo(n-2) } Botton-Up DP 작은 문제들을 먼저 풀기 시작하여, 최종적으로 가장 큰 문제들을 해결하는 방식 주로 반복문을 통해 해결 ${\\color{yellow}점화식과 기저사례}$(base case)가 필요 -&gt; ${\\color{yellow}Tabulation}$ 예시 for (int i = 2; i &lt;= 40; ++i) { dp[i] = dp[i-1] + dp[i-2]; } //점화식 DP 사용 조건 겹치는 부분(작은) 문제 (Overlapping Subproblem) 어떠한 문제가 여러 개의 부분(하위) 문제(subproblem)으로 쪼갤 수 있을 대 사용 최적 부분 구조 (Optimal Substructure) 문제의 정답을 작은 문제의 정답에서 구할 수 있을 때 사용 예시 N번째 피보나치 수를 구하는 문제 N-1번째 피보나치 수를 구하는 문제, N-2번째 피보나치 수를 구하는 문제로 쪼갤 수 있음 문제의 정답을 하위 문제의 정답의 합으로 구할 수 있음 재귀로 풀 때 O(2^N) 이미 구했던 값도 다시 계산해야 함 시간 초과 발생 빛 stack overflow 가능성이 높음 반복문으로 풀 때 O(N) 기저사례와 점화식으로 구현 DP 유의점 복잡한 문제의 경우, 점화식을 직접 계산해서 구해야 한다.",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-16-day7/"
  },{
    "title": "[Algorithm] 너비 우선 탐색 &amp; 다익스트라 알고리즘",
    "text": "목차 너비 우선 탐색 BFS 다익스트라 Dijkstra 알고리즘 너비 우선 탐색 (BFS) BFS (Breadth First Search) 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것 루트 노드 (혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 사용 BFS의 특징 재귀적으로 동작하는 DFS와 달리, BFS는 주로 큐(Queue) 사용 사이클이 있는 경우, 무한 루프에 빠지지 않도록 방문하는 방문 체크를 해주어야 함 물웅덩이에 돌멩이를 하나 던지면, 파동이 전체 방향으로 퍼져나가는 동심원의 형태로 탐색이 진행 BFS의 동작 순서 BFS의 구현 빈 큐 q 및 visited 배열 생성 시작 노드 ‘st’를 큐 q에 삽입 노드 ‘st’를 방문한 것으로 표시 큐 q가 비어있지 않은 동안 다음을 반복 : 큐의 맨 앞에서 요소를 꺼내 ‘now’에 저장 큐의 맨 앞의 요소를 제거 ‘now’의 값을 출력하고 뒤에 공백을 붙임 노드 ‘now’의 인접 리스트 v에서 각 이웃 ‘next’에 대해 만약 ‘next’가 아직 방문하지 않은 노드인 경우 : 노드 ‘next’를 방문한 것으로 표시 ‘next’를 큐 q에 넣음 BFS의 시간복잡도 V : 정점(노드)의 수, E : 간선의 수 인접 리스트로 표현된 그래프 O(V+E) 인접 행렬로 표현된 그래프 O(V^2) DFS와 BFS의 공통점과 차이점 공통점 그래프에서 시작 노드로부터 목적지 노드까지 도달하거니 특정 정보를 찾는 것이 목표 방문 기록을 체크해 이미 방문한 노드를 다시 방문하지 않게 하여 무한 루프 방지 DFS, BFS 두 방식 모드 조건 내의 모든 노드를 검색한다는 점에서 시간 복잡도는 동일 차이점 DFS는 주로 재귀로 구현하지만, BFS는 큐(queue) 자료구조를 활용하여 구현 일반적으로 DFS보다 BFS가 조금 더 빠르게 동작 동작 순서 상 DFS는 트리를 탐색할 때 자주 사용, BFS는 최단 경로 탐색에서 자주 사용 시간 복잡도 주어진 그래프의 구조와 시작 노드에 따라서 실제 시간 복잡도가 다를 수 있으며, 어떤 알고리즘이 더 효율적인지는 그래프의 형태와 알고리즘의 목적에 따라 달라짐 일반적으로 어떤 알고리즘을 선택할지는 문제의 특성과 요구사항에 따라 결정 다익스트라 (Dijkstra) 알고리즘 그래프 알고리즘 알고리즘을 사용하는 경우 BFS 사용 시, 격자모양의 미로에서는 상하좌우 방향의 가중치가 모두 동일 현재 정점에서 이어진 간선들의 가중치가 모두 동일 하지만 가중치가 모두 일정하지 않다면 -&gt; BFS를 사용할 수 없음 다익스트라 알고리즘 설명 한 정점에서 다른 모든 정점으로의 최단 경로를 구하는 알고리즘 간선의 가중치가 양수일 때만 사용 가능 음수면 다익스트라가 아닌 테이크스트라 알고리즘 사용 BFS와 유사하지만, 일반적인 큐가 아닌 우선순위 큐(Priority Queue)를 사용하여 비용이 가장 작은 간선부터 탐색한다는 차이점이 있음 우선순위 큐 (Priority Queue) 들어오는 순서에 상관 없이 우선 순위가 높은 데이터가 먼저 나가는 자료구조 Heap을 이용해 구현하는 것이 가장 효율적 ${\\color{red}그리디(Greedy) 알고리즘}$ 매 단계에서 현재까지의 부분 해(solution)를 최적화하여 최종적으로 전체 문제의 최적 해를 찾아냄 다익스트라 알고리즘 동작 순서 출발 노드 선택 출발 노드로부터 각 노드까지의 최단 거리 배열 초기화 출발노드 거리는 0, 나머지 노드는 무한대(충분히 큰 값)로 설정 현재 노드 설정 현재까지의 최단 거리가 확정된 노드 중 가장 가까운 노드 선택 이웃 노드 갱신 선택한 노드를 기준으로 해당 노드와 이웃한 노드들 간의 거리 갱신 모든 노드를 확인할 때까지 3,4단계 반복 핵심 아이디어 각 노드까지의 현재까지 알려진 최단 거리를 계속 갱신하며 출발 노드로부터 최단 경로를 찾는 것 비용이 가장 작은 간선부터 이어주기 위해 우선순위 큐를 사용한다. 다익스트라 알고리즘 시간 복잡도 V : 정점(노드)의 수, E : 간선의 수 O(ElogV) 다익스트라 알고리즘의 구현 문제 예시 방향 그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로의 비용을 구하여라 첫째 줄에 정점의 개수와 간선의 개수가 입력됨 둘째 줄에는 시작 정점의 번호가 입력됨 셋째 줄부터 간선의 개수만큼의 줄에 걸쳐 (u,v,w)가 주어짐 (u,v,w) -&gt; u에서 v로 가는 양의 가중치 w인 간선 존재 구현 예시 출발 노드 선택 출발 노드로부터 각 노드까지의 최단 거리 배열 초기화 현재 노드 설정 이웃 노드 갱신 모든 노드 확인할 때까지 3,4단계 반복",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-15-day6/"
  },{
    "title": "[Algorithm] 깊이 우선 탐색",
    "text": "목차 DFS란? DFS특징 DFS 시간 복잡도 깊이 우선 탐색 (DFS) DFS란?(Depth First Search) 특정 정점(노드)에서 시작해서 트리나 그래프에서 한 가지 경로를 최대한 깊게 탐색하고, 해당 경로를 끝까지 탐색한 후 다른 경로로 이동 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 계속 가다가, 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행하는 방법과 유사 모든 정점을 방문하고자 하는 경우에 사용 DFS 특징 일반적으로 재귀 함수 사용 Stack으로도 구현 가능 모든 경우의 수에 대해 탐색을 진행 사이클이 있는 경우, 무한 루프에 빠지지 않도록 방문 체크 해줘야함 BFS보다 깊은 경로를 빠르게 찾는데 용이 진행 순서 구현 함수 DFS(now): 현재 노드를 방문한 것으로 표시 현재 노드를 출력 모든 이웃노드 'next'에 대해서 반복: 만약 'next'를 아직 방문하지 않았다면: DFS(next) DFS 시간 복잡도 V : 정점(노드)의 수, E : 간선의 수 인접 리스트로 표현된 그래프 O(V+E) 인접 행렬로 표현된 그래프 O(V^2) 희소 그래프 Sparse Graph 그래프 내에 적은 숫자의 간선만을 가지는 그래프 인접 행렬보다 인접 리스트 사용이 유리",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-12-day5/"
  },{
    "title": "[Algorithm] 재귀와 정렬",
    "text": "목차 재귀 정렬 재귀 재귀 : 자신을 정의할 때, 자기 자신을 참조하는 것 재귀 함수 : 함수 내부에서 자기 자신을 호출하는 함수 주의할 점 무한 루프에 빠지지 않도록 종료 조건을 잘 설정 종료 조건을 기저 사례 (base case)라고도 함 함수의 파라미터 및 인자 설정에 유의 정렬 정렬의 종류 삽입 정렬 (Insertion Sort) 최악 O(n^2) 버블 정렬 (Bubble Sort) 최악 O(n^2) 합병 정렬 (Merge Sort) 최악 O(nlogn) 퀵 정렬 (Quick Sort) 최악 O(n^2) 평균 O(nlogn) 설명 배열의 요소들 중에서 피벗(Pivot)을 정하여, 피벗의 앞에는 피벗보다 작은 원소들이 오고, 피벗 뒤에는 피벗보다 큰 값이 오도록 배열을 둘로 나눔 분할된 두 개의 배열의 크기가 0이나 1이 될 때까지, 분할된 두 배열에 대해 재귀적으로 이 과정을 반복 재귀 호출이 한 번 진행될 때마다 최소한 하나의 원소가 최종적인 위치에 있게 되므로, 종료됨이 보장 힙 정렬 (Heap Sort) 최악 O(nlogn) 특정 정렬이 빠르다고 항상 좋은 것은 아님 데이터의 특성, 크기에 따라 적절한 방법 사용해야 함 언어들의 라이브러리 내장 sort 구현 C++ 인트로 정렬 (Intro Sort) 퀵 정렬 + 힙 정렬 + 삽입 정렬 Python 팀 정렬 (Tim Sort) 합병 정렬 + 삽입 정렬 Java Java7 이전에는 병합 정렬, 이후에는 팀 정렬 코테에선 왠만하면 내장 sort함수를 사용",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-11-day4/"
  },{
    "title": "[Algorithm] 문자열",
    "text": "목차 코딩테스트에 자주 나오는 문자열 1) 회문 2) 올바른 괄호 문자열 분할 정복과 백트래킹 1) 분할 정복 2) 백트레킹 코딩테스트에 자주 나오는 문자열 1. 회문 (Palindrome) 앞뒤 방향으로 볼 때, 같은 순서의 문자로 구성된 문자열을 의미 예시 “소주 만 병만 주소”, “Madam, I’m Adam”, “1234321” 2. 올바른 괄호 문자열 (VPS = Valid Parenthesis String) 조건 빈 문자열은 올바른 괄호 문자열이다 S가 올바른 괄호 문자열이라면, (S)도 올바른 괄호 문자열이다. S, T가 괄호 문자열이라면 ST도 올바른 괄호 문자열이다. 보통은 Stack을 사용해서 해결 ’)’가 입력될 때마다, 스택에 있는 ‘(‘를 하나씩 지움 이때, 스택(top)이 비어있거나, ‘(‘가 없으면 올바른 괄호 문자열이 아님 모든 문자열을 순회한 뒤, 스택이 비어있으면 올바른 괄호 문자열 치환 사용하기 ’(‘를 1, ‘)’를 -1로 치환 문자열 S를 전부 순회하며 합 계산 중간에 합이 음수가 되거나, 모든 계산이 끝나고 0이 아니면 올바른 괄호 문자열이 아님 분할 정복과 백트래킹 분할 정복 (Divide and Conquer) 큰 문자를 작은 문제로 분할하여 작은 문제의 답을 모다 큰 문제의 답을 구함 기저 사례(base case)를 잘 설정하여 일정 기준 이상 분할되지 않도록 해야 함 보통 재귀로 구현 예시 피보나치 수열 Z 백트래킹 답이 될 수 없는 경우는 탐색 대상에서 제외하며 효율적으로 답을 구하는 알고리즘 가지치기(pruning)를 통해 연산량을 유의미하게 줄여줌 가지치기를 사용하기 위해서는 현재 상태에서 도달할 수 있는 상태가 모두 답이 될 수 없음을 보여야 함 정확한 시간 복잡도 측정 어려움 보통 재귀로 구현 많이 연습해봐야 익힐 수 있음 예시 스도쿠 대입해보고 현재 상태에서 스도쿠를 완성할 수 없다면, 분기점으로 다시 돌아옴 Nqueen",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-10-day3/"
  },{
    "title": "[Algorithm] 유클리드 호제법",
    "text": "목차 유클리드 호제법 소수 판별법 유클리드 호제법 두 수가 서로 상대방 수를 나누어 원하는 수를 구하는 것 GCD (Greatest Common Divisor) 최대공약수 두 자연수 a, b에 대해서 (a &gt; b) a를 b로 나눈 나머지를 r이라고 하면 a와 b의 최대공약수는 b와 r의 최대공약수와 동일 이 성질에 따라, b를 r로 나눈 나머지 r’를 구하고, 다시 r을 r’로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을때 나누는 수가 a와 b의 최대공약수 예시 1071과 1029의 최대공약수 구하기 1071 % 1029 = 42 1029 % 42 = 21 42 % 21 = 0 21이 1071과 1029의 최대공약수 LCM (Least Common Multiple) 최소공배수 LCM(a, b) = a * b / GCD(a, b) 어떠한 두 수의 곱은, 그 두 수의 최대공약수와 최소공배수의 곱과 같다 cpp의 gcd, lcm 함수는 c++17부터 지원 numeric 모듈 보통 코테에서 c++17 사용 python은 math 모듈의 gcd, lcm 함수 gcd는 python 3.5 lcm은 python 3.9 보통 코테에서 python 3.8 사용 java는 지원하지 않음 소수 판별법 1은 소수, 합성수 아님 에라토스테네스의 체 O(Nlog(logN)) N이 커지면 거의 O(N) 회귀가 아닌 반복",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-09-day2/"
  },{
    "title": "[Algorithm] 시간 복잡도",
    "text": "시간 복잡도 언어별 실행 속도 cpp &gt; Java &gt; python 보통 언어별 시간 보정이 존재 우선 java가 편하니까 Java로 해보기로! 평균적으로 대략 1초에 1억 번 연산 (10^8) 실제 문항을 풀 때, N의 범위를 먼저 확인할 것 시간 복잡도를 고민하지 않고 무작정 구현붜 하면 처음부터 다시 코드를 작성해야함 예를 들어, 시간제한 1초 / 1 &lt;= N &lt;= 10^5 인 경우 O(N^2)는 불가능 O(NlogN)까지 가능",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-08-day1/"
  },{
    "title": "[Flutter] URI과 URL의 차이",
    "text": "목차 URI URL URN URI와 URL의 차이점 flutter앱을 개발하는 도중, http통신관련 코드를 짜면서 Uri.parse()함수를 여러 번 접하게 되었다. 주소 관련 변수명을 url로 쓰고 있어 이 둘의 의미가 혼동되어 정확하게 알아보고자 하였다. URI (Uniform Resource Identifier) 우리 말로 ‘통합 자원 식별자’ Uniform -&gt; 리소스를 식별는 통일된 방식 Resource -&gt; URI로 식별이 가능한 웹 브라우저 파일 및 그 이외의 리소스를 포함하는 모든 종류의 자원 Identifier -&gt; 다른 항목과 구분하기 위해 필요한 정보 즉, URI는 인터넷상의 리소스 자원 자체를 식별하는 고유한 문자열 시퀀스 URL (Uniform Resource Locator) 네트워크상에서 통합 자원(리소스)의 “위치”를 나타내기 위한 규약 웹 사이트 주소 + 컴퓨터 네트워크 상의 자원 특정 웹 페이지의 주소에 접속하기 위해서는 웹 사이트의 주소뿐만 아니라 프로토콜(https, http, sftp, smp 등)을 함께 알아야 접속이 가능한데, URL은 이들 모두를 나타낸다. URN (Uniform Resource Name) 리소스의 위치, 프로토콜, 호스트 등과는 상관없이 각 자원에 이름을 부여한 것 웹 문서의 물리적인 위치와 상관없이 웹 문서 자체를 나타낸다. URI와 URL의 차이점 URI= 식별자, URL=식별자+위치 nan0silver.github.io는 리소스의 이름만 나타내므로 URI https://nan0silver.github.io/는 이름과 위치를 나타내므로 URL (프로토콜 http를 포함하기 때문) URL ⊂ URI URL은 프로토콜과 결합된 상태이다. (프로토콜 + 이름) URI는 그 자체로 이름이 될 수 있다.",
    "tags": "flutter",
    "url": "/flutter/2023-08-14-about-UriUrl/"
  },{
    "title": "[Flask] Flask서버에 외부 접근하는 방법",
    "text": "app.run()안에 바인딩될 호스트 정보를 넣어준다. app.run()은 127.0.0.1로 실행되며 이는 로컬에서만 실행가능하다. app.run(host=’0.0.0.0’)의 경우 모든 호스트로 접근 가능하다. 포트 변경을 원하는 경우 app.run(host=’0.0.0.0’, port=8000)과 같이 사용한다. 위의 방법으로 실행하면 flask서버를 실행한 컴퓨터의 IP주소와 함께 설정한 포트로 연결가능한 주소가 나온다.",
    "tags": "flutter",
    "url": "/flutter/2023-07-01-flask-run/"
  },{
    "title": "[Flutter] Flask 서버와 Flutter 통신",
    "text": "목차 Flask란? Dio Future Flask에서 json형태로 response보내는 함수 Flask란? 웹 애플리케이션 개발을 위한 파이썬 프레임워크 가장 유명한 Django(장고)보다 가볍고 필요한 기능만 최대한 라이트한 개발을 할 수 있다. Dio A powerful Http client for Dart http처럼 서버와 통신하기 위해 필요한 패키지 많은 기능을 가지고 있고, 여러가지 커스텀을 쉽게 할 수 있다. pubspec.yaml에 dependency를 추가해주어야 한다. Http와 json형식의 데이터로 받아올 때 차이점 Http로 요청 후 리턴받은 데이터를 decode해준 값이 Dio로 요청 후 리턴받은 데이터와 동일하다. https://kyungsnim.net/175 에서 참고 Future 지금은 없지만 미래에 요청한 데이터 혹은 에러가 담길 그릇 싱글스레드 환경에서 비동기 처리를 위함 비동기 : 어떤 동작이 완료되지 않아도 다음 동작을 수행하는 것 동기 : 모든 동작이 완료된 후 다음 동작을 수행하는 것 Flask에서 json 형태로 response보내는 함수 jsonify json response를 보내기 위해 이미 content-type header가 ‘application/json’로 되어 있는 flask.Response() 객체를 리턴 jsonify도 함수 내부에서도 json form으로 serialize하는 과정에서 json.dumps를 사용 다만 dump하기 전에 받은 값들을 모두 dictionary로 만들었다. Parameter accept dictionary list json.dumps python이 가지고 있는 json library의 json.dumps() 수동으로 MIME type header를 추가해주어야 하는 encoded string을 리턴한다. flask가 알아서 판단해 response를 자동으로 보내주도록 사용하기 때문에 직접적으로 사용할 수 있다. 다만 reponse header fields는 디폴트(text/html; charset=utf-80)로 처리된다. Parameter accept jsonify보다 더 많은 타입",
    "tags": "flutter",
    "url": "/flutter/2023-04-18-about-flask/"
  },{
    "title": "[Flutter] Flutter UI",
    "text": "Flutter Layout Widget의 생명주기 Flutter Layout Flutter Layout의 핵심은 위젯 위젯은 현재 주어진 상태(데이터)를 기반으로 어떤 UI를 구현할지 정의 플러터 프레임워크는 기존 상태 위젯과 새로운 상태의 위젯을 비교하여 UI변화를 반영 최소한의 리소스로 UI변경을 이룸 레이아웃 모델, 앱 내 이미지, 아이콘, 글자 등 거의 모든 것이 위젯 위젯은 자식을 하나만 갖는 위젯과 자식을 여럿 갖는 위젯으로 나뉨 자식을 하나만 갖는 위젯 container 위젯 자식 위젯을 커스터마이징할 수 있는 위젯 클래스 여백, 간격, 테두리, 배경색 등을 추가할 수 있음 나머지 UI는 속성에 의해 제어됨 (color속성, Text.style속성 등) 자식을 여럿 갖는 위젯 children 매개변수를 입력 받음 리스트로 여러 위젯을 입력할 수 있음 Column 위젯, Row 위젯 children 매개변수에 입력된 모든 위젯들을 세로(가로)로 베치 ListView 위젯 리스트 구현가능, 입력된 위젯이 화면을 벗어나게 되면 스크롤 가능해짐 예시 위의 스크린샷에 해당하는 위젯을 구현하기 위한 위젯 트리이다. ❗️Material apps vs Non-Material apps Material apps 플랫 디자인의 장점을 살리면서도 빛에 따른 종이의 그림자 효과를 이요해 입체감을 살리는 디자인방식을 가진 앱 구글에서 사용하고 있는 플랫 디자인 지침 앱마다 다른 디자인을 통일시키기 위함 Scaffold 위젯 기본적인 material design의 시각적인 레이아웃 구조를 실행한다. Scafflod 위젯 vs Container Scafflod 기본적으로 appbar, body라는 2개의 옵션을 가짐 Container Scafflod의 body부분에 들어가는 부속품 봉지라고 생각하면 됨 한 개의 자식을 가지는 레이아웃 위젯 Container의 생성자는 아래와 같다. Container({ Key key, this.alignment, this.padding, Color color, Decoration decoration, this.foregroundDecoration, double width, double height, BoxConstraints constraints, this.margin, this.transform, this.child, })&lt;/pre&gt; - Widget의 생명주기 Stateful Widget의 생명주기 stateless widget은 한 번 만들어지면 갱신할 수 없어 생명주기가 없다. stateful widget은 10단계의 생명주기가 있다. createState()함수 상태를 생성하는 함수 다른 생명주기 함수들이 포함된 State 클래스를 반환 StatefulWidget 클래스를 상속받는 클래스는 반드시 이 함수를 호출해야 한다. Class MyHomePage extends StatefulWidget { @override _MyHomePageState createState() =&gt; new _MyHomePageState(); } mounted == true createState() 함수가 호출되어 상태가 생성되면 mounted 속성이 true가 된다. 위젯을 제어할 수 있는 buildContext클래스에 접근 가능해짐 buildContext가 활성화되어야 setState()함수 이용 가능 initState()함수 위젯을 초기화하는 함수 주로 데이터 목록을 만들거나 처음 필요한 데이터를 주고받을 때 호출 이 함수를 호출할 때 내부에서 _getJsonData() 함수를 호출하면 서버에서 데이터를 가져와 화면에 출력할 수 있음 didChangeDependencies()함수 initState()함수 호출 후, 해당 위젯이 데이터에 의존하는 위젯이라면 반드시 호출해야하는 함수 주로 상속받은 위젯을 사용할 때 피상속자가 변경되면 호출 build()함수 위젯을 화면에 렌더링하는 함수 (Widget을 반환한다.) @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Page'), ); } didUpdateWidget()함수 부모 위젯이나 데이터가 변경되어 위젯을 갱신해야 할 때 호출하는 함수 initState()함수는 위젯을 초기화할 때 한 번만 호출되므로 위젯이 변경되었을 때 이 함수를 호출해야함 setState()함수 데이터가 변경되었다는 것을 알려주고 이를 반영하여 화면 UI를 변경하는 함수 deactive()함수 위젯의 상태 관리를 중지하는 함수 State객체가 플러터 구성 트리에서 제거될 때 호출됨 dispose()함수를 호출하기 전까지는 State객체를 재사용할 수 있게 해줌 dispose()함수 State객체를 영구적으로 소멸할 때 호출되는 함수 mounted == false 생명주기를 끝내주는 함수 false가 된 다음 이 State는 재사용할 수 없다.",
    "tags": "flutter",
    "url": "/flutter/2023-04-13-flutter-UI/"
  },{
    "title": "[Flutter] Start Flutter",
    "text": "목차 What is Flutter Dart Flutter Project What is Flutter? 크로스 플랫폼 앱 개발 프레임 워크 Dart 언어 사용 구글에서 만듬 컴파일 언어의 특징을 활용하여 앱 개발 가능 프레임워크, 엔진, 임베더 계층으로 구성 프레임워크 Dart로 개발된 여러 클래스로 앱 개발 엔진 플러터의 코어 C, C++ 데이터 통신, 다트 컴파일, 렌더링, 시스템 이벤트 임베더 플러터 앱이 크로스 플랫폼에서 동작하도록 플러터 엔진이 렌더링한 결과를 플랫폼별 네이티브 언어로 뷰를 만들어 화면에 보여줌 네이티브 언어 안드로이드 : 자바, 코틀린 IOS : 오브젝티브-C, 스위프트 플러터의 장점 높은 개발 효율 hot reload 코드 변경 이후 빌드시간에 의한 낭비되는 시간을 없애기 위해 업데이트된 소스파일들이 dart virtual machine에 주입되면 flutter는 변경된 사안을 기반으로 widge tree를 재구성 -&gt; 변경된 것이 빠르게 결과물에 적용됨 유연한 사용자 인터페이스 다양한 위젯 제공 강력한 애니메이션 기능 제공 빠른 속도 Dart 비동기 처리 방식 작업이 끝나기를 기다리지 않고 다음 작업을 처리하게 하는 것 작동 방식 async 함수를 비동기로 만듬 await 비동기 함수 안에서 언제 끝날지 모르는 작업 앞에 붙임 해당 작업의 결과를 받기 위해 비동기 함수이름 앞에 Future 붙임 예시 코드 Future checkVersion() async { var version = await lookUpVersion(); print(version); }&lt;/pre&gt; 하나의 thread로 동작 Flutter Project lib 폴더 플러터 앱 개발을 위한 다트 파일 pubspec.yaml 플러터의 다양한 패키지, 이미지, 폰트 사용할수 있게 해줌",
    "tags": "flutter",
    "url": "/flutter/2023-04-06-start-flutter/"
  }]};
