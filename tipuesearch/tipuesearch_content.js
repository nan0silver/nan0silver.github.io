var tipuesearch = {"pages": [{
    "title": "[Spring] JPA vs MyBatis",
    "text": "JPA란? MyBatis란? 🔍 JPA vs MyBatis JPA vs MyBatis 비유로 이해하기 JPA vs MyBatis 코드로 비교하기 사용 방식 차이 요약 장단점 비교 실무에 쓰는 방법 한줄 정리 📌 JPA란? (Java Persistence API) 자바에서 관계형 데이터베이스(RDB)를 객체로 다룰 수 있게 해주는 표준 API. SQL을 직접 작성하지 않아도 객체처럼 DB 데이터를 저장/조회/수정/삭제 가능. 구현체 중 가장 유명한 것은 Hibernate고, Spring에서 주로 이걸 씀. JPA 핵심 용어 용어 설명 Entity DB 테이블과 매핑되는 자바 클래스 EntityManager JPA의 핵심! DB와 객체 사이의 작업을 처리하는 도구 Persistence Context (영속성 컨텍스트) 엔티티를 관리하는 JPA 내부 메모리 공간 JPQL (Java Persistence Query Language) 객체 지향 쿼리 언어. SQL과 유사하지만, 테이블이 아닌 클래스/필드 단위로 작동 📌 MyBatis란? 자바에서 SQL을 직접 작성해서 데이터베이스와 통신할 수 있게 해주는 프레임워크. SQL 중심의 프로그래밍이 가능하고, 복잡하고 세밀한 쿼리 제어에 유리함. XML 또는 어노테이션 기반으로 SQL을 작성하고, 쿼리 결과를 자바 객체와 매핑해줌. Spring과도 쉽게 통합 가능하며, 실무에서는 여전히 널리 사용됨. MyBatis 핵심 용어 용어 설명 Mapper 인터페이스 SQL 문장을 호출하는 자바 인터페이스. XML과 1:1 매칭되어 동작함 Mapper XML 실제 SQL이 작성되는 파일. &lt;select&gt;, &lt;insert&gt; 등 태그로 구성됨 SqlSession DB 연결과 SQL 실행을 담당하는 핵심 객체 (JDBC의 Connection 역할) ResultMap 쿼리 결과를 자바 객체에 정밀하게 매핑할 때 사용하는 설정 #{} / ${} SQL 파라미터 바인딩 방식. #{}는 안전한 바인딩, ${}는 SQL 인젝션 주의 TypeAlias 자바 클래스의 이름을 짧게 별칭으로 사용할 수 있도록 하는 기능 🔍 JPA vs MyBatis 항목 JPA MyBatis 개발 방식 자동 매핑 (객체 중심) 수동 매핑 (SQL 중심) 핵심 개념 객체를 DB에 자동 매핑 직접 SQL 작성 + 매핑 학습 곡선 좀 더 높음 (추상화 많음) 비교적 쉬움 (SQL 그대로 작성) 유연성 추상화 많아 덜 유연함 SQL 작성 자유로움 성능 제어 ORM에 맡김 (튜닝 어려움) 직접 SQL 작성으로 제어 쉬움 대표 도구 Hibernate (JPA 구현체) MyBatis 프레임워크 JPA vs MyBatis 비유로 이해하기 ☝️ JPA = 자동세탁기 👕 세탁기 안에 옷(객체)을 넣으면 → 알아서 물(쿼리) 넣고, 빨고, 말리고 → 깨끗한 결과(조회된 객체)를 자동으로 꺼내줌! → 개발자는 “옷만 넣고 결과만 받으면 됨” → 단, 세탁 방식은 기계가 알아서 함 (튜닝 어려움) ✌️ MyBatis = 손빨래 🧼 개발자가 직접 물 붓고, 비비고, 헹구고 어떤 SQL 쿼리를 쓰고, 어떤 칼럼을 어떤 필드에 넣을지도 직접 지정 → 개발자는 “컨트롤을 많이 할 수 있음” → 다만 귀찮고 실수할 가능성 있음 🧩 JPA vs MyBatis 코드로 비교하기 ✅ JPA 예제 (Hibernate 기반) @Entity public class Member { @Id @GeneratedValue private Long id; private String name; } // 저장 Member m = new Member(\"Sungwoo\"); entityManager.persist(m); // 조회 Member result = entityManager.find(Member.class, m.getId()); 👉 SQL 없이 객체만 조작하면 됨! → INSERT, SELECT, UPDATE, DELETE를 자동으로 처리 ✅ MyBatis 예제 &lt;!-- mapper.xml --&gt; &lt;select id=\"findMemberById\" parameterType=\"long\" resultType=\"Member\"&gt; SELECT id, name FROM members WHERE id = #{id} &lt;/select&gt; // 자바 코드 Member m = memberMapper.findMemberById(1L); 👉 SQL을 내가 직접 작성함 → DB 구조가 복잡하거나 튜닝이 필요할 땐 더 유리 ✅ 사용 방식 차이 요약 항목 JPA MyBatis SQL 작성 ❌ 안 함 (자동) ✅ 직접 함 객체 ↔ DB 매핑 자동 처리 명시적 지정 코드 양 적음 많음 유지보수 테이블 구조 바뀌면 자동 적용 SQL 전부 수정해야 함 복잡한 쿼리 어려움 (JPQL, QueryDSL) 자유롭고 세밀하게 가능 ✅ 장단점 비교 🟢 JPA의 장점 생산성 높음 (코드 적게 작성) 객체 지향적으로 설계 가능 유지보수 편함 (쿼리 덜 바꿈) 캐싱, 지연 로딩, 영속성 컨텍스트 등 부가기능 풍부 🔴 JPA의 단점 처음 배울 때 어렵고 추상화가 깊음 성능 튜닝 어려움 복잡한 쿼리 작성이 불편함 (JOIN, GROUP BY 등) 🟢 MyBatis의 장점 SQL을 자유롭게 짤 수 있어 → DB 성능 튜닝 유리 복잡한 쿼리나 데이터 조작에 강함 개발자 컨트롤이 높음 🔴 MyBatis의 단점 반복 코드 많음 (SQL + 매핑 따로) 유지보수 힘듦 (테이블 구조 바뀌면 SQL 전부 바꿔야 함) 객체 지향 구조 만들기 어렵고, 연결이 느슨함 ✅ 실무에 쓰는 방법 상황 실무 선택 단순한 CRUD 위주의 서비스 JPA (빠르고 코드 간결) 복잡한 SQL 다루는 시스템 MyBatis 대기업/공공 시스템 아직도 MyBatis 많음 스타트업/신규 프로젝트 JPA + QueryDSL 조합 인기 둘 다 필요 일부는 JPA, 일부는 MyBatis 혼용 (실제로 많음) 📌 한줄 정리 “JPA는 객체 중심의 ORM 프레임워크로, DB와의 데이터 처리를 추상화해 코드 생산성을 높여줍니다. 반면 MyBatis는 SQL 중심의 프레임워크로, 복잡한 쿼리나 성능 튜닝이 필요한 경우에 유리합니다. 프로젝트 성격에 따라 두 기술을 선택하거나 병행할 수 있습니다.”",
    "tags": "spring",
    "url": "/spring/2025-04-05-jpa-mybatis/"
  },{
    "title": "[Spring] DTO vs VO vs Entity",
    "text": "DTO vs VO vs Entity 📦 DTO vs VO 📦 Entity vs VO 📦 Entity와 DTO로 분리해야하는 이유 코드 예제 💬 면접 시 설명 예시 🚀 Java 17부터는 record로 VO를 만들기 더 쉬워짐! DTO vs VO vs Entity Entity는 DB와 매핑되는 핵심 객체, DTO는 데이터 전달용 객체, VO는 값 자체에 의미가 있는 불변 객체 Entity는 저장용, DTO는 전달용, VO는 표현용 객체 DTO : Data Transfer Object ➡️ 데이터 전달용 객체 (계층 간, 네트워크 등) 🚐 손님에게 배달될 포장된 도시락 음식점 → 배달기사 → 고객까지 전달하는 용도 💡 클라이언트와 데이터 주고받는 운반용 객체! 💡 메뉴명, 수량, 요청사항 등 담겨 있고, 전달 중에 수정될 수도 있음 (상황에 따라 포장을 다르게 담을 수 있다.) 외부에 노출되는 API요청이나 응답은 Entity가 아닌 DTO를 통해 전달함으로써 보안성과 유연성을 확보 🔴 DTO는 데이터를 “옮기는 상자” VO : Value Object ➡️ 값을 표현하는 객체 (의미 있는 불변 값) 🍱 도시락 자체 만들어지면 바꿀 수 없음 (불변) 메뉴가 같으면 같은 도시락 취급 값 자체가 의미 있음 - 예: 좌표, 돈, 날짜, 주소 등 🔴 VO는 의미 있는 값을 담은 “정체성 있는 객체” “무엇을 나타내는 값인지”가 중요한 객체 Entity ➡️ 실제 DB 테이블과 연결된 핵심 객체 🍱 도시락 안의 구성 요소 (밥, 반찬, 소스 등) 소중하기 때문에 주방 안에서만 써야 함 Entity는 VO를 포함할 수 있음 DB와 직접 연결된 객체이기 때문에 식별자가 존재하며 상태가 바뀔 수 있음 🔴 Entity는 “누구인지”를 식별할 수 있는 객체 📦 DTO vs VO 구분 DTO VO 목적 데이터 전달 값 표현 가변성 가변(mutable) 불변(immutable) equals/hashCode 기준 주소 (기본) 값 기준으로 재정의 주 사용 위치 Controller ↔ Service ↔ API 도메인 내부, 로직 내 값 처리 예시 회원 요청 객체, 응답 DTO 등 Money, Address, Coordinate 등 생성 시 언제든 생성 가능 생성 후에는 값 변경 ❌ 📦 Entity vs VO 항목 Entity VO 의미 DB 테이블과 1:1 매핑되는 객체 의미 있는 작은 값 단위 객체 식별자 (ID) 있음 (PK, 고유값) 없음 (값 자체로 구별) 불변성 보통 가변 보통 불변 (final) 관리 위치 DB와 연결되는 핵심 모델 Entity 안의 필드나 계산용 값 📦 Entity와 DTO로 분리해야하는 이유 굳이 클래스를 2개로 나누지 않고 그냥 Entity 하나로 다 처리하면 안 되는 이유! 구체적인 이유 5가지 보안 Entity에는 민감한 필드(비밀번호 등)가 있을 수 있음 ➡️ 그대로 외부에 노출하면 위험 유연성 API 요청/응답마다 필요한 필드가 다름 ➡️ DTO로 맞춤 설계 가능 엔티티 보호 DTO로 외부와 통신 ➡️ Entity는 내부에서만 안전하게 관리 유효성 검사 분리 @Valid, @NotNull등 검증 로직은 DTO에만 적용 Entity는 DB와 연결된 순수한 모델이여야 함으로 비즈니스 룰, 요청 유효성 검증 같은 책임이 없어야 한다. JPA의 역할은 저장, 조회인데 검증 로직이 섞이면 책임이 뒤엉킴 (SRP(Single Responsibility Principle) 위반) 레이어 분리 원칙 Controller ↔ Service ↔ Repository 역할 구분이 명확해짐 “Controller” : 클라이언트와 통신 (DTO 입출력) “Service” : 비즈니스 로직 (DTO 🔁 Entity 변환, 로직 처리) “Repository” : DB 접근 (Entity 전용) DTO와 Entity를 나누지 않고 Controller, Service에서 Entity를 직접 다루면 한 객체가 너무 많은 계층을 넘나듬 (의존성 얽힘) 책임이 명확하지 않음 (수정 시 어디를 고쳐야 할지 모름) 보안 이슈 발생 가능 (불필요한 필드 노출) 코드 예제 ✅ DTO (값 전달용, 가변 객체) public class MemberDTO { private String name; private int age; // 생성자 public MemberDTO(String name, int age) { this.name = name; this.age = age; } // getter &amp; setter (값 변경 가능!) public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } setName(), setAge()처럼 값은 변경 가능 주로 Controller 🔁 Service 🔁 Client 간 데이터 전달용 ✅ VO (값 표현용, 불변 객체) public class Money { private final int amount; public Money(int amount) { this.amount = amount; } public int getAmount() { return amount; } // 값 기반 equals, hashCode @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Money)) return false; Money money = (Money) o; return amount == money.amount; } @Override public int hashCode() { return Integer.hashCode(amount); } } 필드가 final, setter없음 → 불변 객체 equals() 재정의 → 값이 같으면 같은 객체로 간주 주로 비즈니스 로직 내부에서 의미 있는 값 표현용 ✅ Entity @Entity public class Member { @Id @GeneratedValue private Long id; private String name; private String password; // 노출되면 안 되는 정보 } 💬 면접 시 설명 예시 “DTO는 계층 간 데이터를 전달할 때 사용하는 객체로, 보통 가변이고 네트워크나 컨트롤러에 노출됩니다. 반면 VO는 불변 객체로, 값 자체가 의미를 가지며 equals와 hashCode를 통해 같은 값을 같다고 간주해 도메인 모델 내에서 활용됩니다. Entity는 DB와 직접 연결된 객체로 식별자가 존재하며 상태가 바뀔 수 있습니다. 외부에 노출되는 API 요청이나 응답은 Entity가 아닌 DTO를 통해 전달함으로써 보안성과 유연성을 확보할 수 있습니다.” 🚀 Java 17부터는 record로 VO를 만들기 더 쉬워짐! public record Coordinate(int x, int y) {} final, 불변성, equals/hashCode 자동 구현! 값 객체(VO)를 표현할 때 record는 아주 강력한 도구",
    "tags": "spring",
    "url": "/spring/2025-04-02-dto-vo/"
  },{
    "title": "[Spring] RestTemplate",
    "text": "RestTemplate이란? 필요한 이유 예시 코드 (Get) 주요 메서드들 응답을 객체로 받기 (JSON → Java 객체) RestTemplate vs WebClient 핵심 비교 코드로 비교 결론: 언제 뭘 쓰면 좋을까? ✅ RestTemplate이란? RestTemplate은 Spring에서 다른 서버의 REST API와 통신할 수 있도록 도와주는 HTTP 클라이언트. 즉, 서버끼리 통신할 때: 다른 서버에 요청을 보내고(GET, POST, PUT, DELETE 등), 그 응답을 받아서 처리할 수 있도록 도와주는 도구 🧠 필요한 이유 웹 애플리케이션을 만들다 보면, 다른 서버에 있는 데이터를 가져오거나 (예: Kakao Map API, 날씨 API) 다른 서버에 정보를 보내야 할 때 이때 RestTemplate이 HTTP 요청/응답을 대신 처리해주는 역할을 함. ⚙️ 예시 코드 (GET 요청) import org.springframework.web.client.RestTemplate; public class Example { public static void main(String[] args) { RestTemplate restTemplate = new RestTemplate(); String url = \"https://api.agify.io/?name=seongwoo\"; // 이름을 넣으면 예상 나이를 알려주는 무료 API String response = restTemplate.getForObject(url, String.class); System.out.println(response); // 출력 예: {\"name\":\"seongwoo\",\"age\":27,\"count\":1123} } } 여기서 getForObject()는 GET 요청을 보내고, 결과를 String 타입으로 받아오는 함수. 🔧 주요 메서드들 메서드 설명 getForObject() GET 요청 후, 결과를 객체로 받음 getForEntity() GET 요청 후, 전체 응답(ResponseEntity) 받음 postForObject() POST 요청 후, 결과를 객체로 받음 postForEntity() POST 요청 후, 전체 응답 받음 put() PUT 요청 (응답 없음) delete() DELETE 요청 📦 응답을 객체로 받기 (JSON → Java 객체) public class AgifyResponse { private String name; private int age; private int count; // 꼭! Getter/Setter 만들어줘야 함 (Lombok 써도 됨) } RestTemplate restTemplate = new RestTemplate(); String url = \"https://api.agify.io/?name=seongwoo\"; AgifyResponse response = restTemplate.getForObject(url, AgifyResponse.class); System.out.println(response.getAge()); // 예: 27 → JSON 데이터를 Java 객체로 자동으로 바꿔줌! (Jackson 같은 라이브러리를 내부에서 사용함) 💡 RestTemplate 특징 요약 동기 방식이다 (요청을 보내고 응답 올 때까지 기다림) 간단한 API 호출엔 유용하지만, 요즘은 WebClient 사용이 증가 (비동기 처리, reactive 프로그래밍에 적합) Spring 5 이후로는 RestTemplate은 점점 deprecated 방향이지만, 여전히 많이 사용됨 🆚 RestTemplate vs WebClient 핵심 비교 항목 RestTemplate WebClient 방식 동기(Synchronous) 비동기(Asynchronous) (동기도 가능) 등장 시기 오래됨 (Spring 3.x부터) 최신 (Spring 5, WebFlux부터 등장) 쓰레드 처리 요청 → 응답 올 때까지 쓰레드 점유 응답 기다리는 동안 쓰레드 반환, 더 효율적 성능 단순 요청에는 충분 고성능 시스템, MSA에서 더 좋음 사용성 코드가 간단하고 직관적 비동기라 처음엔 약간 복잡할 수 있음 미래 방향 Deprecated 예정 (Spring 6에서는 제거될 수 있음) Spring이 권장하는 표준 방식 🔧 코드로 비교 1️⃣ RestTemplate 예시 (동기) RestTemplate restTemplate = new RestTemplate(); String url = \"https://api.agify.io/?name=seongwoo\"; String result = restTemplate.getForObject(url, String.class); System.out.println(result); → 응답이 올 때까지 기다림. 동기 처리. 2️⃣ WebClient 예시 (비동기 + 동기화 처리 가능) import org.springframework.web.reactive.function.client.WebClient; import reactor.core.publisher.Mono; WebClient webClient = WebClient.create(); String url = \"https://api.agify.io/?name=seongwoo\"; // 비동기 방식 → block()을 붙이면 동기처럼 동작 String result = webClient.get() .uri(url) .retrieve() .bodyToMono(String.class) .block(); // 이게 바로 응답 받을 때까지 기다리는 코드 (동기화) System.out.println(result); → WebClient는 원래 비동기지만, .block()을 붙이면 동기처럼 사용할 수도 있음. 💬 비동기 방식으로 진짜 쓰고 싶다면? webClient.get() .uri(url) .retrieve() .bodyToMono(String.class) .subscribe(result -&gt; { System.out.println(\"결과: \" + result); }); System.out.println(\"여긴 먼저 실행됨!\"); // 비동기니까 이게 먼저 출력될 수도 있음 ✅ 결론: 언제 뭘 쓰면 좋을까? 상황 추천 간단한 테스트, 외부 API 한두 번 호출할 때 RestTemplate (빠르게 개발 가능) 마이크로서비스 간 통신, 대용량 처리, reactive 시스템 WebClient (성능과 확장성 좋음) Spring 5 이상 + 새로운 프로젝트 WebClient를 사용하는 게 미래지향적",
    "tags": "spring",
    "url": "/spring/2025-04-01-resttemplate/"
  },{
    "title": "[Etc] 💣 SQL Injection",
    "text": "SQL Injection이란? Spring 관점에서 SQL Injection 방지법 요약 SQL Injection이란? SQL Injection이란, 사용자가 입력한 값을 통해 원래 의도하지 않은 SQL문을 실행하게 만들어 데이터베이스의 데이터를 탈취하거나 조작하는 공격 🔍 예시 (Spring 쓰기 전 일반 JDBC 코드 기준): String sql = \"SELECT * FROM users WHERE username = '\" + username + \"'\"; 만약 username에 아래와 같은 값을 입력하면? ' OR '1'='1 그러면 쿼리가 이렇게 바뀜: SELECT * FROM users WHERE username = '' OR '1'='1' → 모든 유저 정보가 다 조회됨 😱 → 비밀번호 없이 로그인도 가능해짐 🔐 Spring 관점에서 SQL Injection 방지법 ✅ 1. JDBC 직접 사용 시: PreparedStatement 필수! String sql = \"SELECT * FROM users WHERE username = ?\"; PreparedStatement pstmt = conn.prepareStatement(sql); pstmt.setString(1, username); // 자동으로 문자열 escape 처리 이렇게 하면 ' OR '1'='1 같은 입력도 그냥 문자열로 인식되므로 안전하다. ✅ 2. Spring JDBC Template 사용 시 String sql = \"SELECT * FROM users WHERE username = ?\"; User user = jdbcTemplate.queryForObject(sql, new Object[]{username}, userRowMapper); 여기서도 ?를 사용해서 바인딩하면 PreparedStatement가 적용되므로 안전하다. ✅ 3. JPA / Spring Data JPA 사용 시 JPA는 SQL을 직접 작성하지 않고 엔티티 중심으로 데이터를 다루기 때문에 기본적으로 SQL Injection에 강함! 🔸 예시: User user = userRepository.findByUsername(username); 이런 방식은 내부적으로 PreparedStatement를 사용하기 때문에 안전함. 🔸 커스텀 JPQL 사용 시에도 파라미터 바인딩 필수! @Query(\"SELECT u FROM User u WHERE u.username = :username\") User findByUsername(@Param(\"username\") String username); ✅ :username 형태로 파라미터 바인딩하면 OK ❌ 아래처럼 문자열 직접 연결하면 위험: @Query(\"SELECT u FROM User u WHERE u.username = '\" + username + \"'\") 🚨 Spring 배우는 입장에서 조심할 포인트 요약 상황 안전한 방법 주의할 점 JDBC 직접 사용 PreparedStatement 문자열 직접 연결 ❌ JdbcTemplate ? 자리 바인딩 사용 쿼리 조합 ❌ JPA / Spring Data JPA 파라미터 바인딩 (:param) JPQL 문자열 직접 붙이기 ❌ QueryDSL 완전 안전 (타입 기반 쿼리) - 사용자 입력값 처리 입력 검증, 길이 제한 필터 없이 바로 사용 ❌ 🎯 마무리 요약 SQL Injection = 사용자가 입력한 값을 통해 악성 SQL 실행 Spring에서는 기본적으로 PreparedStatement 방식이므로 잘 쓰면 안전함 하지만 직접 쿼리 짜거나, 문자열로 SQL을 조합하는 경우 주의! ORM(JPA) + 파라미터 바인딩 방식으로 작성하면 거의 대부분 안전하게 막을 수 있음",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-03-31-sql-injection/"
  },{
    "title": "[Algorithm] 소수 빠르게 찾는 법",
    "text": "기본 소수 판별 에라토스테네스의 체 Miller-Rabin 소수 판별법 1️⃣ 기본 소수 판별 (O(√N)) 어떤 숫자 N이 소수인지 판별하는 가장 기본적인 방법은 1과 자기 자신을 제외한 다른 수로 나누어떨어지는지 확인하는 것 🔥 2부터 √N까지 나누어보자! 소수가 아니라면 작은 약수를 가지고 있기 때문 코드 예제 public class PrimeCheck { public static boolean isPrime(int n) { if (n &lt; 2) return false; for (int i = 2; i &lt;= Math.sqrt(n); i++) { if (n % i == 0) return false; } return true; } public static void main(String[] args) { System.out.println(isPrime(29)); //true System.out.println(isPrime(100)); //false } } 2️⃣ 에라토스테네스의 체 (O(N log log N)) 여러 개의 소수를 빠르게 찾는 방법 1부터 N까지의 수 중에서 소수를 모두 찾아야 하는 경우 🔥 방법 2부터 시작해서 배수들을 모두 제거 남은 수들만 소수로 판별 장점 한 번 계산해 두면 특정 범위 내에서 빠르게 소수 여부를 판별할 수 있음. 코드 예제 import java.util.*; public class SieveOfEratosthenes { public static List&lt;Integer&gt; sieveOfEratosthenes(int n) { boolean[] isPrime = new boolean[n+1]; Arrays.fill(isPrime, true); isPrime[0] = isPrime[1] = false; for (int i = 2; i * i &lt;= n; i++) { if (isPrime[i]) { for (int j = i*i; j &lt;= n; j += i) { isPrime[j] = false; } } } //소수 리스트 생성 } } 3️⃣ Miller-Rabin 소수판별법 (O(log N)) 소수 판별이 자주 필요할 때 N이 엄청 크면 밀러-라빈 소수판별법을 사용해야함 10^18이상의 큰 수가 소수인지 판별할 때 암후학, 해시 관련 문제에서 사용 🔥 확률적 알고리즘 코드 예제 import java.util.Random; public class MillerRabin { public static boolean isPrime(long n, int k) { // k는 테스트 횟수 if (n &lt; 2) return false; if (n == 2 || n == 3) return true; if (n % 2 == 0) return false; // n - 1 = 2^r * d 형태로 변환 long d = n - 1; int r = 0; while (d % 2 == 0) { r++; d /= 2; } Random rand = new Random(); // Miller-Rabin 테스트 실행 for (int i = 0; i &lt; k; i++) { long a = 2 + rand.nextLong(n - 3); // 2 ≤ a ≤ n-2 long x = powerMod(a, d, n); // x = a^d % n if (x == 1 || x == n - 1) continue; boolean isComposite = true; for (int j = 0; j &lt; r - 1; j++) { x = powerMod(x, 2, n); // x = x^2 % n if (x == n - 1) { isComposite = false; break; } } if (isComposite) return false; // 합성수 판별 } return true; // 소수 판별 } // (base^exp) % mod 연산 (빠른 거듭제곱) private static long powerMod(long base, long exp, long mod) { long result = 1; base %= mod; while (exp &gt; 0) { if ((exp &amp; 1) == 1) { // 홀수 지수 처리 result = (result * base) % mod; } base = (base * base) % mod; // 제곱 exp &gt;&gt;= 1; // 지수 나누기 2 } return result; } public static void main(String[] args) { System.out.println(isPrime(15485863, 5)); // true (소수) System.out.println(isPrime(1000000007, 5)); // true (소수) System.out.println(isPrime(1000000008, 5)); // false (합성수) } }",
    "tags": "algorithm",
    "url": "/algorithm/2025-03-20-is-prime/"
  },{
    "title": "[Etc] 🤖 Layered Architecture &amp; MVC pattern",
    "text": "레이어드 아키텍쳐(Layered Architecture)란? MVC란? 레이어드 아키텍쳐와 MVC를 함께 사용 레이어드 아키텍쳐(Layered Architecture)란? 여러 수평 레이어가 수직적으로 쌓인 구조 (상위 레이어에서 하위 레이어로 단방향 의존성) 각 계층이 명확한 역할을 가지며, 하위 계층만 접근할 수 있도록 설계하여 유지보수성과 확장성을 높이는 것이 목적 Presentation Layer (프레젠테이션 계층) : 1층로비, 방문객 맞이하고 안내 예시: Spring Boot의 Controller 사용자와 직접 상호작용하는 계층 (예: 웹 UI, API 컨트롤러) 사용자의 입력을 받아 비즈니스 로직을 호출하고, 응답을 반환 Business Logic Layer (비즈니스 로직 계층) : 실제 회사 업무 설계 및 규칙 수립 예시: Spring Boot의 Service 핵심 비즈니스 로직을 처리하는 계층 도메인 규칙을 적용하여 데이터 검증 및 가공 수행 Data Access Layer (데이터 접근 계층) : 비즈니스 레이어의 명령 실행 예시: Spring Boot의 Repository 데이터베이스와 직접 상호작용하는 계층 DAO(Repository)를 통해 데이터를 저장하고 조회하는 역할 Database Layer (데이터베이스 계층) : 필요한 정보 저장 및 검색 실제 데이터를 저장하는 물리적 데이터베이스 (MySQL, PostgreSQL 등) 데이터 흐름 요청 → 컨트롤러 → 서비스 → 레포지토리 사용 이유 모듈화: 각 레이어가 독립적이라 변경 사항이 영향을 최소화 유지보수성: 비즈니스 로직(Service)과 DB 접근(Repository)을 분리 테스트 용이: 단위 테스트 작성이 쉬움 (ex: Service 레이어만 Mock 테스트 가능) 레이어 간 관계 [클라이언트] ↓ [Presentation Layer] → Controller ↓ [Business Logic Layer] → Service ↓ [Data Access Layer] → Repository (DAO) ↓ [Database Layer] → DB (MySQL, PostgreSQL) 상위 계층(Presentation)은 하위 계층(Business Logic)만 호출할 수 있음. 데이터베이스 관련 로직이 비즈니스 로직과 분리되어 유지보수가 쉬움. MVC란? Model-View-Controller Model : 요리사가 실제 음식을 준비하고 만드는 작업 View : 음식의 플레이팅 Controller : 고객의 주문을 받고, 요리사에게 전달하여 완성된 요리를 테이블에 서빙 (백엔드) 3개의 요소가 유기적으로 협력 사용자 인터페이스와 비즈니스 로직 분리 데이터 흐름 요청 → 컨트롤러 → 모델 → 뷰 사용 이유 역할 분리: View, Model, Controller가 독립적으로 동작하여 유지보수 용이 유연한 확장: UI 변경(View)이나 비즈니스 로직(Model)을 따로 수정 가능 재사용성 증가: 같은 Model을 여러 View에서 사용 가능 레이어드 아키텍쳐와 MVC를 함께 사용 둘을 함께 사용하면 유지보수성과 확장성이 좋아진다. Controller는 최대한 가볍게 (Thin Controller, Fat Service) 비즈니스 로직은 Service Layer에서 처리 (SRP 원칙 준수) 둘을 함께 사용했을 때 관계 흐름 (요청 → 응답) 사용자 (Client) 가 요청을 보냄 Controller (입력 처리, 요청 매핑) Service (비즈니스 로직 처리) Repository (데이터베이스 접근) Service → Controller 로 응답 반환 Controller → View (또는 JSON) MVC는 역할을 분리하고, 레이어드 아키텍처는 각 계층을 더 체계적으로 조직화하여 유지보수성과 확장성을 높인다",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-03-17-layered-architecture/"
  },{
    "title": "[JAVA] record",
    "text": "record란? record의 특징 기존 클래스 vs record 비교 record 내부 동작 record 주요 기능 record 사용 방법 정리 ✅ record란? (Java 14+) record는 Java 14부터 도입된 새로운 클래스 유형으로, 불변(immutable)한 데이터 객체를 간결하게 표현할 수 있도록 설계되었습니다. 👉 기존의 DTO(Data Transfer Object), VO(Value Object) 등을 만들 때 코드를 대폭 줄여줍니다. 1️⃣ record의 특징 자동으로 생성자, getter, toString(), equals(), hashCode() 제공 불변 객체 (Immutable) Java의 일반적인 클래스처럼 사용 가능 Compact Constructor(압축된 생성자) 지원 상속 불가능 (final 클래스처럼 동작) 2️⃣ 기존 클래스 vs record 비교 🔹 기존 방식: Java 클래스로 DTO 만들기 class Person { private final String name; private final int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + \"}\"; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(name, age); } } getter, toString(), equals(), hashCode()를 직접 구현해야 해서 코드가 길어짐. 🔹 record를 사용한 간단한 구현 record Person(String name, int age) {} 위처럼 한 줄만 작성하면 동일한 기능을 제공함! 자동으로 getter, toString(), equals(), hashCode()가 생성됨. 3️⃣ record의 내부 동작 위의 record Person(String name, int age)는 자동으로 다음과 같이 동작합니다: public final class Person { private final String name; private final int age; public Person(String name, int age) { // 생성자 자동 생성 this.name = name; this.age = age; } public String name() { return name; } // getter 자동 생성 public int age() { return age; } @Override public boolean equals(Object o) { /* 자동 생성 */ } @Override public int hashCode() { /* 자동 생성 */ } @Override public String toString() { return \"Person[name=\" + name + \", age=\" + age + \"]\"; } } 💡 이름이 getName()이 아니라 name()인 점이 특징! 4️⃣ record의 주요 기능 ✅ 1. 기본 사용 record Person(String name, int age) {} public class Main { public static void main(String[] args) { Person p = new Person(\"Alice\", 25); System.out.println(p.name()); // Alice (getter) System.out.println(p.age()); // 25 (getter) System.out.println(p); // Person[name=Alice, age=25] } } name()과 age()가 getter 역할을 함 (getName()이 아님) toString()이 자동 생성됨 → Person[name=Alice, age=25] ✅ 2. Compact Constructor (압축된 생성자) 기본적으로 record는 모든 필드가 자동 초기화되지만, 추가 검증 로직을 넣을 수도 있음. record Person(String name, int age) { public Person { if (age &lt; 0) { throw new IllegalArgumentException(\"나이는 0 이상이어야 합니다.\"); } } } 위처럼 생성자에서 유효성 검사를 추가 가능. ✅ 3. 메서드 추가 가능 record도 일반적인 클래스처럼 메서드를 추가할 수 있음. record Circle(double radius) { public double area() { return Math.PI * radius * radius; } } public class Main { public static void main(String[] args) { Circle c = new Circle(5); System.out.println(\"원의 넓이: \" + c.area()); // 원의 넓이: 78.5398... } } record는 단순히 데이터를 저장하는 역할이지만, 관련 메서드를 추가하는 것도 가능. ✅ 4. 상속 불가능 (final 클래스처럼 동작) record는 자동으로 final로 선언되므로 상속이 불가능함. record Parent(String name) {} // 오류: record는 상속할 수 없음 class Child extends Parent {} // ❌ 컴파일 오류 5️⃣ record를 언제 사용할까? ✅ 불변 객체(Immutable Object)가 필요할 때 ✅ DTO, VO (Data Transfer Object, Value Object)를 만들 때 ✅ 간단한 데이터 저장용 클래스가 필요할 때 ✅ 불필요한 getter, toString(), equals() 코드 작성을 줄이고 싶을 때 ❌ 상속을 해야 하는 경우에는 record를 사용할 수 없음 ❌ 데이터 변경이 필요한 경우 (Mutable Object)는 record보다 일반 클래스를 사용 6️⃣ 정리 특징 일반 클래스 record 코드 길이 길다 (필드, 생성자, getter, toString(), equals(), hashCode()) 짧다 (한 줄로 가능) 불변성(Immutable) X (final 필드 필요) ✅ 기본적으로 불변 자동 생성 X (수동으로 작성해야 함) ✅ 생성자, getter, toString() 자동 생성 상속 가능 여부 ✅ 가능 ❌ 불가능 (final 클래스처럼 동작) 데이터 변경 가능 (setter 추가 가능) ❌ 변경 불가능 🚀 결론: record를 사용하면 불변 객체를 쉽게 만들 수 있으며, DTO나 VO 같은 데이터 클래스를 훨씬 간결하게 표현할 수 있다! 🚀",
    "tags": "java",
    "url": "/java/2025-03-09-record/"
  },{
    "title": "[JAVA] 동시성 처리 (Concurrency)",
    "text": "JAVA에서 동시성 스레드 (Thread) 비동기 처리 (Aysnc) 분산 처리 (Distribute) 핵심 키워드 및 정리 JAVA에서 동시성 여러 작업을 동시에 겹쳐서 처리하는 것 한 번에 여러 일을 수행하며 일의 효율성을 높임 크게 3가지 관점에서 접근 가능하다. 스레드 (Thread) 비동기 (Async) 분산 (Distributed) 스레드 (Thread) 스레드는 프로세스 내에서 실제 작업을 수행하는 작업 단위 한 개의 프로그램(프로세스)은 여러 개의 스레드를 가질 수 있음 멀티 스레드 (Multi-thread) 하나의 프로세스에서 여러 스레드를 동시에 실행하는 방식 자바에서는 주로 JVM(Java Virtual Machine)이 여러 스레드를 관리해줌 ex) 웹 서버(Servlet, Spring)에서는 사용자 요청마다 별도의 스레드를 생성해서 동시에 많은 요청을 처리할 수 있게 함 🔥 중요한 이유 효율성 향상 CPU 자원을 최대한 활용할 수 있음 응답성 향상 동시에 여러 요청을 처리할 수 있음 하지만 최근 자바 프레임워크(Spring)는 스레드를 자동으로 관리해주기 때문에 개발자가 직접 스레드를 관리할 일이 많지 않음 JVM과 프레임워크가 이미 효율적으로 관리해줌 비동기 처리 (Async) 비동기란 “요청을 보낸 뒤 결과를 기다리지 않고 다음 작업을 진행”하는 방식 동기 (Synchronous) 하나의 요청이 끝날 때까지 기다림 비동기 (Asynchronous) 요청이 처리되는 동안 다른 작업 수행 자바에서 비동기 처리를 지원하는 방법 CompletableFuture : 자바 비동기 처리 클래스 자바스크립트의 async/await와 비슷한 방식 🔥 중요한 이유 빠른 응답성 요청 처리 중에도 사용자가 대기하지 않고, 시스템의 다른 작업 수행 가능 높은 확장성 비동기 처리를 하면 서버가 많은 요청을 효율적으로 관리 가능 분산 처리 (Distributed) 분산처리는 “하나의 서버가 아닌, 여러 대의 서버가 나누어서 작업을 처리하는 방식” 서버 하나만 운영하는 것부다 작은 여러 서버(클러스터)를 운영하면 비용이 줄어듬 대규모 서비스나 성장한 서비스에서 자주 사용됨 분산 환경에서 자주 사용되는 기술 Redis 메모리 기반 데이터 저장소로, 분산락(Distributed Lock)울 구현할 때 사용 예를 들어, 여러 서버가 하나의 데이터를 동시에 수정하지 못하게 관리하는 방식 Kafka 메시지 큐(Message Queue)로, 서버간 메시지를 주고받고, 작업을 순차적으로 처리할 때 사용됨 클러스터(Cluster) 여러 대의 서버가 협력하여 요청을 나누어 처리 (MSA와 비슷한 개념) 🔥 중요한 이유 비용 효율성 큰 서버 하나보다 여러 작은 서버가 경제적 안정성 및 확장성 한 서버가 문제가 생기더라도 서비스는 계속 운영됨 핵심 키워드 및 정리 스레스 (Thread) 멀티 스레드 -&gt; JVM, Servlet, Spring 스레드는 직원이다. 회사(JVM, Servlet, Spring)가 직원(스레드)을 잘 관리하면, 일(요청 처리)이 효율적이다. 비동기 (Async) CompletableFuture, async/await 비동기는 배달앱이다. 주문을 넣고 기다리지 않고, 다음 일을 진행한다. 분산처리 (Distributed) Redis, Kafka, 클러스터 분산처리는 프랜차이즈이다. 큰 가게 하나보다 작은 여러 가게가 효율적이고 비용도 절감된다.",
    "tags": "java",
    "url": "/java/2025-03-09-concurrency/"
  },{
    "title": "[Etc] immutable, final, constant",
    "text": "Immutable final const Immutable (불변) 생성 후 객체 자체의 상태를 변경할 수 없음 Java의 키워드는 아님, 다양한 언어에서 사용되는 객체의 속성 개념 객체와 관련됨 특징 모든 필드가 final이고 private setter 메서드가 없음 모든 가변 참조 필드가 방어적 복사를 통해 보호됨 중요한 점 불변 객체는 멀티 스레드 환경에서 안전하게 사용 가능 내부 상태를 변경하는 메서드를 제공하지 않아야 함. 예 : String, Integer, BigDecimal String 클래스는 자바에서 대표적인 불변 객체 String객체를 한 번 생성하면 내부 값이 변경되지 않음. 새로운 값을 할당하려면 새로운 객체가 만들어짐. String s1 = \"Hello\"; String s2 = s1.concat(\" World\"); System.out.println(s1); // 여전히 \"Hello\" Final (최종, 변경 불가) 한 번 할당되면 값을 변경할 수 없는 변수 또는 참조 Java의 키워드 특징 변수에 사용 : 초기화 후 재할당 불가 메서드에 사용 : 오버라이딩 불가 클래스에 사용 : 상속 불가 중요한 점 final은 참조의 변경을 막지만, 참조가 가리키는 객체의 내용 변경은 막지 않음 실무에서 활용 메서드 파라미터 메서드 내에서 파라미터 값이 변경되지 않도록 보장 public void processUser(final User user) { ... } 람다 표현식 람다에서 외부 변수를 사용할 때는 반드시 final 또는 effectively final이어야 함 final String prefix = \"User-\"; userList.stream() .map(user -&gt; prefix + user.getName()) .forEach(System.out::println); 스레드 안정성 멀티스레드 환경에서 불변성 보장에 도움 Const (상수) 프로그램 전체에서 변경되지 않는 고정 값 Java의 키워드 특징 일반적으로 static final로 선언 클래스 로딩 시점에 초기화 관례적으로 대문자와 언더스코어 사용 (UPPER_SNAKE_CASE) 예 public static final int MAX_USERS = 100; static 상수(const)와 자주 함께 사용되는 변수 클래스 수준에서 사용되며, 객체가 아닌 클래스에 종속됨 클래스 로딩 시 한 번만 초기화되며 모든 객체가 공유",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-03-06-immutable/"
  },{
    "title": "[Etc] 🎞️ Boilerplate",
    "text": "보일러플레이트(Boilerplate)란? 보일러플레이트의 특징 예제 코드 보일러플레이트(Boilerplate)란? 소프트웨어 개발에서 반복적으로 사용되는 사용되는 기본 코드 템플릿 🔥 즉, “매번 새로 작성해야하는 기본 코드세트”를 보일러플레이트라고 함 의미 원래는 인쇄 산업에서 반복적으로 사용되는 금속판을 의미 이후 소프트웨어 개발에서도 “반복적으로 작성해야하는 코드 덩어리”를 의미하게 되었다. 보일러플레이트의 특징 반복적인 코드 프로젝트를 시작할 때 매번 작성해야하는 코드들이 포함됨 예를 들어, 웹 애플리케이션을 만들 때 기본적인 프로젝트 구조, 설정 파일, 인증 로직 등이 해당 템플릿 역할 코드 재사용성을 높이고, 개발 시간을 줄여줌 예를 들어, React, Express, Spring Boot같은 프레임워크에서는 보일러플레이트 코드가 포함된 템플릿이 제공됨 프레임워크 및 라이브러리에서 자주 사용됨 React : create-react-app이 기본적인 프로젝트 구조와 설정을 자동으로 생성 Express : express-generator를 사용하면 기본적인 Express 프로젝트 생성 Spring Boot : Spring Initializr를 사용사면 기본적인 설정이 포함된 프로젝트 생성 예제 코드 Spring Boot 보일러플레이트 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } }",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-03-06-boiler-plate/"
  },{
    "title": "[JAVA] 🚀 ArrayList vs 배열(int[]) 성능 비교",
    "text": "ArrayList&lt;Integer&gt;는 언제 더 유리할까? int[] 배열이 더 유리한 경우 성능 비교 실험 (Java) 결론: 언제 ArrayList를 쓰고, 언제 배열(int[])을 써야 할까? 추가 : HashMap&lt;Integer, Integer&gt;와의 성능 비교 🚀 ArrayList vs 배열(int[]) 성능 비교   ArrayList&lt;Integer&gt; int[] 배열 저장 방식 내부적으로 동적 배열(Object[]) 사용 고정 크기의 int[] 배열 사용 메모리 사용량 Integer 객체를 사용하여 오버헤드가 큼 int 원시 타입 사용 (메모리 효율적) 속도 (읽기/쓰기) 일반적으로 int[]보다 느림 빠름 (메모리 직접 접근) 크기 변경 가능 여부 가능 (add(), remove() 등 제공) 불가능 (고정 크기) 사용 편의성 유동적인 크기 조절이 가능 크기 변경이 불가능하여 유연성이 떨어짐 📌 ArrayList&lt;Integer&gt;는 언제 더 유리할까? 크기가 가변적인 데이터를 다룰 때 (add()로 쉽게 추가 가능) 삭제, 삽입이 자주 발생할 때 (remove() 메서드 활용 가능) 제네릭(List&lt;T&gt;)을 활용해야 할 때 🚀 예제: ArrayList 사용 시 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(10); // 값 추가 list.add(20); list.remove(0); // 첫 번째 요소 삭제 크기가 유동적으로 변할 수 있음 (add(), remove() 사용 가능) 그러나 내부적으로 Integer 객체를 사용하므로 메모리 사용량이 큼 (int보다 많은 메모리 차지) 📌 int[] 배열이 더 유리한 경우 고정된 크기의 데이터를 다룰 때 (메모리 절약 가능) 빠른 접근 속도가 필요할 때 메모리에 직접 접근 (O(1)) 가능 성능 최적화가 필요한 경우 (특히 대량 데이터) 🚀 예제: int[] 사용 시 int[] arr = new int[3]; arr[0] = 10; arr[1] = 20; arr[2] = 30; 메모리를 int 타입 크기만큼만 사용(불필요한 Integer 객체 생성 없음) 읽기/쓰기 속도가 빠름 ⏳ 성능 비교 실험 (Java) 내가 직접 ArrayList&lt;Integer&gt;와 int[]의 속도를 비교하는 코드를 실행해볼게! 아래 코드로 같은 데이터를 저장하고 조회하는데 걸리는 시간을 비교해보자. import java.util.ArrayList; public class PerformanceTest { public static void main(String[] args) { int SIZE = 10_000_000; // 1천만 개의 데이터 테스트 // 1️⃣ 배열 테스트 long startTime = System.nanoTime(); int[] array = new int[SIZE]; for (int i = 0; i &lt; SIZE; i++) { array[i] = i; } long endTime = System.nanoTime(); System.out.println(\"배열(int[]) 실행 시간: \" + (endTime - startTime) / 1_000_000 + \" ms\"); // 2️⃣ ArrayList 테스트 startTime = System.nanoTime(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(SIZE); for (int i = 0; i &lt; SIZE; i++) { list.add(i); } endTime = System.nanoTime(); System.out.println(\"ArrayList 실행 시간: \" + (endTime - startTime) / 1_000_000 + \" ms\"); } } ⏳ 성능 테스트 결과 (대략적인 차이) 테스트 환경: 10,000,000개의 데이터를 저장하는 경우 (결과는 실행 환경에 따라 다를 수 있음) 데이터 크기 int[] 배열 (배열) ArrayList&lt;Integer&gt; (리스트) 10,000,000개 데이터 저장 30~50ms 100~200ms ✅ 배열(int[])이 ArrayList&lt;Integer&gt;보다 약 3~5배 빠름! 📌 결론: 언제 ArrayList를 쓰고, 언제 배열(int[])을 써야 할까? 상황 ArrayList&lt;Integer&gt; int[] 배열 데이터 크기가 가변적일 때 ✅ 추천 (자동 크기 증가) ❌ 비효율적 (고정 크기) 빠른 읽기/쓰기 성능이 필요할 때 ❌ 상대적으로 느림 ✅ 빠름 (메모리 직접 접근) 메모리 사용량 최적화가 필요할 때 ❌ Integer 객체로 인해 메모리 낭비 ✅ int 원시 타입이므로 메모리 절약 삭제/삽입이 자주 발생할 때 ✅ remove() 지원 ❌ 배열 크기 고정이라 비효율적 성능이 중요하다면 int[] 배열이 훨씬 빠르고 메모리도 절약된다! 🚀 크기가 변하는 데이터를 다룰 때는 ArrayList&lt;Integer&gt;가 편리하다. ✅ 데이터 개수가 많고, 읽기/쓰기 성능이 중요하다면 int[]을 사용하는 것이 좋다. ⚡ 일반적인 상황에서는 ArrayList&lt;Integer&gt;를 쓰는 게 개발 편의성 면에서 좋다. 즉, 고정된 크기라면 배열을 쓰고, 크기가 유동적이면 ArrayList를 쓰는 게 정답! 😃 추가 : HashMap&lt;Integer, Integer&gt;와의 성능 비교 데이터 구조 실행 속도 (초) 특징 배열 (int[]) 가장 빠름 (0.03~0.05초) 메모리 직접 접근 (고정 크기) ArrayList (ArrayList&lt;Integer&gt;) 중간 (0.1~0.2초) 동적 크기 조정 가능 HashMap (HashMap&lt;Integer, Integer&gt;) 가장 느림 (0.3~0.5초) 키-값 매핑 (빠른 탐색) 3️⃣ HashMap (HashMap&lt;Integer, Integer&gt;) 속도: 가장 느림 (배열보다 약 5~10배 느림) 이유: 내부적으로 해시 함수(Hashing) 사용 → 빠른 탐색(O(1)) 가능 하지만 키-값 저장 방식이라 메모리 오버헤드가 큼 장점: 데이터 검색이 O(1) (거의 즉각적) 키 기반으로 빠르게 값에 접근 가능 언제 사용하면 좋을까? Key-Value 형태의 데이터 저장이 필요할 때 데이터 조회 속도가 중요한 경우 (탐색이 많을 때) 💡 결론 사용 목적 추천 자료 구조 고정된 크기의 데이터 int[] (배열) 크기가 유동적인 리스트 ArrayList&lt;Integer&gt; 빠른 탐색이 필요한 경우 HashMap&lt;Integer, Integer&gt; 즉, ✔ 빠른 연산이 필요하면 int[] 배열 ✔ 동적 크기가 필요하면 ArrayList&lt;Integer&gt; ✔ 키-값 조회가 많다면 HashMap&lt;Integer, Integer&gt;",
    "tags": "java",
    "url": "/java/2025-02-25-arraylist-array/"
  },{
    "title": "[JAVA] SOLID 원칙",
    "text": "1. 단일 책임 원칙 2. 개방-폐쇄 원칙 3. 리스코프 치환 원칙 4. 인터페이스 분리 원칙 5. 의존성 역전 원칙 SOLID 원칙 객체지향 프로그래밍(OOP)에서 SOLID 원칙이란, 유지보수와 확장이 쉬운 소프트웨어를 만들기 위한 5가지 설계 원칙 각각의 원칙의 첫글자를 따서 만든 약자. 1. SRP (Single Responsibility Principle) 🔴 단일 책임 원칙 정의 하나의 클래스는 단 하나의 책임(기능)만 가져야 한다. 즉, 클래스가 변경될 이유는 오직 하나여야 한다/ 의미 클래스가 너무 많은 역할을 담당하게 되면, 유지보수나 확장 시 하나의 변경 사항이 다른 기능까지 의도치 않게 영향을 줄 수 있음 하나의 클래스가 단 하나의 목적만 수행하도록 하면, 코드 관리가 쉬워지고 명확해짐 예시 ❌ 나쁜 예시 : 회원 관리 클래스가 로그인, 회원정보 관리, 이메일 발송까지 전부 담당 ✅ 좋은 예시 : 로그인 클래스, 회원정보 관리 클래스, 이메일 발송 클래스를 각각 따로 분리 2. OCP (Open/Closed Principle) 🟠 개방-폐쇄 원칙 정의 소프트웨어의 구성 요소(클래스, 모듈, 함수 등)는 확장에는 열려있고, 변경에는 닫혀있어야 한다. 의미 새로운 기능을 추가할 때 기존 코드를 수정하지 않고도 기능을 확장할 수 있어야 함. 예시 ❌ 나쁜 예시 : 새로운 결제 방식을 추가할 때마다 기존의 결제 클래스를 직접 수정 ✅ 좋은 예시 : 결제 방식 인터페이스를 정의하고, 이를 구현한 클래스(신용카드 결제, 페이팔 결제 등)를 추가함으로써 기존 코드 수정 없이 확장 가능 3. LSP (Liskov Substitution Principle) 🟡 리스코프 치환 원칙 정의 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 함. 부모 클래스가 사용되는 곳에 자식 클래스를 넣었을 때도 프로그램이 정확히 동작해야 함 의미 상속 관계를 올바르게 설계해 자식 클래스가 부모 클래스의 본질적인 특성을 바꾸지 않아야 한다. 자식 클래스는 부모 클래스가 가진 모든 속성과 메서드를 위반 없이 사용할 수 있어야함 예시 ❌ 나쁜 예시 : ‘정사각형’ 클래스를 ‘직사각형’의 자식 클래스로 만들었지만, 가로세로를 독립적으로 조정할 수 없어서 예상한 동작이 깨지는 경우 ✅ 좋은 예시 : ‘도형’이라는 부모 클래스를 상속하여 ‘직사각형’, ‘정사각형’, ‘삼각형’ 등으로 각자 독립적으로 확장하여 서로 간섭 없이 동작 4. ISP (Interface Segregation Principle) 🟢 인터페이스 분리 원칙 정의 클라이언트는 자신이 사용하지 않은 메서드에 의존하지 않아야 함. 하나의 일반적인 인터페이스보다 여러 개의 구체적이고 세분화된 인터페이스를 사용하는 것이 좋음 의미 하나의 크고 범용적인 인터페이스보다, 용도에 따라 작고 명확하게 구분된 인터페이스를 제공하는 것이 좋음 클라이언트가 필요로 하는 최소한의 메서드만 포함한 인터페이스를 만들어야함 예시 ❌ 나쁜 예시 : 하나의 인터페이스에 “프린트, 팩스, 복사, 스캔” 기능을 모두 넣어서 일부만 사용하는 프린터 기기같이 모든 메서드를 구현해야하는 경우 ✅ 좋은 예시 : “프린트 인터페이스”, “팩스 인터페이스”, “복사 인터페이스”, “스캔 인터페이스”로 나눠서 필요한 기능만 구현하도록 제공 5. DIP (Dependency Inversion Principle) 🔵 의존성 역전 원칙 정의 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안되며 둘 다 추상화에 의존해야함 또한, 추상화(인터페이스나 추상 클래스)는 세부 사항에 의존해서는 안되고, 세부 사항이 추상화에 의존해야함 의미 클래스가 특정 구현(구체적 클래스)이 아닌, 추상화된 인터페이스에 의존하도록 설계해야 함. 이는 의존 관계룰 유연하게 만들어 유지보수 및 확장이 편리해지게 횜 예시 ❌ 나쁜 예시 : 데이터베이스 클래스가 특정 DB(에: MySQL)에 직접 의존하는 코드 설계 ✅ 좋은 예시 : 데이터베이스 인터페이스를 정의하고, 이를 구현하는 다양한 DB클래스(MySQL, PostgreSQL 등)를 만들어 상위 모듈이 인터페이스에만 의존하도록 설계 SOLID 원칙을 지켰을 때의 장점 유지보수 용이성 코드 확장 용이성 가독성 및 코드 품질 향상 테스트 용이성",
    "tags": "java",
    "url": "/java/2025-02-23-solid/"
  },{
    "title": "[Etc] 🔑 Access Token과 Refresh Token 완벽 정리",
    "text": "Access Token과 Refresh Token이란? Access Token Refresh Token Access Token vs. Refresh Token 비교 Access Token과 Refresh Token을 사용하는 이유 Access Token과 Refresh Token을 활용한 인증 흐름 Access Token &amp; Refresh Token 보안 고려 사항 실제 코드 구현 (Java, Spring Security) 1. Access Token과 Refresh Token이란? OAuth 2.0을 사용할 때 핵심이 되는 토큰 토큰 종류 역할 유효 기간 사용 목적 Access Token API 요청 시 인증을 위한 토큰 짧음 (몇 분~1시간) 사용자가 인증된 후 API 접근 Refresh Token Access Token이 만료되었을 때 새 토큰 발급 김 (며칠~몇 달) Access Token을 갱신 2. Access Token ✅ Access Token이란? 사용자가 OAuth 인증을 마치면 Authorization Server가 발급하는 단기 유효 토큰. 이 토큰을 API 요청의 Authorization 헤더에 포함하여 사용. 일반적으로 Bearer Token 방식으로 사용됨. 🎯 Access Token 사용 예시 HTTP 요청에서 Access Token을 포함하여 API 호출: GET /user/profile HTTP/1.1 Host: api.example.com Authorization: Bearer ACCESS_TOKEN ⏳ Access Token의 유효 기간 보안상 짧은 시간(몇 분~1시간 정도) 만 유지됨. Access Token이 만료되면 더 이상 API를 호출할 수 없음. 해결 방법: Refresh Token을 사용하여 새로운 Access Token 발급. 3. Refresh Token ✅ Refresh Token이란? Access Token이 만료되었을 때, 새로운 Access Token을 요청할 수 있도록 제공되는 장기 토큰. Access Token과 다르게, Refresh Token 자체로는 API 요청을 보낼 수 없음. 일반적으로 다시 로그인하지 않고도 인증을 연장할 때 사용. 🎯 Refresh Token 사용 예시 Access Token이 만료되면, Refresh Token을 이용하여 새 Access Token을 요청: POST /auth/token HTTP/1.1 Host: auth.example.com Content-Type: application/x-www-form-urlencoded grant_type=refresh_token&amp; client_id=YOUR_CLIENT_ID&amp; client_secret=YOUR_CLIENT_SECRET&amp; refresh_token=YOUR_REFRESH_TOKEN ⏳ Refresh Token의 유효 기간 며칠~몇 달까지 유지 가능 (보안 정책에 따라 다름). 일반적으로 기기 변경, 비밀번호 변경, 보안 위험 감지 시 강제 만료됨. 4. Access Token vs. Refresh Token 비교   Access Token Refresh Token 목적 API 요청 인증 새로운 Access Token 발급 유효 기간 짧음 (몇 분~1시간) 김 (며칠~몇 달) 보관 위치 클라이언트 저장 클라이언트 저장 (보안 필요) 보안 위험 탈취되면 API 무단 접근 가능 탈취되면 새로운 Access Token 발급 가능 사용 가능 횟수 여러 번 API 요청 가능 1회 또는 제한적 사용 5. Access Token과 Refresh Token을 사용하는 이유 Access Token만 사용하면? 보안상 유효 기간을 길게 설정할 수 없음. 토큰이 만료될 때마다 사용자가 다시 로그인해야 함 → 불편함. Refresh Token을 추가하면? Access Token을 자주 갱신할 수 있음 → 보안 강화. 사용자가 다시 로그인할 필요 없이 자동으로 인증 연장 가능. 👉 Refresh Token을 사용하면 보안과 사용자 편의성 모두 향상됨. 6. Access Token과 Refresh Token을 활용한 인증 흐름 1️⃣ 사용자가 로그인 &amp; 권한 부여 → OAuth 서버가 Access Token과 Refresh Token 발급 2️⃣ 클라이언트가 API 요청 → Authorization: Bearer Access_Token 포함하여 요청 3️⃣ Access Token이 만료됨 → API 서버가 401 Unauthorized 응답 반환 4️⃣ Refresh Token을 사용해 새 Access Token 요청 → 새 Access Token 발급 후 다시 API 요청 가능 5️⃣ Refresh Token도 만료됨 → 사용자는 다시 로그인 필요 👉 Access Token은 API 요청을 인증하는 용도, Refresh Token은 새로운 Access Token을 발급하는 용도! 👉 보안이 중요한 만큼 저장 방식과 유효 기간을 잘 관리해야 함! 🚀 7. Access Token &amp; Refresh Token 보안 고려 사항 ✅ Access Token 보안 유효 기간을 짧게 설정 (몇 분~1시간) HTTPS 사용 필수 (네트워크 스니핑 방지) 탈취되면 API 접근 가능 → 짧은 유효 기간이 보안성을 보장 ✅ Refresh Token 보안 보안 저장소 사용 (예: 모바일 앱에서는 Secure Storage) HTTP 요청 시 노출되지 않도록 주의 (쿠키 또는 안전한 저장소에 보관) 유출 시 즉시 무효화 필요 (서버에서 토큰 무효화 기능 추가) 🚨 탈취 방지 방법 Refresh Token을 클라이언트에서 안전하게 저장 브라우저: HttpOnly Secure Cookie 사용 모바일 앱: Secure Storage / Keychain 사용 Refresh Token 재사용 방지 (One-Time Refresh Token) Refresh Token을 사용할 때마다 새 Refresh Token을 발급하고 이전 것은 무효화 IP &amp; 디바이스 검증 Refresh Token 사용 시 IP 주소와 디바이스 정보를 확인하여 이상 감지 시 무효화 토큰 암호화 및 서명 JWT 기반 Access Token은 서명(Signature) 을 포함하여 위변조 방지 8. Access Token &amp; Refresh Token 실제 코드 구현 (Java, Spring Security) 🔹 Access Token &amp; Refresh Token 발급 API 예제 (Spring Boot) @RestController @RequestMapping(\"/auth\") public class AuthController { @PostMapping(\"/token\") public ResponseEntity&lt;?&gt; getToken(@RequestParam String refreshToken) { if (isValidRefreshToken(refreshToken)) { String newAccessToken = generateNewAccessToken(); return ResponseEntity.ok(newAccessToken); } else { return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(\"Invalid Refresh Token\"); } } private boolean isValidRefreshToken(String token) { // Refresh Token 검증 로직 return token.equals(\"valid-refresh-token\"); // 예제 코드 } private String generateNewAccessToken() { // 새로운 Access Token 생성 (JWT 사용 가능) return UUID.randomUUID().toString(); } }",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-02-22-token/"
  },{
    "title": "[Etc] OAuth란?",
    "text": "OAuth 개념과 특징 OAuth 1.0 vs. OAuth 2.0 OAuth 2.0 상세 동작 방식 OAuth 2.0 Grant Types (인증 방식) OAuth 2.0의 주요 용어 OAuth 2.0을 실제 코드로 구현 OAuth의 장점 &amp; 단점 OAuth란? 서드파티 애플리케이션이 사용자 인증 정보를 직접 다루지 않고, 다른 서비스의 인증을 통해 특정 리소스에 접근할 수 있도록 하는 인증 및 권한 부여 프로토콜 “카카오 로그인”, “구글 로그인”, “페이스북 로그인” 같은 기능이 OAuth를 사용한 대표적인 사례 1. OAuth 개념과 특징 ✅ OAuth의 핵심 개념 인증(Authentication): 사용자가 누구인지 확인하는 과정 권한 부여(Authorization): 사용자가 특정 리소스에 대한 액세스를 허용하는 과정 토큰 기반 인증: ID/비밀번호 대신 Access Token을 사용하여 API 요청 안전한 인증 방식: 클라이언트가 직접 사용자 계정 정보를 저장하지 않아 보안 강화 ✅ OAuth 동작 방식 사용자가 서드파티 앱에서 로그인 버튼 클릭 OAuth 서버(예: Google, Kakao)가 사용자에게 로그인 페이지 제공 사용자가 로그인하고 권한을 승인 OAuth 서버가 서드파티 앱에 Authorization Code 제공 서드파티 앱이 Authorization Code를 사용하여 Access Token 요청 Access Token을 통해 리소스 서버(API)에 접근하여 데이터 제공 2. OAuth 1.0 vs. OAuth 2.0 OAuth는 1.0과 2.0 두 가지 버전이 있으며 현재는 OAuth 2.0이 표준. 특징 OAuth 1.0 OAuth 2.0 출시 2010년 이전 2012년 이후 보안 방식 HMAC-SHA1 서명 Bearer Token 방식 암호화 필수 여부 요청마다 암호화 필요 HTTPS만 사용하면 됨 사용성 복잡함 간단하고 확장성이 좋음 클라이언트 유형 웹 앱 중심 모바일, 웹, 서버, IoT 지원 인증 방식 Access Token, Secret Key Access Token, Refresh Token 💡 현재 OAuth 2.0을 대부분 사용 3. OAuth 2.0 상세 동작 방식 🔑 OAuth 2.0의 핵심 개념 Authorization Code: Access Token을 받기 위한 코드 Access Token: API 요청 시 사용하는 인증 키 Refresh Token: Access Token이 만료될 때 새로운 Token을 발급하는 키 Redirect URI: OAuth 서버가 Authorization Code를 전달할 URL OAuth 2.0 인증 과정 1️⃣ 사용자 인증 &amp; 권한 부여 (Authorization Request) 클라이언트가 OAuth 제공자(Google, Kakao 등)에게 로그인 요청 사용자 로그인 후, 권한 허용 여부를 선택 2️⃣ Authorization Code 발급 사용자가 권한을 허용하면, OAuth 서버가 Authorization Code를 클라이언트에게 전달 3️⃣ Access Token 발급 (Token Exchange) 클라이언트는 Authorization Code를 사용해 Access Token 요청 OAuth 서버가 유효성 검증 후, Access Token과 Refresh Token 발급 4️⃣ API 요청 (Resource Access) 클라이언트는 Access Token을 포함하여 API 서버에 요청 API 서버는 토큰을 확인한 후 데이터 반환 5️⃣ Access Token 갱신 (Token Refresh) Access Token이 만료되면, Refresh Token을 사용하여 새로운 Access Token 발급 4. OAuth 2.0 Grant Types (인증 방식) Grant Type 설명 사용 예시 Authorization Code 보안이 뛰어난 방식으로, 서버를 거쳐 Access Token을 받음 웹, 모바일 앱에서 로그인 연동 Implicit Access Token을 직접 발급 (보안 약함) 예전 프론트엔드 앱에서 사용 (현재는 사용 X) Resource Owner Password Credentials (ROPC) 사용자 ID/PW를 직접 입력받아 Access Token 발급 신뢰할 수 있는 앱 (예: 사내 시스템) Client Credentials 클라이언트(서버) 자체가 인증됨 (사용자 없음) 서버 간 API 호출 Device Code 디바이스(스마트 TV 등)에서 로그인 TV, IoT 기기 💡 일반적으로 “Authorization Code” 방식이 가장 많이 사용됨. 5. OAuth 2.0의 주요 용어 용어 설명 Resource Owner (사용자) API의 데이터를 소유한 사용자 Client (클라이언트 앱) 사용자의 데이터를 요청하는 앱 (예: 서드파티 앱) Authorization Server 인증을 담당하는 서버 (Google, Kakao 등) Resource Server API 요청을 처리하는 서버 (Google API, Kakao API 등) Access Token 사용자가 인증된 후 API에 접근할 수 있는 키 Refresh Token Access Token이 만료되었을 때 재발급하는 키 Redirect URI OAuth 서버가 Authorization Code를 전달하는 URL 6. OAuth 2.0을 실제 코드로 구현 (1) Authorization Code 방식 (Java) import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; public class OAuthExample { public static void main(String[] args) throws Exception { // 1. Authorization Code 요청 String clientId = \"your-client-id\"; String redirectUri = \"https://your-app.com/callback\"; String authUrl = \"https://oauth-provider.com/auth?client_id=\" + clientId + \"&amp;redirect_uri=\" + redirectUri + \"&amp;response_type=code\"; System.out.println(\"Login URL: \" + authUrl); // 2. Access Token 요청 String authCode = \"received-authorization-code\"; String tokenUrl = \"https://oauth-provider.com/token\"; HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(tokenUrl)) .header(\"Content-Type\", \"application/x-www-form-urlencoded\") .POST(HttpRequest.BodyPublishers.ofString(\"client_id=\" + clientId + \"&amp;code=\" + authCode + \"&amp;redirect_uri=\" + redirectUri + \"&amp;grant_type=authorization_code\")) .build(); HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(\"Access Token Response: \" + response.body()); } } 7. OAuth의 장점 &amp; 단점 ✅ 장점 보안성 강화: ID/PW를 직접 저장하지 않고, Access Token으로 인증 편리한 로그인: Google, Kakao 로그인 등 쉽게 연동 가능 API 사용 간편화: 서드파티 서비스와 연동할 때 필수 토큰 만료로 보안 강화: Access Token이 주기적으로 만료되므로 보안성 향상 ❌ 단점 구현이 복잡함: Access Token, Refresh Token 관리 필요 서버 부하 증가: 토큰 발급 및 검증 과정에서 추가적인 요청 발생 Refresh Token 유출 위험: Refresh Token이 유출되면 악용될 가능성 있음",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-02-20-OAuth/"
  },{
    "title": "[Git] 효율적인 Git commit 전략: 단위 결정, 스타일, 충돌 해결 방법",
    "text": "Commit 단위를 결정 짓는 요소 Udacity style Rebase를 잘쓰자! conflict를 해결하는 방법 Commit 단위를 결정 짓는 요소 하나의 목적 / 의도 커밋은 하나의 논리적 작업 단위만 포함한다. 예시 “로그인 버튼 스타일 수정” 과 “API 요청 추가”는 별도 커밋으로 나눔 변경 사항의 크기 가능한 작은 크기로 나누되, 완결성을 가져야 한다. 독립성 독립적으로 동작할 수 있어야 한다. 커밋 후 언제든 코드를 실행하거나 테스트할 수 있어야 한다. 관련성 서로 연관된 변경사항은 하나의 커밋으로 묶는다. 예시: 새로운 기능을 추가하면서 해당 기능의 스타일을 함께 수정하는 경우, 하나의 커밋으로 처리 가능 하지만 독립적인 기능 수정과 스타일 변경은 별도의 커밋으로 분리해야 함. 의미 있는 메시지 커밋 메시지가 변경 사항을 명확하게 설명할 수 있도록 구성해야함 예시 좋은 예 : “사용자 로그인 API 요청 로직 추가” 나쁜 예 : “수정함” 또는 “업데이트” Udacity style Udacity에서 권장하는 커밋 메시지 작성 스타일을 의미 📌 Udacity 커밋 메시지 스타일 type: 설명 (길이 72자 이내) type: 변경 사항의 유형을 나타냄 (예: feat, fix, refactor 등) 설명: 간결하고 명확한 변경 사항 설명 ✅ Udacity 스타일 커밋 메시지 예시 feat: 로그인 API 요청 추가 fix: 비밀번호 입력 검증 로직 수정 refactor: 중복된 코드 제거 및 함수 리팩토링 style: 코드 스타일 정리 (불필요한 공백 제거) docs: README 파일 업데이트 test: 회원가입 유닛 테스트 추가 chore: 패키지 버전 업데이트 🛠 Udacity 스타일 주요 특징 첫 글자는 소문자 사용 Git 커밋 메시지 관례에 따라 소문자로 시작함 커밋 타입을 명확히 구분 feat: 새로운 기능 추가 fix: 버그 수정 refactor: 코드 리팩토링 기능 유지 + 코드의 가독성, 유지보수성, 성능 최적화등 코드 구조 개선 style: 코드 스타일 변경 (기능 변경 없음) 기능 유지 + 들여쓰기, 공백, 줄정리 등 코드 포맷 정리 docs: 문서 수정 test: 테스트 코드 추가/수정 chore: 빌드 및 패키지 관련 작업 제목 길이는 72자 이내로 유지 Git 로그에서 한눈에 보기 쉽게 유지 명령형 사용 \"Fixed login bug\" ❌ → \"fix: 로그인 버그 수정\" ✅ 🎯 Udacity 스타일을 쓰는 이유 협업 시 일관성 있는 커밋 로그 유지 Git 커밋 히스토리 가독성 향상 자동화된 릴리즈 노트 생성 가능 (Conventional Commits 방식과 유사) 커밋 이력이 깔끔하게 정리되고 팀원들이 쉽게 이해할 수 있어 유지보수 및 협업에 유리하다. Rebase를 잘쓰자! 참조하는 commit을 변경하는 명령어 base branch가 변경될 때마다 rebase를 하면 conflict를 최소화할 수 있다. Rebase란? 🔗 [Git] git rebase 블로그에 정리되어 있습니다! conflict를 해결하는 방법, Reset + force push Reset이란? git reset 명령어는 특정 커밋으로 되돌리는 기능을 하며, 되돌리는 방식에 따라 코드 변경 사항을 유지할 수도 있고, 삭제할 수도 있음 git reset의 주요 옵션 --soft 특정 커밋 이전으로 HEAD를 이동하지만, 변경된 파일과 스테이징 영역은 그대로 유지 보통 최근 커밋을 수정하고 다시 커밋할 때 사용 --mixed (기본 옵션) 특정 커밋 이전으로 HEAD 이동, 스테이징 영역은 초기화되지만 작업 디렉터리는 유지됨 --hard 특정 커밋 이전으로 HEAD 이동, 변경된 코드까지 전부 삭제되며 되돌릴 수 없음 Reset 후 force push 사용 로컬에서 git reset을 사용하여 커밋을 변경하면, 원격 저장소와 커밋 이력이 달라져 git push시 conflict가 발생할 수 있다. 이 문제를 해결하기 위해 git push --force를 사용하면, 로컬 브랜치의 변경사항을 강제로 원격 저장소에 반영할 수 있음 conflict 해결 방법으로써의 Reset + force push commit이 여러개인 경우, 중간에 conflict가 난 경우, 이 후의 커밋 모두 conflict가 발생 하지만 git reset으로 커밋을 하나의 커밋으로 만들면 코드 충돌을 빠르게 해결할 수 있음",
    "tags": "git",
    "url": "/git/2025-02-19-git-commit/"
  },{
    "title": "[JavaScript] DOM &amp; BOM",
    "text": "DOM (Document Object Model) DOM 기본 구조 DOM의 특징 DOM을 활용한 사례 BOM (Browser Object Model) BOM의 특징 BOM 주요 객체 사용 예제 DOM과 BOM의 차이점 DOM (Document Object Model) 웹페이지의 HTML을 트리 구조로 표현한 객체 모델 document객체를 통해 접근 가능 루트 노드는 항상 document 객체 JavaScript를 통해 브라우저에서 웹 페이지를 동적으로 문서를 조작할 수 있게 하는 API 요소를 추가, 수정, 삭제 가능 필요한 이유 웹 페이지 내용 동적으로 변경 가능 사용자 입력에 따라 인터랙티브한 기능 추가 HTML 요소를 추가, 수정, 삭제 가능 CSS 스타일을 JavaScript로 변경 가능 이벤트 핸들링(클릭, 키보드 입력 등) 가능 DOM 기본 구조 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;My Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id=\"title\"&gt;Hello, DOM!&lt;/h1&gt; &lt;p class=\"text\"&gt;This is a paragraph.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 이 HTML 문서는 DOM 트리 구조로 변환됨 Document ├── &lt;html&gt; │ ├── &lt;head&gt; │ │ └── &lt;title&gt;My Page&lt;/title&gt; │ ├── &lt;body&gt; │ │ ├── &lt;h1 id=\"title\"&gt;Hello, DOM!&lt;/h1&gt; │ │ └── &lt;p class=\"text\"&gt;This is a paragraph.&lt;/p&gt; DOM 조작 예제 (JavaScript) // 요소 선택 let title = document.getElementById(\"title\"); // &lt;h1&gt; 요소 선택 let text = document.querySelector(\".text\"); // &lt;p&gt; 요소 선택 // 요소 내용 변경 title.innerText = \"Hello, World!\"; text.innerHTML = \"&lt;b&gt;Updated paragraph!&lt;/b&gt;\"; // 요소 스타일 변경 title.style.color = \"blue\"; // 요소 추가 let newParagraph = document.createElement(\"p\"); newParagraph.innerText = \"This is a new paragraph!\"; DOM의 특징 주요 속성 및 메서드 document.body 문서의 &lt;body&gt; 요소 반환 firstElementChile, lastElementChild 첫 번째와 마지막 자식 요소를 반환 children 모든 자식 요소의 컬렉션을 반환 DOM을 활용한 사례 동적 리스트 추가 html &lt;ul id=\"itemList\"&gt;&lt;/ul&gt; &lt;button id=\"addItem\"&gt;Add Item&lt;/button&gt; javascript let button = document.getElementById(\"addItem\"); let list = document.getElementById(\"itemList\"); button.addEventListener(\"click\", function () { let newItem = document.createElement(\"li\"); newItem.innerText = \"New Item\"; list.appendChild(newItem); }); BOM (Browser Object Model) 브라우저 창과 관련된 객체를 제공하는 모델 웹페이지가 아닌 브라우저 자체를 제어할 수 있도록 해주는 API BOM의 특징 웹 브우저 창, URL, 히스토리, 콘솔 등을 조작 가능 window 객체를 통해 접근 가능 대표적인 BOM 객체 window -&gt; 브라우저 창 전체 navigator -&gt; 브라우저 정보 location -&gt; 현재 URL 정보 history -&gt; 방문 기록 관리 screen -&gt; 디바이스 화면 정보 BOM 주요 객체 사용 예제 window console.log(window.innerWidth); //현재 브라우저 창 너비 console.log(window.innerHeight); window.alert(\"This is an alert!\"); navigator console.log(navigator.userAgent); //사용자 브라우저 정보 console.log(navigator.language); //사용 언어 histofy history.back(); //이전 페이지로 이동 history.forward(); //다음 페이지로 이동 DOM과 BOM의 차이점 비교 항목 DOM BOM 역할 HTML 문서를 객체로 표현하여 조작 브라우저 창과 관련된 기능 제공 중심 객체 document 객체 window 객체 조작 대상 HTML 요소, 스타일, 속성 브라우저 창, URL, 히스토리, 화면 정보 사용 예시 &lt;div&gt;, &lt;p&gt; 등의 조작 새 창 열기, 페이지 이동, 알림 띄우기 주요 메서드 .getElementById(), .querySelector(), .innerText alert(), location.href, history.back()",
    "tags": "javascript",
    "url": "/javascript/2025-02-05-dom-bom/"
  },{
    "title": "[Etc] 직렬화 (Serialization)와 역직렬화(Deserialization)",
    "text": "직렬화와 역직렬화 직렬화란? 📦 역직렬화란? 📦 ➡️ 💻 언어별 직렬화 및 역직렬화 예시 직렬화(Serialization)과 역직렬화(Deserialization) 💾 ➡️ 💻 직렬화 프로그램에서 사용하는 데이터를 파일이나 네트워크를 통해 전송하거나 저장하기 쉬운 형태로 변환하는 과정 역직렬화 그 반대로, 저장되거나 전송된 데이터를 다시 프로그램에서 사용할 수 있는 원래의 데이터 형태로 복원하는 과정 직렬화 (Serialization) 이란? 📦 직렬화는 메모리 상에 있는 객체나 데이터 구조를 바이트 스트림 형태로 변환하는 것을 의미한다. 마치 택배 상자에 물건을 포장하는 것처럼, 데이터를 “직렬” 형태로 나열하여 보관하거나 전송하기 좋게 만드는 것. 주요 목적: 데이터 저장: 객체의 상태를 파일이나 데이터베이스에 저장하여 영구적으로 보관 💾 데이터 전송: 네트워크를 통해 객체를 다른 시스템으로 전송 🌐 원격 호출 (RPC, RMI): 객체를 네트워크를 통해 다른 시스템의 메소드 인자로 전달 📞 예시: 객체를 JSON이나 XML 형태로 변환하여 텍스트 파일에 저장 객체를 바이너리 형태로 변환하여 네트워크 소켓을 통해 전송 역직렬화 (Deserialization) 이란? 📦 ➡️ 💻 역직렬화는 직렬화된 바이트 스트림을 다시 원래의 객체나 데이터 구조로 복원하는 과정 택배 상자를 열어 내용물을 꺼내는 것과 비슷하게, 직렬화된 데이터를 “역으로 직렬”화하여 프로그램이 이해할 수 있는 형태로 되돌리는 것. 주요 목적: 저장된 데이터 로드: 파일이나 데이터베이스에서 직렬화된 객체를 읽어와 메모리에 복원 💾 ➡️ 💻 전송된 데이터 수신: 네트워크를 통해 수신된 직렬화된 데이터를 객체로 변환 🌐 ➡️ 💻 원격 호출 결과 처리: 원격 시스템으로부터 직렬화된 객체 형태로 결과를 받아 원래 객체로 복원 📞 ➡️ 💻 예시: JSON이나 XML 텍스트 파일을 읽어 객체로 복원 바이너리 데이터를 네트워크 소켓으로부터 읽어 객체로 복원 언어별 직렬화 및 역직렬화 예시 JavaScripnt (Node.js) JavaScript에서는 기본적으로 JSON 객체를 사용하여 직렬화 및 역직렬화를 많이 수행 바이너리 직렬화는 Buffer 객체 등을 활용해야 합니다. // 직렬화 (Serialization) const data = { name: \"David\", city: \"Seoul\" }; const jsonString = JSON.stringify(data); // 📦 -&gt; JSON String console.log(jsonString); // {\"name\":\"David\",\"city\":\"Seoul\"} // 역직렬화 (Deserialization) const loadedData = JSON.parse(jsonString); // JSON String -&gt; 📦 -&gt; 💻 console.log(loadedData); // { name: 'David', city: 'Seoul' } Python Python에서는 pickle 모듈을 사용하여 직렬화 및 역직렬화를 기본적으로 지원한다. JSON, marshal 등 다양한 모듈도 활용 가능 import pickle # 직렬화 (Serialization) data = {'name': 'Alice', 'age': 30} with open('data.pickle', 'wb') as f: pickle.dump(data, f) # 📦 -&gt; 💾 # 역직렬화 (Deserialization) with open('data.pickle', 'rb') as f: loaded_data = pickle.load(f) # 💾 -&gt; 📦 -&gt; 💻 print(loaded_data) # {'name': 'Alice', 'age': 30} Java Java는 java.io.Serializable 인터페이스를 구현한 클래스에 대해 직렬화를 기본적으로 지원합니다. JSON 라이브러리 (Jackson, Gson 등)를 사용하여 JSON 직렬화/역직렬화도 많이 사용됨. import java.io.*; class Person implements Serializable { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + '}'; } } public class SerializationExample { public static void main(String[] args) { // 직렬화 (Serialization) Person person = new Person(\"Bob\", 25); try (FileOutputStream fileOut = new FileOutputStream(\"person.ser\"); ObjectOutputStream out = new ObjectOutputStream(fileOut)) { out.writeObject(person); // 📦 -&gt; 💾 System.out.println(\"Serialized data is saved in person.ser\"); } catch (IOException i) { i.printStackTrace(); } // 역직렬화 (Deserialization) Person loadedPerson = null; try (FileInputStream fileIn = new FileInputStream(\"person.ser\"); ObjectInputStream in = new ObjectInputStream(fileIn)) { loadedPerson = (Person) in.readObject(); // 💾 -&gt; 📦 -&gt; 💻 } catch (IOException i) { i.printStackTrace(); return; } catch (ClassNotFoundException c) { System.out.println(\"Person class not found\"); c.printStackTrace(); return; } System.out.println(\"Deserialized Person: \" + loadedPerson); // Deserialized Person: Person{name='Bob', age=25} } } Kotlin Kotlin은 Java와 유사하게 java.io.Serializable 인터페이스를 사용하거나, Jackson, Gson 같은 JSON 라이브러리를 활용 Kotlin Serialization library를 사용하여 더 간편하게 직렬화/역직렬화를 할 수도 있음 import kotlinx.serialization.* import kotlinx.serialization.json.* import java.io.* @Serializable data class User(val name: String, val age: Int) fun main() { // 직렬화 (Serialization) val user = User(\"Eve\", 28) val json = Json.encodeToString(User.serializer(), user) # 📦 -&gt; JSON String println(json) # {\"name\":\"Eve\",\"age\":28} // 역직렬화 (Deserialization) val loadedUser = Json.decodeFromString(User.serializer(), json) # JSON String -&gt; 📦 -&gt; 💻 println(loadedUser) # User(name=Eve, age=28) // Java Serializable 사용 (Java와 동일) // ... (Java 예시 코드와 유사) }",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-02-04-serialization/"
  },{
    "title": "[JavaScript] 로컬 스토리지 VS 세션 스토리지",
    "text": "로컬 스토리지 VS 세션 스토리지 데이터 유지 기간 접근 범위 활용 예제 사용 방법 (JavaScript) 로컬 스토리지 (Local Storage) VS 세션 스토리지 (Session Storage) 둘 다 웹 브라우저의 저장소 데이터를 클라이언트 측에 저장할 수 있는 기능을 제공 아래는 차이점을 확인할 수 있다. 데이터 유지 기간 Local Storage 브라우저를 닫아도 데이터가 유지됨 명시적으로 삭제하지 않는 한 영구적으로 저장됨 Session Storage 브라우저의 탭을 닫으면 데이터가 삭제됨 세션동안만 유지됨 세션 : 일정 기간 동안 유지되는 사용자와 시스템 간의 연결 상태 (주로 사용자의 로그인 상태 유지, 임시 데이터 저장에 사용됨) 접근 범위 Local Storage 같은 출처 (Origin, 즉 도메인+프로토콜+포트)가 같다면 모든 탬과 창에서 접근 가능 Session Storage 같은 출처라도 각 탭과 창마다 개별적인 저장소 가짐 다른 탭에서 접근 불가 활용 예제 Local Storage 로그인 정보, 사용자 설정, 테마 설정 등 장기적으로 유지해야하는 데이터 저장 Session Storage 특정 페이지에서만 필요한 임시 데이터 등 일시적인 데이터 저장 사용 방법 (JavaScript) Local Storage // 데이터 저장 localStorage.setItem(\"username\", \"JohnDoe\"); // 데이터 가져오기 console.log(localStorage.getItem(\"username\")); // \"JohnDoe\" Session Storage // 데이터 저장 sessionStorage.setItem(\"sessionUser\", \"JaneDoe\"); // 데이터 가져오기 console.log(sessionStorage.getItem(\"sessionUser\")); // \"JaneDoe\"",
    "tags": "javascript",
    "url": "/javascript/2025-02-04-storage/"
  },{
    "title": "[JavaScript] 함수",
    "text": "함수 (function) 화살표 함수 고차 함수 (map, filter, reduce) 구조 분해 할당 함수 (function) 함수 선언 function으로 선언 호이스팅 (hoisting) JavaScript에서 변수, 함수 선언, 클래스 등의 선언이 코드 실행 전에 메모리에 미리 할당되는 현상 코드에서 선언이 끌어올려진(hoisted) 것처럼 동작 변수 타입 선언 Hoisting 초기화 여부 선언 전 접근 var ✅ O ✅ (undefined) ✅ 가능 (undefined 반환) let ✅ O ❌ (TDZ 존재) ❌ ReferenceError const ✅ O ❌ (TDZ 존재) ❌ ReferenceError 함수 선언 이전에 호출이 가능 function welcomeMessage(username) { return \"Hi, ${username}!\"; } console.log(welcomeMessage(\"Lily\")); 함수 표현식 이름이 없는 함수를 만들어 변수에 할당하여 정의 호이스팅되지 않으므로, 함수 정의 이후에만 호출 가능 화살표 함수 ES6에서 도입된 간결한 함수 표현 방식 //ex1 const welcomeMessage = (username) =&gt; \"Hi, ${username}!\"; console.log(welcomeMessage(\"Lily\")); //ex2 const calculateArea = (width, height) =&gt; { let area = width * height; return area; }; console.log(calculateArea(5, 10)); // 출력: 50 함수 표현식보다 간결하게 작성 가능함 this 바인딩이 화살표 함수의 정의 위치에서 고정되는 특성을 가짐 this 바인딩 (Binding) this 키워드가 특정 실행 문맥(Excution Context)에서 어떤 객체를 가리키는지 결정되는 과정 JavaScript에서 this는 어떻게, 어디서 호출되었느냐에 따라 값이 달라짐 전통적인 함수와 화살표 함수의 this 바인딩 방식이 다름 전통적인 함수 호출 맥락에 따라 this가 변경될 수 있음 화살표 함수 this가 고정되어 예상치 못한 this의 문제를 방지함 기본적인 this 바인딩 규칙 호출 방식 this가 가리키는 대상 일반 함수 호출 window (브라우저) 또는 undefined (strict mode) 메서드 호출 (객체 안에서) 해당 객체 생성자 함수 새로 생성된 인스턴스 call, apply, bind 사용 명시적으로 지정된 객체 화살표 함수 부모(외부) 스코프의 this 예시 //일반 함수 호출 function showThis() { console.log(this); } showThis(); //브라우저: window, strict mode: undefined //화살표 함수 const user2 = { name: \"Lily\", greet: function() { const arrow = () =&gt; { console.log(this.name); }; arrow(); } }; user2.greet(); //\"Lily\" ``` 고차 함수 map 배열의 각 요소를 변환하여 새로운 배열 생성 원본 배열은 유지 const num = [1, 2, 3]; const mul = num.map((n) =&gt; n * 10); console.log(mul); //[ 10, 20, 30 ] filter 배열에서 조건에 맞는 요소만 반환하여 새로운 배열을 생성 원본 배열은 유지 const words = [\"apple\", \"banana\", \"avocado\", \"cherry\", \"apricot\"]; const aWords = words.filter((word) =&gt; word.startsWith(\"a\")); console.log(aWords); // [\"apple\", \"avocado\", \"apricot\"] reduce 배열의 모든 요소를 순회하며 누적하여 단일 값(accumulator) 생성 초기값 설정 가능 집계 연산에 유용 const numbers = [1, 2, 3, 4, 5]; const product = numbers.reduce((acc, num) =&gt; acc * num, 1); console.log(product); // 120 구조 분해 할당 배열 구조 분해 할당 배열을 개별 변수로 분해 가능 스프레드 연산자(...)로 나머지 요소 처리 가능 const [x, y, ...remaining] = [10, 20, 30, 40, 50]; console.log(x, y, remaining); // 10 20 [30, 40, 50] 객체 구조 분해 할당 객체에서 속성을 변후로 추출 가능 기본값 설정 가능 const { brand, model, year = 2023 } = { brand: \"Tesla\", model: \"Model S\" }; console.log(brand, model, year); // Tesla Model S 2023 중첩된 객체의 속성도 분해하여 사용 가능 const person = { info: { firstName: \"Alice\", lastName: \"Johnson\", }, age: 28, }; const { info: { firstName, lastName }, age, } = person; console.log(firstName, lastName, age); // Alice Johnson 28 함수에서 구조 분해 활용 function displayCar({ brand, model, year }) { console.log(`The car is a ${year} ${brand} ${model}`); } displayCar({ brand: \"Toyota\", model: \"Corolla\", year: 2022 }); // The car is a 2022 Toyota Corolla",
    "tags": "javascript",
    "url": "/javascript/2025-01-30-js-function/"
  },{
    "title": "[JAVA] Generic",
    "text": "Generic이란? Generic의 장점 Generic 사용법 Generic이란? 클래스나 메서드에서 사용할 데이터 타입을 지정하지 않고, 나중에 사용할 때 타입을 결정하는 기능 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방법 클래스 내부에서 지정하는 것이 아닌, 외부에서 사용자에 의해 지정되는 것을 의미 specific 타입을 미리 지정해주는 것이 아닌 필요에 의해 지정할 수 있도록 하는 generic 타입 제네릭을 사용하면 코드의 재사용성을 높이고, 타입 안정성을 보장할 수 있음 ArrayList&lt;T&gt;, HashMap&lt;K, V&gt;같은 자바 컬렉션 프레임워크에서 많이 사용됨 Generic의 장점 타입 안정성 (Type Safety) 보장 제네릭을 사용하면 컴파일 시점에 타입을 검사해서 타입 오류 방지 가능 예를 들어, ArrayList에 String만 저장하도록 지정하면 다른 타입을 추가하는 실수를 막을 수 있음 형변환(Casting) 불필요 제네릭을 사용하면 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환할 필요 없음 관리하기 편함 코드의 재사용성 증가 같은 로직을 다양한 데이터 타입에 대해 사용할 수 있어 코드의 중복을 줄일 수 있음 Generic 사용법 import java.util.ArrayList; public class WithGenerics { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //제네릭 사용 //ArrayList list = new ArrayList(); 제네릭 미사용 list.add(\"Hello\"); //list.add(123); 오류 발생 (타입 안정성 보장) //제네릭을 사용하지 않으면 오류 발생 X -&gt; 문제 발생 가능 String str = list.get(0); //형변환 없이 바로 사용 가능 System.out.println(str); } } 제네릭 클래스 만들기 // 제네릭 클래스 선언 (T는 타입 매개변수) class Box&lt;T&gt; { private T value; public void setValue(T value) { this.value = value; } public T getValue() { return value; } } public class GenericExample { public static void main(String[] args) { Box&lt;String&gt; stringBox = new Box&lt;&gt;(); //String으로 구체적인 타입 지정 stringBox.setValue(\"Hello\"); System.out.println(stringBox.getValue()); Box&lt;Integer&gt; intBox = new Box&lt;&gt;(); intBox.setValue(100); System.out.println(intBox.getValue()); } } 제네릭 메서드 만들기 class Util { // 제네릭 메서드 선언 public static &lt;T&gt; void printData(T data) { System.out.println(data); } } public class GenericMethodExample { public static void main(String[] args) { Util.printData(\"Hello\"); // String 타입 Util.printData(123); // Integer 타입 Util.printData(3.14); // Double 타입 } } 제네릭 타입 제한 (Bounded Type Parameter) // Number를 상속받은 타입만 사용 가능 (Integer, Double 등) class NumberBox&lt;T extends Number&gt; { private T number; public void setNumber(T number) { this.number = number; } public T getNumber() { return number; } } public class BoundedGenericExample { public static void main(String[] args) { NumberBox&lt;Integer&gt; intBox = new NumberBox&lt;&gt;(); intBox.setNumber(100); System.out.println(intBox.getNumber()); NumberBox&lt;Double&gt; doubleBox = new NumberBox&lt;&gt;(); doubleBox.setNumber(3.14); System.out.println(doubleBox.getNumber()); // NumberBox&lt;String&gt; strBox = new NumberBox&lt;&gt;(); // 오류 발생 (String은 Number가 아님) } } 와일드카드 (? - 제네릭 타입 미지정) 특정 타입을 제한하지 않고 유연하게 사용하고 싶은 경우 import java.util.ArrayList; import java.util.List; class WildcardExample { public static void printList(List&lt;?&gt; list) { // 와일드카드 사용 for (Object obj : list) { System.out.println(obj); } } public static void main(String[] args) { List&lt;String&gt; stringList = new ArrayList&lt;&gt;(); stringList.add(\"Apple\"); stringList.add(\"Banana\"); List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); intList.add(1); intList.add(2); printList(stringList); // 가능 printList(intList); // 가능 } }",
    "tags": "java",
    "url": "/java/2025-01-29-generic/"
  },{
    "title": "[Etc] TDD (Test-Driven Development, 테스트 주도 개발)",
    "text": "TDD란? TDD의 주요 과정 TDD의 장점 TDD 예제 (Java) TDD VS 전통적인 개발 방식 TDD가 필요한 경우 TDD의 단점 xUnit TDD (Test-Driven Development)란? 테스트 주도 개발 소프트웨어 개발 방법론 중 하나로, 테스트 코드를 먼저 작성한 후 실제 기능을 구현하는 방식 테스트 먼저, 코드 작성 나중! 짧은 개발 주기의 반복에 의존하는 개발 프로세스 애자일 방법론 중 하나인 eXtream Programming(XP)의 “Test-First” 개념에 기반을 둔 단순한 설계를 중요시함 eXtream Programming(XP) 미래에 대한 예측을 최대한 하지 않고, 지속적으로 프로토타입을 완성하는 애자일 방법론 중 하나 추가 요구사항이 생기더라도, 실시간으로 반영할 수 있음 TDD의 주요 과정 Red-Green-Refactor 세 단계 반복 1️⃣ Red (실패하는 테스트 작성) 구현할 기능에 대한 테스트 코드 작성 실제 기능이 이 시점에서는 없기 때문에 테스트는 실패 빨간색 = 실패 2️⃣ Green (코드 작성 후 테스트 통과) 테스트를 통과할 최소한의 코드만 작성 코드가 정상적으로 동작하여 테스트가 성공하면 다음 단계로 넘어감 초록색 = 성공 3️⃣ Refactor (리팩토링) 코드의 중복을 제거하고 더 나은 구조로 개선 테스트를 다시 실행하여 리팩토링 후에도 테스트가 성공하는지 확인 성능 개선, 코드 가독성 높이기 TDD의 장점 버그 감소 미리 테스트를 작성하기 때문에 오류를 조기에 발견할 수 있음 리팩토링 용이 테스트 코드가 보장되므로 안심하고 코드를 사용 가능 유지보수성 향상 코드가 변경될 때 기존 기능이 정상적으로 동작하는지 확인 가능 문서 역할 테스트 코드 자체가 기능 명세서 역할을 함 TDD 예제 (Java) 1. 실패하는 테스트 작성 import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; public class CalculatorTest { @Test void testAddition() { Calculator calc = new Calculator(); assertEquals(5, calc.add(2,3)); } } 현재 Calculator 클래스와 add() 메서드가 없어서 테스트 실패 2. 최소한의 코드 작성 (테스트 통과) public class Calculator { public int add (int a, int b) { return a+b; } } 이제 테스트 실행하면 성공! 3. 리팩토링 코드가 복잡한 경우 성능 최적화나 코드 구조 개선 가능 TDD VS 전통적인 개발 방식 구분 전통적인 개발 방식 TDD 순서 기능 구현 → 테스트 작성 테스트 작성 → 기능 구현 목적 기능 개발 후 버그 찾기 처음부터 버그 방지 유지보수 테스트 부족 시 리팩토링 어려움 안전한 리팩토링 가능 TDD가 필요한 경우 복잡한 로직이 포함된 코드 알고리즘, 비즈니스 로직 장기적으로 유지보수해야하는 프로젝트 협업이 필요한 개발 환경 테스트 코드가 문서 역할을 하므로 이해하기 쉬움 TDD의 단점 간단한 코드에는 불필요한 오버헤드가 발생할 수 있음 초기 개발 속도가 느려질 수 있음 xUnit 단위 테스트를 위한 프레임워크 JUnit(for JAVA)을 시작으로 여러 xUnit 프레임워크가 탄생함 xUnit 이름 해당 언어 관련 사이트 CUnit C CUnit CppUnit C++ CppUnit PHPUnit PHP PHPUnit PyUnit Python PyUnit JUnit Java JUnit",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-28-tdd/"
  },{
    "title": "[JavaScript] 단축 평가",
    "text": "단축 평가란? 단축 평가 동작 방식 단축 평가 활용 예시 주의사항 단축 평가 (Short-circuit evaluation) 논리 연산자 (&amp;&amp;, ||) 를 평가할 때, 결과를 미리 결정할 수 있다면 나머지 표현식을 평가하지 않고 곧바로 결과를 반환하는 것 &amp;&amp; (AND) 연산자: 두 피연산자가 모두 true 일 때만 true 를 반환합니다. || (OR) 연산자: 두 피연산자 중 하나라도 true 이면 true 를 반환합니다. 논리 연산자의 동작 방식을 이용하여 불필요한 연산을 줄이고, 코드 실행 효율성을 높임. &amp;&amp; (AND) 와 || (OR) 연산자를 조건문 없이 사용하는 코드를 가능하게 함 단축 평가 동작 방식 1. &amp;&amp; (AND) 연산자 &amp;&amp; 연산자는 좌항부터 평가 좌항이 false 라면: &amp;&amp; 연산의 결과는 항상 false 이므로, 우항을 평가하지 않고 곧바로 false 를 반환 좌항이 true 라면: &amp;&amp; 연산의 결과는 우항에 따라 결정되므로, 우항을 평가하고 그 결과를 반환 console.log(false &amp;&amp; true); //falsk //(좌항이 false이므로 우항을 평가하지 않고 false 반환) console.log(true &amp;&amp; false); //false //(좌항이 true이므로 우항을 평가하여 false 반환) console.log(true &amp;&amp; true); //true //(좌항이 true이므로 우항을 평가하여 true 반환) 2. || (OR) 연산자 || 연산자는 &amp;&amp; 연산자와 마찬가지로 좌항부터 평가 좌항이 true 라면: || 연산의 결과는 항상 true 이므로, 우항을 평가하지 않고 곧바로 true 를 반환 좌항이 false 라면: || 연산의 결과는 우항에 따라 결정되므로, 우항을 평가하고 그 결과를 반환 console.log(true || false); //true //(좌항이 true이므로 우항을 평가하지 않고 true 반환) console.log(false || true); //true //(좌항이 false이므로 우항을 평가하여 true 반환) console.log(false || false); //false //(좌항이 false이므로 우항을 평가하여 false 반환) 단축 평가 활용 예시 1. 객체의 속성에 접근할 때 객체의 속성에 접근하기 전에 객체가 null 또는 undefined 인지 확인하는 코드를 단축 평가로 간결하게 작성 가능 const person = { name: \"Alice\" }; // const person = null; // person이 null인 경우 // 조건문 사용 let name; if (person) { name = person.name; } else { name = \"Unknown\"; } console.log(name); // Alice // 단축 평가 사용 const name2 = person &amp;&amp; person.name; console.log(name2); // Alice (person이 truthy 값이므로 person.name 평가) const person2 = null; const name3 = person2 &amp;&amp; person2.name; console.log(name3); // null (person2가 falsy 값이므로 person2 그대로 반환) // || 연산자를 사용한 기본값 설정 const name4 = person2 || { name: \"Unknown\" }; console.log(name4); // { name: 'Unknown' } (person2가 falsy 값이므로 { name: 'Unknown' } 반환) console.log(name4.name); // Unknown 2. 함수 매개변수에 기본값 설정 함수 매개변수에 기본값을 설정할 때 || 연산자를 사용하여 코드를 간결하게 만들 수 있다. function greet(name) { // 조건문 사용 const userName = name ? name : \"Guest\"; console.log(`Hello, ${userName}!`); } greet(\"Bob\"); // Hello, Bob! greet(); // Hello, Guest! function greet2(name) { // 단축 평가 사용 const userName = name || \"Guest\"; console.log(`Hello, ${userName}!`); } greet2(\"Charlie\"); // Hello, Charlie! greet2(); // Hello, Guest! 3. 조건부 렌더링 (React) React와 같은 UI 라이브러리에서 조건부 렌더링을 구현할 때 단축 평가를 유용하게 사용할 수 있다. function MyComponent({ items }) { return ( &lt;div&gt; {/_ items가 존재하고 배열인 경우에만 목록 렌더링 _/} {items &amp;&amp; Array.isArray(items) &amp;&amp; ( &lt;ul&gt; {items.map((item) =&gt; ( &lt;li key={item.id}&gt;{item.name}&lt;/li&gt; ))} &lt;/ul&gt; )} {/_ items가 없거나 배열이 아닌 경우 메시지 표시 _/} {!items &amp;&amp; &lt;div&gt;No items to display.&lt;/div&gt;} {items || &lt;div&gt;No items to display.&lt;/div&gt;} {/_ || 연산자 사용 _/} &lt;/div&gt; ); } 주의사항 단축 평가는 코드를 간결하게 만들어주지만, 남용하면 코드의 가독성을 해칠 수 있음. 적절한 상황에서 사용하는 것이 중요합니다. &amp;&amp; 와 || 연산자는 boolean 값이 아닌 값도 반환 가능 단축 평가의 반환 값은 마지막으로 평가된 표현식의 결과이다.",
    "tags": "javascript",
    "url": "/javascript/2025-01-27-javascript-short-circuit-evaluation/"
  },{
    "title": "[JAVA] int와 long의 차이 ➡️ 범위와 오버플로우 문제 완벽 정리",
    "text": "int와 long의 차이 int와 long의 입력값 연산 결과의 최대값 예상하기 문제를 보고 빠르게 판단하는 팁 int와 long의 차이 자꾸 문제를 풀다 int와 long을 혼동해서 문제를 틀리는 경우가 있어서 완벽 정리하려고 한다. 입력값의 범위와 연산 결과의 최댓값을 기준으로 판단하는 습관을 들여야 함 int와 long의 입력값 int : 약 -2,147,483,648 ~ 2,147,483,648 long : 약 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,808 문제에 입력값이 명시되어 있다면 -2,000,000,000 &lt;= N,M &lt;= 2,000,000,000 int는 처리 가능. 하지만 연산 결과를 생각해야 함 범위가 int의 한계와 가깝다면, 입력값은 int로 가능하더라도 연산 결과가 범위를 초과할 수 있기 때문에 long을 사용하는 것이 안전 판단 기준 입력값이 -10^9 ~ 10^9 사이일 경우 단순한 덧셈이나 뺄셈은 int로 처리 가능 곱셈, 제곱 연산, 누적 합계 등은 long이 필요할 수 있음 입력값이 -10^{10} 이상이거나, 결과적으로 큰 숫자가 나올 가능성이 있다면 무조건 long 사용 연산 결과의 최대값 예상하기 문제에서 요구하는 연산 결과 예상하기 예) 누적합 문제 배열의 크기가 1,000,000이고, 각 원소가 최대 10^6이라면, 누적합은 최대 10^12가 될 수 있음 이 경우 int의 범위를 초과하므로 long을 사용해야 함 문제를 보고 빠르게 판단하는 팁 입력 범위 확인 연산의 종류 확인 규칙 만들기 “입력값이 10^9 이상이면 무조건 long으로 처리한다” 테스트 데이터 체크 극단적인 입력값을 대입해보기",
    "tags": "java",
    "url": "/java/2025-01-23-int-long/"
  },{
    "title": "[Git] git rebase",
    "text": "git rebase git rebase VS git merge git rebase 사용법 장점 주의 사항 git rebase Git에서 브랜치의 커밋 히스토리를 재구성할 때 사용하는 명령어로, 현재 브랜치의 기반이 되는 커밋을 변경한다. 브랜치의 시작점을 다른 브랜치의 최신 커밋으로 옮겨서, 변경 이력을 깔끔하게 정리함 이를 통해 브랜치의 히스토리를 “정리(clean)”하거나 최신 상태를 기반으로 변경사항을 다시 적용할 수 있음 ‼️ 실제 동작 방식 main 브랜치가 이렇게 변경되었다. A - B - C (main 최신 상태) 내 feature-branch는 main 브랜치를 기반으로 작업했지만 오랜된 상태임 A - B - (내 변경 사항 X, Y) (feature-branch) ➡️ 이 상태에서 git rebase main을 실행하면 A - B - C - ( 내 변경 사항 X, Y) (rebase된 feature-branch) git rebase의 필요성 1. Base 브랜치가 변경될 때 Conflict 최소화 여러 개발자가 동시에 작업하는 경우, 메인 브랜치(main or develop)의 최신 커밋을 반영하지 않으면 충돌이 발생할 가능성이 높다/ Rebase를 하면, 최신 코드 기준으로 브랜치 변경 이력을 재구성할 수 있어, Merge conflict를 최소화할 수 있다. ✅ 예제 : Rebase없이 충돌 발생 feature-branch에서 작업을 했지만, main 브랜치가 업데이트됨 git merge main을 하면 불필요한 merge commit이 생성됨 merge commit이 많아지면 협업시 코드리뷰할 때 이력 파악이 어려워짐 conflict가 날 가능성이 많아짐 ✅ Rebase로 conflict 최소화 git checkout feature-branch git rebase main # → 최신 main 브랜치 기준으로 변경 이력 재구성 ➡️ Rebase를 하면 최신 코드와 충돌을 최소화하면서 깔끔한 커밋 이력 유지 가능 git rebase VS git merge 일반적으로 merge와 같은 목적으로 사용되지만, 다른 방식으로 작동 merge 두 브랜치의 히스토리를 합치면서, 새로운 병합 커밋을 생성 개발이 완료된 브랜치를 병합할 때 주로 사용 두 개의 문서를 그냥 합치기 rebase 한 브랜치의 커밋을 다른 브랜치의 끝으로 옮겨서, 히스토리가 마치 일렬로 정리된 것처럼 보임 불필요한 병합 커밋을 없애고 이력을 깔끔하게 유지 가능 개발 브랜치를 최신 코드로 업데이트 할 때 주로 사용 새로운 버전의 문서 위에 내 작업을 다시 복사해서 붙여넣기 예시 이미지 16d0e75 커밋 아래는 merge 흔적 16d0e75 커밋 위는 rebase로 인한 선형 히스토리 git rebase 사용법 업스트림 브랜치로 리베이스 git swicth -c feature git rebase main feature 브랜치에서 작업한 커밋을들 main 브랜치의 최신 상태를 기반으로 재적용 interactive rebase git rebase -i HEAD~n 마지막 n개의 커밋을 선택적으로 수정하거나 합칠 수 있음 실행하면 편집 모드가 열리며, 옵션을 선택할 수 있음 pick, reword, edit, squash, drop등 장점 히스토리 정리 불필요한 merge 커밋 제거 최신 상태 유지 주의 사항 리베이스 중 충돌 이미 푸시된 브랜치에 리베이스 금지 git pull --rebase 원격 브랜치의 변경 사항을 병합 대신 리베이스로 가져올 때 사용",
    "tags": "git",
    "url": "/git/2025-01-23-git-rebase/"
  },{
    "title": "[Etc] Naming Convention",
    "text": "Naming Convention이란? 케밥 케이스 (Kebab-case) 카멜 케이스 (camelCase) 스네이크 케이스 (snake_case) 파스칼 케이스 (PascalCase) 선택 기준 Naming Convention이란? 프로그래밍에서 변수, 함수, 클래스 이름 등을 작성하는 규칙 1. 케밥 케이스 (Kebab-case) 단어를 하이픈(-)으로 구분하며, 모든 문자를 소문자로 작성 모양이 케밥을 닮았다고 해서 붙여진 이름 특징 가독성이 좋음 HTML, CSS에서 자주 사용됨 언어에 따라 변수나 함수이름으로는 사용할 수 없는 경우도 있음 하이픈이 연산자로 해석될 수 있어서 예시 /* CSS 클래스 이름 */ .button-primary { background-color: blue; color: white; } /* 파일 이름 */ my-awesome-file.js 2. 카멜 케이스 (camelCase) 첫 단어는 소문자로 시작하고, 이후 단어의 첫 글자를 대문자로 작성 이름이 낙타의 등처럼 튀어나온 형태를 닮아서 붙인 이름 특징 JavaScript, Java, C#, Python 등에서 변수와 함수 이름으로 자주 사용됨 대문자 없이 단어를 연결해 코드 가독성을 높이는 데 도움을 줌 예시 // JavaScript 변수와 함수 let userName = \"Alice\"; function getUserData() { return userName; } 3. 스네이크 케이스 (snake_case) 단어를 밑줄(_)로 구분하며, 모든 문자를 소문자로 작성 뱀이 기어다니는 모양을 닮아서 붙여진 이름 특징 Python, SQL, Ruby, C, C++, PHP, JSON 데이터 스키마에서 변수와 함수 이름으로 자주 사용됨 예시 # Python 변수 이름 user_name = \"Alice\" # Python 함수 이름 def get_user_data(): return user_name 4. 파스칼 케이스 (PascalCase) 각 단어의 첫 글자를 대문자로 작성 카멜 케이스와 비슷하지만 첫 단어도 대문자 특징 Java, TypeScript등의 클래스 이름과 타입 이름으로 자주 사용됨 예시 // Java 클래스 이름 public class UserAccount { private String UserName; public UserAccount(String userName) { this.UserName = userName; } } 선택 기준 언어/환경의 표준에 따라 케이스를 선택 JavaScript, Java camelCase (변수/함수) PascalCase (클래스) Python snake_case CSS/HTML kebab-case 팀 또는 프로젝트의 코딩 컨벤션에 따라 일관성 유지가 중요 (가독성을 위해)",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-22-naming-convention/"
  },{
    "title": "[Git] git clone VS git fork",
    "text": "git clone git fork 주요 차이점 정리 워크플로우 실전 예시 git clone 역할 원격 저장소를 로컬 컴퓨터에 복제 작업 대상 원격 저장소 특징 저장소의 완전한 복사본(전체 커밋 내역, 브랜치 등)을 가져옴 복제 후, 원격 저장소가 자동으로 origin이라는 이름으로 연결됨 로컬에서 작업한 내용을 원격 저장소에 반영하려면 push사용 동작 방식 Git 저장소 초기화 (git init) 새로 생성된 폴더는 Git 저장소로 설정됨 .git 디렉터리가 자동으로 생성됨 원격 저장소 설정 (git remote add origin) 복제한 원격 저장소가 자동으로 origin이라는 이름으로 연결됨 로컬에서 원격 저장소와 동기화(push, pull)를 가능하게 함 브랜치 체크아웃 기본 브랜치(main or master)의 최신 상태가 복제됨 이 브랜치는 로컬 저장소로 가져와 자동으로 체크아웃됨 파일 다운로드 원격 저장소에 있는 모든 파일과 폴더가 로컬 디렉토리에 다운로드됨 git clone 명령을 실행하면, 다운받은 폴더는 자동으로 Git 저장소로 초기화되고, 원격 저장소와도 연결된 상태임 git init이나 git remote add를 실행할 필요가 없음 git fork 역할 원격 저장소를 자신의 원격 계정으로 복제 작업 대상 GitHub/GitLab 계정 상의 저장소 특징 원본 저장소의 복사본이 내 계정의 원격 저장소로 생성됨 내 계정에서 관리할 수 있는 원격 저장소를 만든다는 것이 핵심 원본 저장소와 연결은 유지되지만, 독립적인 저장소로 사용됨 추가 단계 포크 후, 로컬에 복사하려면 git clone을 사용해야 함 사용 시기 오픈소스 프로젝트에 기여할 때, 원본 저장소를 수정하지 않고 내 계정에서 관리 가능한 복사본을 만들어야 할 때 사용 Pull Request를 보내기 위한 준비 단계로 사용 주요 차이점 정리 특징 git clone git fork 복제 대상 원격 저장소 ➡️ 로컬 저장소 원격 저장소 ➡️ 내 원격 저장소 저장소 위치 로컬에서 작업 내 계정의 원격 저장소에서 작업 연결된 원격 저장소 origin으로 원본 저장소 연결 내 계정의 원격 저장소 (원본 저장소는 upstream으로 연결 가능) 사용 목적 로컬에서 작업하고 원본 저장소에 반영 내 계정에서 독립적으로 원격 저장소 관리 주로 사용 상황 협업 프로젝트에 바로 참여 오픈소스 프로젝트에 기여 (Pull Request 준비) 워크플로우 일반적으로 Fork → Clone → Push → Pull Request가 오픈 소스 협업의 표준 워크플로우 Fork 저장소 생성 먼저, 해당 저장소를 Fork하여 내 계정으로 복사 GitHub에서 기여하고자 하는 저장소 페이지로 이동 우측 상단의 Fork 버튼을 클릭 그러면 내 계정에 저장소 복사본이 생성됨 Fork 저장소 Clone Fork된 저장소를 로컬로 복제 git clone https://github.com/your-username/repository.git your-username은 GitHub 계정 이름으로 대체 Clone이 완료되면 로컬 환경에서 작업 가능 원본 저장소 추가 (선택 사항) 원본 저장소와 동기화를 유지하려면, 원본 저장소를 upstream으로 추가 git remote add upstream https://github.com/original-owner/repository.git original-owner는 원본 저장소의 소유자 이름으로 대체 git remote -v 명령을 사용하여 설정이 제대로 되었는지 확인 가능 로컬에서 작업 새로운 파일을 추가하거나 수정 후 커밋 git add . git commit -m \"Add new feature\" Fork된 저장소에 Push 로컬에서 작업한 내용을 자신의 Fork 저장소에 Push git push origin main 여기서 main은 사용하는 브랜치 이름 Pull Request 생성 GitHub로 돌아가, Fork된 저장소에서 원본 저장소로 Pull Request를 생성 내 Fork 저장소 페이지에서 “Contribute” 버튼 클릭. “Open Pull Request” 버튼 클릭. 변경 사항에 대한 설명을 작성하고 Pull Request를 제출합니다. ✅ 요약 다른 사람의 저장소에 기여하기 위한 전체 과정 Fork: 저장소를 내 계정으로 복제. Clone: 내 계정에 있는 저장소를 로컬로 복제. 원본 저장소 추가: 원본 저장소와 동기화(선택 사항). 작업: 로컬에서 파일 수정 및 커밋. Push: 작업 내용을 내 계정 저장소로 업로드. Pull Request: 원본 저장소에 변경 사항을 제안. 실전 예시 git clone만 사용하는 경우 팀 프로젝트에서 기존 저장소를 복제하여 작업 후, 원본 저장소에 바로 push git clone &lt;repository-url&gt; cd &lt;repository-folder&gt; # 작업 후 git push origin &lt;branch-name&gt; git fork와 git clone을 함께 사용하는 경우 오픈소스 프로젝트에서 자신의 계정으로 fork 후, 로컬에서 복제하여 작업 후 pull request 보냄 # GitHub에서 Fork한 후 git clone &lt;forked-repository-url&gt; cd &lt;repository-folder&gt; # 원본 저장소를 upstream으로 추가 git remote add upstream &lt;original-repository-url&gt; git fetch upstream # 작업 후, 내 계정 원격 저장소에 Push git push origin &lt;branch-name&gt;",
    "tags": "git",
    "url": "/git/2025-01-22-git-clone-fork/"
  },{
    "title": "[CSS] CSS Flex",
    "text": "Flex(Flexbox) 주요 Flexbox 속성 20개 예제: 통합 코드 flex를 이용한 게임 Flex(Flexbox) Flexbox(Flexible Box Layout Module) 컨테이너 내의 아이템 간 공간 배분과 정렬 기능을 제공하는 1차원 레이아웃 모델 주로 행이나 열 단위로 작동하며, 복잡한 계산 없이도 요소들의 크기와 순서를 유연하게 배치할 수 있음 장점 복잡한 레이아웃을 간단하게 구현 컨테이너 내 요소의 크기가 불명확하거나 동적인 경우에도 효과적으로 대응 요소의 순서를 CSS로 변경할 수 있어 반응형 디자인에 유용 float나 Position을 사용할 때보다 코드가 간결해짐 주요 Flexbox 속성 CSS3 Flexbox에서 가장 많이 사용되는 20개의 속성(property)을 아래에 정리했습니다. 각각의 속성에 대한 간략한 설명과 함께 예제 코드를 제공합니다. 1. display: flex Flexbox를 활성화. .container { display: flex; } 2. flex-direction 주축의 방향 설정. row (기본값), row-reverse, column, column-reverse. .container { flex-direction: column; } 3. justify-content 주축에서 항목 정렬. flex-start, flex-end, center, space-between, space-around, space-evenly. .container { justify-content: space-between; } 4. align-items 교차축에서 항목 정렬. stretch (기본값), flex-start, flex-end, center, baseline. .container { align-items: center; } 5. align-content 여러 줄에서 교차축 정렬. stretch, flex-start, flex-end, center, space-between, space-around. .container { align-content: space-around; } 6. flex-wrap 항목이 컨테이너를 초과하면 줄 바꿈 여부. nowrap (기본값), wrap, wrap-reverse. .container { flex-wrap: wrap; } 7. flex 개별 항목의 크기 설정 (약어). flex: grow shrink basis; .item { flex: 1 1 auto; } 8. flex-grow 남은 공간을 차지할 비율. 기본값: 0. .item { flex-grow: 2; } 9. flex-shrink 공간 부족 시 줄어드는 비율. 기본값: 1. .item { flex-shrink: 0; } 10. flex-basis 항목의 기본 크기 설정. .item { flex-basis: 100px; } 11. order 항목의 배치 순서. 기본값: 0. .item { order: 2; } 12. gap 항목 간 간격 설정. .container { gap: 20px; } 13. row-gap 가로축 항목 간 간격 설정. .container { row-gap: 15px; } 14. column-gap 세로축 항목 간 간격 설정. .container { column-gap: 10px; } 15. align-self 개별 항목의 교차축 정렬 설정. auto, flex-start, flex-end, center, baseline, stretch. .item { align-self: flex-end; } 16. min-width 항목의 최소 너비. .item { min-width: 100px; } 17. max-width 항목의 최대 너비. .item { max-width: 200px; } 18. min-height 항목의 최소 높이. .item { min-height: 50px; } 19. max-height 항목의 최대 높이. .item { max-height: 150px; } 20. place-content justify-content와 align-content를 한 번에 설정. center, stretch, space-between 등. .container { place-content: center; } 예제: 통합 코드 &lt;div class=\"container\"&gt; &lt;div class=\"item\"&gt;Item 1&lt;/div&gt; &lt;div class=\"item\"&gt;Item 2&lt;/div&gt; &lt;div class=\"item\"&gt;Item 3&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .container { display: flex; flex-direction: row; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; height: 300px; } .item { flex: 1 1 100px; align-self: stretch; min-width: 100px; max-width: 300px; } &lt;/style&gt; flex를 이용한 게임 https://flexboxfroggy.com/#ko 다 깼다!",
    "tags": "javascript",
    "url": "/javascript/2025-01-21-css-flex/"
  },{
    "title": "[Etc] Responsive VS Reactive",
    "text": "Responsive Reactive Responsive VS Reactive 결합된 활용 Responsive (반응형) Responsive는 주로 UI/UX 디자인이나 프론트엔트 개발에서 사용되는 개념 애플리케이션 또는 웹 페이지가 화면 크기, 해상도, 디바이스 특성에 따라 적절히 변하도록 설계된 것을 의미 특징 주요 초점 레이아웃 및 디자인이 다양한 화면 환경(데스크톱, 태블릿, 모바일)에 적응 기술 주로 CSS, Flexbox, Grid, Viewport 등을 사용 목적 사용자 경험을 개선하고, 어떤 장치에서도 보기 좋은 디자인을 제공 예시 웹사이트 반응형 디자인 큰 화면에서는 여러 열(column)을 보여주고, 작은 화면에서는 한 열로 정렬 이미지와 텍스트 사이즈가 디바이스 크기에 따라 자동으로 조정 부트스트랩 (Bootstrap) col-m-6와 같은 클래스 이름을 사용하여 화면 크기에 따라 레이아웃을 조정 Reactive (반응형) Reactive는 주로 프로그래밍 패러다임과 관련이 있음 시스템이 변화를 감지하고 즉각적으로 동작을 수행하는 것을 의미 특징 주요 초점 데이터와 상태의 변화에 따라 UI가 자동으로 업데이트 기술 Reactive Programming과 관련된 라이브러리와 프레임워크를 활용 ex) RxJS, React, Vue, Svelte 등 목적 상태 관리와 데이터 흐름을 단순화하고, 사용자 입력 또는 데이터 변화에 실시간으로 반응 예시 React.js에서의 State변화 사용자가 버튼을 클릭하면 상태가 변경되고, 해당 상태에 따라 UI가 즉각적으로 업데이트 import React, { useState } from \"react\"; function Counter() { const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;Count: {count}&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increase&lt;/button&gt; &lt;/div&gt; ); } RxJS 스트림 데이터를 스트림(stream) 형태로 처리하고, 데이터 변경에 실시간으로 반응 import { fromEvent } from \"rxjs\"; const button = document.getElementById(\"myButton\"); const clicks = fromEvent(button, \"click\"); clicks.subscribe(() =&gt; console.log(\"Button clicked!\")); Responsive VS Reactive 측면 Responsive Reactive 적용 범위 주로 UI/UX와 레이아웃 디자인 상태 관리와 데이터 흐름 목적 화면 크기에 따른 레이아웃 및 스타일 변경 데이터 및 상태 변경에 따른 즉각적인 반응 사용 기술 CSS, Flexbox, Grid 등 React, RxJS, Vue 등 상태 기반 프레임워크 초점 디바이스별 최적화된 레이아웃 제공 데이터의 흐름과 UI 동기화 예시 모바일에서 1열 레이아웃, 데스크톱에서 3열 레이아웃 버튼 클릭 시 상태 업데이트 후 UI 리렌더링 결합된 활용 Responsive와 Reactive는 함께 사용될 때 더 큰 효과를 발휘한다. 예를 들어, React.js로 만들어진 SPA(Single Page Application)에서 반응형 디자인(CSS)을 사용해 다양한 디바이스를 지원하면서, React의 상태 관리(State Management)를 통해 UI를 데이터와 동기화할 수 있음. 예시 Reaponsive는 레이아웃과 UI에 초점을 맞추고, Reactive는 데이터와 상태 관리에 집중 둘이 상호보완적! import React, { useState } from 'react'; import './App.css'; // Responsive 스타일 포함 function App() { const [isDarkMode, setIsDarkMode] = useState(false); return ( &lt;div className={`app ${isDarkMode ? 'dark-mode' : ''}`}&gt; &lt;p&gt;Welcome to the responsive and reactive app!&lt;/p&gt; &lt;button onClick={() =&gt; setIsDarkMode(!isDarkMode)}&gt; Toggle Dark Mode &lt;/button&gt; &lt;/div&gt; ); } /* App.css */ .app { padding: 20px; transition: background-color 0.3s; } .dark-mode { background-color: #333; color: #fff; } @media (max-width: 768px) { .app { font-size: 14px; } }",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-20-responsive/"
  },{
    "title": "[CSS] CSS Float",
    "text": "CSS Float란 Clearfix Clear 속성 Clearfix VS Clear Float 사용시 주의사항 결론 CSS Float이란? Float의 기본 개념 요소가 normal flow에서 벗어나 부모 요소의 왼쪽 또는 오른쪽으로 이동한다. 텍스트와 inline 요소들이 float된 요소 주변을 감싼다. Float의 사용 전통적으로 다단 레이아웃을 만드는 데 사용된다. 이미지나 다른 요소를 텍스트 흐름 내에 배치하는 데 유용 Clearfix Float의 문제점 부모 요소 높이 붕괴 float된 요소는 부모 요소의 높이에 영향을 주지 않아 부모 요소가 높이를 잃을 수 있다. Clearfix 이 문제를 해결하기 위해 clearfix 기법이 사용된다. overflow: auto 또는 overflow: hidden을 부모 요소에 적용한다. 가상 요소 (::after)를 사용하여 float를 해제한다. Clearfix 방법: CSS를 이용한 Clearfix: .clearfix::after { content: \"\"; display: block; clear: both; } 부모 요소에 clearfix 클래스를 추가하여 float 문제를 해결한다. Clear 속성 핵심 문제: 특정 요소가 바로 앞에 있는 float 요소의 영향을 받아 원하는 위치에 배치되지 않을 수 있다. clear 속성의 역할: 특정 요소가 이전의 float 요소 아래로 내려가도록 강제하여 float의 영향을 방지한다. float 요소 다음에 나오는 요소에 주로 사용된다. 사용 예시 (clear 속성): .element { clear: both; } clear: both: 왼쪽과 오른쪽의 float 요소로부터 벗어남. 특정 요소 자체의 위치를 조정하기 위한 용도로 사용된다. Clearfix VS Clear 속성 개념 Clearfix Clear 속성 적용 대상 부모 요소가 float된 자식 요소를 감싸도록 해결 특정 요소가 float 요소의 영향을 받지 않도록 해결 해결 문제 부모 요소 높이 붕괴 문제 특정 요소의 위치 문제 주요 방식 overflow 속성, ::after 가상 요소 clear: left/right/both 속성 사용 위치 부모 요소 float 요소 바로 다음에 나오는 요소 부모 요소의 높이 붕괴 문제를 해결하려면 Clearfix를 사용한다. 요소가 float의 영향을 받아 잘못된 위치에 있을 때는 clear 속성을 사용한다. Float 사용 시 주의사항 Float는 레이아웃의 기본적인 도구이지만, Flexbox나 Grid와 같은 현대적인 레이아웃 기술로 대체될 수 있다. 복잡한 레이아웃에서는 유지보수가 어려워질 수 있다. Float의 대안: Flexbox: 1차원 레이아웃에 적합하며, 요소의 정렬 및 간격 조절에 강력하다. CSS Grid: 2차원 레이아웃에 적합하며, 행과 열을 기반으로 복잡한 레이아웃을 만들 수 있다. 결론 CSS Float는 여전히 유용한 기술이지만, 현대적인 레이아웃 기술과 함께 이해하고 사용하는 것이 중요 프로젝트의 요구 사항에 따라 적절한 레이아웃 기술을 선택해야 함",
    "tags": "javascript",
    "url": "/javascript/2025-01-19-css-float/"
  },{
    "title": "[CSS] CSS 문법",
    "text": "CSS란? CSS 문법 기초 CSS 적용 방법 CSS 프로퍼티 값의 단위 CSS란? CSS : Cascading Style Sheets 웹 페이지의 시각적 표현을 담당하는 스타일 언어 다양한 디바이스의 화면 크기에 대응하는 반응형 디자인 구현 내용과 디자인의 분리로 유지보수성 향상 HTML VS CSS HTML 웹페이지 구조와 콘텐츠 정의 CSS HTML 요소의 스타일과 레이아웃 지정 CSS 문법 기초 선택자 (Selector) 스타일을 적용할 HTML 요소 지정 /* 요소 선택자 */ p { color: blue; } /* 클래스 선택자 */ .highlight { background-color: yellow; } /* ID 선택자 */ #header { font-size: 24px; } /* 전체 선택자 */ * { margin: 0; padding: 0; } /* 무조건 뒤에 오는게 이긴다. 뒤로 갈수록 덮어씌우는 개념 */ /* 아이디랑 클래스 중 아이디가 이김 */ 속성 (Property) 변경하고자 하는 스타일의 종류 값 (Value) 속성에 적용할 구체적인 스타일 값 선언 (Declaration) 속성과 값의 쌍 규칙 (Rule) 선택자와 선언 블록의 조합 선택자 { 속성: 값; 속성: 값; } /* 구체적인 예시 */ h1 { color: blue; font-size: 18px; } CSS 적용 방법 인라인 스타일 HTML 요소 내부에 직접 스타일 적용 내부 스타일시트 head 섹션 내 style 태그에 CSS 작성 외부 스타일시트 별도의 .css파일에 스타일 정의 HTML 문서의 head 섹션에서 링크로 연결 CSS 프로퍼티 값의 단위 크기 단위 px : 픽셀 단위, 절대값 % : 백분율 단위, 상대값 em : 요소에 지정된 사이즈에 상대적인 배수 단위 rem : 최상위 요소(html)의 사이즈 기준 배수 단위 Viewport 단위 : vh, vw, vmin, vmax",
    "tags": "javascript",
    "url": "/javascript/2025-01-18-css/"
  },{
    "title": "[HTML] Emmet",
    "text": "Emmet이란? Emmet의 강력한 단축키 !+Tab Emmet 사용법 Emmet, 어디에서 사용할 수 있나요? Emmet이란? Emmet은 웹 개발자가 HTML, CSS 코드를 훨씬 빠르고 효율적으로 작성할 수 있도록 도와주는 플러그인입니다. 간단한 축약어를 입력하면 Emmet이 알아서 전체 코드로 확장해줍니다. 예를 들어, ul&gt;li*5&gt;a라고 입력하면 다음과 같은 HTML 코드가 자동으로 생성됩니다. &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; Emmet을 사용하면 이런 불필요한 작업을 줄이고, 개발자는 오롯이 로직과 디자인에 집중할 수 있습니다. Emmet의 강력한 단축키 ! + Tab Emmet을 사용하는 가장 대표적인 사례 중 하나는 ! + Tab 단축키입니다. 이 단축키를 입력하면 기본 HTML 문서의 구조가 즉시 생성됩니다. 예를 들어, 빈 파일에서 !를 입력한 후 Tab 키를 누르면 다음과 같은 기본 HTML 문서가 자동으로 작성됩니다. &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 이 기본 구조는 웹 페이지를 시작할 때 반드시 필요한 요소들로 구성되어 있으며, 직접 입력하는 번거로움을 크게 줄여줍니다. 이 기능만 사용해도 초보자부터 숙련된 개발자까지 작업 시간을 크게 단축할 수 있습니다. Emmet 사용법 (굉장히 쉽고 편리함) Emmet의 문법은 간단하면서도 강력합니다. 몇 가지 기본 규칙만 익히면 금방 능숙하게 사용할 수 있습니다. 자식 요소: &gt; 기호를 사용하여 자식 요소를 생성합니다. 예를 들어, div&gt;p는 &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;로 확장됩니다. 형제 요소: + 기호를 사용하여 형제 요소를 생성합니다. 예를 들어, h2+p는 &lt;h2&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;로 확장됩니다. 반복 요소: * 기호를 사용하여 요소를 반복 생성합니다. 예를 들어, li*3는 &lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;로 확장됩니다. 그룹화: () 괄호를 사용하여 요소들을 그룹으로 묶을 수 있습니다. 예를 들어, div&gt;(header&gt;ul&gt;li*2)+footer는 다음과 같이 확장됩니다. &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/div&gt; 속성 추가: [] 괄호를 사용하여 요소에 속성을 추가할 수 있습니다. 예를 들어, a[href=#]는 &lt;a href=\"#\"&gt;&lt;/a&gt;로 확장됩니다. 여러 속성을 추가하려면 a[href=# title=링크]와 같이 작성합니다. 클래스 및 ID 추가: CSS 선택자처럼 . 기호로 클래스를, # 기호로 ID를 추가할 수 있습니다. 예를 들어, div.container는 &lt;div class=\"container\"&gt;&lt;/div&gt;로, div#header는 &lt;div id=\"header\"&gt;&lt;/div&gt;로 확장됩니다. 여러 개의 클래스를 추가하려면 div.container.main처럼 작성합니다. 텍스트 내용 추가: {} 중괄호 안에 텍스트 내용을 입력할 수 있습니다. 예를 들어, p{안녕하세요}는 &lt;p&gt;안녕하세요&lt;/p&gt;로 확장됩니다. 이 외에도 다양한 기능들이 있지만, 이 정도만 알아도 Emmet의 강력함을 충분히 경험할 수 있습니다. Emmet, 어디에서 사용할 수 있나요? Emmet은 대부분의 텍스트 에디터와 IDE에서 플러그인 형태로 제공됩니다. Visual Studio Code, Sublime Text, Atom, IntelliJ IDEA 등 유명한 에디터에서는 기본적으로 Emmet을 지원하거나, 간단한 설치만으로 사용할 수 있습니다.",
    "tags": "javascript",
    "url": "/javascript/2025-01-17-emmet/"
  },{
    "title": "[AI] 생성형 AI와 LLM",
    "text": "LLM 생성형 AI GPT Prompt Engineering RTF Framework LLM (Large Language Model) 광범위한 양의 텍스트 데이터를 학습한 모델 인간의 글과 대화 방식을 받아들이며 더욱 정교하고 자연스러운 대화 능력 갖춰감 생성형 AI (Generative AI) 데이터를 분석하고 학습하여 새로운 콘텐츠를 생성하는 인공지능 기술 GPT (Genertive Pre-trained Transformer) OpenAI가 개발한 대형 언어 모델로, 사전 학습된 트렌스포머 구조를 기반으로 한 생성형 AI기술 트렌스포머 구조 Google의 논문 “Attention is All You Need”에서 소개된 딥러닝 모델 구조 Pre-training 방대한 텍스트 데이터를 기반으로 언어의 패턴과 문맥을 학습 Fine-tuning (미세 조정) 특정 목적이나 응용에 맞춰 추가 학습을 진행하여 성능 최적화 생성 능력 기존 데이터를 이해하고 이를 기반으로 새로운 텍스트 생성 ChatGPT 맥락을 파악하는 능력이 뛰어남 환각(Hallucinate) 실제 데이터나 사실을 반영하지 않고 비현실적이거나 오류를 포함하 내용을 만들어내는 경우가 있다 해결 방법 파인 튜닝 프롬프트 엔지니어링 크로스체킹 Prompt Engineering 어떻게 질문을 하느냐에 따라 결과가 달라질 수 있음 필요성 내가 원하는 바를 정확히 주면 줄수록 정확한 대답을 얻을 수 있음 언제나 고급 모델을 쓸수는 없음 (너무 비쌈) Zero-shot Prompting 작업에 대한 지시만 포함하는 프롬프트 방식 One-shot Prompting 작업 예시를 하나 제공하여 AI가 이를 참고로 결과를 생성하도록 하는 방식 Few-shot Prompting 작업 예시를 여러 개 제공하는 방식 복잡한 작업 수행에서 사용 Chain of Thought (CoT) 모델이 단계적으로 사고 과정을 출력하도록 유도 Zero-shot CoT Tree of Thoughts (ToT) 가능한 대안을 모두 도출하고 그 중 촤선의 답변을 선택하도록 하는 방식 “모든 옵션을 평가하고 가장 좋은 대안을 제시하세요” ReAct 결과물을 생성(Reaction)하고 피드백(Reasoning)을 통해 개선해나가는 방식 “예제를 짜고 정상적으로 작동하는지 검증하시오” RTF Framework Role, Task, Format를 명확히 정의해 프롬프트를 설계하는 방법론 Role-based Prompting AI의 역할을 명확히 지정하여 특정 관점이나 전문성으로 답 얻을 수 있음 Task 특정 작업을 지시 프롬프트의 핵심 Format AI의 응답 형식을 지정 (JSON, 엑셀 등) 면접할때 사용 가능 당신은 백엔드 면접관입니다. 주니어 개발자 면접을 진행할 때 어떤 질문을 묻겠습니까? 학습자의 수준에 맞춘 접근 가능",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2025-01-16-basic/"
  },{
    "title": "[AI] RAG (Retrieval-Augmented Generation) 이란?",
    "text": "RAG RAG의 작동 방식 RAG의 장점 RAG의 활용 분야 결론 RAG (Retrieval-Augmented Generation) 거대 언어 모델(LLM)은 학습 데이터에 없거나 최신 정보에 대해서는 어려움을 겪을 수 있다. 이러한 한계를 극복하기 위한 기술이 RAG (Retrieval-Augmented Generation), 즉 검색 증강 생성입니다. RAG는 언어 모델이 답변을 생성하기 전에 외부 지식 소스에서 관련 정보를 검색하여 답변의 품질과 정확성을 높이는 방법론입니다. 마치 20년차 개발자가 새로운 기술에 대해 설명하기 전에 관련 문서를 찾아보고 이해하는 과정과 유사. RAG의 작동 방식 검색 (Retrieval) 사용자의 질문이나 요청이 들어오면, RAG 시스템은 미리 구축된 외부 지식 베이스에서 관련 정보를 검색 이 지식 베이스는 문서, 웹 페이지, 데이터베이스 등 다양한 형태를 가짐 검색 과정에서는 질문의 의미를 파악하고, 지식 베이스 내의 정보와 유사성을 비교하여 가장 관련성이 높은 정보를 추출. 생성 (Generation) 검색된 관련 정보는 원래의 질문 또는 요청과 함께 언어 모델에 입력됨 언어 모델은 이 정보를 바탕으로 답변을 생성 이때, 단순히 검색된 정보를 나열하는 것이 아니라, 검색된 정보를 바탕으로 새로운 문장을 구성하거나, 질문에 대한 답변을 논리적으로 도출하는 등 더욱 풍부하고 맥락에 맞는 답변을 생성 가능 RAG의 장점 정보의 최신성 확보 언어 모델은 학습 데이터 시점 이후의 최신 정보에 접근하기 어렵습니다. RAG는 외부 지식 베이스를 통해 실시간 또는 최신 정보를 활용하여 답변의 정확성을 높일 수 있습니다. 답변의 근거 제시 RAG는 답변을 생성할 때 사용된 외부 정보의 출처를 제시할 수 있습니다. 답변의 신뢰도를 높이고, 사용자가 정보를 추가적으로 검증할 수 있도록 돕습니다. 모델 업데이트 비용 절감 기존 언어 모델은 새로운 정보를 학습시키기 위해 모델 전체를 재학습해야 하는 경우가 많아 비용과 시간이 많이 소요됩니다. RAG는 외부 지식 베이스만 업데이트하면 되므로 모델 업데이트 비용을 크게 절감할 수 있습니다. 특정 도메인에 대한 전문성 강화 특정 분야의 지식 베이스를 RAG에 활용하면, 언어 모델은 해당 분야에 대한 전문적인 답변을 제공할 수 있습니다. 예를 들어, 의료 분야의 RAG 시스템은 최신 의학 논문을 검색하여 환자에게 정확한 정보를 제공할 수 있습니다. RAG의 활용 분야 챗봇 및 가상 비서 사용자의 질문에 대해 최신 정보를 기반으로 정확하고 상세한 답변을 제공하는 챗봇을 구축할 수 있습니다. 지식 검색 시스템 방대한 양의 문서나 데이터베이스에서 사용자의 질문에 가장 적합한 정보를 빠르게 찾아 제공하는 시스템을 구축할 수 있습니다. 콘텐츠 생성 특정 주제에 대한 최신 정보를 검색하여 블로그 게시물, 기사, 보고서 등 다양한 형태의 콘텐츠를 생성하는 데 활용될 수 있습니다. 교육 및 연구 학생이나 연구자가 특정 주제에 대한 정보를 검색하고 이해하는 과정을 돕는 도구로 활용될 수 있습니다. 결론 RAG (Retrieval-Augmented Generation)은 언어 모델의 잠재력을 한 단계 더 끌어올리는 중요한 기술입니다. 외부 지식 소스를 활용하여 답변의 정확성, 최신성, 신뢰성을 높임으로써, 인공지능이 더욱 유용하고 신뢰할 수 있는 도구로 발전하는 데 기여할 것입니다. 마치 숙련된 개발자가 끊임없이 새로운 정보를 습득하고 활용하여 문제를 해결하는 것처럼, RAG는 인공지능이 더욱 똑똑하게 정보를 처리하고 활용할 수 있도록 돕는 핵심적인 기술입니다.",
    "tags": "miscellaneous ai",
    "url": "/miscellaneous/ai/2025-01-15-rag/"
  },{
    "title": "[Algorithm] Linear Time Sorting Algorithm",
    "text": "Counting Sort Radix Sort Order Statistics Randomized Selection Worst-Case Linear-Time Selection 그외 Counting Sort No comparison sort 조건 데이터의 크기 범위가 제한된 경우 데이터의 갯수가 상수개인 경우 CountingSort(A, B, k) { for i = 1 to k C[i] = 0; for j = 1 to n C[A[j]] += 1; for i = 2 to k C[i] = C[i] + C[i-1]; for j = n downto 1 //stable하게 만들기 위해 1 to n이 아닌 n to 1 수행 B[C[A[j]]] = A[j]; C[A[j]] -= 1; } k가 n개 이하일 때 정렬이 가능하다. k가 너무 큰 경우 각 자리수마다 counting sort를 수행하는 방법을 사용할 수 있다. - radix sort 시간 복잡도 : \\(O(n)\\) 장점 stable하다 단점 in-place 알고리즘은 아니다. (extra place 필요) Radix Sort counting sort의 일반 버전 RadixSort(A, d){ for i=1 to d StableSort(A) on digit i //StableSort = counting sort } 시간 복잡도 : \\(d*O(n)\\) Radix Sort의 핵심은 stable한 것이다. counting sort때문에 in-place하진 않다. 자릿수의 최대 값은 \\(logn\\)이다. 따라서 radix sort가 merge sort보다 빠를 수 있다. 한계 길이가 다른 문자열같은 digit이 정확하지 않으면 사용할 수 없다. Order Statistics n개의 요소들 중 i번째로 작은 요소를 고르는 것 minimun은 첫 번째 order statistic Randomized Selection quicksort의 partition()을 사용한다. 하지만 우리는 오직 하나의 subarray만 평가하면 된다. RandomizedSelect(A, l, r, k) if (l == r) then return A[l]; p = RandomizedPartition(A, l, r) if (p == k) then return A[p]; if (p &lt; k) then return RandomizedSelect(A, l, p-1, k); else return RandomizedSelect(A, p+1, r, k); ``` 시간 복잡도 worst case : \\(O(n^2)\\) best, average case : \\(O(n)\\) Worst-Case Linear-Time Selection generte a good partitioning element Randomized selection에서 pivot value를 고르는데 추가로 $\\Theta(n)$시간을 써 업그레이드한 방법 알고리즘 n개의 element들을 5개씩 묶어 그룹을 만든다. 각 그룹의 중간값을 찾는다. -&gt; \\(O(const)\\) Select()를 재귀적으로 사용해 n/5개의 중간값 x를 찾는다. \\[n/5 + n/25 + n/125 + ... &lt; n\\] x를 중심으로 partition을 진행한다. 시간 복잡도 : \\(O(n)\\) Quick sort에서도 해당 알고리즘을 이용해 worst case의 시간복잡도를 \\(O(nlogn)\\)으로 만들 수 있다. 하지만 이 경우 pivot value를 찾는 과정에서 캐쉬가 한번 뒤집혀져 quick sort의 장점 중 하나인 cache friendly 장점이 사라진다. 차라리 merge sort나 heap sort를 사용한다. 그외 Insertion sort \\[O(n^2)\\] Merge sort, Heap sort, Quick sort comparison sort all comparison sorts are \\(\\Omega(nlogn)\\)",
    "tags": "algorithm",
    "url": "/algorithm/2024-12-13-linear-time-sorting/"
  },{
    "title": "[Algorithm] 분할정복 알고리즘 (Divide and conquer)",
    "text": "분할정복 알고리즘 설계 방법 특징 및 장단점 분할정복 알고리즘 (Divide and conquer algorithm) 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법. 대표적인 예로는 정렬 알고리즘 중에서 퀵 정렬이나 합병 정렬과 이진 탐색, 선택 문제, 고속 푸리에 변환(FFT) 문제들이 있음. 설계 방법 1) Divide ∙  원래 문제가 분할하여 비슷한 유형의 더 작은 하위 문제로 분할이 가능할 때 까지 나눈다. 2) Conquer ∙  각 하위 문제를 재귀적으로 해결한다. 하위 문제의 규모가 나눌 수 없는 단위가 되면 탈출 조건을 설정하고 해결한다. 3) Combine ∙  Conquer한 문제들을 통합하여 원래 문제의 답을 얻어 해결한다. 🖋 Divide를 제대로 나누면 Conquer과정은 자동으로 쉬워진다. 그래서 Divide를 잘 설계하는 것이 중요! 🖋 분할정복 알고리즘은 재귀 알고리즘이 많이 사용되는데, 이 부분에서 분할정복 알고리즘의 효율성을 깎아내릴 수 있다. 특징 및 장단점 ∙  분할된 작은 문제는 원래 문제와 성격이 동일하다  -&gt; 입력 크기만 작아짐 ∙  분할된 문제는 서로 독립적이다(중복 제거 X) -&gt; 순환적 분할  및 결과 결합 가능 ∙  분할정복은 Top-down방식으로 재귀 호출의 장단점과 똑같다고 보면 된다. 장점 단점 ∙  Top-down 재귀방식으로 구현하기 때문에 코드가 직관적이다. ∙  재귀함수 호출로 오버헤드가 발생할 수 있다 ∙  문제를 나누어 해결한다는 특징상 병렬적으로 문제를 해결할 수 있다. ∙  스택에 다량의 데이터가 보관되는 경우 오버플로우가 발생할 수 있다.",
    "tags": "algorithm",
    "url": "/algorithm/2024-12-12-divide-conquer/"
  },{
    "title": "[JAVA] Set",
    "text": "목차 텍스트 블록 formatted() 메서드 레코드 패턴 매칭 case문 개선 Set 데이터 자료구조(데이터 컬렉션) 중 하나로, 특정한 값들을 저장하는 추상자료형 List와 다르게 데이터를 중복해서 저장할 수 없음 저장된 데이터를 인덱스로 관리하지 않기 때문에 저장 순서가 보장되지 않음 수학의 유한 집합을 컴퓨터로 구현한 것 특성 데이터를 비순차적으로 저장할 수 있는 순열 자료구조 삽입한 데이터가 순서대로 저장되지 않음 수정 가능(mutable) 중복해서 삽입 불가능 Fast Lookup이 필요할 때 주로 쓰임 대표적인 클래스 HashSet, TreeSet, LinkedHashSet 클래스들의 주요 메소드 add(E e) 리턴타입 : boolean interator() 리턴타입 : Iterator 검색을 위한 반복자 생성 size() 리턴타입 : int clear() 리턴타입 : void remove(Object o) 리턴타입 : boolean HashSet Set 컬랙션을 구현하는 대표적인 클래스 데이터를 중복 저장할 수 없고 순서를 보장하지 않는다. 예시 Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(\"one\"); set.add(\"two\"); Interator&lt;String&gt; iter = set.iterator(); while(iter.hasNext()) { //꺼낼 것이 있다면 true 리턴 System.out.println(iter.next()); //다음 데이터 리턴 } TreeSet 중복된 데이터를 저장할 수 없고 입력한 순서대로 값을 저장하지 않음 TreeSet은 기본적으로 오름차순으로 데이터를 정렬 LinkedHashSet 입력된 순서대로 데이터를 관리한다. 중복된 데이터를 저장할 수는 없음 저장된 데이터의 존재를 빠르게 확인할 수 있지만 내부에 삽입 순서로 정렬된 목록이 포함됨 포켓몬 고와 같은 게임에서 객체가 이미 목록에 있는지 여부를 빠르게 확인하고 목록에 없는 경우 목록에 추가할 수 있음 LinkedHashSet vs HashSet HashSet은 HashMap을 사용해 개체를 저장 LinkedHashSet은 LinkedHashMap을 사용 삽입 순서를 유지할 필요가 없지만 고유한 개체를 저장해야하는 경우 HashSet이 적합 LinkedHashSet의 성능은 HashSet보다 약간 느림",
    "tags": "java",
    "url": "/java/2024-12-08-set/"
  },{
    "title": "[Spring] Spring 매핑 개념과 주요 애너테이션 활용법",
    "text": "Mapping 맵핑 (Mapping) Mapping 클라이언트로 부터 요청이 들어오는 URL과 컨트롤러 메서드를 연결하는 작업 Mapping 애너테이션을 사용해 클라이언트의 요청이 URL로 들어올 때 해당 URL에 맞는 컨트롤러가 있는지 확인하고 해당 컨트롤러를 매핑하여 요청을 처리 @RequestMapping 클라이언트가 특정 URL로 요청을 보낼 때, 이 요청을 처리할 컨트롤러 메서드를 정의하는 것 Get, Post, Put, Delete, Patch등의 URL을 다 포함하고 있으며, 옵션을 통해 종류를 지정할 수 있음 @Controller public class ProductController { @RequestMapping(\"/products\", method = RequestMethod.GET) public String listProducts() { return \"product-list\"; } @RequestMapping(\"/products\", method = RequestMethod.POST) public String addProducts() { return \"product-added\"; } } HTTP 메서드에 특화된 매핑 @GetMapping GET 요청만 받는 애노테이션 @RequestMapping(method = RequestMethod.GET) @PostMapping POST 요청만 받는 애노테이션 @RequestMapping(method = RequestMethod.POST) @PutMapping PUT 요청만 받는 애노테이션 @RequestMapping(method = RequestMethod.PUT) @DeleteMapping DELETE 요청만 받는 애노테이션 @RequestMapping(method = RequestMethod.DELETE) @PatchtMapping PATCT 요청만 받는 애노테이션 @RequestMapping(method = RequestMethod.PATCH)",
    "tags": "spring",
    "url": "/spring/2024-12-03-mapping/"
  },{
    "title": "[Spring] Spring Framework의 주요 개념 (IoC, DI, AOP, PSA)",
    "text": "스프링 콘셉트 스프링 콘셉트 스프링 프레임워크의 주요 개념에 대해 다룬다. IoC Inversion of Control 객체의 생성과 관리를 개발자가 아니라 프레임워크가 대신하는 것 public class A { private B b; } 객체를 직접 생성하지 않고(new 키워드 사용하지 않고) 외부에서 관리하는 객체를 가져와 사용 스프링에서는 스프링 컨테이너가 객체를 관리, 제공하는 역할을 함 스프링 컨테이너 빈이 생성되고 소멸되기 까지의 생명주기를 관리하는 것 DI Dependency Injection 외부에서 객체를 주입받아 사용하는 것 예시 (IoC/DI를 기초로 하는 스프링 코드) public class A { //A에서 B를 주입받음 @Autowired B b; } Bean 스프링 컨테이너가 생성하고 관리하는 객체 스프링은 빈을 컨테이너에 등록하기 위해 XML 파일 설정, 애너테이션 추가 등 방법 제공 AOP Aspect Oriented Programming 프로그래밍 시 핵심 관점과 부가 관점을 나누어 개발하는 것 PSA Portable Service Abstraction 어느 기술을 사용하던 일관된 방식으로 처리하도록 하는 것 대표적인 예 클라이언트의 매핑과 클래스, 메서드의 매핑을 위한 애너테이션",
    "tags": "spring",
    "url": "/spring/2024-12-02-spring-basic/"
  },{
    "title": "[JAVA] JAVA 메모리 모델과 변수의 종류 : static, 지역변수, 레퍼런스 변수 이해하기",
    "text": "static 변수 Method Area 지역변수 &amp; 레퍼런스 변수 지역 변수 레퍼런스 변수 JAVA 변수들의 특징 및 차이점 요약 static 변수와 지역 변수 비교 static 변수와 레퍼런스 변수 비교 지역 변수와 레퍼런스 변수 비교 static 변수 인스턴스가 아닌 클래스에 귀속 인스턴스가 여러 개 생성되도 static 변수는 딱 하나 클래스가 메모리에 로드될 때 한 번 생성됨 객체가 아닌 클래스 자체에 저장되기 때문에 모든 객체가 동일한 메모리 위치를 공유함 특징 수명 클래스가 메모리에 로드될 때 생성되고, 프로그램이 종료될 때까지 유지됨 일반적인 지역변수와 달리 블록을 벗어나도 소멸되지 않음 메모리 위치 static 변수는 Method Area에 저장됨 static 변수의 객체 독립성 static 변수가 클래스 자체에 속해 있기 때문에, 객체를 생성하지 않아도 해당 클래스 이름만으로 직접 접근 가능 예시 public class Example { static int staticVar = 10; //static 변수 (클래스 변수) int instanceVar = 20; //인스턴스 변수 (객체 변수) public static void main(String[] args) { //static 변수는 클래스 이름으로 접근 가능 System.out.println(\"Static Variable: \" + Example.staticVar); //출력: 10 //객체를 생성하지 않아도 static 변수에 접근 가능 Example.staticVar = 30; System.out.println(\"Static Variable: \" +Example.staticVar); //출력: 30 //객체를 생성해야 인스턴스 변수에 접근 가능 Example obj1 = new Example(); System.out.println(\"Instance Variable: \" + obj1.instanceVar); //출력: 20 } } static 변수 사용 시점 공유 데이터가 필요할 때 모든 객체에서 동일한 값 공유해아 할 때 사용 예: 총 객체 갯수, 공통 설정값 등 객체와 무관하게 동작해야할 때 클래스 자체의 정보를 나타내거나, 객체 없이 사용 가능한 값을 저장할 때 예: 수학 상수 Math.PI, System.out.println()의 out도 static public class TestClass{ static int number; } public class Test{ public static void main(String []arg){ TestClass class1 = new TestClass(); TestClass class2 = new TestClass(); class1.number = 3; class2.number = 5; System.out.println(\"class1의 number: \" + class1.number); System.out.println(\"class2의 number: \" + class2.number); } } // class1의 number: 5 // class2의 number: 5 마지막에 number에 5가 저장되어있기 때문에 5가 두번 출력 Method Area JVM(Java Virtual Machine)의 메모리 구조 중 하나 클래스 수준의 정보를 저장하는 영역 저장되는 데이터 종류 클래스 정보 클래스의 이름, 부모 클래스, 접근 제어자 등의 메타데이터 클래스 변수 (static 변수) 클래스가 로드될 때 메모리에 할당되며 모든 객체에서 공유됨 메서드 정보 메서드의 이름, 리턴 타입, 매개변수 타입 등 메서드의 바이트코드 포함 상수 (Constant Pool) 컴파일 시 생성된 상수(문자열, 숫자 리터럴 등)와 참조(메서드 참조, 클래스 참조)가 저장됨 런타임 상수 풀(Runtime Constant Pool) 런타임 중에 동적으로 생성된 상수와 참조. 특징 JVM내에서 유일 : 모든 스레드가 공유 수명 : JVM이 종료될 때까지 유지 Garbage Collection 대상 아님 : 클래스 정보는 명시적으로 제거되지 않음 지역변수 &amp; 레퍼런스 변수 지역변수 (Local Variable) 특정 블록이나 함수 안에서만 선언되고 사용가능한 변수 해당 블록이나 함수가 실행을 마치면 메모리에서 삭제되며, 외부에서 접근 불가능 특징 유효 범위 (Scope) 변수가 선언된 블록(중괄호 {}로 감싸진 영역) 내에서만 유효 초기화 필요 지역변수는 자동으로 초기화 되지 않음 메모리 관리 지역변수는 함수 호출시 생성되고, 함수 종료 시 자동으로 소멸됨 일반적으로 스택 메모리 사용 예제 public class Example { public static void main(String[] args) { int x = 1; // x는 main 메서드의 지역 변수 if (x &lt; 10) { int y = 20; // y는 if 블록의 지역 변수 } //y는 if블록 밖에서 사용할 수 없음 } } 레퍼런스 변수 (Reference Variable) 객체의 메모리 주소를 저장한는 변수, 즉 객체를 참조하는 데 사용됨 실제 객체 데이터를 직접 저장하지 않고 객체가 메모리에 위치한 주소만 저장 특징 객체와 연결 레퍼런스 변수는 new키워드 등을 통해 생성된 객체를 가리킴 동적 메모리 사용 레퍼런스 변수가 가리키는 객체는 힙(Heap)메모리에 저장됨 null값 가능 초기화되지 않은 레퍼런스 변수는 null값을 가질 수 있음 null값을 참조하려면 NullPointerException이 발생 두 레퍼런스 변수가 동일한 객체를 가리킬 수 있음 한 레퍼런스 변수를 통해 객체를 수정하면 다른 레퍼런스 변수도 수정됨 예제 public class Example{ public static void main(String[] args) { String str = \"Hello\"; //str은 String객체를 참조하는 레퍼런스 변수 System.out.println(str.length()); //참조된 객체의 메서드 호출 가능 str = null; //str이 아무 객체도 참조하지 않음 //System.out.println(str.length()); //NullPointerException 발생 } } public class Example { public static void main(String[] args) { int[] numbers = {1,2,3}; int[] ref = numbers; //같은 객체 참조 ref[0] = 100; //참조를 통해 객체 수정 System.out.println(numbers[0]); //출력: 100 } } Java 변수 비교: static, 지역 변수, 레퍼런스 변수의 특징과 차이점 static 변수와 지역 변수 비교 특징 static 변수 지역 변수 범위(Scope) 클래스 전체에서 접근 가능 (전역적) 선언된 블록(예: 함수) 내에서만 유효 수명(Lifetime) 프로그램 종료 시까지 유지 블록 실행이 끝나면 소멸 공유 모든 객체가 같은 값을 공유 각 함수 호출마다 독립적으로 생성 메모리 위치 메서드 영역(Method Area) 스택(Stack) 메모리 static 변수와 레퍼런스 변수 비교 특징 static 변수 레퍼런스 변수 저장 내용 클래스 수준에서 공유되는 데이터 객체의 메모리 주소를 저장 초기화 여부 명시적 초기화가 없으면 기본값으로 초기화됨 초기화되지 않으면 null 값을 가짐 수명 클래스 로드부터 프로그램 종료까지 유지 변수의 유효 범위 내에서만 사용 가능 클래스 의존성 클래스와 연결 (객체와 무관) 객체를 가리킴 (객체가 없으면 의미 없음) 메모리 위치 메서드 영역(Method Area) 스택(지역 변수일 때) 또는 힙(객체를 참조할 때) 지역 변수와 레퍼런스 변수 비교 특징 지역 변수 레퍼런스 변수 저장 내용 값 자체 객체의 메모리 주소 유효 범위 선언된 블록 내 객체가 참조되는 동안 메모리 위치 스택 메모리 힙 메모리에 저장된 객체를 참조 초기화 필요성 명시적 초기화 필요 초기화되지 않은 경우 null 값을 가질 수 있음",
    "tags": "java",
    "url": "/java/2024-11-20-variable/"
  },{
    "title": "[JAVA] JAVA version 17의 주요 변화",
    "text": "목차 텍스트 블록 formatted() 메서드 레코드 패턴 매칭 case문 개선 텍스트 블록 이전 버전에서는 여러 줄의 텍스트를 작성할때 \\n을 추가해야해서 가독성이 좋지 않은 부분이 개선되었다. 예시 String example11 = \"SELETE * FROM \\\"product\\\"\\n\" + \"WHERE \\\"country\\\" = \\\"KOREA\\\"\\n\" + \"ORDER BY \\\"name\\\";\\n\"; String example17 = \"\"\" SELECT * FROM \"product\" WHERE \"country\" = \"KOREA\" ORDER BY \"name; \"\"\"; //가독성이 훨씬 좋아졌다 formatted() 메서드 값을 파싱하는 데 더 편하게 해주는 formatted() 메서드 제공 예시 String example17 = \"\"\" { \"id\": %d, \"name\": %s } \"\"\".formatted(1, \"nahyun\"); 레코드 데이터 전달을 위한 객체를 더 빠르고 간편하게 만들기 위한 기능 getter를 자동으로 만들어 주기 때문에 애너테이션이나 메서드로 게터를 정의하지 않아도 됨 예시 record Item(String name, int price) { //파라미터가 private final로 정의된다 } Item product1 = new Item(\"product1\", 2500); product1.price(); //2500 패턴 매칭 타입 확인을 위해 사용하던 instanceof 키워드를 개선 이전에는 instanceof 키워드와 형변환 코드를 조합해야 했지만 이제는 바로 형변환 가능 자료형에 맞는 case 처리 switch-case문에서 자료형에 맞게 case 처리 가능 예시 static double getIntegerValue(Object object) { return switch (object) { case Double d -&gt; d.intValue(); case Float f -&gt; f.intValue(); case String s -&gt; Integer.parseInt(s); default -&gt; 0d; }; }",
    "tags": "java",
    "url": "/java/2024-11-15-java17/"
  },{
    "title": "[CS] 컴파일 언어 VS 인터프리터 언어, 그리고 Java",
    "text": "컴파일 언어 인터프리터 언어 컴파일 언어 VS 인터프리터 언어 항상 접할때마다 헷갈려서 정리하기로 했다. 컴파일 언어 한번에 전체 코드 번역 소스코드를 기계어로 변환하는 과정(컴파일)을 거친 후 실행 실행 파일이 생성됨으로 배포에 용이함 컴파일 타임 사용 이 과정을 거쳐 소스코드는 기계어가 되어 실행가능한 상태가 됨 실행 속도 기계어로 변환된 상태에서 실행되므로 매우 빠름 인터프리터 언어보다 20~100배 이상 빠름 개발 과정 문법 오류를 실행 전에 발견할 수 있어 안정적임 하지만 코드 변경 시 다시 컴파일해야 하므로 개발 편의성이 다소 떨어짐 대표적인 언어 C, C++, 러스트, Go 등 인터프리터 언어 스크립트 언어 별도의 실행 파일 없이, 소스코드를 직접 실행하는 경우가 많음 번역과 실행이 동시에 이루어짐 프로그램을 실행할 때 한 줄씩 읽고 해석한 뒤 바로 실행 런타임 사용 실행 시점에 코드가 해석되므로 빌드 과정이 필요 없음 실행 속도 한 줄씩 해석하며 실행하므로 컴파일언어보다 느림. 개발 과정 즉시 실행 및 테스트가 가능하여 개발 속도가 빠름 동적 타입을 지원하는 경우가 많아 코드 수정이 용이 대표적인 언어 Python, Ruby, JavaScript 등 기타 특징 python은 C++로 만들어져 있음 컴파일 언어는 빠르지만 개발 편의성이 떨어져 인터프리터 언어를 만드는데 사용되기도 함 실행 속도를 개선하기 위해 JIT(Just-In-Time) 컴파일러를 사용하는 경우도 있음 Python의 PyPy, Javascript의 V8엔진 등 왜 인터프리터 언어가 더 느릴까? 인터프리터 언어가 빌드 과정이 없는데 왜 느릴까? ‼️ 코드를 실행하는 방식 때문! 1. 한 줄씩 해석하며 실행하기 때문 컴파일 언어는 미리 전체 코드를 기계어로 변환한 후 실행하지만, 인터프리터 언어는 실행할 때마다 한 줄씩 해석하고 실행 컴파일 언어 실행 전에 한 번만 컴파일 -&gt; 실행 시에는 기계어(0과1)로 바로 실행 -&gt; 속도가 빠름 인터프리터 언어 실행할 때마다 소스 코드를 읽고, 해석하고, 실행 -&gt; 한 줄씩 번역하면서 실행해야 해서 속도가 느림 2. 동적 타입 (dynamic typing) 지원이 많아서 대부분의 인터프리터 언어 (Python, JavaScript 등)는 동적 타입 (dynamic typing)을 지원 동적 타입 언어는 실행 중 변수의 타입을 결정하기 때문에 매 실행마다 타입 체크가 필요 반면, 컴파일 언어(C, C++ 등)는 컴파일 시점에 타입이 결점되므로 실행 속도가 훨씬 빠름 3. 최적화 부족 컴파일러는 최적화(Optimization)를 통해 코드를 더 효율적으로 변환함 예를 들어, 컴파일러는 불필요한 연산을 제거하고, 반복문을 최적화하는 등 실행 속도를 높이기 위해 다양한 작업 수행 인터프리터 언어는 실행할 때마다 소스 코드를 직접 해석하기 때문에 이런 최적화가 어려움 4. 메모리 관리 방식 차이 컴파일 언어는 메모리 할당을 미리 최적화할 수 있지만, 인터프리터 언어는 실행 중에 동적으로 메모리를 할당하는 경우가 많아 메모리 관리 부담이 큼 그럼 인터프리터 언어의 속도를 높이는 방법은? ✅ 1. JIT(Just-In-Time) 컴파일 JIT 컴파일러는 인터프리터 방식과 컴파일 방식의 장점을 결합한 방법 프로그램 실행 도중 자주 실행되는 코드 블록을 미리 기계어로 변환해서 속도를 높임 대표적 예시 Java의 JVM (HotSpot JIT 컴파일러) Python의 PyPy JavaScriptdml V8 엔진 (Chrome, Node.js) ✅ 2. 바이트코드(Bytecode) 사용 일부 인터프리터 언어는 소스 코드를 직접 해석하는 대신, 한 번 중간 코드(바이트코드)로 변환한 후 실행하는 방식을 사용 예: Python의 CPython(기본 구현체) Python 소스 코드(.py) -&gt; 바이트코드(.pyc) 변환 -&gt; 실행 덕분에 매번 소스 코드를 해석하는 부담이 줄어듦 🔹 Java는 어떻게 실행될까? Java는 전통적인 컴파일 언어와 인터프리터 언어의 특징을 혼합한 하이브리드 언어 1️⃣ 소스 코드 → 바이트코드 변환 (컴파일 과정) Java 코드를 작성하면, javac 컴파일러가 이를 바이트코드(Bytecode) 로 변환. 바이트코드는 완전한 기계어가 아니라 JVM(Java Virtual Machine)에서 실행할 수 있는 중간 코드 이 과정은 전통적인 컴파일 언어(C, C++)와 비슷하지만, 완전히 기계어로 변환되지 않고 플랫폼 독립적인 코드로 남아 있음. 2️⃣ JVM에서 바이트코드 실행 (인터프리터 + JIT 컴파일) Java의 실행 과정에서는 JVM(Java Virtual Machine) 이 핵심 역할을 수행 JVM은 바이트코드를 한 줄씩 읽고 실행하는 인터프리터 방식을 사용하지만, 성능을 높이기 위해 JIT(Just-In-Time) 컴파일러를 활용. 🔹 JIT(Just-In-Time) 컴파일러가 하는 일 JIT 컴파일러는 인터프리터와 컴파일 방식의 장점을 결합한 기술이야. 실행 중 자주 사용되는 바이트코드를 분석해서 기계어로 변환(컴파일)한 후 캐싱해 둠. 이후 같은 코드가 실행될 때는 다시 해석하지 않고, 컴파일된 기계어를 바로 실행해서 성능을 높여. 즉, Java는 처음에는 인터프리터처럼 실행되지만, JIT이 동작하면 컴파일된 기계어 코드가 사용되므로 속도가 빨라지는 것이야. 🔹 Java는 컴파일 언어일까? 인터프리터 언어일까? ✔ 둘 다 아님! Java는 하이브리드 방식을 사용 컴파일 언어처럼: 소스 코드를 바이트코드로 변환하는 컴파일 과정이 있음. 인터프리터 언어처럼: JVM이 바이트코드를 한 줄씩 해석하며 실행할 수도 있음. JIT을 사용하면: 실행 중 특정 코드 블록을 기계어로 컴파일해서 성능을 높임.",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2024-11-08-language/"
  },{
    "title": "[AWS] AWS 기초",
    "text": "목차 AWS란? S3 &amp; Cloudfront AWS 솔루션 실무 적용 사례 AWS 클라우드 인프라의 구성 요소 AWS 네트워크 구성 요소 설명: 캠퍼스 예시로 이해하기 AWS 초기 설정 및 구성 시 주의점 AWS에 대한 기초 내용 AWS란? Amazon Web Service 클라우드 컴퓨팅 플랫폼 인터넷을 통해 IT리소스(서버, 스토리지, 데이터베이스, 네트워킹 등)를 제공하고 관리하는 서비스 특징 확장성 (Scalability) 사용자가 필요에 따라 리소스를 쉽게 확장, 축소 가능 블랙 프라이데이에는 몇 배의 트래픽이 몰림. 이때마다 하드웨어를 사용하는건 비효율적, 이때만 자원을 사용하고 끝나면 반납할 수 있음 유연성 (Flexibility) 다양한 IT 환경에 맞춰 손쉽게 맞춤화 가능 자바스크립트로 백엔드 많이 사용 비용 효율성 (Cost Efficiency) 초기 자본 투자 없이, 사용한 만큼 지불하는 비용 구조 가용성 높은 가용성과 자동 백업, 복구 기능으로 서비스 중간 최소화 람다 서비스를 처음 띄울 때 서울 4개의 구역에 띄워놓을 수 있음. 한 개의 구역에 오류가 나도 다른 구역에서는 잘 쓸 수 있음. AWS 계정 만들어보기 AWS Cloud Practitioner Essentials (Korean) Cloud Practitioner 자격증 있음 공부하는 것 추천함 (따는건 비쌈) 큰 회사에서는 AWS 자격증이 크게 상관없겠지만, 작은 회사에서는 AWS역량이 필수적 S3 &amp; Cloudfront S3 Simple Storage Service AWS 최초의 서비스 클라우드 파일 저장소 AWS 사용하고 있는 회사라면 99%의 확률로 활용하고 있음 S3는 서버사이트 스크립팅(PHP, Python등)이 필요없는 정적 웹사이트에 최적 기본 개념 버킷 (Bucket) S3에서 데이터를 저장하는 컨테이너 모든 S3객체는 반드시 하나의 버킷에 속해 있음 S3 스토리지의 최상위 계층이며, 사용자가 데이터를 저장하고 관리할 수 있는 폴더와 비슷 컴퓨터에서 C드라이브와 비슷한 느낌 각 버킷은 고유한 이름을 가짐(전세걔 유일) 데이터 저장 위치(region), 권한 설정, 버전 관리, 수명 주기 정책 등 관리 가능 Key S3버킷 내 객체(파일)를 고유하게 식별하는 문자열 버킷 내 키는 객체의 “경로”로 생각 가능 디렉토리 구조를 흉내낼 수 있도록 설계됨 그냥 전체가 하나의 키임 사용 방법 AWS Console AWS Cli FTP 프로그램 file transfer protocol 사이버덕, 파일질라 Cloudfront AWS CDN 서비스 Contents Delivery Network 인터넷 사용자에게 웹 콘텐츠를 빠르고 효율적으로 제공하기 위해 설계된 분산형 서버 네트워크 S3를 비롯한 AWS의 다른 서비스와 연동이 쉬움 AWS를 사용하는 회사라면 99% 사용 S3는 저장에 특화, Cloudfront는 전송에 특화 S3는 직접 접근으로 주로 내부 사용자나 제한된 사용자들에게 제공을 많이함 하지만 Cloudfront는 CDN을 통해 접근하기때문에 속도도 빠르고 캐싱도 됨 S3 1GB당 약 0.117$, Cloudfront 1GB당 0.095$ CloudFront는 약정 계약이 가능 AWS 솔루션 실무 적용 사례 이미지 리사이즈 대역폭 및 비용 감소할 수 있음 첫 번째 AWS 활용 포트폴리오 S3에 이미지가 업로드 되면 자동적으로 원하는 크기로 리사이징하여 저장하는 방법 원하는 사이즈의 이미지를 실시간으로 생성하는 방법 본인이 자신있는 프로그래밍 언어를 선택하여 AWS Lambda 기능을 활용해서 작성 ‘aws cloudfront 이미지 리사이징’ 구글 검색 보안 민감정보 보호 방법 Signed URL 특정 사용자에게만 접근 권한을 부여하기 위해 URL에 만료 시간과 암호화된 서명을 포함한 URL Signed Cookie 특정 조건을 만족하는 사용자만 CloudFront를 통해 콘텐츠에 접근할 수 있도록 설정하는 보안 메커니즘 AWS 클라우드 인프라의 구성 요소 EC2 (Elastic Compute Cloud) 개발자가 클라우드 컴퓨팅 작업을 할 수 있도록 설계된 서비스 가상화된 서버를 하나의 인스턴스 형태로 제공하며, 컴퓨팅 요구사항에 맞게 용량 조절 가능 IDC Internet Data Center 물리적 인프라를 제공하는 시설 리전 (Region) 물리적으로 분리된 지리적 위치 각 리전은 여러 개의 데이터 센터(Availability Zone, AZ)로 구성되어 있음 리전 간 데이터 전송은 네트워크 지연 시간(latency)이 발생할 수 있음 각 리전은 법적, 규제 요구 사항을 충족하도록 설계됨 Availability Zone 리전 내에서 독립적으로 운영되는 데이터 센터 각 AZ는 하나 이상의 데이터 센터로 구성되어 있음 VPC (가상 사설 네트워크) Virtual Private Cloud 네트워크 2개 이상의 컴퓨터나 장치가 서로 데이터를 주고 받을 수 있도록 연결된 시스템 사설 공개되지 않은, 외부와 분리되느 특정 사용자나 조직만 접근할 수 있는 가상 물리적인 하드웨어 장비나 네트워크 인프라 없이, 소프트웨어를 통해 논리적으로 격리 AWS 네트워크 구성 요소 설명: 캠퍼스 예시로 이해하기 퍼블릭 서브넷 Public Subnet public : 인터넷과 직접 연결되어있다. subnet : sub + network, 하나의 네트워크를 더 작은 단위의 네트워크로 (부분 집합) 중앙 운동장, 도서관, 기념품샵 등등 프라이빗 서브넷 Private Subnet 인터넷과 직접 연결되어있지 않다. 교수 연구실, 실험실 (아무나 못들어가는) 라우팅 / 라우팅 테이블 Routing Table 라우팅 : 경로, 네트워크 내에서 데이터가 이동할 경로를 결정 캠퍼스 내 길 / 길 안내 지도 인터넷 게이트웨이 학교 정문 NAT 게이트웨이 Network Address Translation Network Address : IP주소 (Internet Protocol) 네트워크 상에서 각 장치를 식별하기 위해 사용되는 고유한 숫자 주소 내부 네트워크의 사설 IP 주소를 공용 IP주소로 변환 경비실, 차량 차단기, 보안 검사대 네트워크 ACL (Access Control List) 전체 구역 통제 시스템 서브넷 단위 Stateless, 상태 비기반, 독립적인 제어 들어올 때도 검사하고 나갈때도 검사함 우선순위가 있음 차단기의 정책, 비행기 탈 때와 비슷 보안 그룹 (Security Group) 개별 사무실 출입 통제 시스템 기본적으로 모든 트래픽은 차단하며 허용 규칙만 있음 stateful, 상태 기반 (신분증 제출하고 출입증 받아가는 느낌) 라우팅 테이블에 인터넷 게이트웨이랑 퍼블릭 서브넷이 연결 반대로 생각하면 퍼블릭 서브넷과 프라이빗 서브넷을 구분짓는 중요한 요소가 됨 AWS 초기 설정 및 구성 시 주의점 AWS에서 처음으로 제공해주는 VPC는 가급적으로 사용하지 말자 람다를 private 서브에 올리고 nat를 사용하는 것을 추천 람다는 실행할 때마다 ip가 바뀜, 문제가 될 수 있음",
    "tags": "aws",
    "url": "/aws/2024-09-02-aws/"
  },{
    "title": "[JAVA] StringBuilder",
    "text": "목차 String StringBuilder String 반복적으로 String을 연결하거나, 수정해야 할 경우, 보통은 아래와 같은 경우로 string을 사용한다. public class Main{ public static void main(String[] args) { String java = \"자바\"; java += \"공부\"; System.out.println(java); } } 하지만 string은 불변(immutable)객체이므로, “자바”메모리에 “공부”가 추가되는 것이 아니라, 새로운 메모리에 “자바공부”가 저장됨 문자열이 수정될 때마다 새로운 메모리를 할당받기 때문에 성능저하가 일어날 수 있음 StringBuilder StringBuilder는 mutable sequence of characters. 문자열이 변경될 때마다 새로운 메모리를 할당받지 않고, 버퍼를 통해 문자열을 관리하다 toStirng()을 통해 Stirng 객체를 생성 StringBuilder가 효율적인 경우 문자열의 반복적인 연결 문자열의 잦은 수정 대량의 문자열을 처리할 때 단점 StringBuilder는 thread-safe하지 않아 멀티쓰레드 환경에서 좋지 않다. 멀티쓰레스 환경에서는 StringBuffer를 추천 StringBuffer는 StringBuilder와 동일한 API를 사용하지만 각각의 메소드에 대해 동기화를 보장하기 때문 String보다는 빠르고 StirngBuilder보다는 느림",
    "tags": "java",
    "url": "/java/2024-08-29-stringbuilder/"
  },{
    "title": "[Algorithm] 서로소 집합과 유니온 파인드",
    "text": "서로소 집합 유니온 파인드 유니온 파인드의 자료구조 유니온 파인드의 예시 트리와 관련된 용어들 루트 노드, 자식노드, 부모노드, 서브트리, 리프노드, 깊이 이 이미지에서 깊이는 5 이진트리 자식 노드가 2개씩 있는 트리 서로소 집합 서로 공통된 원소를 가지고 있지 않은 두 개 이상의 집합 분리 집합 (Disjoint Set)이라고도 부름 사용 용도 서로 다른 원소들이 같은 집합에 속해있는지, 아닌지 판별할 때 사용 사이클이 존재하는지 판별할때 사용 Union-Find 자료구조로 서로소 집합을 표현 유니온 파인드가 다른 고급 알고리즘의 베이스가 됨 (Kruskal Algorithm) 유니온 파인드 유니온 파인드(Union-Find)의 자료구조 init, find, merge(union) 함수들의 형태로 보통 이루어짐 함수명 고정 X init 초기화 함수 Parent 배열에 대해 자신의 인덱스 값을 가지도록 초기화 초기에 자신의 부모 노드는 자신이라는 의미 void init() { for (int i = 1; i &lt;= n; ++i) { parent[i] = i; } } find 자신의 부모 노드를 찾는 함수 재귀 함수로 구현됨 자기 자신을 가리키는 인덱스 (루트 노드)를 찾을 때까지 반복 int find_parent1(int x) { return x == parent[x] ? x : find_parent1(parent[x]); } int find_parent2(int x) { if (x == parent[x]) return x; else return parent[x] = find_parent2(parent[x]); } // memoization을 사용하는 2가 더 빠름 ``` merge 두 노드를 하나의 집합으로 합치는 함수 y의 부모 노드는 x find 함수를 같이 사용 if 문에서 x == y이면? 사이클이 발생하는 경우이므로 제외 void merge_parent(int x, int y) { int x = find_parent(x); int y = find_parent(y); if (x != y) parent[y] = x; } ``` 유니온 파인드의 예시 최종적으로 오직 루트 노드만이 자기 자신을 가리키게 됨 이러한 특서으로 루트 노드 찾을 수 있음",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-18-day9/"
  },{
    "title": "[JAVA] 키보드로 사용자 입력받는 2가지 방법 (BufferdReader, Scanner)",
    "text": "목차 BufferReader, InputStreamReader, System.in Scanner 1. BufferdReader, InputStreamReader, System.in System.in 일반적으로 keyboard 입력을 지칭하는 Standard Input Stream InputStreamReader byte stream을 character stream으로 변경해주는 역할 수행 InputStreamReader 클래스는 생성자의 파라미터로 InputStream 객체를 전달받음 이 InputStream 객체의 종류에 따라 키보드 사용자 입력을 읽어들일수도 있고, 파일 내용을 읽어들일 수도 있음 사용법 InputstreamReader (InputStream in) InputstreamReader (InputStream in, String charsetName) InputstreamReader (InputStream in, Charset cs) InputstreamReader (InputStream in, CharsetDecoder dec) 생성자의 파라미터로 charset 정보를 전달받아 읽어들이는 stream의 charset을 지정할 수도 있음 BufferedReader 효율적으로 문자를 읽어들이기 위해 버퍼링을 해줌 버퍼링 (Buffering) 효율적인 데이터 처리를 위해 중간 저장공간(Buffer)을 사용하는 것 (주로 입출력에서 사용) 디스크 접근은 시간이 오래걸리기 때문에 한번에 데이터를 저장하여 시간을 줄이고, 필요할 때마다 데이터를 읽음 I/O작업은 시간이 많이 걸리기 때문에 버퍼링으로 접근횟수를 줄여 효율적으로 데이터 사용이 가능 기본 버퍼 사이즈를 그대로 이용할 수도, 생성자를 이용해 버퍼 사이즈를 지정할 수도 있음 보통 FileReader, InputStreamReader의 read()와 같이 비용이 많이 드는 Reader를 파라미터로 전달받아 사용함 만약 BufferedReader없이 FileReader나 InputStreamReader를 사용하면 시스템은 바이트별로 사용자의 입력을 받아서 처리하는 동작을 반복함 시스템에서 IO는 자원소모가 많음 하지만 BufferReader를 사용하면, 시스템은 버퍼가 비어있을 때만, 실제 IO를 일으켜서 데이터를 읽어오고, 나머지 경우에는 메모리에 있는 버퍼의 데이터를 읽어서 처리함 데이터를 문자열로 받아오기 때문에, 적절히 데이터를 처리 후 사용해야 한다. BufferdReader, InputStreamReader, System.in를 이용한 예제 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class UserInput { public static void main(String[] args) throws IOExceptio{ //키보드 사용자 입력을 받을 수 있는 객체 생성 BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); // 입력 데이터 읽기 (한 줄) String str = reader.readLine(); // 입력 데이터 출력 System.out.println(str); } } 2. Scanner Scanner 클래스를 이용하면 1번 방법보다 더 쉽게 사용자 키보드 입력을 받을 수 있음 입력받은 데이터를 Scanner클래스 메소드를 사용해 더 쉽게 가공 가능 예제 import java.util.Scanner; public class ScannerLoop { public static void main(String[] args) { // Scanner 선언 Scanner scanner = new Scanner(System.in); //다음으로 읽어들일 token이 있는지 체크 while (scanner.hasNext()) { //token별로 입력값을 읽어 String을 리턴 String str = scanner.next(); System.out.println(str); } scanner.close(); } } token(공백)별로 사용자 입력값을 읽어들이는 예제",
    "tags": "java",
    "url": "/java/2024-07-17-day8/"
  },{
    "title": "[Algorithm] 동적 계획법 (DP)",
    "text": "목차 Dynamic Programming 정의 DP의 종류 DP 사용조건 DP 유의점 동적 계획법 (DP, Dynamic Programming) 예시 문제 1 1000원짜리 커피를 500원짜리 동전과 100원짜리 동전만 사용하여 계산하려고 한다. 동전을 가장 적게 사용하여 계산하려고 할 때, 필요한 동전의 최소 개수는? (단, 동전은 무수히 많다.) Solution (500 * 2) VS (500 * 1 + 100 * 5) VS (100 * 10) 그리디 알고리즘으로 해결 가능 예시 문제 2 23원짜리 커피를 5원짜리 동전과 2원짜리 동전만 사용하여 계산하려고 한다. 동전을 가장 적게 사용하여 계산하려고 할 때, 필요한 동전의 최소 개수는? (단, 동전은 무수히 많다.) Solution 그리디 알고리즘으로 해결 불가능 그리디 알고리즘을 적용할 수 잇는 조건 중 하나인 최적 부분 구조 조건을 만족하지 않기 때문 지역적으로 최적이 전역적으로도 최적이 아님 Dynamic Programming 정의 이전에 계산한 값을 재사용하여, 하나의 문제를 한 번만 풀게 하는 알고리즘 패러다임 Divide &amp; Conquer과 비슷하지만, 중간 결과를 저장하여 효율성을 높인다는 점에서 차이 이전에 계산해둔 값을 메모리(배열 등)에 저장해서 반복 작업을 줄이는 기법이 핵심 하위 문제의 결과를 먼저 저장하고, 이를 나중에 필요할 때 사용 Tabulation(botton-up), Memoization(top-down) DP의 종류 Top-Down DP 가장 큰 문제부터 풀기 시작하여, 작은 문제들을 재귀적으로 호출하여 답을 구하는 방식 주로 재귀를 통해 해결 ${\\color{yellow}메모이제이션(Memoization)}$을 활용하여 복잡도를 줄임 예시 int fibo(int n) { if (n &lt;= 2 ) return 1; int &amp;ret = dp[n] if (ret != -1) return ret; return ret = fibo(n-1) + fibo(n-2) } Botton-Up DP 작은 문제들을 먼저 풀기 시작하여, 최종적으로 가장 큰 문제들을 해결하는 방식 주로 반복문을 통해 해결 ${\\color{yellow}점화식과 기저사례}$(base case)가 필요 -&gt; ${\\color{yellow}Tabulation}$ 예시 for (int i = 2; i &lt;= 40; ++i) { dp[i] = dp[i-1] + dp[i-2]; } //점화식 DP 사용 조건 겹치는 부분(작은) 문제 (Overlapping Subproblem) 어떠한 문제가 여러 개의 부분(하위) 문제(subproblem)으로 쪼갤 수 있을 대 사용 최적 부분 구조 (Optimal Substructure) 문제의 정답을 작은 문제의 정답에서 구할 수 있을 때 사용 예시 N번째 피보나치 수를 구하는 문제 N-1번째 피보나치 수를 구하는 문제, N-2번째 피보나치 수를 구하는 문제로 쪼갤 수 있음 문제의 정답을 하위 문제의 정답의 합으로 구할 수 있음 재귀로 풀 때 O(2^N) 이미 구했던 값도 다시 계산해야 함 시간 초과 발생 빛 stack overflow 가능성이 높음 반복문으로 풀 때 O(N) 기저사례와 점화식으로 구현 DP 유의점 복잡한 문제의 경우, 점화식을 직접 계산해서 구해야 한다.",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-16-day7/"
  },{
    "title": "[Algorithm] 너비 우선 탐색 &amp; 다익스트라 알고리즘",
    "text": "목차 너비 우선 탐색 BFS 다익스트라 Dijkstra 알고리즘 너비 우선 탐색 (BFS) BFS (Breadth First Search) 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것 루트 노드 (혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 사용 BFS의 특징 재귀적으로 동작하는 DFS와 달리, BFS는 주로 큐(Queue) 사용 사이클이 있는 경우, 무한 루프에 빠지지 않도록 방문하는 방문 체크를 해주어야 함 물웅덩이에 돌멩이를 하나 던지면, 파동이 전체 방향으로 퍼져나가는 동심원의 형태로 탐색이 진행 BFS의 동작 순서 BFS의 구현 빈 큐 q 및 visited 배열 생성 시작 노드 ‘st’를 큐 q에 삽입 노드 ‘st’를 방문한 것으로 표시 큐 q가 비어있지 않은 동안 다음을 반복 : 큐의 맨 앞에서 요소를 꺼내 ‘now’에 저장 큐의 맨 앞의 요소를 제거 ‘now’의 값을 출력하고 뒤에 공백을 붙임 노드 ‘now’의 인접 리스트 v에서 각 이웃 ‘next’에 대해 만약 ‘next’가 아직 방문하지 않은 노드인 경우 : 노드 ‘next’를 방문한 것으로 표시 ‘next’를 큐 q에 넣음 BFS의 시간복잡도 V : 정점(노드)의 수, E : 간선의 수 인접 리스트로 표현된 그래프 O(V+E) 인접 행렬로 표현된 그래프 O(V^2) DFS와 BFS의 공통점과 차이점 공통점 그래프에서 시작 노드로부터 목적지 노드까지 도달하거니 특정 정보를 찾는 것이 목표 방문 기록을 체크해 이미 방문한 노드를 다시 방문하지 않게 하여 무한 루프 방지 DFS, BFS 두 방식 모드 조건 내의 모든 노드를 검색한다는 점에서 시간 복잡도는 동일 차이점 DFS는 주로 재귀로 구현하지만, BFS는 큐(queue) 자료구조를 활용하여 구현 일반적으로 DFS보다 BFS가 조금 더 빠르게 동작 동작 순서 상 DFS는 트리를 탐색할 때 자주 사용, BFS는 최단 경로 탐색에서 자주 사용 시간 복잡도 주어진 그래프의 구조와 시작 노드에 따라서 실제 시간 복잡도가 다를 수 있으며, 어떤 알고리즘이 더 효율적인지는 그래프의 형태와 알고리즘의 목적에 따라 달라짐 일반적으로 어떤 알고리즘을 선택할지는 문제의 특성과 요구사항에 따라 결정 다익스트라 (Dijkstra) 알고리즘 그래프 알고리즘 알고리즘을 사용하는 경우 BFS 사용 시, 격자모양의 미로에서는 상하좌우 방향의 가중치가 모두 동일 현재 정점에서 이어진 간선들의 가중치가 모두 동일 하지만 가중치가 모두 일정하지 않다면 -&gt; BFS를 사용할 수 없음 다익스트라 알고리즘 설명 한 정점에서 다른 모든 정점으로의 최단 경로를 구하는 알고리즘 간선의 가중치가 양수일 때만 사용 가능 음수면 다익스트라가 아닌 테이크스트라 알고리즘 사용 BFS와 유사하지만, 일반적인 큐가 아닌 우선순위 큐(Priority Queue)를 사용하여 비용이 가장 작은 간선부터 탐색한다는 차이점이 있음 우선순위 큐 (Priority Queue) 들어오는 순서에 상관 없이 우선 순위가 높은 데이터가 먼저 나가는 자료구조 Heap을 이용해 구현하는 것이 가장 효율적 그리디(Greedy) 알고리즘 매 단계에서 현재까지의 부분 해(solution)를 최적화하여 최종적으로 전체 문제의 최적 해를 찾아냄 다익스트라 알고리즘 동작 순서 출발 노드 선택 출발 노드로부터 각 노드까지의 최단 거리 배열 초기화 출발노드 거리는 0, 나머지 노드는 무한대(충분히 큰 값)로 설정 현재 노드 설정 현재까지의 최단 거리가 확정된 노드 중 가장 가까운 노드 선택 이웃 노드 갱신 선택한 노드를 기준으로 해당 노드와 이웃한 노드들 간의 거리 갱신 모든 노드를 확인할 때까지 3,4단계 반복 핵심 아이디어 각 노드까지의 현재까지 알려진 최단 거리를 계속 갱신하며 출발 노드로부터 최단 경로를 찾는 것 비용이 가장 작은 간선부터 이어주기 위해 우선순위 큐를 사용한다. 다익스트라 알고리즘 시간 복잡도 V : 정점(노드)의 수, E : 간선의 수 O(ElogV) 다익스트라 알고리즘의 구현 문제 예시 방향 그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로의 비용을 구하여라 첫째 줄에 정점의 개수와 간선의 개수가 입력됨 둘째 줄에는 시작 정점의 번호가 입력됨 셋째 줄부터 간선의 개수만큼의 줄에 걸쳐 (u,v,w)가 주어짐 (u,v,w) -&gt; u에서 v로 가는 양의 가중치 w인 간선 존재 구현 예시 출발 노드 선택 출발 노드로부터 각 노드까지의 최단 거리 배열 초기화 현재 노드 설정 이웃 노드 갱신 모든 노드 확인할 때까지 3,4단계 반복",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-15-day6/"
  },{
    "title": "[Algorithm] 깊이 우선 탐색",
    "text": "목차 DFS란? DFS특징 DFS 시간 복잡도 깊이 우선 탐색 (DFS) DFS란?(Depth First Search) 특정 정점(노드)에서 시작해서 트리나 그래프에서 한 가지 경로를 최대한 깊게 탐색하고, 해당 경로를 끝까지 탐색한 후 다른 경로로 이동 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 계속 가다가, 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행하는 방법과 유사 모든 정점을 방문하고자 하는 경우에 사용 DFS 특징 일반적으로 재귀 함수 사용 Stack으로도 구현 가능 모든 경우의 수에 대해 탐색을 진행 사이클이 있는 경우, 무한 루프에 빠지지 않도록 방문 체크 해줘야함 BFS보다 깊은 경로를 빠르게 찾는데 용이 진행 순서 구현 함수 DFS(now): 현재 노드를 방문한 것으로 표시 현재 노드를 출력 모든 이웃노드 'next'에 대해서 반복: 만약 'next'를 아직 방문하지 않았다면: DFS(next) DFS 시간 복잡도 V : 정점(노드)의 수, E : 간선의 수 인접 리스트로 표현된 그래프 O(V+E) 인접 행렬로 표현된 그래프 O(V^2) 희소 그래프 Sparse Graph 그래프 내에 적은 숫자의 간선만을 가지는 그래프 인접 행렬보다 인접 리스트 사용이 유리",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-12-day5/"
  },{
    "title": "[Algorithm] 재귀와 정렬",
    "text": "목차 재귀 정렬 재귀 재귀 : 자신을 정의할 때, 자기 자신을 참조하는 것 재귀 함수 : 함수 내부에서 자기 자신을 호출하는 함수 주의할 점 무한 루프에 빠지지 않도록 종료 조건을 잘 설정 종료 조건을 기저 사례 (base case)라고도 함 함수의 파라미터 및 인자 설정에 유의 정렬 정렬의 종류 삽입 정렬 (Insertion Sort) 최악 O(n^2) 버블 정렬 (Bubble Sort) 최악 O(n^2) 합병 정렬 (Merge Sort) 최악 O(nlogn) 퀵 정렬 (Quick Sort) 최악 O(n^2) 평균 O(nlogn) 설명 배열의 요소들 중에서 피벗(Pivot)을 정하여, 피벗의 앞에는 피벗보다 작은 원소들이 오고, 피벗 뒤에는 피벗보다 큰 값이 오도록 배열을 둘로 나눔 분할된 두 개의 배열의 크기가 0이나 1이 될 때까지, 분할된 두 배열에 대해 재귀적으로 이 과정을 반복 재귀 호출이 한 번 진행될 때마다 최소한 하나의 원소가 최종적인 위치에 있게 되므로, 종료됨이 보장 힙 정렬 (Heap Sort) 최악 O(nlogn) 특정 정렬이 빠르다고 항상 좋은 것은 아님 데이터의 특성, 크기에 따라 적절한 방법 사용해야 함 언어들의 라이브러리 내장 sort 구현 C++ 인트로 정렬 (Intro Sort) 퀵 정렬 + 힙 정렬 + 삽입 정렬 Python 팀 정렬 (Tim Sort) 합병 정렬 + 삽입 정렬 Java Java7 이전에는 병합 정렬, 이후에는 팀 정렬 코테에선 왠만하면 내장 sort함수를 사용",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-11-day4/"
  },{
    "title": "[Algorithm] 문자열",
    "text": "목차 코딩테스트에 자주 나오는 문자열 1) 회문 2) 올바른 괄호 문자열 분할 정복과 백트래킹 1) 분할 정복 2) 백트레킹 코딩테스트에 자주 나오는 문자열 1. 회문 (Palindrome) 앞뒤 방향으로 볼 때, 같은 순서의 문자로 구성된 문자열을 의미 예시 “소주 만 병만 주소”, “Madam, I’m Adam”, “1234321” 2. 올바른 괄호 문자열 (VPS = Valid Parenthesis String) 조건 빈 문자열은 올바른 괄호 문자열이다 S가 올바른 괄호 문자열이라면, (S)도 올바른 괄호 문자열이다. S, T가 괄호 문자열이라면 ST도 올바른 괄호 문자열이다. 보통은 Stack을 사용해서 해결 ’)’가 입력될 때마다, 스택에 있는 ‘(‘를 하나씩 지움 이때, 스택(top)이 비어있거나, ‘(‘가 없으면 올바른 괄호 문자열이 아님 모든 문자열을 순회한 뒤, 스택이 비어있으면 올바른 괄호 문자열 치환 사용하기 ’(‘를 1, ‘)’를 -1로 치환 문자열 S를 전부 순회하며 합 계산 중간에 합이 음수가 되거나, 모든 계산이 끝나고 0이 아니면 올바른 괄호 문자열이 아님 분할 정복과 백트래킹 분할 정복 (Divide and Conquer) 큰 문자를 작은 문제로 분할하여 작은 문제의 답을 모다 큰 문제의 답을 구함 기저 사례(base case)를 잘 설정하여 일정 기준 이상 분할되지 않도록 해야 함 보통 재귀로 구현 예시 피보나치 수열 Z 백트래킹 답이 될 수 없는 경우는 탐색 대상에서 제외하며 효율적으로 답을 구하는 알고리즘 가지치기(pruning)를 통해 연산량을 유의미하게 줄여줌 가지치기를 사용하기 위해서는 현재 상태에서 도달할 수 있는 상태가 모두 답이 될 수 없음을 보여야 함 정확한 시간 복잡도 측정 어려움 보통 재귀로 구현 많이 연습해봐야 익힐 수 있음 예시 스도쿠 대입해보고 현재 상태에서 스도쿠를 완성할 수 없다면, 분기점으로 다시 돌아옴 Nqueen",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-10-day3/"
  },{
    "title": "[Algorithm] 유클리드 호제법",
    "text": "목차 유클리드 호제법 소수 판별법 유클리드 호제법 두 수가 서로 상대방 수를 나누어 원하는 수를 구하는 것 GCD (Greatest Common Divisor) 최대공약수 두 자연수 a, b에 대해서 (a &gt; b) a를 b로 나눈 나머지를 r이라고 하면 a와 b의 최대공약수는 b와 r의 최대공약수와 동일 이 성질에 따라, b를 r로 나눈 나머지 r’를 구하고, 다시 r을 r’로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을때 나누는 수가 a와 b의 최대공약수 예시 1071과 1029의 최대공약수 구하기 1071 % 1029 = 42 1029 % 42 = 21 42 % 21 = 0 21이 1071과 1029의 최대공약수 LCM (Least Common Multiple) 최소공배수 LCM(a, b) = a * b / GCD(a, b) 어떠한 두 수의 곱은, 그 두 수의 최대공약수와 최소공배수의 곱과 같다 cpp의 gcd, lcm 함수는 c++17부터 지원 numeric 모듈 보통 코테에서 c++17 사용 python은 math 모듈의 gcd, lcm 함수 gcd는 python 3.5 lcm은 python 3.9 보통 코테에서 python 3.8 사용 java는 지원하지 않음 소수 판별법 1은 소수, 합성수 아님 에라토스테네스의 체 O(Nlog(logN)) N이 커지면 거의 O(N) 회귀가 아닌 반복",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-09-day2/"
  },{
    "title": "[Algorithm] 시간 복잡도",
    "text": "시간 복잡도 언어별 실행 속도 cpp &gt; Java &gt; python 보통 언어별 시간 보정이 존재 우선 java가 편하니까 Java로 해보기로! 평균적으로 대략 1초에 1억 번 연산 (10^8) 실제 문항을 풀 때, N의 범위를 먼저 확인할 것 시간 복잡도를 고민하지 않고 무작정 구현 먼저 하면 처음부터 다시 코드를 작성해야함 예를 들어, 시간제한 1초 / 1 &lt;= N &lt;= 10^5 인 경우 O(N^2)는 불가능 O(NlogN)까지 가능",
    "tags": "algorithm",
    "url": "/algorithm/2024-07-08-day1/"
  },{
    "title": "[Etc] URI과 URL의 차이",
    "text": "목차 URI URL URN URI와 URL의 차이점 flutter앱을 개발하는 도중, http통신관련 코드를 짜면서 Uri.parse()함수를 여러 번 접하게 되었다. 주소 관련 변수명을 url로 쓰고 있어 이 둘의 의미가 혼동되어 정확하게 알아보고자 하였다. URI (Uniform Resource Identifier) 우리 말로 ‘통합 자원 식별자’ Uniform -&gt; 리소스를 식별는 통일된 방식 Resource -&gt; URI로 식별이 가능한 웹 브라우저 파일 및 그 이외의 리소스를 포함하는 모든 종류의 자원 Identifier -&gt; 다른 항목과 구분하기 위해 필요한 정보 즉, URI는 인터넷상의 리소스 자원 자체를 식별하는 고유한 문자열 시퀀스 URL (Uniform Resource Locator) 네트워크상에서 통합 자원(리소스)의 “위치”를 나타내기 위한 규약 웹 사이트 주소 + 컴퓨터 네트워크 상의 자원 특정 웹 페이지의 주소에 접속하기 위해서는 웹 사이트의 주소뿐만 아니라 프로토콜(https, http, sftp, smp 등)을 함께 알아야 접속이 가능한데, URL은 이들 모두를 나타낸다. URN (Uniform Resource Name) 리소스의 위치, 프로토콜, 호스트 등과는 상관없이 각 자원에 이름을 부여한 것 웹 문서의 물리적인 위치와 상관없이 웹 문서 자체를 나타낸다. URI와 URL의 차이점 URI= 식별자, URL=식별자+위치 nan0silver.github.io는 리소스의 이름만 나타내므로 URI https://nan0silver.github.io/는 이름과 위치를 나타내므로 URL (프로토콜 http를 포함하기 때문) URL ⊂ URI URL은 프로토콜과 결합된 상태이다. (프로토콜 + 이름) URI는 그 자체로 이름이 될 수 있다.",
    "tags": "miscellaneous",
    "url": "/miscellaneous/2023-08-14-about-UriUrl/"
  },{
    "title": "[Flask] Flask서버에 외부 접근하는 방법",
    "text": "app.run()안에 바인딩될 호스트 정보를 넣어준다. app.run()은 127.0.0.1로 실행되며 이는 로컬에서만 실행가능하다. app.run(host=’0.0.0.0’)의 경우 모든 호스트로 접근 가능하다. 포트 변경을 원하는 경우 app.run(host=’0.0.0.0’, port=8000)과 같이 사용한다. 위의 방법으로 실행하면 flask서버를 실행한 컴퓨터의 IP주소와 함께 설정한 포트로 연결가능한 주소가 나온다.",
    "tags": "flask",
    "url": "/flask/2023-07-01-flask-run/"
  },{
    "title": "[Flask] Flask 서버와 통신",
    "text": "목차 Flask란? Dio Future Flask에서 json형태로 response보내는 함수 Flask란? 웹 애플리케이션 개발을 위한 파이썬 프레임워크 가장 유명한 Django(장고)보다 가볍고 필요한 기능만 최대한 라이트한 개발을 할 수 있다. Dio A powerful Http client for Dart http처럼 서버와 통신하기 위해 필요한 패키지 많은 기능을 가지고 있고, 여러가지 커스텀을 쉽게 할 수 있다. pubspec.yaml에 dependency를 추가해주어야 한다. Http와 json형식의 데이터로 받아올 때 차이점 Http로 요청 후 리턴받은 데이터를 decode해준 값이 Dio로 요청 후 리턴받은 데이터와 동일하다. https://kyungsnim.net/175 에서 참고 Future 지금은 없지만 미래에 요청한 데이터 혹은 에러가 담길 그릇 싱글스레드 환경에서 비동기 처리를 위함 비동기 : 어떤 동작이 완료되지 않아도 다음 동작을 수행하는 것 동기 : 모든 동작이 완료된 후 다음 동작을 수행하는 것 Flask에서 json 형태로 response보내는 함수 jsonify json response를 보내기 위해 이미 content-type header가 ‘application/json’로 되어 있는 flask.Response() 객체를 리턴 jsonify도 함수 내부에서도 json form으로 serialize하는 과정에서 json.dumps를 사용 다만 dump하기 전에 받은 값들을 모두 dictionary로 만들었다. Parameter accept dictionary list json.dumps python이 가지고 있는 json library의 json.dumps() 수동으로 MIME type header를 추가해주어야 하는 encoded string을 리턴한다. flask가 알아서 판단해 response를 자동으로 보내주도록 사용하기 때문에 직접적으로 사용할 수 있다. 다만 reponse header fields는 디폴트(text/html; charset=utf-80)로 처리된다. Parameter accept jsonify보다 더 많은 타입",
    "tags": "flask",
    "url": "/flask/2023-04-18-about-flask/"
  },{
    "title": "[Flutter] Flutter UI",
    "text": "Flutter Layout Widget의 생명주기 Flutter Layout Flutter Layout의 핵심은 위젯 위젯은 현재 주어진 상태(데이터)를 기반으로 어떤 UI를 구현할지 정의 플러터 프레임워크는 기존 상태 위젯과 새로운 상태의 위젯을 비교하여 UI변화를 반영 최소한의 리소스로 UI변경을 이룸 레이아웃 모델, 앱 내 이미지, 아이콘, 글자 등 거의 모든 것이 위젯 위젯은 자식을 하나만 갖는 위젯과 자식을 여럿 갖는 위젯으로 나뉨 자식을 하나만 갖는 위젯 container 위젯 자식 위젯을 커스터마이징할 수 있는 위젯 클래스 여백, 간격, 테두리, 배경색 등을 추가할 수 있음 나머지 UI는 속성에 의해 제어됨 (color속성, Text.style속성 등) 자식을 여럿 갖는 위젯 children 매개변수를 입력 받음 리스트로 여러 위젯을 입력할 수 있음 Column 위젯, Row 위젯 children 매개변수에 입력된 모든 위젯들을 세로(가로)로 베치 ListView 위젯 리스트 구현가능, 입력된 위젯이 화면을 벗어나게 되면 스크롤 가능해짐 예시 위의 스크린샷에 해당하는 위젯을 구현하기 위한 위젯 트리이다. ❗️Material apps vs Non-Material apps Material apps 플랫 디자인의 장점을 살리면서도 빛에 따른 종이의 그림자 효과를 이요해 입체감을 살리는 디자인방식을 가진 앱 구글에서 사용하고 있는 플랫 디자인 지침 앱마다 다른 디자인을 통일시키기 위함 Scaffold 위젯 기본적인 material design의 시각적인 레이아웃 구조를 실행한다. Scafflod 위젯 vs Container Scafflod 기본적으로 appbar, body라는 2개의 옵션을 가짐 Container Scafflod의 body부분에 들어가는 부속품 봉지라고 생각하면 됨 한 개의 자식을 가지는 레이아웃 위젯 Container의 생성자는 아래와 같다. Container({ Key key, this.alignment, this.padding, Color color, Decoration decoration, this.foregroundDecoration, double width, double height, BoxConstraints constraints, this.margin, this.transform, this.child, })&lt;/pre&gt; - Widget의 생명주기 Stateful Widget의 생명주기 stateless widget은 한 번 만들어지면 갱신할 수 없어 생명주기가 없다. stateful widget은 10단계의 생명주기가 있다. createState()함수 상태를 생성하는 함수 다른 생명주기 함수들이 포함된 State 클래스를 반환 StatefulWidget 클래스를 상속받는 클래스는 반드시 이 함수를 호출해야 한다. Class MyHomePage extends StatefulWidget { @override _MyHomePageState createState() =&gt; new _MyHomePageState(); } mounted == true createState() 함수가 호출되어 상태가 생성되면 mounted 속성이 true가 된다. 위젯을 제어할 수 있는 buildContext클래스에 접근 가능해짐 buildContext가 활성화되어야 setState()함수 이용 가능 initState()함수 위젯을 초기화하는 함수 주로 데이터 목록을 만들거나 처음 필요한 데이터를 주고받을 때 호출 이 함수를 호출할 때 내부에서 _getJsonData() 함수를 호출하면 서버에서 데이터를 가져와 화면에 출력할 수 있음 didChangeDependencies()함수 initState()함수 호출 후, 해당 위젯이 데이터에 의존하는 위젯이라면 반드시 호출해야하는 함수 주로 상속받은 위젯을 사용할 때 피상속자가 변경되면 호출 build()함수 위젯을 화면에 렌더링하는 함수 (Widget을 반환한다.) @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Page'), ); } didUpdateWidget()함수 부모 위젯이나 데이터가 변경되어 위젯을 갱신해야 할 때 호출하는 함수 initState()함수는 위젯을 초기화할 때 한 번만 호출되므로 위젯이 변경되었을 때 이 함수를 호출해야함 setState()함수 데이터가 변경되었다는 것을 알려주고 이를 반영하여 화면 UI를 변경하는 함수 deactive()함수 위젯의 상태 관리를 중지하는 함수 State객체가 플러터 구성 트리에서 제거될 때 호출됨 dispose()함수를 호출하기 전까지는 State객체를 재사용할 수 있게 해줌 dispose()함수 State객체를 영구적으로 소멸할 때 호출되는 함수 mounted == false 생명주기를 끝내주는 함수 false가 된 다음 이 State는 재사용할 수 없다.",
    "tags": "flutter",
    "url": "/flutter/2023-04-13-flutter-UI/"
  },{
    "title": "[Flutter] Start Flutter",
    "text": "목차 What is Flutter Dart Flutter Project What is Flutter? 크로스 플랫폼 앱 개발 프레임 워크 Dart 언어 사용 구글에서 만듬 컴파일 언어의 특징을 활용하여 앱 개발 가능 프레임워크, 엔진, 임베더 계층으로 구성 프레임워크 Dart로 개발된 여러 클래스로 앱 개발 엔진 플러터의 코어 C, C++ 데이터 통신, 다트 컴파일, 렌더링, 시스템 이벤트 임베더 플러터 앱이 크로스 플랫폼에서 동작하도록 플러터 엔진이 렌더링한 결과를 플랫폼별 네이티브 언어로 뷰를 만들어 화면에 보여줌 네이티브 언어 안드로이드 : 자바, 코틀린 IOS : 오브젝티브-C, 스위프트 플러터의 장점 높은 개발 효율 hot reload 코드 변경 이후 빌드시간에 의한 낭비되는 시간을 없애기 위해 업데이트된 소스파일들이 dart virtual machine에 주입되면 flutter는 변경된 사안을 기반으로 widge tree를 재구성 -&gt; 변경된 것이 빠르게 결과물에 적용됨 유연한 사용자 인터페이스 다양한 위젯 제공 강력한 애니메이션 기능 제공 빠른 속도 Dart 비동기 처리 방식 작업이 끝나기를 기다리지 않고 다음 작업을 처리하게 하는 것 작동 방식 async 함수를 비동기로 만듬 await 비동기 함수 안에서 언제 끝날지 모르는 작업 앞에 붙임 해당 작업의 결과를 받기 위해 비동기 함수이름 앞에 Future 붙임 예시 코드 Future checkVersion() async { var version = await lookUpVersion(); print(version); }&lt;/pre&gt; 하나의 thread로 동작 Flutter Project lib 폴더 플러터 앱 개발을 위한 다트 파일 pubspec.yaml 플러터의 다양한 패키지, 이미지, 폰트 사용할수 있게 해줌",
    "tags": "flutter",
    "url": "/flutter/2023-04-06-start-flutter/"
  }]};
